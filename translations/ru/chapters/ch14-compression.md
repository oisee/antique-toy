# Глава 14: Сжатие --- больше данных в меньшем пространстве

ZX Spectrum 128K имеет 128 килобайт ОЗУ. Это звучит щедро, пока ты не начнёшь вычитать: экран забирает 6 912 байт (6 144 пикселей + 768 атрибутов), системные переменные претендуют на свою долю, музыкальному проигрывателю AY и его данным паттернов нужен банк-другой, твой код занимает ещё несколько тысяч байт, и стеку нужно пространство для дыхания. К тому моменту, когда ты садишься хранить фактическое содержимое своего демо --- графику, кадры анимации, предрассчитанные таблицы подстановки --- ты борешься за каждый байт.

Одно полноэкранное изображение на Spectrum --- это 6 912 байт. 4K интро может вместить примерно 0,6 одного. 48K демо теоретически могло бы содержать семь экранов без ничего другого. Но демо --- не слайд-шоу. В них есть музыка. Есть код. Есть эффекты, требующие таблиц предрассчитанных данных. Вопрос не в том, сжимать ли --- а какой упаковщик использовать и когда.

Эта глава построена вокруг бенчмарка. В 2017 году Introspec (spke, Life on Mars) опубликовал "Data Compression for Modern Z80 Coding" на Hype --- скрупулёзное сравнение десяти инструментов сжатия, протестированных на тщательно разработанном корпусе. Та статья с её 22 000 просмотров и сотнями комментариев стала справочником, к которому обращаются ZX-кодеры при выборе упаковщика. Мы пройдём через его результаты, поймём компромиссы и научимся выбирать правильный инструмент для каждой задачи.

---

## Проблема памяти

Давай будем конкретны насчёт ограничений. Рассмотрим Break Space от Thesuper (Chaos Constructions 2016, 2-е место) --- демо с 19 сценами, работающее на ZX Spectrum 128K. Одна из этих сцен, Magen Fractal от psndcj, показывает 122 кадра анимации. Каждый кадр --- полный 6 912-байтный экран. Без сжатия это 843 264 байта --- более чем в шесть раз больше общего ОЗУ машины.

psndcj сжал все 122 кадра в 10 512 байт. Это 1,25% от оригинального размера. Вся анимация, каждый её кадр, помещается в пространство меньше двух несжатых экранов.

Другая сцена в Break Space, анимация Mondrian, упаковывает 256 нарисованных вручную кадров --- каждый квадрат вырезан отдельно, индивидуально сжат --- в 3 килобайта.

Это не теоретические упражнения. Это продакшн-техники из демо, участвовавшего в одном из самых престижных комп сцены. Сжатие --- не оптимизация, применяемая в конце. Это фундаментальное архитектурное решение, определяющее, что может содержать твоё демо.

### Сжатие как усилитель пропускной способности

Introspec сформулировал идею, возвышающую сжатие от трюка хранения до техники производительности: **сжатие действует как метод увеличения эффективной пропускной способности памяти**.

Допустим, эффекту нужно 2 КБ данных на кадр. Сохрани их сжатыми до 800 байт и распакуй с помощью LZ4 при 34 тактах (T-state) на выходной байт. Распаковка стоит 69 632 такта --- почти ровно один кадр. Но ты можешь перекрыть её со временем бордюра, буферизовать кадр вперёд с двойной буферизацией и чередовать с рендерингом эффекта. Результат: больше данных проходит через систему, чем шина могла бы доставить из несжатого хранилища. Распаковщик --- усилитель данных.

---

## Бенчмарк

Introspec не просто прогнал каждый упаковщик на нескольких файлах и оценил результаты на глаз. Он разработал корпус и измерил систематически.

### Корпус

Тестовые данные составили 1 233 995 байт в пяти категориях:

- **Calgary corpus** --- стандартный академический бенчмарк сжатия (текст, бинарные, смешанные)
- **Canterbury corpus** --- более современный академический стандарт
- **30 графических файлов ZX Spectrum** --- загрузочные экраны, мультиколорные изображения, игровые экраны
- **24 музыкальных файла** --- PT3-паттерны, дампы регистров AY, данные сэмплов
- **Разнообразные ZX-данные** --- тайловые карты, таблицы подстановки, смешанные данные демо

Этот микс имеет значение. Упаковщик, превосходный на английском тексте, может буксовать на ZX-графике, где длинные ряды нулей в пиксельной области чередуются с почти случайными атрибутными данными. Тестирование на реальных данных Spectrum --- данных, которые ты реально будешь сжимать --- необходимо.

### Результаты

Десять инструментов. Измерены по общему сжатому размеру (меньше --- лучше), скорости распаковки в тактах (T-state) на выходной байт (меньше --- быстрее) и размеру кода распаковщика в байтах (меньше --- лучше для sizecoding-продукций).

| Инструмент | Сжатый (байт) | Степень сжатия | Скорость (T/байт) | Размер распаковщика | Примечания |
|------------|--------------|----------------|-------------------|---------------------|------------|
| **Exomizer** | 596 161 | 48,3% | ~250 | ~170 байт | Лучшая степень сжатия |
| **ApLib** | 606 833 | 49,2% | ~105 | 199 байт | Хороший баланс |
| PuCrunch | 616 855 | 50,0% | --- | --- | Сложная альтернатива LZ |
| Hrust 1 | 613 602 | 49,7% | --- | --- | Перемещаемый стековый распаковщик |
| **Pletter 5** | 635 797 | 51,5% | ~69 | ~120 байт | Быстрый + приличное сжатие |
| MegaLZ | 636 910 | 51,6% | ~130 | ~110 байт | Воскрешён Introspec'ом в 2019 |
| **ZX7** | 653 879 | 53,0% | ~107 | **69 байт** | Крошечный распаковщик |
| **ZX0** | --- | ~52% | ~100 | **~70 байт** | Преемник ZX7 |
| **LZ4** | 722 522 | 58,6% | **~34** | ~100 байт | Самая быстрая распаковка |
| Hrum | --- | ~52% | --- | --- | Объявлен устаревшим |

Только Exomizer пробил барьер 600 000 байт по всему корпусу. Но скорость распаковки Exomizer --- примерно 250 тактов (T-state) на выходной байт --- делает его непрактичным для всего, что нужно распаковывать во время воспроизведения.

### Треугольник компромиссов

Каждый упаковщик делает компромисс между тремя качествами:

1. **Степень сжатия** --- насколько маленькими становятся сжатые данные
2. **Скорость распаковки** --- сколько тактов (T-state) на выходной байт
3. **Размер кода распаковщика** --- сколько байт занимает подпрограмма распаковки

Ты не можешь получить все три. Exomizer побеждает по степени сжатия, но медленно распаковывается и имеет большой распаковщик. LZ4 --- самый быстрый для распаковки, но теряет 10 процентных пунктов степени сжатия. ZX7 имеет 69-байтный распаковщик, но сжимает менее агрессивно, чем Exomizer.

Гений Introspec'а в том, что он отобразил эти компромиссы на Парето-фронтире --- кривой, где ни один инструмент не может улучшиться по одному измерению без потери по другому. Если упаковщик доминируется по всем трём осям другим инструментом, он устарел. Если он лежит на фронтире --- он правильный выбор для какого-то сценария.

Его практические рекомендации чётки:

- **Максимальное сжатие, скорость не важна:** Exomizer. Используй для однократной распаковки при загрузке --- загрузочные экраны, данные уровней, всё, что ты распаковываешь один раз в буфер и используешь многократно.
- **Хорошее сжатие, умеренная скорость (~105 T/байт):** ApLib. Надёжный универсальный выбор, когда нужна приличная степень и можно позволить ~105 тактов на байт.
- **Быстрая распаковка (~69 T/байт):** Pletter 5. Когда нужно распаковывать во время геймплея или между сценами и нельзя позволить медленную распаковку Exomizer.
- **Самая быстрая распаковка (~34 T/байт):** LZ4. Единственный выбор для потоковой передачи в реальном времени --- распаковки данных по мере их воспроизведения. При 34 тактах (T-state) на выходной байт LZ4 может распаковать более 2 000 байт за кадр. Это труба данных 2 КБ/кадр.
- **Самый маленький распаковщик (69--70 байт):** ZX7 или ZX0. Когда сам распаковщик должен быть крошечным --- в 256-байтных, 512-байтных или 1K интро, где каждый байт кода на счету.

Пусть эти числа направляют твои решения. Нет универсально "лучшего" упаковщика. Есть только лучший упаковщик для твоих конкретных ограничений.

---

## Как работает LZ-сжатие

Все упаковщики в таблице выше принадлежат к семейству Лемпеля-Зива. Понимание основной идеи поможет предсказать, какие данные хорошо сжимаются, а какие нет.

LZ-сжатие заменяет повторяющиеся последовательности байт обратными ссылками. Совпадение говорит: "скопируй N байт с позиции P байт назад в уже декодированном потоке". Сжатый поток чередуется между **литералами** (сырые байты без полезного совпадения) и **совпадениями** (пары смещение + длина, ссылающиеся на более ранний вывод).

Различия между упаковщиками сводятся к кодированию: сколько бит на смещение, сколько на длину, как сигнализировать литерал против совпадения. Exomizer использует сложные побитовые коды переменной длины, которые сжимают плотно, но требуют тщательного извлечения бит для декодирования --- отсюда ~250 тактов (T-state) на байт. LZ4 использует байт-выровненные токены, которые Z80 обрабатывает простыми сдвигами и масками --- отсюда ~34 такта на байт ценой 10 процентных пунктов степени сжатия. ZX0 использует однобитные флаги (0 = литерал, 1 = совпадение) с чередующимися кодами Элиаса для длин, попадая в точку баланса между размером и скоростью.

Данные ZX Spectrum хорошо сжимаются, потому что имеют структуру: большие области идентичных байт (чёрные фоны, пустые атрибуты), повторяющиеся паттерны (тайлы, шрифты, интерфейс), коррелированные пиксельные данные с регулярными смещениями. Музыка тоже хорошо сжимается --- PT3-паттерны полны повторяющихся нотных последовательностей и пустых строк. Что плохо сжимается: случайные данные, уже сжатые данные и очень короткие файлы, где накладные расходы кодирования превышают экономию.

---

## ZX0 --- выбор sizecoding-мастера

ZX0, созданный Einar Saukas, -- духовный преемник ZX7 и стал стандартным упаковщиком для современной ZX Spectrum-разработки. Он заслуживает особого внимания.

### Почему ZX0 существует

ZX7 уже был замечателен: 69-байтный распаковщик, достигающий уважаемой степени сжатия. Но Saukas увидел возможность для улучшения. ZX0 использует алгоритм оптимального парсинга --- он не просто находит хорошие совпадения, он находит *наилучшую возможную последовательность* совпадений и литералов для всего файла. Результат --- степень сжатия, близкая к значительно более крупным упаковщикам, с распаковщиком, остающимся в диапазоне 70 байт.

### Распаковщик

Z80-распаковщик для ZX0 --- это вручную оптимизированный ассемблер, спроектированный специально под набор инструкций Z80. Он использует регистр флагов Z80, инструкции блочной пересылки и точные тайминги условных переходов, чтобы выжать максимум функциональности в минимум байт. Вот о каком коде идёт речь:

```z80
; ZX0 decompressor — standard version
; HL = source (compressed data)
; DE = destination (output buffer)
; Uses: AF, BC, DE, HL
dzx0_standard:
        ld      bc, $ffff       ; initial offset = -1
        push    bc
        inc     bc              ; BC = 0 (literal length counter)
        ld      a, $80          ; bit buffer: only flag bit set
dzx0s_literals:
        call    dzx0s_elias     ; read literal length
        ldir                    ; copy literals
        add     a, a            ; read flag bit
        jr      c, dzx0s_new_offset
        call    dzx0s_elias     ; read match length
        ex      (sp), hl        ; retrieve offset from stack
        push    hl              ; put it back
        add     hl, de          ; calculate match address
        ldir                    ; copy match
        add     a, a            ; read flag bit
        jr      nc, dzx0s_literals
dzx0s_new_offset:
        ; ... offset decoding continues ...
```

Каждая инструкция работает на два фронта. Аккумулятор служит одновременно битовым буфером и рабочим регистром. Стек хранит последнее использованное смещение для повторных совпадений. Инструкция LDIR обрабатывает и копирование литералов, и копирование совпадений, сохраняя код маленьким.

При примерно 70 байтах весь распаковщик занимает меньше места, чем одна строка символов ZX Spectrum. Для 256-байтного интро это оставляет 186 байт на всё остальное --- эффект, анимацию, музыку. Для 4K интро 70 байт --- ничтожные накладные расходы. Вот почему ZX0 стал повсеместным.

### Когда использовать ZX0

- **256-байтные -- 1K интро:** Крошечный распаковщик незаменим. Каждый байт, сэкономленный на распаковщике -- байт, доступный для контента.
- **4K интро:** ZX0 может распаковать 4 096 байт в 15--30 КБ кода и данных. Megademica от SerzhSoft (1-е место, Revision 2019) использовала именно эту стратегию, чтобы вместить то, что рецензенты назвали "полноценным new-school демо", в 4K интро.
- **Общая разработка демо и игр:** Когда нужен надёжный универсальный упаковщик с малым footprint. ZX0 --- не самый быстрый распаковщик, но достаточно быстрый для однократной распаковки при загрузке, а его степень сжатия конкурентна с инструментами, имеющими значительно более крупные распаковщики.
- **RED REDUX** (2025) использовал более новый вариант ZX2 (тоже от Saukas) для достижения замечательного подвига -- включения Protracker-музыки в 256-байтное интро.

ZX0 --- не правильный выбор для потоковой передачи в реальном времени (используй LZ4) или для максимального сжатия любой ценой (используй Exomizer). Но для подавляющего большинства проектов ZX Spectrum он является правильным вариантом по умолчанию.

---

## RLE и дельта-кодирование

Не всему нужен полноценный LZ-упаковщик. Две более простые техники обрабатывают определённые типы данных более эффективно.

### RLE: кодирование длин серий

Простейшая схема: замени серию идентичных байт на счётчик и значение. Распаковщик тривиален:

```z80
; Minimal RLE decompressor — HL = source, DE = destination
rle_decompress:
        ld      a, (hl)         ; read count
        inc     hl
        or      a
        ret     z               ; count = 0 means end
        ld      b, a
        ld      a, (hl)         ; read value
        inc     hl
.fill:  ld      (de), a
        inc     de
        djnz    .fill
        jr      rle_decompress
```

Менее 30 байт кода распаковщика. RLE отлично сжимает, когда данные содержат длинные серии --- пустые экраны, одноцветные фоны, заливки атрибутов. Он ужасно сжимает сложный пиксель-арт. Преимущество перед LZ: для sizecoding-интро, где даже 70 байт ZX0 кажутся дорогими, пользовательская RLE-схема высвобождает ценное пространство.

### Дельта-кодирование: храни то, что изменилось

Дельта-кодирование хранит разности между последовательными значениями, а не абсолютные значения. Два кадра анимации, идентичные на 90%? Храни только изменённые байты --- список пар (позиция, новое_значение). Если только 691 байт отличаются из 6 912, дельта составляет 2 073 байта (3 байта на изменение) вместо полного кадра. Примени LZ поверх дельта-потока, и он сжимается ещё сильнее --- поток разностей содержит больше нулей и повторяющихся малых значений, чем сырые данные кадра.

Magen Fractal из Break Space использует именно это: 122 кадра по 6 912 байт каждый, сжатые до 10 512 байт суммарно, потому что каждый кадр отличается от предыдущего на малую величину. Дельта + LZ --- стандартный конвейер для многокадровых анимаций, скроллящихся тайловых карт и спрайтовых анимаций, где фигура меняет позу, но фон остаётся неподвижным.

---

## Практический конвейер

Понимание алгоритмов сжатия полезно. Интеграция их в конвейер сборки необходима.

### От ассета к бинарнику

Конвейер: исходный ассет (PNG) --> конвертер (png2scr) --> упаковщик (zx0) --> ассемблер (sjasmplus) --> файл .tap. Упаковщик работает на твоей машине разработки, не на Spectrum. Для ZX0: `zx0 screen.scr screen.zx0`. Включи результат директивой INCBIN sjasmplus:

```z80
compressed_screen:
    incbin "assets/screen.zx0"
```

В рантайме распакуй простым вызовом:

```z80
    ld   hl, compressed_screen    ; source: compressed data
    ld   de, $4000                ; destination: screen memory
    call dzx0_standard            ; decompress
```

### Интеграция в Makefile

Шаг сжатия принадлежит твоему Makefile, а не твоей голове:

```makefile
%.zx0: %.scr
	zx0 $< $@

demo.tap: main.asm assets/screen.zx0
	sjasmplus main.asm --raw=demo.bin
	bin2tap demo.bin demo.tap
```

Измени исходный PNG, запусти `make`, и сжатый бинарник перегенерируется автоматически. Никаких ручных шагов, никакой забытой перепаковки.

### Пример: загрузочный экран с ZX0

Полный минимальный пример --- распакуй загрузочный экран в видеопамять и жди нажатия клавиши:

```z80
; loading_screen.asm — assemble with sjasmplus
        org  $8000
start:
        ld   hl, compressed_screen
        ld   de, $4000
        call dzx0_standard

.wait:  xor  a
        in   a, ($fe)
        cpl
        and  $1f
        jr   z, .wait
        ret

        include "dzx0_standard.asm"

compressed_screen:
        incbin "screen.zx0"

        display "Total: ", /d, $ - start, " bytes"
```

Используй директиву DISPLAY sjasmplus для вывода информации о размере при ассемблировании. Всегда знай точно, насколько велики твои сжатые данные --- разница между ZX0 и Exomizer на одном загрузочном экране может составлять 400 байт, а на 8 сценах это складывается.

### Выбор правильного упаковщика

Спрашивай по порядку: (1) sizecoding-интро? ZX0/ZX7 --- 69--70 байтный распаковщик не обсуждается. (2) Потоковая передача в реальном времени? LZ4 --- ничто другое не достаточно быстро. (3) Однократная загрузка? Exomizer --- максимальная степень, скорость не важна. (4) Нужен баланс? ApLib или Pletter 5, оба на Парето-фронтире. (5) Данные полны идентичных серий? Пользовательский RLE. (6) Последовательные кадры анимации? Сначала дельта-кодирование, затем LZ.

---

## Возрождение MegaLZ

В 2017 году Introspec объявил MegaLZ "морально устаревшим". Два года спустя он сам его воскресил.

Идея: *формат* сжатия и *реализация распаковщика* --- это разделяемые задачи. Формат MegaLZ был хорош --- первый Spectrum-упаковщик, использующий оптимальный парсер (LVD, 2005), с гамма-кодами Элиаса и чуть большим окном, чем Pletter 5. Что было плохо --- Z80-распаковщик. Introspec написал два новых:

- **Компактный:** 92 байта, ~98 тактов (T-state) на байт
- **Быстрый:** 234 байта, ~63 такта (T-state) на байт --- быстрее трёх последовательных LDIR

С этими распаковщиками MegaLZ "убедительно бьёт Pletter 5 и ZX7" по комбинированной метрике степень-плюс-скорость. Урок: не считай упаковщик мёртвым. Формат --- это сложная часть. Распаковщик --- это Z80-код, а Z80-код всегда можно переписать.

---

## Что значат числа на практике

**4K интро:** 4 096 байт суммарно. Распаковщик ZX0: ~70 байт. Движок + музыка + эффекты: ~2 400 байт. Остаётся ~1 626 байт на сжатые данные, которые распаковываются в ~3 127 байт сырых ассетов. Megademica от SerzhSoft (1-е место, Revision 2019) сжала туннельные эффекты, переходы, AY-музыку и быстрые смены сцен ровно в 4 096 байт. Она была номинирована на Outstanding Technical Achievement на Meteoriks.

**Потоковая передача в реальном времени:** нужно 2 КБ данных на кадр при 50 fps. LZ4 при 34 T/байт распаковывает 2 048 байт за 69 632 такта (T-state) --- почти ровно один кадр (69 888 тактов на 48K). Плотно, но выполнимо с перекрытием распаковки во время бордюра. ApLib потребовал бы 215 040 тактов на те же данные --- более трёх кадров. Exomizer --- более семи. Для потоковой передачи LZ4 --- единственный вариант.

**128K мультисценовое демо:** восемь сцен, каждая с 6 912-байтным загрузочным экраном. Exomizer сжимает каждый до ~3 338 байт; ZX0 до ~3 594 байт. Разница: 256 байт на экран, 2 048 байт на 8 сцен. Когда распаковка происходит при переходе между сценами, медленная распаковка Exomizer незаметна. Экономия 2 КБ --- заметна.

**256-байтное интро:** 70-байтный распаковщик ZX0 оставляет 186 байт на всё. Чаще при таком размере ты пропускаешь LZ и генерируешь данные процедурно с LFSR-генераторами и вызовами калькулятора ПЗУ. Но когда нужны конкретные неалгоритмические данные --- цветовая рампа, фрагмент битмапа --- ZX0 остаётся инструментом.

---

## Итого: шпаргалка по упаковщикам

| Твоя ситуация | Используй | Почему |
|---|---|---|
| Однократная загрузка, максимальная степень | Exomizer | 48,3% степень, скорость не важна |
| Универсальное, хороший баланс | ApLib | 49,2% степень, ~105 T/байт |
| Нужна скорость + приличная степень | Pletter 5 | 51,5% степень, ~69 T/байт |
| Потоковая передача в реальном времени | LZ4 | ~34 T/байт, 2+ КБ за кадр |
| sizecoding-интро (256б--1K) | ZX0 / ZX7 | 69--70 байтный распаковщик |
| 4K интро | ZX0 | Крошечный распаковщик + хорошая степень |
| Серии идентичных байт | RLE (пользовательский) | Распаковщик менее 30 байт |
| Последовательные кадры анимации | Дельта + LZ | Использовать межкадровую избыточность |

Числа --- это ответ. Не мнения, не фольклор, не "я слышал, Exomizer лучший". Introspec протестировал десять упаковщиков на 1,2 мегабайтах реальных данных Spectrum и опубликовал результаты. Используй его числа. Выбери упаковщик, подходящий под твои ограничения. Затем переходи к сложной части --- созданию чего-то, что стоит сжимать.

---

## Попробуй сам

1. **Сожми загрузочный экран.** Возьми любой .scr файл ZX Spectrum (скачай с zxart.ee или создай свой в Multipaint). Сожми его ZX0 и Exomizer. Сравни размеры. Затем напиши минимальный загрузчик, показанный в этой главе, для распаковки и отображения. Замерь время распаковки, используя тайминг через цвет бордюра из Главы 1.

2. **Измерь предел потоковой передачи.** Напиши тесный цикл, распаковывающий данные стандартным распаковщиком ZX0, и измерь, сколько байт он может распаковать за кадр. Сравни с распаковщиком LZ4. Проверь числа из таблицы бенчмарка по своим собственным измерениям.

3. **Построй дельта-упаковщик.** Возьми два экрана ZX Spectrum, отличающихся незначительно (сохрани игровой экран, перемести спрайт, сохрани снова). Напиши простой инструмент (на Python или другом языке), который производит дельта-поток: список пар (смещение, новое_значение) для отличающихся байт. Сравни размер дельта-потока с размером полного второго экрана. Затем сожми дельта-поток ZX0 и сравни снова.

4. **Интегрируй сжатие в Makefile.** Настрой проект с Makefile, который автоматически сжимает ассеты как шаг сборки. Измени исходный PNG, запусти `make` и убедись, что сжатый бинарник перегенерирован и финальный файл .tap обновлён. Это рабочий процесс, который ты будешь использовать в каждом проекте отныне.

> **Источники:** Introspec "Data Compression for Modern Z80 Coding" (Hype, 2017); Introspec "Compression on the Spectrum: MegaLZ" (Hype, 2019); Break Space NFO (Thesuper, 2016); Einar Saukas, ZX0 (github.com/einar-saukas/ZX0)
