# Глава 7: Ротозумер и чанки-пиксели

> *«Трюк в том, что ты не вращаешь экран. Ты вращаешь свой проход по текстуре.»*
> -- перефразируя ключевую идею, стоящую за каждым когда-либо написанным ротозумером

---

Есть момент в Illusion, когда экран заполняется паттерном — текстурой, монохромной, повторяющейся — и затем она начинает вращаться. Вращение плавное и непрерывное, зум дышит туда-сюда, и всё это идёт в таком темпе, что забываешь: ты смотришь, как Z80 гонит пиксели на 3.5 МГц. Это не самый технически сложный эффект в демо. Сфера (Глава 6) сложнее математически. Точечный скроллер (Глава 10) жёстче по бюджету тактов. Но ротозумер — тот, что выглядит лёгким, а на Spectrum сделать что-то лёгким на вид — самый трудный трюк из всех.

Эта глава прослеживает две нити. Первая — анализ Introspec'а 2017 года ротозумера из Illusion от X-Trade. Вторая — статья sq 2022 года на Hype об оптимизации чанки-пикселей, которая доводит подход до 4x4 пикселей и каталогизирует семейство стратегий рендеринга с точными подсчётами тактов. Вместе они отображают пространство решений: как работают чанки-пиксели, как их используют ротозумеры и какие компромиссы производительности определяют, работает ли твой эффект на 4 кадрах за экран или на 12.

---

## Что на самом деле делает ротозумер

Ротозумер отображает 2D-текстуру, повёрнутую на некоторый угол и масштабированную на некоторый коэффициент. Наивный подход: для каждого экранного пикселя вычислить соответствующую текстурную координату через тригонометрическое вращение:

```
    tx = sx * cos(theta) * scale  +  sy * sin(theta) * scale  +  offset_x
    ty = -sx * sin(theta) * scale  +  sy * cos(theta) * scale  +  offset_y
```

При 256x192 это 49 152 пикселя, каждый требующий двух умножений. Даже с 54-тактным умножением через таблицу квадратов (Глава 4) получается более пяти миллионов тактов — примерно 70 кадров процессорного времени. Эффект математически тривиален и вычислительно невозможен.

Ключевая идея в том, что преобразование *линейно*. Перемещение на один пиксель вправо по экрану всегда добавляет одинаковое (dx, dy) к текстурным координатам. Перемещение на один пиксель вниз всегда добавляет одинаковое (dx', dy'). Стоимость на пиксель коллапсирует от двух умножений до двух сложений:

```
Step right:   dx = cos(theta) * scale,   dy = -sin(theta) * scale
Step down:    dx' = sin(theta) * scale,  dy' = cos(theta) * scale
```

Начинаем каждую строку с правильной текстурной координаты и шагаем на (dx, dy) для каждого пикселя. Внутренний цикл становится: прочитать тексель, продвинуть на (dx, dy), повторить. Два сложения на пиксель, никаких умножений. Подготовка к кадру — четыре умножения для вычисления векторов шага из текущего угла и масштаба. Всё остальное следует из линейности.

Это фундаментальная оптимизация, стоящая за каждым ротозумером на любой платформе. На Amiga, на PC, на Spectrum.

---

## Чанки-пиксели: размен разрешения на скорость

Даже при двух сложениях на пиксель запись 6 144 байт в черезстрочную видеопамять Spectrum за кадр непрактична — не если ты ещё хочешь обновить угол и оставить время на музыку. Чанки-пиксели решают это, снижая эффективное разрешение. Вместо одного текселя на экранный пиксель ты отображаешь один тексель на блок 2x2, 4x4 или 8x8.

Illusion использует чанки-пиксели 2x2: эффективное разрешение 128x96, четырёхкратное сокращение работы. Эффект выглядит блочно вблизи, но при скорости, с которой текстура проносится по экрану, движение скрывает грубость. Глаз прощает низкое разрешение, когда всё движется.

Кодировка рассчитана на внутренний цикл. Каждый чанки-пиксель хранится как `$03` (вкл.) или `$00` (выкл.). Почему `$03`? Потому что `ADD A,A` дважды сдвигает влево на 2 позиции, а затем `ADD A,(HL)` подмешивает `$03` следующего пикселя в младшие биты. Четыре чанки-пикселя объединяются в один выходной байт, не используя ничего, кроме сдвигов и сложений — без масок, без ветвлений, без битовых манипуляций.

---

## Внутренний цикл из Illusion

Дизассемблирование Introspec'а выявляет ядро рендерящей последовательности. HL проходит по текстуре; H отслеживает одну ось, L — другую:

```z80
; Inner loop: combine 4 chunky pixels into one output byte
    ld   a,(hl)        ;  7T  -- read first chunky pixel ($03 or $00)
    inc  l             ;  4T  -- step right in texture
    dec  h             ;  4T  -- step up in texture
    add  a,a           ;  4T  -- shift left
    add  a,a           ;  4T  -- shift left (now shifted by 2)
    add  a,(hl)        ;  7T  -- add second chunky pixel
```

Последовательность повторяется для третьего и четвёртого пикселей. `inc l` и `dec h` вместе прочерчивают диагональный путь по текстуре — а диагональный означает повёрнутый. Конкретная комбинация инструкций инкремента и декремента определяет угол вращения.

| Шаг | Инструкции | Такты |
|------|-------------|----------|
| Чтение пикселя 1 | `ld a,(hl)` | 7 |
| Проход | `inc l : dec h` | 8 |
| Сдвиг + чтение пикселя 2 | `add a,a : add a,a : add a,(hl)` | 15 |
| Проход | `inc l : dec h` | 8 |
| Сдвиг + чтение пикселя 3 | `add a,a : add a,a : add a,(hl)` | 15 |
| Проход | `inc l : dec h` | 8 |
| Сдвиг + чтение пикселя 4 | `add a,a : add a,a : add a,(hl)` | 15 |
| Проход | `inc l : dec h` | 8 |
| Вывод + продвижение | `ld (de),a : inc e` | ~11 |
| **Итого на байт** | | **~95** |

Introspec измерил примерно 95 тактов на 4 чанки.

Критическое наблюдение: направление прохода жёстко закодировано в потоке инструкций. Другой угол вращения требует других инструкций. Восемь основных направлений возможны с использованием комбинаций `inc l`, `dec l`, `inc h`, `dec h` и `nop`. Это означает, что рендерящий код меняется каждый кадр.

---

## Покадровая генерация кода

Рендерящий код генерируется заново каждый кадр, с инструкциями прохода, подставленными под текущий угол:

| Диапазон угла | Шаг H | Шаг L | Направление |
|-------------|--------|--------|-----------|
| ~0 градусов | `nop` | `inc l` | Чисто вправо |
| ~45 градусов | `dec h` | `inc l` | Вправо и вверх |
| ~90 градусов | `dec h` | `nop` | Чисто вверх |
| ~135 градусов | `dec h` | `dec l` | Влево и вверх |
| ~180 градусов | `nop` | `dec l` | Чисто влево |
| ~225 градусов | `inc h` | `dec l` | Влево и вниз |
| ~270 градусов | `inc h` | `nop` | Чисто вниз |
| ~315 градусов | `inc h` | `inc l` | Вправо и вниз |

Для промежуточных углов генератор распределяет шаги неравномерно, используя накопление ошибки в стиле Брезенхэма. Вращение на 30 градусов чередует `inc l : nop` и `inc l : dec h` примерно в соотношении 2:1, аппроксимируя тангенс 30 градусов (1.73:1). Результирующий код — развёрнутый цикл, где каждая итерация имеет свою специфическую пару прохода, настроенную на текущий угол.

Стоимость рендеринга для 128x96 при чанки 2x2:

```
16 output bytes/row x 95 T-states = 1,520 T-states/row
1,520 x 96 rows = 145,920 T-states total
```

Примерно 2 кадра на Pentagon. Более консервативная оценка Introspec'а в 4–6 кадров на экран учитывает генерацию кода, перенос буфера и накладные расходы, набирающиеся сверх голого внутреннего цикла.

---

## Перенос буфера на экран

Ротозумер рендерит во внеэкранный буфер, затем переносит в видеопамять. Черезстрочная раскладка экрана делает прямой рендеринг болезненным, а буферизация предотвращает разрывы.

Перенос использует стек:

```z80
    pop  hl                   ; 10T -- read 2 bytes from buffer
    ld   (screen_addr),hl     ; 16T -- write 2 bytes to screen
```

Экранные адреса встроены как литеральные операнды, предвычисленные с учётом чередования Spectrum — ещё один пример генерации кода. При 26 тактах на два байта полный перенос 1 536 байт стоит менее 20 000 тактов. Проход рендеринга — узкое место, не перенос.

---

## Глубокое погружение: чанки-пиксели 4x4 (sq, Hype 2022)

Статья sq доводит чанки-пиксели до 4x4 — эффективное разрешение 64x48. Визуальный результат грубее, но выигрыш в производительности открывает двери для эффектов вроде бампмаппинга и чересстрочного рендеринга. Статья — образец методологии оптимизации: начать просто, итеративно улучшать, измерять на каждом шаге.

**Подход 1: Базовый LD/INC (101 такт на пару).** Загрузить чанки-значение, записать в буфер, продвинуть указатели. Узкое место — управление указателями: `INC HL` по 6 тактов набирается за тысячи итераций.

**Подход 2: Вариант с LDI (104 такта — медленнее!).** `LDI` копирует байт и автоинкрементирует оба указателя одной инструкцией. Но она также декрементирует BC, занимая регистровую пару. Накладные расходы на сохранение/восстановление делают его *медленнее* наивного подхода. Поучительный урок: на Z80 «умная» инструкция не всегда быстрая.

**Подход 3: LDD двойной байт (80 тактов на пару).** Организуя источник и назначение в обратном порядке, автодекремент `LDD` работает в твою пользу. Комбинированная двухбайтная последовательность использует это для 21% улучшения над базовым вариантом.

**Подход 4: Самомодифицирующийся код (76–78 тактов на пару).** Предгенерировать 256 процедур рендеринга, по одной на каждое возможное значение байта, с пиксельным значением, вшитым как непосредственный операнд:

```z80
; One of 256 pre-generated procedures
proc_A5:
    ld   (hl),$A5        ; 10T  -- value baked into instruction
    inc  l               ;  4T
    ld   (hl),$A5        ; 10T  -- 4x4 block spans 2 bytes horizontally
    ; ... handle vertical repetition ...
    ret                  ; 10T
```

256 процедур занимают примерно 3 КБ. Рендеринг на пиксель падает до 76–78 тактов — на 23% быстрее базового, на 27% быстрее LDI.

### Сравнение производительности

| Подход | Такты/пару | Относительно | Память |
|----------|------------|----------|--------|
| Базовый LD/INC | 101 | 1.00x | Минимум |
| Вариант LDI | 104 | 0.97x | Минимум |
| LDD двойной байт | 80 | 1.26x | Минимум |
| Самомодифицирующийся (256 проц.) | 76–78 | 1.30x | ~3 КБ |

Самомодифицирующийся подход побеждает, но отрыв от LDD невелик. В 128K-демо 3 КБ легко найдутся. В 48K-продукции подход LDD может оказаться лучшим инженерным решением.

### Исторические корни: Born Dead #05

sq отмечает, что эти техники развивают работу, опубликованную в Born Dead #05, российской демосценовой газете примерно 2001 года. Основополагающая статья описывала базовый чанки-рендеринг; вклад sq — систематическая оптимизация и вариант с предгенерированными процедурами. Так эволюционирует сценовое знание: техника появляется в малоизвестном дисковом журнале, распространяется внутри сообщества, и двадцать один год спустя кто-то возвращается к ней с новыми замерами и новыми трюками.

---

## Практика: построение простого ротозумера

Вот структура работающего ротозумера с чанки-пикселями 2x2 и шахматной текстурой.

**Текстура.** 256-байтная таблица, выровненная по странице, где каждый байт — `$03` или `$00`, генерирующая полоски шириной 8 пикселей. Регистр H обеспечивает второе измерение; XOR H с индексом создаёт полноценную шахматную доску:

```z80
    ALIGN 256
texture:
    LUA ALLPASS
    for i = 0, 255 do
        if math.floor(i / 8) % 2 == 0 then
            sj.add_byte(0x03)
        else
            sj.add_byte(0x00)
        end
    end
    ENDLUA
```

**Таблица синусов и покадровая подготовка.** 256-элементная таблица синусов, выровненная по странице, управляет вращением. Каждый кадр читает `sin(frame_counter)` и `cos(frame_counter)` (косинус через смещение индекса на 64) для вычисления векторов шага, затем подставляет в инструкции прохода внутреннего цикла правильные опкоды.

**Цикл рендеринга.** Внешний цикл задаёт начальную текстурную координату для каждой строки (шагая перпендикулярно направлению прохода). Внутренний цикл проходит по текстуре:

```z80
.byte_loop:
    ld   a,(hl)              ; read texel 1
    inc  l                   ; walk (patched per-frame)
    add  a,a : add  a,a     ; shift
    add  a,(hl)              ; read texel 2
    inc  l                   ; walk
    add  a,a : add  a,a     ; shift
    add  a,(hl)              ; read texel 3
    inc  l                   ; walk
    add  a,a : add  a,a     ; shift
    add  a,(hl)              ; read texel 4
    inc  l                   ; walk
    ld   (de),a              ; write output byte
    inc  de
    djnz .byte_loop
```

Инструкции `inc l` — цели генератора кода. Перед каждым кадром они заменяются на подходящую комбинацию `inc l`/`dec l`/`inc h`/`dec h`/`nop` в зависимости от текущего угла. Для некардинальных углов аккумулятор ошибки Брезенхэма распределяет шаги по второстепенной оси вдоль строки, так что каждая инструкция прохода в развёрнутом цикле может отличаться от соседних.

**Главный цикл.** `HALT` для синхронизации, вычислить векторы шага, сгенерировать код прохода, отрендерить в буфер, перенести буфер на экран через стек, инкрементировать счётчик кадров, повторить.

---

## Пространство решений

Размер чанки-пикселя — самое важное проектное решение в ротозумере:

| Параметр | 2x2 (Illusion) | 4x4 (sq) | 8x8 (атрибуты) |
|-----------|----------------|----------|-------------------|
| Разрешение | 128x96 | 64x48 | 32x24 |
| Текселей/кадр | 12 288 | 3 072 | 768 |
| Стоимость внутр. цикла | ~146 000 T | ~29 000 T | ~7 300 T |
| Кадров/экран | ~2.3 | ~0.5 | ~0.1 |
| Визуальное качество | Хорошее в движении | Чанки, но быстро | Очень блочно |
| Применение | Ключевые эффекты | Бампмаппинг, оверлеи | Атрибутные эффекты |

Версия 4x4 укладывается в один кадр с запасом для музыкального движка и других эффектов. Версия 2x2 занимает 2–3 кадра, но выглядит существенно лучше. Случай 8x8 — это атрибутный туннель из Главы 9.

Как только у тебя есть быстрый чанки-рендерер, ротозумер — лишь одно применение. Тот же движок приводит в действие **бампмаппинг** (читать разницу высот вместо сырых текселей, выводить затенение), **чересстрочные эффекты** (рендерить чётные/нечётные строки в чередующихся кадрах, удваивая эффективную частоту кадров ценой мерцания) и **искажение текстуры** (менять направление прохода построчно для волнистых или рябящих эффектов). Ротозумер 4x4 может делить кадр со скроллтекстом, музыкальным движком и переносом экрана. Работа sq была мотивирована именно этой универсальностью.

---

## Ротозумер в контексте

Ротозумер — не алгоритм вращения. Это *паттерн обхода памяти*. Ты проходишь по буферу по прямой линии, и направление прохода определяет, что ты видишь. Вращение — один из вариантов направления. Зум — выбор размера шага. Z80 не знает тригонометрии. Он знает `INC L` и `DEC H`. Всё остальное — интерпретация программиста.

В Illusion ротозумер стоит рядом со сферой и точечным скроллером. Все три разделяют одну архитектуру: предвычисленные параметры, сгенерированные внутренние циклы, последовательный доступ к памяти. Сфера использует таблицы пропусков и переменное количество `INC L`. Ротозумер использует направленно подставленные инструкции прохода. Точечный скроллер использует стековые таблицы адресов. Три эффекта, одна философия движка.

Dark построил все три. Introspec трассировал все три. Паттерн, связывающий их — урок Части II: вычислить необходимое до начала внутреннего цикла, сгенерировать код, который только читает-сдвигает-пишет, и поддерживать последовательный доступ к памяти.

---

## Итого

- Ротозумер отображает повёрнутую и масштабированную текстуру, проходя по ней под углом. Линейность снижает стоимость на пиксель от двух умножений до двух сложений.
- Чанки-пиксели (2x2, 4x4) снижают эффективное разрешение и стоимость рендеринга пропорционально. Illusion использует 2x2 при 128x96; система sq использует 4x4 при 64x48.
- Внутренний цикл Illusion: `ld a,(hl) : add a,a : add a,a : add a,(hl)` с инструкциями прохода между чтениями. Стоимость: ~95 тактов на байт для 4 чанки-пикселей.
- Направление прохода меняется каждый кадр, требуя генерации кода — рендерящий цикл подставляется перед каждым кадром.
- Путь оптимизации sq для 4x4: базовый LD/INC (101 такт) к LDI (104 такта, медленнее) к LDD (80 тактов) к самомодифицирующемуся коду с 256 предгенерированными процедурами (76–78 тактов, ~3 КБ). Основан на более ранней работе в Born Dead #05 (~2001).
- Перенос буфера на экран через `pop hl : ld (nn),hl` по ~26 тактов на два байта.
- Ротозумер разделяет архитектуру со сферой (Глава 6) и точечным скроллером (Глава 10): предвычисленные параметры, сгенерированные внутренние циклы, последовательный доступ к памяти.

---

> **Источники:** Introspec, «Технический анализ Illusion от X-Trade» (Hype, 2017); sq, «Chunky Effects on ZX Spectrum» (Hype, 2022); Born Dead #05 (~2001, оригинальные техники чанки-пикселей).
