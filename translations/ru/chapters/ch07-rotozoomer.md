# Глава 7: Ротозумер и чанки-пиксели

> *«Трюк в том, что ты не вращаешь экран. Ты вращаешь свой проход по текстуре.»*
> -- перефразируя ключевую идею, стоящую за каждым когда-либо написанным ротозумером

---

Есть момент в Illusion, когда экран заполняется паттерном — текстурой, монохромной, повторяющейся — и затем она начинает вращаться. Вращение плавное и непрерывное, зум дышит туда-сюда, и всё это идёт в таком темпе, что забываешь: ты смотришь, как Z80 гонит пиксели на 3.5 МГц. Это не самый технически сложный эффект в демо. Сфера (Глава 6) сложнее математически. Точечный скроллер (Глава 10) жёстче по бюджету тактов. Но ротозумер — тот, что выглядит лёгким, а на Spectrum сделать что-то лёгким на вид — самый трудный трюк из всех.

Эта глава прослеживает две нити. Первая — анализ Introspec'а 2017 года ротозумера из Illusion от X-Trade. Вторая — статья sq 2022 года на Hype об оптимизации чанки-пикселей, которая доводит подход до 4x4 пикселей и каталогизирует семейство стратегий рендеринга с точными подсчётами тактов. Вместе они отображают пространство решений: как работают чанки-пиксели, как их используют ротозумеры и какие компромиссы производительности определяют, работает ли твой эффект на 4 кадрах за экран или на 12.

---

## Что на самом деле делает ротозумер

Ротозумер отображает 2D-текстуру, повёрнутую на некоторый угол и масштабированную на некоторый коэффициент. Наивный подход: для каждого экранного пикселя вычислить соответствующую текстурную координату через тригонометрическое вращение:

```text
    tx = sx * cos(theta) * scale  +  sy * sin(theta) * scale  +  offset_x
    ty = -sx * sin(theta) * scale  +  sy * cos(theta) * scale  +  offset_y
```

При 256x192 это 49 152 пикселя, каждый требующий двух умножений. Даже с 54-тактным умножением через таблицу квадратов (Глава 4) получается более пяти миллионов тактов — примерно 70 кадров процессорного времени. Эффект математически тривиален и вычислительно невозможен.

Ключевая идея в том, что преобразование *линейно*. Перемещение на один пиксель вправо по экрану всегда добавляет одинаковое (dx, dy) к текстурным координатам. Перемещение на один пиксель вниз всегда добавляет одинаковое (dx', dy'). Стоимость на пиксель коллапсирует от двух умножений до двух сложений:

```text
Step right:   dx = cos(theta) * scale,   dy = -sin(theta) * scale
Step down:    dx' = sin(theta) * scale,  dy' = cos(theta) * scale
```

Начинаем каждую строку с правильной текстурной координаты и шагаем на (dx, dy) для каждого пикселя. Внутренний цикл становится: прочитать тексель, продвинуть на (dx, dy), повторить. Два сложения на пиксель, никаких умножений. Подготовка к кадру — четыре умножения для вычисления векторов шага из текущего угла и масштаба. Всё остальное следует из линейности.

Это фундаментальная оптимизация, стоящая за каждым ротозумером на любой платформе. На Amiga, на PC, на Spectrum.

### Пошаговое перемещение с фиксированной точкой на Z80

На 16-битной или 32-битной платформе dx и dy были бы значениями с фиксированной точкой: целая часть выбирает тексель, а дробная накапливает субпиксельную точность. На Z80 у нас нет ни регистров, ни пропускной способности для настоящих внутренних циклов с фиксированной точкой. Классическое решение для Spectrum — свести шаг к целочисленным приращениям — всегда ровно +1, -1 или 0 по каждой оси — и управлять *соотношением* шагов между осями для аппроксимации угла.

Рассмотрим поворот на 30 градусов. Точный вектор шага составит (cos 30, -sin 30) = (0.866, -0.5). На машине с арифметикой с фиксированной точкой ты бы прибавлял 0.866 к координате столбца и вычитал 0.5 из координаты строки на каждый пиксель. На Z80 внутренний цикл вместо этого чередует два целочисленных шага: для одних пикселей шаг (+1 столбец, 0 строк), для других — (+1 столбец, -1 строка). Если распределить их примерно в соотношении 2:1 — два шага только по столбцу на каждый диагональный шаг — среднее направление аппроксимирует соотношение 0.866:0.5 обхода под углом 30 градусов. Это алгоритм линии Брезенхэма, применённый к обходу текстуры.

Коэффициент масштабирования определяет, сколько текселей ты пропускаешь на каждый экранный пиксель. При масштабе 1.0 каждый тексель соответствует одному экранному пикселю. При масштабе 2.0 ты пропускаешь каждый второй тексель, фактически приближая изображение. На Spectrum это контролируется удвоением инструкций обхода: вместо одного `INC L` на пиксель ты выполняешь два, шагая на 2 текселя и получая 2-кратное увеличение. Промежуточные уровни масштабирования снова используют распределение в стиле Брезенхэма: одни пиксели шагают на 1, другие на 2, а соотношение управляется аккумулятором ошибки.

Покадровая стоимость вычисления этих параметров пренебрежимо мала: четыре обращения к таблице синусов, несколько умножений (или обращений к таблицам подстановки, см. Главу 4) и подготовительный проход Брезенхэма. Вся тяжёлая работа — во внутреннем цикле, который сведён к одним лишь инкрементам регистров и чтениям памяти.

---

## Чанки-пиксели: размен разрешения на скорость

Даже при двух сложениях на пиксель запись 6 144 байт в чересстрочную видеопамять Spectrum за кадр непрактична — не если ты ещё хочешь обновить угол и оставить время на музыку. Чанки-пиксели решают это, снижая эффективное разрешение. Вместо одного текселя на экранный пиксель ты отображаешь один тексель на блок 2x2, 4x4 или 8x8.

Illusion использует чанки-пиксели 2x2: эффективное разрешение 128x96, четырёхкратное сокращение работы. Эффект выглядит блочно вблизи, но при скорости, с которой текстура проносится по экрану, движение скрывает грубость. Глаз прощает низкое разрешение, когда всё движется.

### Почему 2x2 — золотая середина

Выбор размера блока — это компромисс между тремя параметрами: визуальным качеством, скоростью рендеринга и памятью. При 2x2 ты получаешь 128x96 эффективных пикселей — достаточно, чтобы читать текст и распознавать узоры в текстуре. При 4x4 сетка 64x48 заметно грубее; мелкие детали текстуры становятся нечитаемыми, но эффект всё ещё «читается» как связная вращающаяся поверхность. При 8x8 остаётся лишь 32x24 блока, что соответствует разрешению сетки атрибутов — любые детали текстуры теряются, и эффект выглядит как цветные прямоугольники. Последний вариант может быть полезен для чисто цветовых эффектов (атрибутные туннели, Глава 9), но для пиксельного ротозумера практический диапазон — 2x2 или 4x4.

Расход памяти тоже имеет значение. Каждый чанки-пиксель занимает один байт, поэтому ротозумер 2x2 при разрешении 128x96 обрабатывает 12 288 текселей за кадр. При ширине текстурной строки 256 байт (естественная ширина для 8-битного заворачивания) сама текстура занимает 256 байт на строку, умноженные на нужное количество строк. Версия 4x4 обрабатывает всего 3 072 текселя, то есть внутренний цикл выполняет в четыре раза меньше итераций — но визуальная цена существенна.

На практике спектрумовские демо используют 2x2 для ключевых эффектов ротозумера, а 4x4 оставляют для ситуаций, когда ротозумер делит экран с другими эффектами (оверлеи бампмаппинга, композиции с разделённым экраном).

### Трюк с кодировкой $03

Кодировка рассчитана на внутренний цикл. Каждый чанки-пиксель хранится как `$03` (вкл.) или `$00` (выкл.). Это значение выбрано не случайно — оно кодирует ровно два установленных младших бита: `%00000011`. Посмотри, что происходит, когда четыре пикселя накапливаются в регистре A:

```text
After pixel 1:  A = %00000011                  ($03)
After 2x shift: A = %00001100                  ($0C)
After pixel 2:  A = %00001100 + %00000011      ($0F)
After 2x shift: A = %00111100                  ($3C)
After pixel 3:  A = %00111100 + %00000011      ($3F)
After 2x shift: A = %11111100                  ($FC)
After pixel 4:  A = %11111100 + %00000011      ($FF)
```

Если все четыре пикселя «включены», результат — `$FF`, все биты установлены. Если все четыре «выключены» (`$00`), сдвиги и сложения дают `$00`. Смешанные паттерны дают правильную полосу по 2 бита на пиксель: например, вкл-выкл-вкл-выкл даёт `%11001100` = `$CC`. Каждая пара битов в выходном байте соответствует одному чанки-пикселю. Поскольку каждый чанки-пиксель имеет ширину 2 экранных пикселя (2x2), 8-битный выходной байт покрывает ровно 8 экранных пикселей: четыре чанки-столбца по два пикселя каждый.

Ключевое свойство: поскольку мы всегда прибавляем только `$03` или `$00`, переноса между полями пикселей не возникает. Двухбитные группы никогда не переполняются друг в друга. Именно это делает кодировку безветвленной — не нужны маски, не нужны операции OR, только `ADD A,A` и `ADD A,(HL)`.

---

## Внутренний цикл из Illusion

Дизассемблирование Introspec'а выявляет ядро рендерящей последовательности. HL проходит по текстуре; H отслеживает одну ось, L — другую:

```z80 id:ch07_the_inner_loop_from_illusion
; Inner loop: combine 4 chunky pixels into one output byte
    ld   a,(hl)        ;  7T  -- read first chunky pixel ($03 or $00)
    inc  l             ;  4T  -- step right in texture
    dec  h             ;  4T  -- step up in texture
    add  a,a           ;  4T  -- shift left
    add  a,a           ;  4T  -- shift left (now shifted by 2)
    add  a,(hl)        ;  7T  -- add second chunky pixel
```

Последовательность повторяется для третьего и четвёртого пикселей. `inc l` и `dec h` вместе прочерчивают диагональный путь по текстуре — а диагональный означает повёрнутый. Конкретная комбинация инструкций инкремента и декремента определяет угол вращения.

| Шаг | Инструкции | Такты |
|------|-------------|----------|
| Чтение пикселя 1 | `ld a,(hl)` | 7 |
| Проход | `inc l : dec h` | 8 |
| Сдвиг + чтение пикселя 2 | `add a,a : add a,a : add a,(hl)` | 15 |
| Проход | `inc l : dec h` | 8 |
| Сдвиг + чтение пикселя 3 | `add a,a : add a,a : add a,(hl)` | 15 |
| Проход | `inc l : dec h` | 8 |
| Сдвиг + чтение пикселя 4 | `add a,a : add a,a : add a,(hl)` | 15 |
| Проход | `inc l : dec h` | 8 |
| Вывод + продвижение | `ld (de),a : inc e` | ~11 |
| **Итого на байт** | | **~95** |

Introspec измерил примерно 95 тактов на 4 чанки.

Критическое наблюдение: направление прохода жёстко закодировано в потоке инструкций. Другой угол вращения требует других инструкций. Восемь основных направлений возможны с использованием комбинаций `inc l`, `dec l`, `inc h`, `dec h` и `nop`. Это означает, что рендерящий код меняется каждый кадр.

### Самомодифицирующийся код на уровне байта

«Покадровая генерация кода» звучит экзотично, но механизм прост. Каждая инструкция обхода — это один байт в памяти. `INC L` — опкод `$2C`. `DEC L` — `$2D`. `INC H` — `$24`. `DEC H` — `$25`. `NOP` — `$00`. Чтобы изменить направление обхода с «вправо и вверх» (`INC L` + `DEC H`) на «чисто вправо» (`INC L` + `NOP`), ты записываешь `$00` в байт, где сейчас находится `$25`. Это и есть весь шаг генерации кода: `LD A,$00 : LD (walk_target),A`. Несколько записей в поток инструкций — и внутренний цикл теперь обходит текстуру в другом направлении.

Адреса-цели известны на этапе ассемблирования. Каждое место SMC помечено меткой (например, `.smc_walk_h_0:`) и код подмены использует эти метки как буквальные адреса. Нет динамического выделения памяти, нет разбора инструкций, нет дизассемблирования в рантайме. Ты записываешь известные опкоды по известным адресам. У Z80 нет кэша инструкций, который нужно инвалидировать, нет конвейера, который нужно сбрасывать. Запись вступает в силу немедленно при следующем чтении с этого адреса.

В полностью развёрнутом внутреннем цикле (который Illusion использует для своих 16-байтных строк) пришлось бы подменить 64 места с инструкциями обхода: 4 пары инструкций обхода на каждый выходной байт, умноженные на 16 байт на строку. Подмена 64 байт стоит примерно 64 x 13 = 832 такта (T-state) (каждая `LD (nn),A` — 13 тактов (T-state)), что ничтожно мало по сравнению со 100 000+ тактами (T-state) рендеринга. Генератор кода дёшев. Важен сгенерированный код.

---

## Покадровая генерация кода

Рендерящий код генерируется заново каждый кадр, с инструкциями прохода, подставленными под текущий угол:

| Диапазон угла | Шаг H | Шаг L | Направление |
|-------------|--------|--------|-----------|
| ~0 градусов | `nop` | `inc l` | Чисто вправо |
| ~45 градусов | `dec h` | `inc l` | Вправо и вверх |
| ~90 градусов | `dec h` | `nop` | Чисто вверх |
| ~135 градусов | `dec h` | `dec l` | Влево и вверх |
| ~180 градусов | `nop` | `dec l` | Чисто влево |
| ~225 градусов | `inc h` | `dec l` | Влево и вниз |
| ~270 градусов | `inc h` | `nop` | Чисто вниз |
| ~315 градусов | `inc h` | `inc l` | Вправо и вниз |

Для промежуточных углов генератор распределяет шаги неравномерно, используя накопление ошибки в стиле Брезенхэма. Вращение на 30 градусов чередует `inc l : nop` и `inc l : dec h` примерно в соотношении 2:1, аппроксимируя тангенс 30 градусов (1.73:1). Результирующий код — развёрнутый цикл, где каждая итерация имеет свою специфическую пару прохода, настроенную на текущий угол.

Стоимость рендеринга для 128x96 при чанки 2x2. Область 128x96 — это 96 строк пикселей, но каждый тексель 2x2 покрывает две строки пикселей, давая 48 текстурных строк. Каждая текстурная строка порождает 16 выходных байт (128 пикселей / 8 бит на байт, по 4 чанки-пикселя в каждом байте):

```text
16 output bytes/row x 95 T-states = 1,520 T-states/row
1,520 x 48 texel rows = 72,960 T-states total
```

Примерно 1 кадр на Pentagon (71 680 тактов (T-state) на кадр). Но это только голый внутренний цикл. Полный подсчёт включает:

```text
Code generation:        ~  1,000 T  (patching walk instructions)
Row setup (per row):    ~    800 T  (48 rows x ~17 T each)
Buffer-to-screen copy:  ~ 20,000 T  (stack trick, 1,536 bytes)
Sine table lookups:     ~    200 T
Frame overhead:         ~    500 T  (HALT, border, angle update)
                        ----------
Inner loop:               72,960 T
Total per frame:        ~ 95,460 T  (= 1.33 Pentagon frames)
```

На стандартном 48K/128K Spectrum при 69 888 тактах (T-state) на кадр рендеринг занимает примерно 1,4 кадра. Оценка Introspec в 4–6 кадров на экран учитывает более сложный путь кода в Illusion (который обрабатывает полный экран 256x192, а не только полосу 128x96) и стоимость музыкального движка, работающего в прерывании. На Pentagon с его чуть более длинным кадром (71 680 тактов (T-state)) и без спорной памяти внутренний цикл работает примерно на 3% быстрее.

Спорная память на 48K/128K Spectrum добавляет ещё одну скрытую стоимость. Во время верхних 192 строк развёртки ULA крадёт такты у процессора при обращении к нижним 16 КБ ОЗУ ($4000-$7FFF). Внутренний цикл читает из текстуры (которая должна быть выше $8000, вне спорной памяти) и пишет в буфер (тоже выше $8000), поэтому он полностью избегает конкуренции. Перенос буфера на экран, однако, пишет напрямую в видеопамять и будет замедлен спорной памятью, если пересечётся с периодом отображения. Поэтому демо синхронизируют перенос на экран с периодом бордюра или нижней частью отображения.

---

## Перенос буфера на экран

Ротозумер рендерит во внеэкранный буфер, затем переносит в видеопамять. Черезстрочная раскладка экрана делает прямой рендеринг болезненным, а буферизация предотвращает разрывы.

Перенос использует стек:

```z80 id:ch07_buffer_to_screen_transfer
    pop  hl                   ; 10T -- read 2 bytes from buffer
    ld   (screen_addr),hl     ; 16T -- write 2 bytes to screen
```

Экранные адреса встроены как литеральные операнды, предвычисленные с учётом чередования Spectrum — ещё один пример генерации кода. При 26 тактах на два байта полный перенос 1 536 байт стоит менее 20 000 тактов. Проход рендеринга — узкое место, не перенос.

---

## Глубокое погружение: чанки-пиксели 4x4 (sq, Hype 2022)

Статья sq доводит чанки-пиксели до 4x4 — эффективное разрешение 64x48. Визуальный результат грубее, но выигрыш в производительности открывает двери для эффектов вроде бампмаппинга и чересстрочного рендеринга. Статья — образец методологии оптимизации: начать просто, итеративно улучшать, измерять на каждом шаге.

**Подход 1: Базовый LD/INC (101 такт на пару).** Загрузить чанки-значение, записать в буфер, продвинуть указатели. Узкое место — управление указателями: `INC HL` по 6 тактов набирается за тысячи итераций.

**Подход 2: Вариант с LDI (104 такта — медленнее!).** `LDI` копирует байт и автоинкрементирует оба указателя одной инструкцией. Но она также декрементирует BC, занимая регистровую пару. Накладные расходы на сохранение/восстановление делают его *медленнее* наивного подхода. Поучительный урок: на Z80 «умная» инструкция не всегда быстрая.

**Подход 3: LDD двойной байт (80 тактов на пару).** Организуя источник и назначение в обратном порядке, автодекремент `LDD` работает в твою пользу. Комбинированная двухбайтная последовательность использует это для 21% улучшения над базовым вариантом.

**Подход 4: Самомодифицирующийся код (76–78 тактов на пару).** Предгенерировать 256 процедур рендеринга, по одной на каждое возможное значение байта, с пиксельным значением, вшитым как непосредственный операнд:

```z80 id:ch07_deep_dive_4x4_chunky_pixels
; One of 256 pre-generated procedures
proc_A5:
    ld   (hl),$A5        ; 10T  -- value baked into instruction
    inc  l               ;  4T
    ld   (hl),$A5        ; 10T  -- 4x4 block spans 2 bytes horizontally
    ; ... handle vertical repetition ...
    ret                  ; 10T
```

256 процедур занимают примерно 3 КБ. Рендеринг на пиксель падает до 76–78 тактов — на 23% быстрее базового, на 27% быстрее LDI.

### Сравнение производительности

| Подход | Такты/пару | Относительно | Память |
|----------|------------|----------|--------|
| Базовый LD/INC | 101 | 1.00x | Минимум |
| Вариант LDI | 104 | 0.97x | Минимум |
| LDD двойной байт | 80 | 1.26x | Минимум |
| Самомодифицирующийся (256 проц.) | 76–78 | 1.30x | ~3 КБ |

Самомодифицирующийся подход побеждает, но отрыв от LDD невелик. В 128K-демо 3 КБ легко найдутся. В 48K-продукции подход LDD может оказаться лучшим инженерным решением.

### Исторические корни: Born Dead #05 и сценовая преемственность

sq отмечает, что эти техники развивают работу, опубликованную в Born Dead #05, российской демосценовой газете примерно 2001 года. Born Dead был одним из нескольких русскоязычных дисковых журналов, служивших техническими изданиями для демосцены ZX Spectrum. В отличие от западных PC-демосценовых публикаций, которые могли рассчитывать на оборудование уровня 486, спектрумовские журналы работали в условиях сообщества, всё ещё активно разрабатывавшего новые техники для машины 1982 года. Основополагающая статья описывала базовый чанки-рендеринг — идею о том, что битовый дисплей Spectrum можно трактовать как чанки-пиксельный буфер более низкого разрешения, выигрывая в скорости за счёт разрешения.

Вклад sq, двадцать один год спустя, состоял в систематической оптимизации и варианте с предгенерированными процедурами. Но между Born Dead #05 и статьёй sq 2022 года чанки-ротозумер появился в многочисленных демо для Spectrum. Illusion от X-Trade (ENLiGHT'96) была одной из первых полноценных реализаций. Среди других заметных примеров — GOA4K и Refresh от Exploder^XTM, работы 4D, а также более поздние произведения российской и польской сцен. Техника распространялась отчасти через дизассемблирование — анализ Illusion, выполненный Introspec в 2017 году, сам по себе является примером сценовой традиции обучения через реверс-инжиниринг — и отчасти через неформальную сеть знаний: дисковые журналы, посты на BBS и прямое общение между кодерами.

Так эволюционирует сценовое знание: техника появляется в малоизвестном дисковом журнале, распространяется внутри сообщества, и двадцать один год спустя кто-то возвращается к ней с новыми замерами и новыми трюками. Цепочка от Born Dead к sq и к этой главе непрерывна.

---

## Практика: построение простого ротозумера

Вот структура работающего ротозумера с чанки-пикселями 2x2 и шахматной текстурой.

**Текстура.** 256-байтная таблица, выровненная по странице, где каждый байт — `$03` или `$00`, генерирующая полоски шириной 8 пикселей. Регистр H обеспечивает второе измерение; XOR H с индексом создаёт полноценную шахматную доску:

```lua id:ch07_practical_building_a_simple
    ALIGN 256
texture:
    LUA ALLPASS
    for i = 0, 255 do
        if math.floor(i / 8) % 2 == 0 then
            sj.add_byte(0x03)
        else
            sj.add_byte(0x00)
        end
    end
    ENDLUA
```

**Таблица синусов и покадровая подготовка.** 256-элементная таблица синусов, выровненная по странице, управляет вращением. Каждый кадр читает `sin(frame_counter)` и `cos(frame_counter)` (косинус через смещение индекса на 64) для вычисления векторов шага, затем подставляет в инструкции прохода внутреннего цикла правильные опкоды.

**Цикл рендеринга.** Внешний цикл задаёт начальную текстурную координату для каждой строки (шагая перпендикулярно направлению прохода). Внутренний цикл проходит по текстуре:

```z80 id:ch07_practical_building_a_simple_2
.byte_loop:
    ld   a,(hl)              ; read texel 1
    inc  l                   ; walk (patched per-frame)
    add  a,a : add  a,a     ; shift
    add  a,(hl)              ; read texel 2
    inc  l                   ; walk
    add  a,a : add  a,a     ; shift
    add  a,(hl)              ; read texel 3
    inc  l                   ; walk
    add  a,a : add  a,a     ; shift
    add  a,(hl)              ; read texel 4
    inc  l                   ; walk
    ld   (de),a              ; write output byte
    inc  de
    djnz .byte_loop
```

Инструкции `inc l` — цели генератора кода. Перед каждым кадром они заменяются на подходящую комбинацию `inc l`/`dec l`/`inc h`/`dec h`/`nop` в зависимости от текущего угла. Для некардинальных углов аккумулятор ошибки Брезенхэма распределяет шаги по второстепенной оси вдоль строки, так что каждая инструкция прохода в развёрнутом цикле может отличаться от соседних.

![Результат работы ротозумера — текстура вращается и масштабируется в реальном времени, отрендерена чанки-пикселями 2x2](../../build/screenshots/ch07_rotozoomer.png)

**Главный цикл.** `HALT` для синхронизации, вычислить векторы шага, сгенерировать код прохода, отрендерить в буфер, перенести буфер на экран через стек, инкрементировать счётчик кадров, повторить.

---

## Дизайн текстуры и обработка границ

Текстура — наиболее ограниченная структура данных в ротозумере. Каждое проектное решение внутреннего цикла — выравнивание по странице, поведение заворачивания, размеры степени двойки — восходит к тому, как текстура размещена в памяти.

### Почему выравнивание по странице, почему 256 столбцов

Текстура выровнена по странице, чтобы H выбирал строку, а L — столбец. Это не просто удобно — это делает внутренний цикл возможным. `INC L` и `DEC L` автоматически заворачиваются на границе 256-байтной страницы — когда L переполняется с `$FF` в `$00`, H остаётся неизменным. Текстура заворачивается по горизонтали бесплатно, без каких-либо накладных расходов на ветвление. Если бы текстура не была выровнена по странице, инкременты L вызывали бы перенос в H, разрушая адрес строки. Пришлось бы использовать явное маскирование (`AND $3F` после каждого шага), что добавило бы 4–8 тактов (T-state) на пиксель и уничтожило бы плотный внутренний цикл.

Вертикальная ось (H) тоже заворачивается, но в пределах всего диапазона строк, выделенных текстуре. Если ты выделишь 64 строки (страницы), H будет варьироваться от базовой страницы текстуры до base+63. `INC H` и `DEC H` спокойно выйдут за пределы текстуры в какую бы то ни было следующую память. Illusion решает это маскированием H по высоте текстуры в начале каждой строки (не на каждый пиксель — попиксельное маскирование было бы слишком дорогим). Это работает, потому что в пределах одной 16-байтной строки координата H изменяется максимум на 16 шагов, и если текстура достаточно высока относительно ширины строки, переполнение внутри строки не может достичь памяти, которая даст визуальный мусор. Текстура из 64 строк с 16 шагами H на строку имеет комфортный запас.

### Выбор размера текстуры

Текстура должна иметь ширину, равную степени двойки (всегда 256, поскольку L — 8-битный), и в идеале высоту, равную степени двойки, для удобного маскирования. Типичные варианты:

- **256x256** (64 КБ): заполняет всю верхнюю память на 128K Spectrum. Максимальное разрешение, но не остаётся места для кода или буферов.
- **256x64** (16 КБ): практичный выбор. Помещается в один банк памяти 16 КБ на 128K-оборудовании. 6-битная маска высоты (`AND $3F`) быстра и тайлится бесшовно.
- **256x32** (8 КБ): помещается на 48K Spectrum с местом для всего остального. Текстура повторяется заметнее, но для шахматного или полосатого узора повторение *и есть* дизайн.
- **256x16** (4 КБ): минимум. Подходит для очень простых паттернов вроде одноосевых полос.

Для неповторяющихся текстур (изображения, логотипы) высота должна быть не менее эффективной высоты экрана, делённой на коэффициент масштабирования. Ротозумер 2x2 с 96 эффективными строками требует как минимум 96 текстурных строк, чтобы избежать видимого тайлинга при масштабе 1:1. При более высоких уровнях масштабирования строк нужно меньше, потому что камера «ближе» к поверхности текстуры.

### А как насчёт границ экрана?

Экран Spectrum — 256x192, что составляет 32 байта в ширину на 192 строки. Если твой ротозумер заполняет полосу 128x96 в центре, ты никогда не приближаешься к краю видеопамяти. Но полноэкранный ротозумер при 256x192 (или даже 128x192 с чанки 2x2) должен обрабатывать случай, когда выходной адрес достигает области атрибутов по адресу `$5800`. Простейший подход: рендерить в буфер и копировать только ту часть, которая помещается. Более агрессивный подход: обрезать количество строк до видимой области на этапе генерации кода, что позволяет избежать бесполезных вычислений, но усложняет цикл по строкам.

На практике большинство спектрумовских ротозумеров рендерят полосу меньше полного экрана. Визуальное обрамление — бордюр, заголовок, титры с музыкой — скрывает обрезку и высвобождает такты для других эффектов.

---

## Пространство решений

Размер чанки-пикселя — самое важное проектное решение в ротозумере:

| Параметр | 2x2 (Illusion) | 4x4 (sq) | 8x8 (атрибуты) |
|-----------|----------------|----------|-------------------|
| Разрешение | 128x96 | 64x48 | 32x24 |
| Текселей/кадр | 12 288 | 3 072 | 768 |
| Стоимость внутр. цикла | ~73 000 T | ~29 000 T | ~7 300 T |
| Кадров/экран | ~1,3 | ~0,5 | ~0,1 |
| Визуальное качество | Хорошее в движении | Чанки, но быстро | Очень блочно |
| Применение | Ключевые эффекты | Бампмаппинг, оверлеи | Атрибутные эффекты |

Версия 4x4 укладывается в один кадр с запасом для музыкального движка и других эффектов. Версия 2x2 занимает примерно 1,3–1,5 кадра (с учётом накладных расходов), но выглядит существенно лучше. Случай 8x8 — это атрибутный туннель из Главы 9.

Как только у тебя есть быстрый чанки-рендерер, ротозумер — лишь одно применение. Тот же движок приводит в действие **бампмаппинг** (читать разницу высот вместо сырых текселей, выводить затенение), **чересстрочные эффекты** (рендерить чётные/нечётные строки в чередующихся кадрах, удваивая эффективную частоту кадров ценой мерцания) и **искажение текстуры** (менять направление прохода построчно для волнистых или рябящих эффектов). Ротозумер 4x4 может делить кадр со скроллтекстом, музыкальным движком и переносом экрана. Работа sq была мотивирована именно этой универсальностью.

---

## Три подхода к вращению текстуры

Всё вышеизложенное рассматривает ротозумер как одну технику с настраиваемым размером блока. Но «ротозумер» на Spectrum — это на самом деле семейство трёх различных подходов, каждый со своим внутренним циклом, своим визуальным характером и своим профилем производительности. Они разделяют одну и ту же математическую основу — линейные векторы шага, распределение углов в стиле Брезенхэма — но полностью расходятся на уровне рендеринга.

### Вариант 1: Монохромный битмап (полное пиксельное разрешение)

Чистейшая форма: каждый экранный пиксель соответствует одному текселю. Текстура монохромная — один бит на пиксель — поэтому чтение текселя означает проверку одного бита, а запись на экран означает установку или сброс одного бита. Никакой чанки-кодировки, никакой группировки блоков. Результат — повёрнутая текстура в полном разрешении 256x192 дисплея Spectrum.

Скелет внутреннего цикла выглядит примерно так:

```z80 id:ch07_variant_1_monochrome_bitmap
; For each screen pixel:
; DE = texture pointer, HL = screen pointer
    ld   a,(de)           ;  7T  -- read texture byte
    and  n                ;  7T  -- test texture bit at current coords
    jr   z,.pixel_off     ; 12/7T
    set  m,(hl)           ; 15T  -- set screen bit
    jr   .pixel_done      ; 12T
.pixel_off:
    res  m,(hl)           ; 15T  -- clear screen bit
.pixel_done:
    ; advance texture coords (inc e / dec d / etc.)
    ; advance screen bit position
    ; ... next pixel
```

Обрати внимание, что SET и RES работают только с (HL), (IX+d) или (IY+d) — не с (DE) и не с (BC). Это вынуждает HL служить указателем на экран, а DE — обрабатывать координаты текстуры.

Стоимость на пиксель жестокая: минимум 35–45 тактов (T-state) с ветвлением на каждом пикселе. На 49 152 пикселя это 1,5–2 миллиона тактов (T-state) только на проход рендеринга — примерно 21–28 кадров на стандартном Spectrum. Полноэкранный монохромный ротозумер при 50 кадрах в секунду — такого не будет.

Но никто не говорил, что нужно заполнять весь экран. Техника раскрывается при применении к меньшей области — полосе 128x64, круглому вьюпорту, маскированной зоне — или когда ты готов принять более низкую частоту кадров ради визуального эффекта вращения в полном разрешении. Она также прекрасно работает для эффектов искажения, где «вращение» неравномерно: варьирование векторов шага по строкам развёртки создаёт волновые искажения, эффекты бочки и вид «звуковой ряби», встречающийся в частях Illusion от Dark/X-Trade. Координатное отображение перестаёт быть простым вращением и превращается в построчную деформацию текстуры. Математика та же — пошаговое перемещение с фиксированной точкой вдоль направления — но само направление меняется на каждой строке.

Визуальная отдача поразительна. Там, где чанки-ротозумер 2x2 выглядит как вращающаяся мозаика, монохромная битмап-версия выглядит как вращающееся *изображение*. На машине, где каждый эффект борется за один и тот же бюджет кадра в 69 888 тактов (T-state), выделение нескольких кадров на рендеринг в полном разрешении — это осознанный эстетический выбор.

### Вариант 2: Чанки-ротозумер (блоки 2x2 или 4x4)

Это техника, описанная в основной части этой главы. Каждый экранный блок (2x2 или 4x4 пикселя) соответствует одному текселю. Кодировка `$03`/`$00`, накопление через `add a,a : add a,(hl)`, подмена инструкций обхода — всё это нацелено на этот подход.

При 2x2 (эффективное разрешение 128x96) внутренний цикл работает приблизительно на 95 тактов (T-state) за выходной байт, создавая плавный, узнаваемый ротозумер, видимый в Illusion. При 4x4 (64x48) вариант sq с предгенерированными процедурами полностью устраняет накладные расходы цикла, снижая стоимость до 76–78 тактов (T-state) на выходную пару и оставляя место для мультиэффектных композиций в пределах одного кадра.

Чанки-ротозумер занимает золотую середину: достаточно быстрый для реального времени, достаточно детальный, чтобы нести на себе ключевой эффект. Это рабочая лошадка репертуара ротозумеров на Spectrum.

### Вариант 3: Атрибутный ротозумер («пиксели» из блоков 8x8)

Область атрибутов Spectrum по адресам `$5800`-`$5AFF` хранит цветовую информацию для каждой знакоместной ячейки 8x8 пикселей: 32 столбца на 24 строки, всего 768 байт. Каждый байт кодирует INK, PAPER, BRIGHT и FLASH для одного блока 8x8. Атрибутный ротозумер полностью игнорирует битмап и трактует эти 768 ячеек атрибутов как поверхность отображения. Каждая ячейка становится одним «пикселем» в изображении 32x24.

Внутренний цикл структурно идентичен чанки-версии — обходим координаты текстуры, читаем значение, записываем на выход — но выход — это область атрибутов, а значение «текселя» — это байт цветового атрибута, а не битовый паттерн. Эффективное разрешение — всего 32x24, а значит, весь проход рендеринга — это 768 итераций цикла обхода.

Расчёт:

```text
32 columns x 24 rows = 768 attribute cells
~10 T-states per cell (read texel + write attribute + step)
768 x 10 = ~7,680 T-states total
```

Это примерно 11% одного кадра. Ты мог бы запустить атрибутный ротозумер девять раз подряд — и всё ещё оставался бы запас для музыкального движка. Стоимость настолько мала, что эффект по сути бесплатен.

Но визуальная отдача отличается от битмап-вариантов. Ты вращаешь не пиксели — ты вращаешь цветные блоки. При 32x24 мелкие детали невидимы. Вместо этого ты получаешь раскатывающееся поле цвета, яркую мозаику, которая вращается и дышит. Атрибутный ротозумер в Illusion использует именно это: ярко окрашенную текстуру (не монохромный битмап), отображённую через сетку атрибутов, создавая характерный вид «витража» из вращающихся цветовых полей, которым Illusion знаменита. Поля PAPER и INK в каждом байте атрибута дают два цвета на ячейку, поэтому тщательно спроектированная текстура может нести больше визуальной информации, чем подразумевает сырое разрешение.

Атрибутный ротозумер идеально подходит для фонов, переходов или как базовый слой с наложенными поверх пиксельными эффектами. Поскольку он пишет только в область атрибутов, битмап можно одновременно использовать для другого эффекта — скроллера, логотипа, поля частиц — работающего в своём ритме. Этот многослойный подход — визитная карточка мультиэффектных экранов демо на Spectrum.

### Сравнение

| Вариант | Эффективное разрешение | Байт записано/кадр | ~Тактов (рендеринг) | Цвет | Типичное применение |
|---------|---------------------|--------------------|--------------------|--------|-------------|
| Монохромный битмап | 256x192 (или подобласть) | 6 144 (полный экран) | 1 500 000–2 000 000 | 1 бит | Главный эффект, искажение, деформация |
| Чанки 2x2 | 128x96 | 1 536 | ~73 000 | 1 бит | Ключевой ротозумер |
| Чанки 4x4 | 64x48 | 384 | ~29 000 | 1 бит | Мультиэффект, оверлей |
| Атрибутный | 32x24 | 768 | ~7 700 | INK+PAPER (2 цвета/ячейка) | Фон, цветовая заливка, переход |

Движение сверху вниз по таблице — это плавный обмен: разрешение на скорость, детализация на запас тактов. Монохромный битмап даёт всё, что может показать дисплей Spectrum, ценой, требующей полной отдачи. Атрибутная версия почти ничего не даёт в разрешении, но работает так быстро, что ротозумер становится лишь одним из инструментов в мультиэффектной композиции, а не главным событием.

Все четыре строки этой таблицы используют один и тот же базовый алгоритм. Векторы шага вычисляются одинаково. Распределение по Брезенхэму работает одинаково. Разница лишь в том, куда ты пишешь и сколько итераций выполняешь. Построив один ротозумер, ты построил их все.

---

## Ротозумер в контексте

Ротозумер — не алгоритм вращения. Это *паттерн обхода памяти*. Ты проходишь по буферу по прямой линии, и направление прохода определяет, что ты видишь. Вращение — один из вариантов направления. Зум — выбор размера шага. Z80 не знает тригонометрии. Он знает `INC L` и `DEC H`. Всё остальное — интерпретация программиста.

В Illusion ротозумер стоит рядом со сферой и точечным скроллером. Все три разделяют одну архитектуру: предвычисленные параметры, сгенерированные внутренние циклы, последовательный доступ к памяти. Сфера использует таблицы пропусков и переменное количество `INC L`. Ротозумер использует направленно подставленные инструкции прохода. Точечный скроллер использует стековые таблицы адресов. Три эффекта, одна философия движка.

Dark построил все три. Introspec трассировал все три. Паттерн, связывающий их — урок Части II: вычислить необходимое до начала внутреннего цикла, сгенерировать код, который только читает-сдвигает-пишет, и поддерживать последовательный доступ к памяти.

---

## Итого

- Ротозумер отображает повёрнутую и масштабированную текстуру, проходя по ней под углом. Линейность снижает стоимость на пиксель от двух умножений до двух сложений.
- Чанки-пиксели (2x2, 4x4) снижают эффективное разрешение и стоимость рендеринга пропорционально. Illusion использует 2x2 при 128x96; система sq использует 4x4 при 64x48.
- Внутренний цикл Illusion: `ld a,(hl) : add a,a : add a,a : add a,(hl)` с инструкциями прохода между чтениями. Стоимость: ~95 тактов на байт для 4 чанки-пикселей.
- Направление прохода меняется каждый кадр, требуя генерации кода — рендерящий цикл подставляется перед каждым кадром.
- Путь оптимизации sq для 4x4: базовый LD/INC (101 такт) к LDI (104 такта, медленнее) к LDD (80 тактов) к самомодифицирующемуся коду с 256 предгенерированными процедурами (76–78 тактов, ~3 КБ). Основан на более ранней работе в Born Dead #05 (~2001).
- Перенос буфера на экран через `pop hl : ld (nn),hl` по ~26 тактов на два байта.
- Ротозумер разделяет архитектуру со сферой (Глава 6) и точечным скроллером (Глава 10): предвычисленные параметры, сгенерированные внутренние циклы, последовательный доступ к памяти.

---

> **Источники:** Introspec, «Технический анализ Illusion от X-Trade» (Hype, 2017); sq, «Chunky Effects on ZX Spectrum» (Hype, 2022); Born Dead #05 (~2001, оригинальные техники чанки-пикселей).
