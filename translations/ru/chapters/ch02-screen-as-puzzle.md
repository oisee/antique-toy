# Глава 2: Экран как головоломка

> «Почему строки идут в таком порядке?»
> -- Каждый программист ZX Spectrum, рано или поздно

Открой любой эмулятор, набери `PEEK 16384` — и ты читаешь первый байт экранной памяти Spectrum. Но какой это байт? Не верхний левый экрана в каком-либо простом смысле. Пиксель с координатой (0,0) действительно там — но пиксель (0,1), следующая строка вниз, живёт на 256 байт дальше. Пиксель (0,8), верхняя строка второго знакоместа, расположен всего в 32 байтах от начала. А пиксель (0,64) — первая строка средней трети экрана — живёт ровно в 2 048 байтах от начала, по адресу `$4800`.

Это самая знаменитая головоломка Spectrum. Раскладка экранной памяти не последовательная, не интуитивная и не случайная. Она — следствие аппаратных решений, принятых в 1982 году, и она определяет каждый фрагмент кода, который работает с экраном. Понимание этой раскладки — и изучение трюков, позволяющих быстро по ней перемещаться — фундаментально для всего, что последует в этой книге.

---

## Карта памяти: 6 912 байт экрана

Экран Spectrum занимает фиксированную область памяти:

```
$4000 - $57FF    Пиксельные данные   6 144 байта   (256 x 192 пикселей, 1 бит на пиксель)
$5800 - $5AFF    Атрибуты              768 байт   (32 x 24 цветовые ячейки)
```

Пиксельная область хранит растр: 256 пикселей по горизонтали, упакованные по 8 в байт, что даёт 32 байта на строку. При 192 строках это 32 x 192 = 6 144 байта. Каждый байт представляет 8 горизонтальных пикселей, где бит 7 — крайний левый, а бит 0 — крайний правый.

Область атрибутов хранит цветовую информацию: один байт на 8x8 знакоместо. 32 столбца и 24 строки, итого 32 x 24 = 768 байт.

Вместе: 6 144 + 768 = 6 912 байт. Это весь экран.

![Раскладка экранной памяти ZX Spectrum с третями, знакоместами и областью атрибутов](illustrations/output/ch02_screen_layout.png)

Пиксельные данные и данные атрибутов служат разным целям, но тесно связаны. Каждый пиксельный байт управляет 8 точками на экране; байт атрибута соответствующего 8x8 знакоместа определяет, каким цветом эти точки отображаются. Измени пиксель — изменишь форму. Измени атрибут — изменишь цвет. Но цвет можно менять только для целого блока 8x8 — не попиксельно. Это и есть «конфликт атрибутов», определяющий визуальный характер Spectrum, и мы вернёмся к нему чуть позже.

Но сначала — головоломка: почему пиксельные строки перемешаны?

---

## Чересстрочность: Где живут строки

Если бы Spectrum хранил пиксельные строки последовательно, строка 0 была бы по адресу `$4000`, строка 1 — по `$4020`, строка 2 — по `$4040`, и так далее. Каждая строка — 32 байта, значит строка N просто по `$4000 + N * 32`. Просто, быстро, разумно.

Но не так всё устроено.

Экран разделён на три **трети**, каждая высотой 64 пиксельных строки. Внутри каждой трети строки чередуются по знакоместам. Вот где реально находятся первые 16 строк:

```
Row  0:  $4000     Треть 0, знакоместо 0, развёрточная строка 0
Row  1:  $4100     Треть 0, знакоместо 0, развёрточная строка 1
Row  2:  $4200     Треть 0, знакоместо 0, развёрточная строка 2
Row  3:  $4300     Треть 0, знакоместо 0, развёрточная строка 3
Row  4:  $4400     Треть 0, знакоместо 0, развёрточная строка 4
Row  5:  $4500     Треть 0, знакоместо 0, развёрточная строка 5
Row  6:  $4600     Треть 0, знакоместо 0, развёрточная строка 6
Row  7:  $4700     Треть 0, знакоместо 0, развёрточная строка 7
Row  8:  $4020     Треть 0, знакоместо 1, развёрточная строка 0
Row  9:  $4120     Треть 0, знакоместо 1, развёрточная строка 1
Row 10:  $4220     Треть 0, знакоместо 1, развёрточная строка 2
Row 11:  $4320     Треть 0, знакоместо 1, развёрточная строка 3
Row 12:  $4420     Треть 0, знакоместо 1, развёрточная строка 4
Row 13:  $4520     Треть 0, знакоместо 1, развёрточная строка 5
Row 14:  $4620     Треть 0, знакоместо 1, развёрточная строка 6
Row 15:  $4720     Треть 0, знакоместо 1, развёрточная строка 7
```

Посмотри на паттерн. Первые 8 строк — это 8 развёрточных строк знакоместа 0, но они расположены через 256 байт, а не через 32. Внутри этих 8 строк старший байт адреса увеличивается на 1 с каждой: `$40`, `$41`, `$42`, ... `$47`. Затем строка 8 перескакивает на `$4020` — назад к старшему байту `$40`, но с младшим байтом, увеличенным на 32.

Вот полная картина для верхней трети экрана:

```
Знакоместо 0:   развёрточные строки в $4000, $4100, $4200, $4300, $4400, $4500, $4600, $4700
Знакоместо 1:   развёрточные строки в $4020, $4120, $4220, $4320, $4420, $4520, $4620, $4720
Знакоместо 2:   развёрточные строки в $4040, $4140, $4240, $4340, $4440, $4540, $4640, $4740
Знакоместо 3:   развёрточные строки в $4060, $4160, $4260, $4360, $4460, $4560, $4660, $4760
Знакоместо 4:   развёрточные строки в $4080, $4180, $4280, $4380, $4480, $4580, $4680, $4780
Знакоместо 5:   развёрточные строки в $40A0, $41A0, $42A0, $43A0, $44A0, $45A0, $46A0, $47A0
Знакоместо 6:   развёрточные строки в $40C0, $41C0, $42C0, $43C0, $44C0, $45C0, $46C0, $47C0
Знакоместо 7:   развёрточные строки в $40E0, $41E0, $42E0, $43E0, $44E0, $45E0, $46E0, $47E0
```

Средняя треть начинается с `$4800` и следует тому же паттерну. Нижняя треть начинается с `$5000`.

### Почему?

Причина — ULA, Uncommitted Logic Array, формирующая видеосигнал. ULA считывает один байт пиксельных данных и один байт атрибутов для каждого 8-пиксельного знакоместа при развёртке. Ей нужны оба байта в определённые моменты, когда луч проходит по экрану.

Чересстрочная раскладка означала, что логика формирования адресов в ULA могла быть построена с меньшим числом вентилей. Когда ULA сканирует слева направо по строке знакомест, она инкрементирует младшие 5 бит адреса (столбец). Дойдя до правого края, она инкрементирует старший байт для перехода к следующей развёрточной строке внутри того же знакоместа. Завершив все 8 строк, она сбрасывает старший байт и продвигает биты строки в младшем байте.

Это элегантно с аппаратной точки зрения. Формирование адресов ULA — это простая комбинация счётчиков: никакого умножения, никакой сложной адресной арифметики. Разводка печатной платы была проще, количество вентилей меньше, а микросхема дешевле в производстве.

Программист платит эту цену.

---

## Битовая раскладка: Декодирование (x, y) в адрес

Чтобы точно понять чересстрочность, посмотри, как координата Y отображается в 16-битный экранный адрес. Рассмотрим пиксель в столбце `x` (0--255) и строке `y` (0--191). Байт, содержащий этот пиксель, находится по адресу:

```
Старший байт:  0 1 0 T T S S S
Младший байт:  L L L C C C C C
```

Где:
- `TT` = какая треть экрана (0, 1 или 2). Биты 7--6 координаты y.
- `SSS` = развёрточная строка внутри знакоместа (0--7). Биты 2--0 координаты y.
- `LLL` = номер строки знакомест внутри трети (0--7). Биты 5--3 координаты y.
- `CCCCC` = столбец в байтах (0--31). Это x / 8, или эквивалентно биты 7--3 координаты x.

Ключевой момент: биты y расположены не по порядку. Биты 7-6 идут в одно место, биты 5-3 — в другое, а биты 2-0 — в третье. Координата y нарезана и распределена по адресу.

Визуализируем на конкретном примере. Пиксель (80, 100):

```
x = 80:     байт столбца = 80 / 8 = 10      CCCCC = 01010
y = 100:    двоичное = 01100100
            TT  = 01       (треть 1, средняя)
            LLL = 100      (знакоместо 4 внутри трети)
            SSS = 100      (развёрточная строка 4 внутри знакоместа)

Старший байт:  0  1  0  0  1  1  0  0  = $4C
Младший байт:  1  0  0  0  1  0  1  0  = $8A

Адрес: $4C8A
```

Бит внутри этого байта определяется тремя младшими битами x. Бит 7 — крайний левый пиксель, поэтому позиция пикселя (x AND 7) соответствует биту 7 - (x AND 7).

### Вычисление адреса на Z80

Преобразование (x, y) в экранный адрес нужно делать быстро и часто. Вот стандартная процедура:

```z80
; Input:  B = y (0-191), C = x (0-255)
; Output: HL = screen address, A = bit mask
;
pixel_addr:
    ld   a, b          ; 4T   A = y
    and  $07           ; 7T   A = SSS (scan line within char)
    or   $40           ; 7T   A = 010 00 SSS (add screen base)
    ld   h, a          ; 4T   H = high byte (partial)

    ld   a, b          ; 4T   A = y again
    rra                ; 4T   \
    rra                ; 4T    | shift bits 5-3 of y
    rra                ; 4T   /  down to bits 2-0
    and  $E0           ; 7T   mask to get LLL 00000
    ld   l, a          ; 4T   L = LLL 00000 (partial)

    ld   a, b          ; 4T   A = y again
    and  $C0           ; 7T   A = TT 000000
    rra                ; 4T   \
    rra                ; 4T    | shift bits 7-6 of y
    rra                ; 4T   /  to bits 4-3
    or   h             ; 4T   combine with SSS
    ld   h, a          ; 4T   H = 010 TT SSS (complete)

    ld   a, c          ; 4T   A = x
    rra                ; 4T   \
    rra                ; 4T    | x / 8
    rra                ; 4T   /
    and  $1F           ; 7T   mask to CCCCC
    or   l             ; 4T   combine with LLL 00000
    ld   l, a          ; 4T   L = LLL CCCCC (complete)
                       ; --- Total: ~91 T-states
```

91 такт — не дёшево. В тесном внутреннем цикле, обрабатывающем тысячи пикселей, ты не будешь вызывать эту процедуру для каждого пикселя. Вместо этого вычисляешь начальный адрес один раз, а затем перемещаешься по экрану с помощью быстрых манипуляций указателем — что подводит нас к самой важной процедуре в графическом программировании на Spectrum.

---

## DOWN_HL: Перемещение на одну пиксельную строку вниз

У тебя есть указатель в HL на некоторый байт на экране. Ты хочешь переместить его на одну пиксельную строку вниз — к байту в том же столбце, но на одну развёрточную строку ниже. Что тут сложного?

На линейном фреймбуфере добавляешь 32 (число байт в строке). Одна `ADD HL, DE` при DE = 32: 11 тактов, готово.

На Spectrum это головоломка внутри головоломки. Перемещение на одну пиксельную строку вниз означает:

1. **Внутри знакоместа** (развёрточные строки 0--6 к 1--7): инкремент H. Биты развёрточной строки находятся в младших 3 битах H, поэтому `INC H` перемещает на одну строку вниз.

2. **При переходе через границу знакоместа** (строка 7 к строке 0 следующего знакоместа): сбросить биты развёрточной строки в H обратно в 0 и добавить 32 к L для перехода к следующей строке знакомест.

3. **При переходе через границу трети** (нижняя строка знакоместа 7 одной трети к верхней строке знакоместа 0 следующей): сбросить L и добавить 8 к H для перехода к следующей трети. Эквивалентно — добавить `$0800` к адресу.

Классическая процедура обрабатывает все три случая:

```z80
; DOWN_HL: move HL one pixel row down on the Spectrum screen
; Input:  HL = current screen address
; Output: HL = screen address one row below
;
down_hl:
    inc  h             ; 4T   try moving one scan line down
    ld   a, h          ; 4T
    and  7             ; 7T   did we cross a character boundary?
    ret  nz            ; 11T  (5T if taken) no: done

    ; Crossed a character cell boundary.
    ; Reset scan line to 0, advance character row.
    ld   a, l          ; 4T
    add  a, 32         ; 7T   next character row (L += 32)
    ld   l, a          ; 4T
    ret  c             ; 11T  (5T if taken) if carry, we crossed into next third

    ; No carry from L, but we need to undo the H increment
    ; that moved us into the wrong third.
    ld   a, h          ; 4T
    sub  8             ; 7T   back up one third in H
    ld   h, a          ; 4T
    ret                ; 10T
```

Эта процедура занимает разное время в зависимости от случая:

| Случай | Частота | Такты |
|------|-----------|----------|
| Внутри знакоместа | 7 из 8 строк | 4 + 4 + 7 + 5 = **20** |
| Граница знакоместа, та же треть | 6 из 64 строк | 4 + 4 + 7 + 11 + 4 + 7 + 4 + 11 + 4 + 7 + 4 + 10 = **77** |
| Граница трети | 2 из 192 строк | 4 + 4 + 7 + 11 + 4 + 7 + 4 + 5 = **46** |

Типичный случай — внутри знакоместа — быстрый: 20 тактов. Но редкий случай (переход через строку знакомест внутри той же трети) медленный: 77 тактов. В среднем по всем 192 строкам стоимость составляет около **24,6 такта на вызов**.

Это среднее скрывает проблему. Если ты итерируешь по всему экрану сверху вниз, вызывая DOWN_HL на каждой строке, те редкие вызовы по 77 тактов дают непредсказуемые пики во времени. Для демо-эффекта, которому нужен стабильный тайминг на каждой строке развёртки, эта нестабильность неприемлема.

### Оптимизация Introspec'а

В декабре 2020 года Introspec (spke) опубликовал детальный анализ на Hype под названием «Ещё раз про DOWN_HL». Статья рассматривала задачу эффективной итерации по всему экрану сверху вниз — не стоимость одного вызова, а полную стоимость прохода HL через все 192 строки.

Наивный подход — вызов классической процедуры DOWN_HL 191 раз — стоит **5 922 такта** для полного прохода по экрану. Цель Introspec'а была найти самый быстрый способ пройти все 192 строки, посещая каждый экранный адрес в порядке сверху вниз.

Его ключевой идеей было использование **раздельных счётчиков**. Вместо проверки битов адреса после каждого инкремента для обнаружения пересечения границ он структурировал цикл в соответствии с трёхуровневой иерархией экрана:

```
Для каждой трети (3 итерации):
    Для каждой строки знакомест в трети (8 итераций):
        Для каждой развёрточной строки в знакоместе (8 итераций):
            обработать эту строку
            INC H                  ; следующая развёрточная строка
        отменить 8 INC H, ADD 32 к L   ; следующая строка знакомест
    отменить 8 ADD 32, перейти к следующей трети
```

Внутренняя операция — просто `INC H` — 4 такта. Никаких проверок, никаких переходов. Переходы между строками знакомест и третями происходят в фиксированных, предсказуемых точках цикла, поэтому во внутреннем цикле нет условной логики вообще.

Результат: **2 343 такта** для полного прохода по экрану. Это улучшение на 60% по сравнению с классическим подходом, и стоимость на строку абсолютно предсказуема — никакой нестабильности.

Была также элегантная вариация, приписываемая RST7, с двойным счётчиком, где внешний цикл поддерживает пару счётчиков, естественно отслеживающих границы знакомест и третей. Тело внутреннего цикла сводится к одному `INC H`, а обработка границ вложена в манипуляции со счётчиками на уровне внешнего цикла.

Практический урок: когда нужно итерировать по экрану Spectrum по порядку, не вызывай общую процедуру DOWN_HL 191 раз. Перестрой цикл в соответствии с естественной иерархией экрана, и ветвления исчезнут.

Вот упрощённая версия подхода с раздельными счётчиками:

```z80
; Iterate all 192 screen rows using split counters
; HL = $4000 at entry (top-left of screen)
;
iterate_screen:
    ld   hl, $4000          ; 10T  start of screen
    ld   c, 3               ; 7T   3 thirds

.third_loop:
    ld   b, 8               ; 7T   8 character rows per third

.row_loop:
    push hl                 ; 11T  save start of this char row

    ; --- Process 8 scan lines within this character cell ---
    REPT 7
        ; ... your per-row code here, using HL ...
        inc  h              ; 4T   next scan line
    ENDR
    ; ... process the 8th (last) scan line ...

    pop  hl                 ; 10T  restore char row start
    ld   a, l               ; 4T
    add  a, 32              ; 7T   next character row
    ld   l, a               ; 4T

    djnz .row_loop          ; 13T/8T

    ; Advance to next third
    ld   a, h               ; 4T
    add  a, 8               ; 7T   next third ($0800 higher)
    ld   h, a               ; 4T

    dec  c                  ; 4T
    jr   nz, .third_loop    ; 12T/7T
```

Директива `REPT 7` (поддерживается sjasmplus) повторяет блок 7 раз на этапе ассемблирования — частичная развёртка. Внутри этого блока перемещение на одну развёрточную строку вниз — это один `INC H`. Никаких проверок, никаких переходов. Продвижение по строкам знакомест и по третям происходит на фиксированных внешних границах цикла.

---

## Память атрибутов: 768 байт, которые изменили всё

Под пиксельными данными, по адресам `$5800`--`$5AFF`, находится память атрибутов. Это 768 байт — по одному на каждое 8x8 знакоместо на экране, расположенных последовательно слева направо, сверху вниз. В отличие от пиксельной области, раскладка атрибутов полностью линейна: ячейка (col, row) находится по адресу `$5800 + row * 32 + col`.

Каждый байт атрибута имеет следующую структуру:

```
  Бит:   7     6     5  4  3     2  1  0
       +-----+-----+--------+--------+
       |  F  |  B  | PAPER  |  INK   |
       +-----+-----+--------+--------+

  F       = Flash (0 = выкл, 1 = мигание ~1,6 Гц)
  B       = Bright (0 = нормальная яркость, 1 = яркий)
  PAPER   = Цвет фона (0-7)
  INK     = Цвет чернил (0-7)
```

3-битные коды цветов:

```
  0 = Чёрный      4 = Зелёный
  1 = Синий        5 = Голубой
  2 = Красный      6 = Жёлтый
  3 = Пурпурный    7 = Белый
```

С битом BRIGHT каждый цвет имеет обычный и яркий вариант. Чёрный остаётся чёрным с яркостью или без, так что всего палитра — 15 различимых цветов:

```
Обычные:  Чёрный  Синий  Красный  Пурпурный  Зелёный  Голубой  Жёлтый  Белый
Яркие:    Чёрный  Синий  Красный  Пурпурный  Зелёный  Голубой  Жёлтый  Белый
                (более яркие версии каждого)
```

![Битовая раскладка байта атрибута: flash, bright, paper, ink](illustrations/output/ch02_attr_byte.png)

Байт атрибута `$47` означает: flash выкл, bright выкл, paper = 0 (чёрный), ink = 7 (белый). Белый текст на чёрном фоне — умолчание Spectrum. Яркая версия была бы `$C7`: `$47` OR `$40` устанавливает бит bright.

Стоп — это неправильно. Давай перечитаем битовую раскладку. Бит 6 — bright, значит яркий белый на чёрном — это `$47` с установленным битом 6: `$47 | $40 = $47`. Нет, `$47` уже равен `01000111`. Бит 7 — flash, бит 6 — bright. Значит `$47` = flash выкл, bright **вкл**, paper 000, ink 111 = яркий белый на чёрном. Не-яркая версия была бы `$07`.

Такие битовые детали важны, когда ты конструируешь значения атрибутов на скорости. Типичный паттерн:

```z80
; Build an attribute byte: bright white ink on blue paper
; Bright = 1, Paper = 001 (blue), Ink = 111 (white)
; = 01 001 111 = $4F
    ld   a, $4F
```

### Конфликт атрибутов

Вот определяющее ограничение ZX Spectrum: внутри каждого 8x8 пиксельного знакоместа может быть только **два цвета** — ink и paper. Каждый установленный пиксель (1) отображается цветом ink. Каждый сброшенный пиксель (0) отображается цветом paper. Нельзя иметь три цвета, или градиенты, или попиксельную раскраску внутри одного знакоместа.

Это означает, что если красный спрайт перекрывается с зелёным фоном, знакоместо 8x8, содержащее перекрытие, должно выбрать: все установленные пиксели в этой ячейке — либо красные, либо зелёные. Нельзя иметь часть красных и часть зелёных установленных пикселей в одной ячейке. Визуальный результат — режущий глаз блок цвета, «конфликтующий» с окружением — печально известный конфликт атрибутов.

```
Без конфликта (гипотетическая попиксельная раскраска):

  +---------+---------+
  |  Красный| Красный |
  |  спрайт | на      |
  |  пиксели| зелёном |
  |         | фоне    |
  +---------+---------+

С конфликтом атрибутов (реальность Spectrum):

  +---------+---------+
  |  Красный| Либо    |
  |  спрайт | ВСЁ     |
  |  пиксели| красное |
  |         | или ВСЁ  |
  |         | зелёное  |
  +---------+---------+

  Перекрывающаяся ячейка не может иметь оба цвета.
```

Многие ранние игры для Spectrum просто избегали проблемы: монохромная графика или персонажи, тщательно выровненные по сетке 8x8. Игры вроде Knight Lore и Head Over Heels использовали одну пару ink/paper для всей игровой области, полностью устраняя конфликт ценой цвета.

Но демосцена увидела это иначе. Конфликт атрибутов — это не просто ограничение, это **творческое ограничение**. Сетка 8x8 диктует определённую эстетику: смелые блоки цвета, чёткие геометрические паттерны, намеренное использование контраста. Демо-эффекты, работающие целиком в пространстве атрибутов — туннели, плазмы, скроллеры — могут обновлять 768 байт за кадр вместо 6 144, освобождая огромное количество тактов для вычислений. Когда весь экран управляется атрибутами, конфликт становится неактуальным, потому что ты не смешиваешь спрайты с фонами — атрибуты *и есть* графика.

Демо Introspec'а Eager (2015) полностью построило свой визуальный язык на этом понимании. Эффект туннеля, хаотический зумер и анимация цветового цикла — все работают с атрибутами, не с пикселями. Результат — эффект, работающий на полной частоте кадров с запасом для цифровых барабанов и изощрённого скриптового движка. Конфликт не проблема, потому что ограничение было принято с самого начала.

---

## Бордюр: Больше, чем декорация

Область отображения 256x192 пикселей расположена в центре экрана, окружённая широким бордюром. Цвет бордюра устанавливается записью в порт `$FE`:

```z80
    ld   a, 1          ; 7T   blue = colour 1
    out  ($FE), a       ; 11T  set border colour
```

На цвет бордюра влияют только биты 0--2 записываемого байта. Есть 8 цветов (0--7), без ярких вариантов — палитра бордюра не-яркая. Биты 3 и 4 порта `$FE` управляют выходами MIC и EAR (магнитофонный интерфейс и бипер), поэтому их нужно маскировать или устанавливать надлежащим образом, если ты не намерен шуметь.

Смена цвета бордюра вступает в силу немедленно — на следующей же отрисовываемой строке развёртки. Именно это делает бордюр столь полезным инструментом отладки. Как мы видели в главе 1, смена цвета бордюра до и после секции кода создаёт видимую полосу, высота которой показывает стоимость кода в тактах. Бордюр — твой осциллограф.

### Эффекты в бордюре

Поскольку смена цвета бордюра видна на следующей строке развёртки, точно рассчитанные по времени инструкции `OUT` могут создавать многоцветные полосы, растровые бары и даже грубую графику в области бордюра.

Базовый принцип: ULA рисует одну строку развёртки каждые 224 такта (на Pentagon). Если выполнить инструкцию `OUT ($FE), A` в нужный момент, ты изменишь цвет бордюра в определённой горизонтальной позиции текущей строки. Выполняя быструю последовательность инструкций `OUT` с разными значениями цвета, можно рисовать горизонтальные цветные полосы в бордюре.

```z80
; Simple border stripes
; Assumes we are synced to the start of a border scanline

    ld   a, 2          ; 7T   red
    out  ($FE), a       ; 11T
    ; ... delay to fill this scanline ...
    ld   a, 5          ; 7T   cyan
    out  ($FE), a       ; 11T
    ; ... delay to fill next scanline ...
    ld   a, 6          ; 7T   yellow
    out  ($FE), a       ; 11T
```

Более продвинутые бордюрные эффекты могут создавать градиентные полосы, бегущий текст или даже низкоразрешающие изображения. Сложность экстремальна: у тебя 224 такта на строку, и каждая смена цвета стоит минимум 18 тактов (7 на `LD A,n` + 11 на `OUT`). Это даёт примерно 12 смен цвета на строку, что означает максимум 12 горизонтальных цветных полос на линию.

Демо-кодеры довели это до поразительных крайностей. Предзагружая несколько регистров значениями цветов и используя более быстрые последовательности вроде `OUT (C), A` с последующими обменами регистров, они выжимают больше смен цвета на строку. Бордюр становится самостоятельным дисплеем — холстом за пределами холста.

Для наших целей главная роль бордюра — та же, что в главе 1: бесплатный, всегда доступный визуализатор тайминга. Когда ты будешь оптимизировать процедуру заполнения экрана далее в этой главе, бордюр покажет твой прогресс.

---

## Практика: Заполнение шахматным узором

Пример в `chapters/ch02-screen-as-puzzle/examples/fill_screen.a80` заполняет пиксельную область шахматным узором, а атрибуты — ярким белым на синем. Разберём его по секциям.

```z80
    ORG $8000

SCREEN  EQU $4000       ; pixel area start
ATTRS   EQU $5800       ; attribute area start
SCRLEN  EQU 6144        ; pixel bytes (256*192/8)
ATTLEN  EQU 768         ; attribute bytes (32*24)
```

Код размещён по адресу `$8000` — безопасно в неспорной памяти на всех моделях Spectrum. Константы именуют ключевые адреса и размеры.

```z80
start:
    ; --- Fill pixels with checkerboard pattern ---
    ld   hl, SCREEN
    ld   de, SCREEN + 1
    ld   bc, SCRLEN - 1
    ld   (hl), $55       ; checkerboard: 01010101
    ldir
```

Здесь использован классический трюк самокопирования LDIR. Записывается `$55` (двоичное `01010101`) в первый байт по `$4000`, затем копируется из каждого байта в следующий для 6 143 байт. Результат: каждый байт пиксельной области содержит `$55`, что даёт чередующиеся установленные/сброшенные пиксели — шахматную доску. Поскольку паттерн одинаков в каждом байте, чересстрочный порядок строк не имеет значения — каждая строка получает один и тот же паттерн.

Стоимость: `LDIR` по 21 такту на байт x 6 143 + 16 за последний байт = 129 019 тактов. Почти два полных кадра на Pentagon. Это нормально для однократной настройки, но ты ни за что не станешь так делать в цикле покадровой отрисовки.

```z80
    ; --- Fill attributes: white ink on blue paper ---
    ; Attribute byte: flash=0, bright=1, paper=001 (blue), ink=111 (white)
    ; = 01 001 111 = $4F
    ld   hl, ATTRS
    ld   de, ATTRS + 1
    ld   bc, ATTLEN - 1
    ld   (hl), $4F
    ldir
```

Тот же приём для атрибутов. Значение `$4F` декодируется как: flash выкл (0), bright вкл (1), paper синий (001), ink белый (111). Каждое 8x8 знакоместо получает яркие белые чернила на синей бумаге. Пиксели шахматной доски — установленные/сброшенные, поэтому ты видишь чередующиеся белые и синие точки — классический визуальный паттерн ZX Spectrum.

Стоимость: 768 байт x 21 + последний байт за 16 = 16 143 такта.

```z80
    ; --- Border: blue ---
    ld   a, 1
    out  ($FE), a

    ; Infinite loop
.wait:
    halt
    jr   .wait
```

Устанавливает бордюр в синий (цвет 1) в тон бумаге, создавая визуально чистую рамку. Затем бесконечный цикл с HALT между кадрами. `HALT` ожидает следующего маскируемого прерывания, которое срабатывает раз в кадр — это пульс покоя каждой программы для Spectrum.

### Что попробовать

Загрузи `fill_screen.a80` в ассемблер и эмулятор. Затем экспериментируй:

- Замени `$55` на `$AA` для обратной шахматной доски, или `$FF` для сплошной заливки, или `$81` для вертикальных полос.
- Замени `$4F` на `$07`, чтобы увидеть тот же паттерн без BRIGHT, или на `$38` для белой бумаги с чёрными чернилами (инверсия умолчания).
- Попробуй `$C7` — это устанавливает бит flash. Наблюдай, как знакоместа чередуют цвета ink и paper с частотой ~1,6 Гц.
- Замени пиксельную заливку LDIR на цикл с DOWN_HL, записывающий разные паттерны в разные строки. Теперь ты увидишь чересстрочность в действии: если записать `$FF` в строки 0-7 (развёрточные строки первого знакоместа), заполненная область будет выглядеть как 8 горизонтальных полосок, разделённых промежутками — потому что эти строки отстоят на 256 байт, а не на 32.

---

## Навигация по экрану: Практическая сводка

Вот основные операции с указателями для экрана Spectrum, собранные в одном месте. Это строительные блоки каждой графической процедуры.

### Перемещение вправо на один байт (8 пикселей)

```z80
    inc  l             ; 4T
```

Это работает внутри строки знакомест, потому что столбец находится в младших 5 битах L. Если нужно пересечь границу байтов на правом краю (столбец 31 к столбцу 0 следующей строки), потребуется полный DOWN_HL плюс сброс L — но обычно это не нужно, потому что циклы имеют ширину 32 байта.

### Перемещение вниз на одну пиксельную строку

```z80
    inc  h             ; 4T    (within a character cell)
```

Это работает для 7 из 8 строк. На 8-й строке нужна полная логика пересечения границы из процедуры DOWN_HL выше.

### Перемещение вниз на одну строку знакомест (8 пикселей)

```z80
    ld   a, l          ; 4T
    add  a, 32         ; 7T
    ld   l, a          ; 4T    total: 15T (if no third crossing)
```

Это продвигает на одну строку знакомест внутри трети. Если L переполняется (флаг переноса установлен), ты пересёк границу следующей трети и нужно добавить 8 к H.

### Перемещение вверх на одну пиксельную строку

```z80
    dec  h             ; 4T    (within a character cell)
```

Обратная операция `INC H`. Те же проблемы с границами знакомест и третей. Вот полная процедура UP_HL, зеркальная к DOWN_HL:

```z80
; UP_HL: move HL one pixel row up on the Spectrum screen
; Input:  HL = current screen address
; Output: HL = screen address one row above
;
; Classic version:
up_hl:
    dec  h             ; 4T   try moving one scan line up
    ld   a, h          ; 4T
    and  7             ; 7T   did we cross a character boundary?
    cp   7             ; 7T
    ret  nz            ; 11T  (5T if taken) no: done

    ; Crossed a character cell boundary upward.
    ld   a, l          ; 4T
    sub  32            ; 7T   previous character row (L -= 32)
    ld   l, a          ; 4T
    ret  c             ; 11T  (5T if taken) if carry, crossed into prev third

    ld   a, h          ; 4T
    add  a, 8          ; 7T   compensate H
    ld   h, a          ; 4T
    ret                ; 10T
```

Есть тонкая оптимизация, предложенная Артёмом Топчием: замена `and 7 / cp 7` на `cpl / and 7`. После `DEC H`, если младшие 3 бита H обернулись с `000` на `111`, мы пересекли границу знакоместа. Классический тест проверяет `AND 7` и затем сравнивает с 7. Оптимизированная версия сначала инвертирует: если биты равны `111`, CPL делает их `000`, и `AND 7` даёт ноль. Это экономит 1 байт и 3 такта на пути пересечения границы:

```z80
; UP_HL optimised (Artem Topchiy)
; Saves 1 byte, 3 T-states on boundary crossing
;
up_hl_opt:
    dec  h             ; 4T
    ld   a, h          ; 4T
    cpl                ; 4T   complement: 111 -> 000
    and  7             ; 7T   zero if we crossed boundary
    ret  nz            ; 11T  (5T if taken)

    ld   a, l          ; 4T
    sub  32            ; 7T
    ld   l, a          ; 4T
    ret  c             ; 11T  (5T if taken)

    ld   a, h          ; 4T
    add  a, 8          ; 7T
    ld   h, a          ; 4T
    ret                ; 10T
```

Тот же трюк с `CPL / AND 7` работает и в DOWN_HL, хотя условие границы там проверяет `000` (которые CPL превращает в `111`, тоже ненулевые после AND), поэтому при движении вниз он не помогает. Именно направление *вверх* — то, где классическому коду нужен дополнительный `CP 7`, который оптимизация устраняет.

### Вычисление адреса атрибута по адресу пикселя

Если HL указывает на байт в пиксельной области, соответствующий адрес атрибута вычисляется так:

```z80
; Convert pixel address in HL to attribute address in HL
; Input:  HL = pixel address ($4000-$57FF)
; Output: HL = attribute address ($5800-$5AFF)
;
    ld   a, h          ; 4T
    rrca               ; 4T   \
    rrca               ; 4T    | rotate right 3 times
    rrca               ; 4T   /  A = SSS010TT
    and  3             ; 7T   A = 000000TT
    or   $58           ; 7T   A = 010110TT
    ld   h, a          ; 4T   H now has the third
```

Это работает, потому что L уже содержит `LLL CCCCC` — строку знакомест внутри трети (0--7) в сочетании со столбцом (0--31) — и это в точности младший байт адреса атрибута. Старший байт просто требует добавления номера трети к `$58`. Элегантно.

```z80
; Convert pixel address in HL to attribute address in HL
; Input:  HL = pixel address ($4000-$57FF)
; Output: HL = corresponding attribute address ($5800-$5AFF)
;
    ld   a, h          ; 4T
    rrca               ; 4T
    rrca               ; 4T
    rrca               ; 4T
    and  3             ; 7T
    or   $58           ; 7T
    ld   h, a          ; 4T
    ; L unchanged       --- Total: 34T
```

**Частный случай: когда биты развёрточной строки в H равны 111.** Если ты проходишь знакоместо сверху вниз и только что обработал последнюю развёрточную строку (строка 7), младшие 3 бита H — `111`. В этом случае есть более быстрая 4-инструкционная конверсия, предложенная Артёмом Топчием:

```z80
; Pixel-to-attribute when H low bits are %111
; (e.g., after processing the last scanline of a character cell)
; Input:  HL where H = 010TT111
; Output: HL = attribute address
;
    srl  h             ; 8T   010TT111 -> 0010TT11
    rrc  h             ; 8T   0010TT11 -> 10010TT1
    srl  h             ; 8T   10010TT1 -> 010010TT
    set  4, h          ; 8T   010010TT -> 010110TT = $58+TT
    ; L unchanged.     --- Total: 32T, 4 instructions
```

Это на 2 такта быстрее общего метода и избегает последовательности `AND / OR`. Компромисс в том, что это работает только когда биты развёрточной строки равны `111` — но именно такая ситуация возникает после цикла отрисовки знакоместа сверху вниз, что является одним из самых распространённых сценариев.

---

> **Врезка: Agon Light 2**
>
> Дисплеем Agon Light 2 управляет VDP (Video Display Processor) — микроконтроллер ESP32, исполняющий библиотеку FabGL. Процессор eZ80 общается с VDP через последовательный канал, отправляя команды для установки графических режимов, рисования пикселей, определения спрайтов и управления палитрами.
>
> Здесь нет чересстрочной раскладки памяти. Нет конфликта атрибутов. VDP поддерживает несколько растровых режимов с различным разрешением (от 640x480 до 320x240 и ниже), с 64 цветами или полными RGBA-палитрами в зависимости от режима. Аппаратные спрайты (до 256) и карты тайлов поддерживаются нативно.
>
> Что меняется для программиста:
>
> - **Нет головоломки с адресами.** Координаты пикселей линейно отображаются в позиции буфера. Не нужны DOWN_HL или обход экрана с раздельными счётчиками.
> - **Нет конфликта атрибутов.** Каждый пиксель может быть любого цвета. Ограничение сетки 8x8 не существует.
> - **Нет прямого доступа к фреймбуферу.** Процессор не может записывать напрямую в видеопамять, как процессор Spectrum пишет в `$4000`. Вместо этого ты отправляешь команды VDP через последовательный канал. Рисование пикселя означает отправку последовательности команд, а не запись байта. Это вносит задержку — последовательный канал работает на 1 152 000 бод — но зато процессор свободен во время отрисовки.
> - **Нет тактовых трюков с бордюром.** VDP управляет таймингом дисплея независимо. Нельзя создавать растровые эффекты, рассчитывая время инструкций `OUT`, потому что конвейер отображения отделён от тактового генератора процессора.
>
> Для программиста Spectrum, Agon ощущается одновременно освобождающе и разочаровывающе. Ограничений, заставлявших находить творческие решения на Spectrum, просто не существует — но и прямых аппаратных трюков, которые эти ограничения порождали, тоже нет. Ты обмениваешь головоломку на API.

---

## Собираем всё вместе: Что раскладка экрана означает для кода

Каждая техника в остальной части книги определяется раскладкой экрана, описанной в этой главе. Вот почему каждый элемент важен:

**Отрисовка спрайтов** требует вычисления экранного адреса для позиции спрайта, а затем итерации вниз по строкам спрайта. Каждая строка — это `INC H` (7 из 8 раз) или полный переход через границу знакоместа. Спрайт высотой 16 пикселей занимает ровно 2 знакоместа — ты пересечёшь одну границу. Спрайт высотой 24 пикселя занимает 3 знакоместа с пересечением 2 границ. Стоимость пересечения границы — это фиксированный налог на каждый спрайт.

**Очистка экрана** (глава 3) использует PUSH-трюк — установку SP в `$5800` и проталкивание данных вниз через пиксельную область. Чересстрочность не имеет значения для очистки, потому что каждый байт получает одно и то же значение. Но для *узорных* очисток (полосатые фоны, градиентные заливки) чересстрочность означает, что нужно тщательно продумать, какие строки получают какие данные.

**Скроллинг** (глава 17) — это где раскладка больше всего мешает. Прокрутка экрана вверх на один пиксель означает перемещение 32 байт каждой строки по адресу строки выше неё. На линейном фреймбуфере это одно большое блочное копирование. На Spectrum адреса источника и назначения для каждой строки связаны логикой DOWN_HL — не фиксированным смещением. Процедура прокрутки должна навигировать по чересстрочности для каждой копируемой строки.

**Эффекты с атрибутами** (главы 8--9) — это где раскладка помогает. Поскольку область атрибутов линейна и мала (768 байт), обновление цветов быстрое. Полное обновление атрибутов всего экрана через LDIR стоит около 16 000 тактов — менее четверти кадра. Вот почему эффекты на атрибутах (туннели, плазмы, цветовые циклы) — основа демосценовой работы на Spectrum.

---

## Итого

- 6 912-байтовый экран Spectrum состоит из **6 144 байт пиксельных данных** по адресам `$4000`--`$57FF` и **768 байт атрибутов** по адресам `$5800`--`$5AFF`.
- Пиксельные строки **чередуются** по знакоместам: адрес кодирует y как `010 TT SSS` (старший байт) и `LLL CCCCC` (младший байт), где биты y перемешаны по адресу.
- Перемещение **на одну пиксельную строку вниз** внутри знакоместа — это просто `INC H` (4 такта). Пересечение границ знакомест и третей требует дополнительной логики.
- Классическая процедура **DOWN_HL** обрабатывает все случаи, но стоит до 77 тактов на границах. Для полноэкранной итерации **циклы с раздельными счётчиками** (подход Introspec'а) снижают общую стоимость на 60% и устраняют нестабильность тайминга.
- Каждый байт атрибута кодирует **Flash, Bright, Paper и Ink** в формате `FBPPPIII`. Только **два цвета на 8x8 знакоместо** — это конфликт атрибутов.
- Конфликт атрибутов — это не просто ограничение, а **творческое ограничение**, определившее визуальную эстетику Spectrum и приведшее к эффективным демо-эффектам, работающим только с атрибутами.
- Цвет **бордюра** устанавливается через `OUT ($FE), A` (биты 0--2), и изменения видны на следующей строке развёртки, что делает его **инструментом отладки тайминга** и холстом для демосценовых растровых эффектов.
- **Agon Light 2** не имеет чересстрочной раскладки, конфликта атрибутов и прямого доступа к фреймбуферу — он заменяет головоломку на командный API VDP.

---

## Попробуй сам

1. **Вычисли адреса.** Возьми 10 случайных координат (x, y) и рассчитай экранный адрес вручную, используя битовую раскладку `010TTSSS LLLCCCCC`. Затем напиши маленькую процедуру на Z80, которая ставит один пиксель по каждой координате, и проверь, что твои вычисления совпадают.

2. **Визуализируй чересстрочность.** Модифицируй `fill_screen.a80`, чтобы записать разные значения в первые 8 строк. Запиши `$FF` (сплошной) в строку 0 и `$00` (пустой) в строки 1--7. Поскольку строки 0--7 находятся по адресам `$4000`, `$4100`, ..., `$4700`, тебе нужно менять H для достижения каждой строки. Результат должен быть одной яркой линией вверху с промежутком из 7 пустых линий до следующей сплошной линии на строке 8.

3. **Замерь DOWN_HL.** Используй тестовую обвязку с цветом бордюра из главы 1. Вызови классическую процедуру DOWN_HL 191 раз (для полного прохода по экрану) и измерь полосу. Затем реализуй версию с раздельными счётчиками и сравни. Версия с раздельными счётчиками должна дать заметно более короткую полосу.

4. **Рисовальщик атрибутов.** Напиши процедуру, заполняющую область атрибутов градиентом: столбец 0 получает цвет 0, столбец 1 — цвет 1, и так далее (циклически по 0--7). Каждая строка должна иметь один и тот же паттерн. Затем модифицируй, чтобы каждая строка сдвигала паттерн на одну позицию — диагональная радуга. Это зерно демо-эффекта на атрибутах.

5. **Полосы бордюра.** После `HALT` выполни тесный цикл, меняющий цвет бордюра на каждой строке развёртки в течение 64 строк. Используй 8 цветов бордюра по порядку (0, 1, 2, 3, 4, 5, 6, 7, повтор). Ты увидишь горизонтальные радужные полосы в верхнем бордюре. Подбери задержку между инструкциями `OUT`, пока полосы не станут чистыми и стабильными.

---

> **Источники:** Introspec «Ещё раз про DOWN_HL» (Hype, 2020); Introspec «GO WEST Part 1» (Hype, 2015) об эффектах спорной памяти на экранных адресах; Introspec «Making of Eager» (Hype, 2015) о проектировании эффектов на атрибутах; документация ULA Spectrum по обоснованию раскладки памяти; Артём Топчий (личная переписка, 2026) за оптимизированную UP_HL и быструю конверсию пиксельного адреса в адрес атрибута.

*Далее: Глава 3 — Инструментарий демосценера. Развёрнутые циклы, самомодифицирующийся код, стек как канал данных и техники, позволяющие делать невозможное в рамках бюджета.*
