# Глава 2: Экран как головоломка

> «Почему строки идут в таком порядке?»
> -- Каждый программист ZX Spectrum, рано или поздно

Открой любой эмулятор, набери `PEEK 16384` — и ты читаешь первый байт экранной памяти Spectrum. Но какой это байт? Не верхний левый экрана в каком-либо простом смысле. Пиксель с координатой (0,0) действительно там — но пиксель (0,1), следующая строка вниз, живёт на 256 байт дальше. Пиксель (0,8), верхняя строка второго знакоместа, расположен всего в 32 байтах от начала. А пиксель (0,64) — первая строка средней трети экрана — живёт ровно в 2 048 байтах от начала, по адресу `$4800`.

Это самая знаменитая головоломка Spectrum. Раскладка экранной памяти не последовательная, не интуитивная и не случайная. Она — следствие аппаратных решений, принятых в 1982 году, и она определяет каждый фрагмент кода, который работает с экраном. Понимание этой раскладки — и изучение трюков, позволяющих быстро по ней перемещаться — фундаментально для всего, что последует в этой книге.

---

## Карта памяти: 6 912 байт экрана

Экран Spectrum занимает фиксированную область памяти:

```text
$4000 - $57FF    Pixel data      6,144 bytes   (256 x 192 pixels, 1 bit per pixel)
$5800 - $5AFF    Attributes        768 bytes   (32 x 24 colour cells)
```

Пиксельная область хранит растр: 256 пикселей по горизонтали, упакованные по 8 в байт, что даёт 32 байта на строку. При 192 строках это 32 x 192 = 6 144 байта. Каждый байт представляет 8 горизонтальных пикселей, где бит 7 — крайний левый, а бит 0 — крайний правый.

Область атрибутов хранит цветовую информацию: один байт на 8x8 знакоместо. 32 столбца и 24 строки, итого 32 x 24 = 768 байт.

Вместе: 6 144 + 768 = 6 912 байт. Это весь экран.

<!-- figure: ch02_screen_layout -->
![ZX Spectrum screen memory layout with thirds, character cells, and attribute area](illustrations/output/ch02_screen_layout.png)

Пиксельные данные и данные атрибутов служат разным целям, но тесно связаны. Каждый пиксельный байт управляет 8 точками на экране; байт атрибута соответствующего 8x8 знакоместа определяет, каким цветом эти точки отображаются. Измени пиксель — изменишь форму. Измени атрибут — изменишь цвет. Но цвет можно менять только для целого блока 8x8 — не попиксельно. Это и есть «конфликт атрибутов», определяющий визуальный характер Spectrum, и мы вернёмся к нему чуть позже.

Но сначала — головоломка: почему пиксельные строки перемешаны?

---

## Чересстрочность: Где живут строки

Если бы Spectrum хранил пиксельные строки последовательно, строка 0 была бы по адресу `$4000`, строка 1 — по `$4020`, строка 2 — по `$4040`, и так далее. Каждая строка — 32 байта, значит строка N просто по `$4000 + N * 32`. Просто, быстро, разумно.

Но не так всё устроено.

Экран разделён на три **трети**, каждая высотой 64 пиксельных строки. Внутри каждой трети строки чередуются по знакоместам. Вот где реально находятся первые 16 строк:

```text
Row  0:  $4000     Third 0, char row 0, scan line 0
Row  1:  $4100     Third 0, char row 0, scan line 1
Row  2:  $4200     Third 0, char row 0, scan line 2
Row  3:  $4300     Third 0, char row 0, scan line 3
Row  4:  $4400     Third 0, char row 0, scan line 4
Row  5:  $4500     Third 0, char row 0, scan line 5
Row  6:  $4600     Third 0, char row 0, scan line 6
Row  7:  $4700     Third 0, char row 0, scan line 7
Row  8:  $4020     Third 0, char row 1, scan line 0
Row  9:  $4120     Third 0, char row 1, scan line 1
Row 10:  $4220     Third 0, char row 1, scan line 2
Row 11:  $4320     Third 0, char row 1, scan line 3
Row 12:  $4420     Third 0, char row 1, scan line 4
Row 13:  $4520     Third 0, char row 1, scan line 5
Row 14:  $4620     Third 0, char row 1, scan line 6
Row 15:  $4720     Third 0, char row 1, scan line 7
```

Посмотри на паттерн. Первые 8 строк — это 8 развёрточных строк знакоместа 0, но они расположены через 256 байт, а не через 32. Внутри этих 8 строк старший байт адреса увеличивается на 1 с каждой: `$40`, `$41`, `$42`, ... `$47`. Затем строка 8 перескакивает на `$4020` — назад к старшему байту `$40`, но с младшим байтом, увеличенным на 32.

Вот полная картина для верхней трети экрана:

```text
Char row 0:   scan lines at $4000, $4100, $4200, $4300, $4400, $4500, $4600, $4700
Char row 1:   scan lines at $4020, $4120, $4220, $4320, $4420, $4520, $4620, $4720
Char row 2:   scan lines at $4040, $4140, $4240, $4340, $4440, $4540, $4640, $4740
Char row 3:   scan lines at $4060, $4160, $4260, $4360, $4460, $4560, $4660, $4760
Char row 4:   scan lines at $4080, $4180, $4280, $4380, $4480, $4580, $4680, $4780
Char row 5:   scan lines at $40A0, $41A0, $42A0, $43A0, $44A0, $45A0, $46A0, $47A0
Char row 6:   scan lines at $40C0, $41C0, $42C0, $43C0, $44C0, $45C0, $46C0, $47C0
Char row 7:   scan lines at $40E0, $41E0, $42E0, $43E0, $44E0, $45E0, $46E0, $47E0
```

Средняя треть начинается с `$4800` и следует тому же паттерну. Нижняя треть начинается с `$5000`.

### Почему?

Причина — ULA, Uncommitted Logic Array, формирующая видеосигнал. ULA считывает один байт пиксельных данных и один байт атрибутов для каждого 8-пиксельного знакоместа при развёртке. Ей нужны оба байта в определённые моменты, когда луч проходит по экрану.

Чересстрочная раскладка означала, что логика формирования адресов в ULA могла быть построена с меньшим числом вентилей. Когда ULA сканирует слева направо по строке знакомест, она инкрементирует младшие 5 бит адреса (столбец). Дойдя до правого края, она инкрементирует старший байт для перехода к следующей развёрточной строке внутри того же знакоместа. Завершив все 8 строк, она сбрасывает старший байт и продвигает биты строки в младшем байте.

Это элегантно с аппаратной точки зрения. Формирование адресов ULA — это простая комбинация счётчиков: никакого умножения, никакой сложной адресной арифметики. Разводка печатной платы была проще, количество вентилей меньше, а микросхема дешевле в производстве.

Программист платит эту цену.

---

## Битовая раскладка: Декодирование (x, y) в адрес

![Раскладка экранной памяти ZX Spectrum — чересстрочные трети с цветовой кодировкой битовых полей адреса](../../build/screenshots/proto_ch02_screen_layout.png)

Чтобы точно понять чересстрочность, посмотри, как координата Y отображается в 16-битный экранный адрес. Рассмотрим пиксель в столбце `x` (0--255) и строке `y` (0--191). Байт, содержащий этот пиксель, находится по адресу:

```text
High byte:  0 1 0 T T S S S
Low byte:   L L L C C C C C
```

Где:
- `TT` = какая треть экрана (0, 1 или 2). Биты 7--6 координаты y.
- `SSS` = развёрточная строка внутри знакоместа (0--7). Биты 2--0 координаты y.
- `LLL` = номер строки знакомест внутри трети (0--7). Биты 5--3 координаты y.
- `CCCCC` = столбец в байтах (0--31). Это x / 8, или эквивалентно биты 7--3 координаты x.

Ключевой момент: биты y расположены не по порядку. Биты 7-6 идут в одно место, биты 5-3 — в другое, а биты 2-0 — в третье. Координата y нарезана и распределена по адресу.

Визуализируем на конкретном примере. Пиксель (80, 100):

```text
x = 80:     column byte = 80 / 8 = 10      CCCCC = 01010
y = 100:    binary = 01100100
            TT  = 01       (third 1, the middle third)
            LLL = 100      (char row 4 within the third)
            SSS = 100      (scan line 4 within the char cell)

High byte:  0  1  0  0  1  1  0  0  = $4C
Low byte:   1  0  0  0  1  0  1  0  = $8A

Address: $4C8A
```

Бит внутри этого байта определяется тремя младшими битами x. Бит 7 — крайний левый пиксель, поэтому позиция пикселя (x AND 7) соответствует биту 7 - (x AND 7).

### Вычисление адреса на Z80

Преобразование (x, y) в экранный адрес нужно делать быстро и часто. Вот стандартная процедура:

```z80 id:ch02_the_address_calculation_in
; Input:  B = y (0-191), C = x (0-255)
; Output: HL = screen address, A = bit mask
;
pixel_addr:
    ld   a, b          ; 4T   A = y
    and  $07           ; 7T   A = SSS (scan line within char)
    or   $40           ; 7T   A = 010 00 SSS (add screen base)
    ld   h, a          ; 4T   H = high byte (partial)

    ld   a, b          ; 4T   A = y again
    rra                ; 4T   \
    rra                ; 4T    | shift bits 5-3 of y
    rra                ; 4T   /  down to bits 2-0
    and  $E0           ; 7T   mask to get LLL 00000
    ld   l, a          ; 4T   L = LLL 00000 (partial)

    ld   a, b          ; 4T   A = y again
    and  $C0           ; 7T   A = TT 000000
    rra                ; 4T   \
    rra                ; 4T    | shift bits 7-6 of y
    rra                ; 4T   /  to bits 4-3
    or   h             ; 4T   combine with SSS
    ld   h, a          ; 4T   H = 010 TT SSS (complete)

    ld   a, c          ; 4T   A = x
    rra                ; 4T   \
    rra                ; 4T    | x / 8
    rra                ; 4T   /
    and  $1F           ; 7T   mask to CCCCC
    or   l             ; 4T   combine with LLL 00000
    ld   l, a          ; 4T   L = LLL CCCCC (complete)
                       ; --- Total: ~91 T-states
```

91 такт — не дёшево. В тесном внутреннем цикле, обрабатывающем тысячи пикселей, ты не будешь вызывать эту процедуру для каждого пикселя. Вместо этого вычисляешь начальный адрес один раз, а затем перемещаешься по экрану с помощью быстрых манипуляций указателем — что подводит нас к самой важной процедуре в графическом программировании на Spectrum.

![Демо построения пикселей — отдельные пиксели, размещённые на экране с помощью процедуры вычисления адреса](../../build/screenshots/ch02_pixel_demo.png)

---

## DOWN_HL: Перемещение на одну пиксельную строку вниз

У тебя есть указатель в HL на некоторый байт на экране. Ты хочешь переместить его на одну пиксельную строку вниз — к байту в том же столбце, но на одну развёрточную строку ниже. Что тут сложного?

На линейном фреймбуфере добавляешь 32 (число байт в строке). Одна `ADD HL, DE` при DE = 32: 11 тактов, готово.

На Spectrum это головоломка внутри головоломки. Перемещение на одну пиксельную строку вниз означает:

1. **Внутри знакоместа** (развёрточные строки 0--6 к 1--7): инкремент H. Биты развёрточной строки находятся в младших 3 битах H, поэтому `INC H` перемещает на одну строку вниз.

2. **При переходе через границу знакоместа** (строка 7 к строке 0 следующего знакоместа): сбросить биты развёрточной строки в H обратно в 0 и добавить 32 к L для перехода к следующей строке знакомест.

3. **При переходе через границу трети** (нижняя строка знакоместа 7 одной трети к верхней строке знакоместа 0 следующей): сбросить L и добавить 8 к H для перехода к следующей трети. Эквивалентно — добавить `$0800` к адресу.

Классическая процедура обрабатывает все три случая:

```z80 id:ch02_downhl_moving_one_pixel_row
; DOWN_HL: move HL one pixel row down on the Spectrum screen
; Input:  HL = current screen address
; Output: HL = screen address one row below
;
down_hl:
    inc  h             ; 4T   try moving one scan line down
    ld   a, h          ; 4T
    and  7             ; 7T   did we cross a character boundary?
    ret  nz            ; 11/5T  no: done

    ; Crossed a character cell boundary.
    ; Reset scan line to 0, advance character row.
    ld   a, l          ; 4T
    add  a, 32         ; 7T   next character row (L += 32)
    ld   l, a          ; 4T
    ret  c             ; 11/5T  if carry, we crossed into next third

    ; No carry from L, but we need to undo the H increment
    ; that moved us into the wrong third.
    ld   a, h          ; 4T
    sub  8             ; 7T   back up one third in H
    ld   h, a          ; 4T
    ret                ; 10T
```

Эта процедура занимает разное время в зависимости от случая:

| Случай | Частота | Такты |
|------|-----------|----------|
| Внутри знакоместа | 7 из 8 строк | 4 + 4 + 7 + 11 = **26** |
| Граница знакоместа, та же треть | 7 из 64 строк | 4 + 4 + 7 + 5 + 4 + 7 + 4 + 5 + 4 + 7 + 4 + 10 = **65** |
| Граница трети | 2 из 192 строк | 4 + 4 + 7 + 5 + 4 + 7 + 4 + 11 = **46** |

Типичный случай — внутри знакоместа — быстрый: 26 тактов (T-state) (условный RET, который срабатывает, стоит 11T, а не 5T). Редкий случай (переход через строку знакомест внутри той же трети) — 65 тактов (T-state). В среднем по всем 192 строкам стоимость составляет около **30,5 такта (T-state) на вызов**.

Это среднее скрывает проблему. Если ты итерируешь по всему экрану сверху вниз, вызывая DOWN_HL на каждой строке, те редкие вызовы по 65 тактов (T-state) дают непредсказуемые пики во времени. Для демо-эффекта, которому нужен стабильный тайминг на каждой строке развёртки, эта нестабильность неприемлема.

### Оптимизация Introspec'а

В декабре 2020 года Introspec (spke) опубликовал детальный анализ на Hype под названием «Ещё раз про DOWN_HL». Статья рассматривала задачу эффективной итерации по всему экрану сверху вниз — не стоимость одного вызова, а полную стоимость прохода HL через все 192 строки.

Наивный подход — вызов классической процедуры DOWN_HL 191 раз — стоит **5 825 тактов (T-state)** для полного прохода по экрану. Цель Introspec'а была найти самый быстрый способ пройти все 192 строки, посещая каждый экранный адрес в порядке сверху вниз.

Его ключевой идеей было использование **раздельных счётчиков**. Вместо проверки битов адреса после каждого инкремента для обнаружения пересечения границ он структурировал цикл в соответствии с трёхуровневой иерархией экрана:

```text id:ch02_introspec_s_optimisation
For each third (3 iterations):
    For each character row within the third (8 iterations):
        For each scan line within the character cell (8 iterations):
            process this row
            INC H                  ; next scan line
        undo 8 INC H's, ADD 32 to L   ; next character row
    undo 8 ADD 32's, advance to next third
```

Внутренняя операция — просто `INC H` — 4 такта. Никаких проверок, никаких переходов. Переходы между строками знакомест и третями происходят в фиксированных, предсказуемых точках цикла, поэтому во внутреннем цикле нет условной логики вообще.

Результат: **2 343 такта** для полного прохода по экрану. Это улучшение на 60% по сравнению с классическим подходом, и стоимость на строку абсолютно предсказуема — никакой нестабильности.

Была также элегантная вариация, приписываемая RST7, с двойным счётчиком, где внешний цикл поддерживает пару счётчиков, естественно отслеживающих границы знакомест и третей. Тело внутреннего цикла сводится к одному `INC H`, а обработка границ вложена в манипуляции со счётчиками на уровне внешнего цикла.

Практический урок: когда нужно итерировать по экрану Spectrum по порядку, не вызывай общую процедуру DOWN_HL 191 раз. Перестрой цикл в соответствии с естественной иерархией экрана, и ветвления исчезнут.

Вот упрощённая версия подхода с раздельными счётчиками:

```z80 id:ch02_introspec_s_optimisation_2
; Iterate all 192 screen rows using split counters
; HL = $4000 at entry (top-left of screen)
;
iterate_screen:
    ld   hl, $4000          ; 10T  start of screen
    ld   c, 3               ; 7T   3 thirds

.third_loop:
    ld   b, 8               ; 7T   8 character rows per third

.row_loop:
    push hl                 ; 11T  save start of this char row

    ; --- Process 8 scan lines within this character cell ---
    REPT 7
        ; ... your per-row code here, using HL ...
        inc  h              ; 4T   next scan line
    ENDR
    ; ... process the 8th (last) scan line ...

    pop  hl                 ; 10T  restore char row start
    ld   a, l               ; 4T
    add  a, 32              ; 7T   next character row
    ld   l, a               ; 4T

    djnz .row_loop          ; 13T/8T

    ; Advance to next third
    ld   a, h               ; 4T
    add  a, 8               ; 7T   next third ($0800 higher)
    ld   h, a               ; 4T

    dec  c                  ; 4T
    jr   nz, .third_loop    ; 12T/7T
```

Директива `REPT 7` (поддерживается sjasmplus) повторяет блок 7 раз на этапе ассемблирования — частичная развёртка. Внутри этого блока перемещение на одну развёрточную строку вниз — это один `INC H`. Никаких проверок, никаких переходов. Продвижение по строкам знакомест и по третям происходит на фиксированных внешних границах цикла.

---

## Память атрибутов: 768 байт, которые изменили всё

Под пиксельными данными, по адресам `$5800`--`$5AFF`, находится память атрибутов. Это 768 байт — по одному на каждое 8x8 знакоместо на экране, расположенных последовательно слева направо, сверху вниз. В отличие от пиксельной области, раскладка атрибутов полностью линейна: ячейка (col, row) находится по адресу `$5800 + row * 32 + col`.

Каждый байт атрибута имеет следующую структуру:

```text
  Bit:   7     6     5  4  3     2  1  0
       +-----+-----+--------+--------+
       |  F  |  B  | PAPER  |  INK   |
       +-----+-----+--------+--------+

  F       = Flash (0 = off, 1 = flashing at ~1.6 Hz)
  B       = Bright (0 = normal, 1 = bright)
  PAPER   = Background colour (0-7)
  INK     = Foreground colour (0-7)
```

3-битные коды цветов:

```text
  0 = Black       4 = Green
  1 = Blue        5 = Cyan
  2 = Red         6 = Yellow
  3 = Magenta     7 = White
```

С битом BRIGHT каждый цвет имеет обычный и яркий вариант. Чёрный остаётся чёрным с яркостью или без, так что всего палитра — 15 различимых цветов:

```text
Normal:  Black  Blue  Red  Magenta  Green  Cyan  Yellow  White
Bright:  Black  Blue  Red  Magenta  Green  Cyan  Yellow  White
                (brighter versions of each)
```

<!-- figure: ch02_attr_byte -->
![Attribute byte bit layout showing flash, bright, paper, and ink fields](illustrations/output/ch02_attr_byte.png)

Байт атрибута `$47` = `01000111`: мерцание (flash) выкл (бит 7 = 0), яркость (bright) **вкл** (бит 6 = 1), фон (paper) = 000 (чёрный), чернила (ink) = 111 (белый). Яркий белый текст на чёрном фоне. Неяркая версия — `$07` = `00000111` — умолчание Spectrum после `BORDER 0: PAPER 0: INK 7`.

Такие битовые детали важны, когда ты конструируешь значения атрибутов на скорости. Типичный паттерн:

```z80 id:ch02_attribute_memory_768_bytes_4
; Build an attribute byte: bright white ink on blue paper
; Bright = 1, Paper = 001 (blue), Ink = 111 (white)
; = 01 001 111 = $4F
    ld   a, $4F
```

### Конфликт атрибутов

Вот определяющее ограничение ZX Spectrum: внутри каждого 8x8 пиксельного знакоместа может быть только **два цвета** — ink и paper. Каждый установленный пиксель (1) отображается цветом ink. Каждый сброшенный пиксель (0) отображается цветом paper. Нельзя иметь три цвета, или градиенты, или попиксельную раскраску внутри одного знакоместа.

Это означает, что если красный спрайт перекрывается с зелёным фоном, знакоместо 8x8, содержащее перекрытие, должно выбрать: все установленные пиксели в этой ячейке — либо красные, либо зелёные. Нельзя иметь часть красных и часть зелёных установленных пикселей в одной ячейке. Визуальный результат — режущий глаз блок цвета, «конфликтующий» с окружением — печально известный конфликт атрибутов.

```text
Without clash (hypothetical per-pixel colour):

  +---------+---------+
  |  Red    | Red on  |
  |  sprite | green   |
  |  pixels | back-   |
  |         | ground  |
  +---------+---------+

With attribute clash (Spectrum reality):

  +---------+---------+
  |  Red    | Either  |
  |  sprite | ALL red |
  |  pixels | or ALL  |
  |         | green   |
  +---------+---------+

  The overlapping cell cannot have both colours.
```

Многие ранние игры для Spectrum просто избегали проблемы: монохромная графика или персонажи, тщательно выровненные по сетке 8x8. Игры вроде Knight Lore и Head Over Heels использовали одну пару ink/paper для всей игровой области, полностью устраняя конфликт ценой цвета.

Но демосцена увидела это иначе. Конфликт атрибутов — это не просто ограничение, это **творческое ограничение**. Сетка 8x8 диктует определённую эстетику: смелые блоки цвета, чёткие геометрические паттерны, намеренное использование контраста. Демо-эффекты, работающие целиком в пространстве атрибутов — туннели, плазмы, скроллеры — могут обновлять 768 байт за кадр вместо 6 144, освобождая огромное количество тактов для вычислений. Когда весь экран управляется атрибутами, конфликт становится неактуальным, потому что ты не смешиваешь спрайты с фонами — атрибуты *и есть* графика.

Демо Introspec'а Eager (2015) полностью построило свой визуальный язык на этом понимании. Эффект туннеля, хаотический зумер и анимация цветового цикла — все работают с атрибутами, не с пикселями. Результат — эффект, работающий на полной частоте кадров с запасом для цифровых барабанов и изощрённого скриптового движка. Конфликт не проблема, потому что ограничение было принято с самого начала.

---

## Бордюр: Больше, чем декорация

Область отображения 256x192 пикселей расположена в центре экрана, окружённая широким бордюром. Цвет бордюра устанавливается записью в порт `$FE`:

```z80 id:ch02_the_border_more_than
    ld   a, 1          ; 7T   blue = colour 1
    out  ($FE), a       ; 11T  set border colour
```

На цвет бордюра влияют только биты 0--2 записываемого байта. Есть 8 цветов (0--7), без ярких вариантов — палитра бордюра не-яркая. Биты 3 и 4 порта `$FE` управляют выходами MIC и EAR (магнитофонный интерфейс и бипер), поэтому их нужно маскировать или устанавливать надлежащим образом, если ты не намерен шуметь.

Смена цвета бордюра вступает в силу немедленно — на следующей же отрисовываемой строке развёртки. Именно это делает бордюр столь полезным инструментом отладки. Как мы видели в главе 1, смена цвета бордюра до и после секции кода создаёт видимую полосу, высота которой показывает стоимость кода в тактах. Бордюр — твой осциллограф.

### Эффекты в бордюре

Поскольку смена цвета бордюра видна на следующей строке развёртки, точно рассчитанные по времени инструкции `OUT` могут создавать многоцветные полосы, растровые бары и даже грубую графику в области бордюра.

Базовый принцип: ULA рисует одну строку развёртки каждые 224 такта (на Pentagon). Если выполнить инструкцию `OUT ($FE), A` в нужный момент, ты изменишь цвет бордюра в определённой горизонтальной позиции текущей строки. Выполняя быструю последовательность инструкций `OUT` с разными значениями цвета, можно рисовать горизонтальные цветные полосы в бордюре.

```z80 id:ch02_border_effects
; Simple border stripes
; Assumes we are synced to the start of a border scanline

    ld   a, 2          ; 7T   red
    out  ($FE), a       ; 11T
    ; ... delay to fill this scanline ...
    ld   a, 5          ; 7T   cyan
    out  ($FE), a       ; 11T
    ; ... delay to fill next scanline ...
    ld   a, 6          ; 7T   yellow
    out  ($FE), a       ; 11T
```

Более продвинутые бордюрные эффекты могут создавать градиентные полосы, бегущий текст или даже низкоразрешающие изображения. Сложность экстремальна: у тебя 224 такта на строку, и каждая смена цвета стоит минимум 18 тактов (7 на `LD A,n` + 11 на `OUT`). Это даёт примерно 12 смен цвета на строку, что означает максимум 12 горизонтальных цветных полос на линию.

Демо-кодеры довели это до поразительных крайностей. Предзагружая несколько регистров значениями цветов и используя более быстрые последовательности вроде `OUT (C), A` с последующими обменами регистров, они выжимают больше смен цвета на строку. Бордюр становится самостоятельным дисплеем — холстом за пределами холста.

Для наших целей главная роль бордюра — та же, что в главе 1: бесплатный, всегда доступный визуализатор тайминга. Когда ты будешь оптимизировать процедуру заполнения экрана далее в этой главе, бордюр покажет твой прогресс.

---

## Практика: Заполнение шахматным узором

Пример в `chapters/ch02-screen-as-puzzle/examples/fill_screen.a80` заполняет пиксельную область шахматным узором, а атрибуты — ярким белым на синем. Разберём его по секциям.

```z80 id:ch02_practical_the_checkerboard
    ORG $8000

SCREEN  EQU $4000       ; pixel area start
ATTRS   EQU $5800       ; attribute area start
SCRLEN  EQU 6144        ; pixel bytes (256*192/8)
ATTLEN  EQU 768         ; attribute bytes (32*24)
```

Код размещён по адресу `$8000` — безопасно в неспорной памяти на всех моделях Spectrum. Константы именуют ключевые адреса и размеры.

```z80 id:ch02_practical_the_checkerboard_2
start:
    ; --- Fill pixels with checkerboard pattern ---
    ld   hl, SCREEN
    ld   de, SCREEN + 1
    ld   bc, SCRLEN - 1
    ld   (hl), $55       ; checkerboard: 01010101
    ldir
```

Здесь использован классический трюк самокопирования LDIR. Записывается `$55` (двоичное `01010101`) в первый байт по `$4000`, затем копируется из каждого байта в следующий для 6 143 байт. Результат: каждый байт пиксельной области содержит `$55`, что даёт чередующиеся установленные/сброшенные пиксели — шахматную доску. Поскольку паттерн одинаков в каждом байте, чересстрочный порядок строк не имеет значения — каждая строка получает один и тот же паттерн.

Стоимость: `LDIR` копирует 6 143 байта. Последняя итерация стоит 16T, все остальные — 21T: (6 143 - 1) x 21 + 16 = 128 998 тактов (T-state). Почти два полных кадра на Pentagon. Это нормально для однократной настройки, но ты ни за что не станешь так делать в цикле покадровой отрисовки.

```z80 id:ch02_practical_the_checkerboard_3
    ; --- Fill attributes: white ink on blue paper ---
    ; Attribute byte: flash=0, bright=1, paper=001 (blue), ink=111 (white)
    ; = 01 001 111 = $4F
    ld   hl, ATTRS
    ld   de, ATTRS + 1
    ld   bc, ATTLEN - 1
    ld   (hl), $4F
    ldir
```

Тот же приём для атрибутов. Значение `$4F` декодируется как: flash выкл (0), bright вкл (1), paper синий (001), ink белый (111). Каждое 8x8 знакоместо получает яркие белые чернила на синей бумаге. Пиксели шахматной доски — установленные/сброшенные, поэтому ты видишь чередующиеся белые и синие точки — классический визуальный паттерн ZX Spectrum.

Стоимость: `LDIR` копирует 767 байт — (767 - 1) x 21 + 16 = 16 102 такта (T-state).

```z80 id:ch02_practical_the_checkerboard_4
    ; --- Border: blue ---
    ld   a, 1
    out  ($FE), a

    ; Infinite loop
.wait:
    halt
    jr   .wait
```

Устанавливает бордюр в синий (цвет 1) в тон бумаге, создавая визуально чистую рамку. Затем бесконечный цикл с HALT между кадрами. `HALT` ожидает следующего маскируемого прерывания, которое срабатывает раз в кадр — это пульс покоя каждой программы для Spectrum.

![Заливка экрана чередующимися байтами — шахматный узор ярко-белым на синем](../../build/screenshots/ch02_fill_screen.png)

### Что попробовать

Загрузи `fill_screen.a80` в ассемблер и эмулятор. Затем экспериментируй:

- Замени `$55` на `$AA` для обратной шахматной доски, или `$FF` для сплошной заливки, или `$81` для вертикальных полос.
- Замени `$4F` на `$07`, чтобы увидеть тот же паттерн без BRIGHT, или на `$38` для белой бумаги с чёрными чернилами (инверсия умолчания).
- Попробуй `$C7` — это устанавливает бит flash. Наблюдай, как знакоместа чередуют цвета ink и paper с частотой ~1,6 Гц.
- Замени пиксельную заливку LDIR на цикл с DOWN_HL, записывающий разные паттерны в разные строки. Теперь ты увидишь чересстрочность в действии: если записать `$FF` в строки 0-7 (развёрточные строки первого знакоместа), заполненная область будет выглядеть как 8 горизонтальных полосок, разделённых промежутками — потому что эти строки отстоят на 256 байт, а не на 32.

---

## Навигация по экрану: Практическая сводка

Вот основные операции с указателями для экрана Spectrum, собранные в одном месте. Это строительные блоки каждой графической процедуры.

### Перемещение вправо на один байт (8 пикселей)

```z80 id:ch02_moving_right_one_byte_8
    inc  l             ; 4T
```

Это работает внутри строки знакомест, потому что столбец находится в младших 5 битах L. Если нужно пересечь границу байтов на правом краю (столбец 31 к столбцу 0 следующей строки), потребуется полный DOWN_HL плюс сброс L — но обычно это не нужно, потому что циклы имеют ширину 32 байта.

### Перемещение вниз на одну пиксельную строку

```z80 id:ch02_moving_down_one_pixel_row
    inc  h             ; 4T    (within a character cell)
```

Это работает для 7 из 8 строк. На 8-й строке нужна полная логика пересечения границы из процедуры DOWN_HL выше.

### Перемещение вниз на одну строку знакомест (8 пикселей)

```z80 id:ch02_moving_down_one_character_row
    ld   a, l          ; 4T
    add  a, 32         ; 7T
    ld   l, a          ; 4T    total: 15T (if no third crossing)
```

Это продвигает на одну строку знакомест внутри трети. Если L переполняется (флаг переноса установлен), ты пересёк границу следующей трети и нужно добавить 8 к H.

### Перемещение вверх на одну пиксельную строку

```z80 id:ch02_moving_up_one_pixel_row
    dec  h             ; 4T    (within a character cell)
```

Обратная операция `INC H`. Те же проблемы с границами знакомест и третей. Вот полная процедура UP_HL, зеркальная к DOWN_HL:

```z80 id:ch02_moving_up_one_pixel_row_2
; UP_HL: move HL one pixel row up on the Spectrum screen
; Input:  HL = current screen address
; Output: HL = screen address one row above
;
; Classic version:
up_hl:
    dec  h             ; 4T   try moving one scan line up
    ld   a, h          ; 4T
    and  7             ; 7T   did we cross a character boundary?
    cp   7             ; 7T
    ret  nz            ; 11/5T  no: done

    ; Crossed a character cell boundary upward.
    ld   a, l          ; 4T
    sub  32            ; 7T   previous character row (L -= 32)
    ld   l, a          ; 4T
    ret  c             ; 11/5T  if carry, crossed into prev third

    ld   a, h          ; 4T
    add  a, 8          ; 7T   compensate H
    ld   h, a          ; 4T
    ret                ; 10T
```

Есть тонкая оптимизация, предложенная Art-top (Артём Топчий): замена `and 7 / cp 7` на `cpl / and 7`. После `DEC H`, если младшие 3 бита H обернулись с `000` на `111`, мы пересекли границу знакоместа. Классический тест проверяет `AND 7` и затем сравнивает с 7. Оптимизированная версия сначала инвертирует: если биты равны `111`, CPL делает их `000`, и `AND 7` даёт ноль. Это экономит 1 байт и 3 такта (T-state) на пути пересечения границы:

```z80 id:ch02_moving_up_one_pixel_row_3
; UP_HL optimised (Art-top)
; Saves 1 byte, 3 T-states on boundary crossing
;
up_hl_opt:
    dec  h             ; 4T
    ld   a, h          ; 4T
    cpl                ; 4T   complement: 111 -> 000
    and  7             ; 7T   zero if we crossed boundary
    ret  nz            ; 11/5T

    ld   a, l          ; 4T
    sub  32            ; 7T
    ld   l, a          ; 4T
    ret  c             ; 11/5T

    ld   a, h          ; 4T
    add  a, 8          ; 7T
    ld   h, a          ; 4T
    ret                ; 10T
```

Тот же трюк с `CPL / AND 7` работает и в DOWN_HL, хотя условие границы там проверяет `000` (которые CPL превращает в `111`, тоже ненулевые после AND), поэтому при движении вниз он не помогает. Именно направление *вверх* — то, где классическому коду нужен дополнительный `CP 7`, который оптимизация устраняет.

### Вычисление адреса атрибута по адресу пикселя

Если HL указывает на байт в пиксельной области, можно вычислить соответствующий адрес атрибута. Вспомни структуру пиксельного адреса: H = `010TTSSS`, L = `LLLCCCCC`. Адрес атрибута для той же ячейки атрибутов — `$5800 + TT * 256 + LLL * 32 + CCCCC`. Поскольку L уже содержит `LLL * 32 + CCCCC` (диапазон 0--255), адрес атрибута — просто `($58 + TT) : L`. Всё, что нужно сделать — извлечь два бита TT из H, объединить их с `$58` и оставить L без изменений:

```z80 id:ch02_computing_the_attribute
; Convert pixel address in HL to attribute address in HL
; Input:  HL = pixel address ($4000-$57FF)
; Output: HL = corresponding attribute address ($5800-$5AFF)
;
    ld   a, h          ; 4T
    rrca               ; 4T
    rrca               ; 4T
    rrca               ; 4T
    and  3             ; 7T
    or   $58           ; 7T
    ld   h, a          ; 4T
    ; L unchanged       --- Total: 34T
```

Каждая техника в остальной части книги определяется раскладкой экрана, описанной в этой главе. Вот почему каждый элемент важен:

**Особый случай: когда в H биты строки развёртки = 111.** Если ты итерируешь по ячейке атрибутов сверху вниз и только что обработал последнюю строку развёртки (строка развёртки 7), младшие 3 бита H равны `111`. В этом случае существует более быстрое преобразование из 4 инструкций, предложенное Art-top:

```z80 id:ch02_computing_the_attribute_2
; Pixel-to-attribute when H low bits are %111
; (e.g., after processing the last scanline of a character cell)
; Input:  HL where H = 010TT111
; Output: HL = attribute address
;
    srl  h             ; 8T   010TT111 -> 0010TT11
    rrc  h             ; 8T   0010TT11 -> 10010TT1
    srl  h             ; 8T   10010TT1 -> 010010TT
    set  4, h          ; 8T   010010TT -> 010110TT = $58+TT
    ; L unchanged.     --- Total: 32T, 4 instructions
```

**Скроллинг** (глава 17) — это где раскладка больше всего мешает. Прокрутка экрана вверх на один пиксель означает перемещение 32 байт каждой строки по адресу строки выше неё. На линейном фреймбуфере это одно большое блочное копирование. На Spectrum адреса источника и назначения для каждой строки связаны логикой DOWN_HL — не фиксированным смещением. Процедура прокрутки должна навигировать по чересстрочности для каждой копируемой строки.

---

> **Врезка: Agon Light 2**
>
> Дисплей Agon Light 2 управляется VDP (Video Display Processor) — микроконтроллером ESP32, на котором работает библиотека FabGL. ЦП eZ80 обменивается с VDP через последовательный канал, отправляя команды для установки графических режимов, рисования пикселей, определения спрайтов и управления палитрами.
>
> Здесь нет чересстрочной раскладки экрана. Нет конфликта атрибутов. VDP поддерживает несколько растровых режимов с различными разрешениями (от 640x480 до 320x240 и ниже), с 64 цветами или полными RGBA-палитрами в зависимости от режима. Аппаратные спрайты (до 256) и тайловые карты поддерживаются нативно.
>
> Что меняется для программиста:
>
> - **Никакой адресной головоломки.** Пиксельные координаты линейно отображаются на позиции в буфере. Тебе не нужны DOWN_HL или обход экрана с раздельными счётчиками.
> - **Никакого конфликта атрибутов.** Каждый пиксель может быть любого цвета. Ограничение сетки 8x8 не существует.
> - **Нет прямого доступа к фреймбуферу.** ЦП не может напрямую писать в видеопамять так, как ЦП Spectrum пишет в `$4000`. Вместо этого ты отправляешь команды VDP через последовательный канал. Нарисовать пиксель — значит отправить последовательность команд, а не записать байт. Это вносит задержку — последовательный канал работает на 1 152 000 бод — но зато ЦП свободен во время рендеринга.
> - **Нет трюков на уровне тактов с бордюром.** VDP управляет таймингом отображения независимо. Ты не можешь создавать растровые эффекты, синхронизируя инструкции `OUT`, потому что конвейер отображения отвязан от тактовой частоты ЦП.
>
> Для программиста Spectrum Agon одновременно освобождает и разочаровывает. Ограничения, которые порождали творческие решения на Spectrum, попросту не существуют — но не существуют и прямые аппаратные трюки, которые эти ограничения делали возможными. Ты меняешь головоломку на API.

---

- 6 912-байтовый экран Spectrum состоит из **6 144 байт пиксельных данных** по адресам `$4000`--`$57FF` и **768 байт атрибутов** по адресам `$5800`--`$5AFF`.
- Пиксельные строки **чередуются** по знакоместам: адрес кодирует y как `010 TT SSS` (старший байт) и `LLL CCCCC` (младший байт), где биты y перемешаны по адресу.
- Перемещение **на одну пиксельную строку вниз** внутри знакоместа — это просто `INC H` (4 такта). Пересечение границ знакомест и третей требует дополнительной логики.
- Классическая процедура **DOWN_HL** обрабатывает все случаи, но стоит до 77 тактов на границах. Для полноэкранной итерации **циклы с раздельными счётчиками** (подход Introspec'а) снижают общую стоимость на 60% и устраняют нестабильность тайминга.
- Каждый байт атрибута кодирует **Flash, Bright, Paper и Ink** в формате `FBPPPIII`. Только **два цвета на 8x8 знакоместо** — это конфликт атрибутов.
- Конфликт атрибутов — это не просто ограничение, а **творческое ограничение**, определившее визуальную эстетику Spectrum и приведшее к эффективным демо-эффектам, работающим только с атрибутами.
- Цвет **бордюра** устанавливается через `OUT ($FE), A` (биты 0--2), и изменения видны на следующей строке развёртки, что делает его **инструментом отладки тайминга** и холстом для демосценовых растровых эффектов.
- **Agon Light 2** не имеет чересстрочной раскладки, конфликта атрибутов и прямого доступа к фреймбуферу — он заменяет головоломку на командный API VDP.

---

## Попробуй сам

1. **Вычисли адреса.** Возьми 10 случайных координат (x, y) и рассчитай экранный адрес вручную, используя битовую раскладку `010TTSSS LLLCCCCC`. Затем напиши маленькую процедуру на Z80, которая ставит один пиксель по каждой координате, и проверь, что твои вычисления совпадают.

2. **Визуализируй чересстрочность.** Модифицируй `fill_screen.a80`, чтобы записать разные значения в первые 8 строк. Запиши `$FF` (сплошной) в строку 0 и `$00` (пустой) в строки 1--7. Поскольку строки 0--7 находятся по адресам `$4000`, `$4100`, ..., `$4700`, тебе нужно менять H для достижения каждой строки. Результат должен быть одной яркой линией вверху с промежутком из 7 пустых линий до следующей сплошной линии на строке 8.

3. **Замерь DOWN_HL.** Используй тестовую обвязку с цветом бордюра из главы 1. Вызови классическую процедуру DOWN_HL 191 раз (для полного прохода по экрану) и измерь полосу. Затем реализуй версию с раздельными счётчиками и сравни. Версия с раздельными счётчиками должна дать заметно более короткую полосу.

---

5. **Полосы бордюра.** После `HALT` выполни тесный цикл, меняющий цвет бордюра на каждой строке развёртки в течение 64 строк. Используй 8 цветов бордюра по порядку (0, 1, 2, 3, 4, 5, 6, 7, повтор). Ты увидишь горизонтальные радужные полосы в верхнем бордюре. Подбери задержку между инструкциями `OUT`, пока полосы не станут чистыми и стабильными.

- Дисплей Spectrum на 6 912 байт состоит из **6 144 байт пиксельных данных** по адресам `$4000`--`$57FF` и **768 байт атрибутов** по адресам `$5800`--`$5AFF`.
- Строки пикселей **чересстрочно перемешаны** по знакоместам: адрес кодирует y как `010 TT SSS` (старший байт) и `LLL CCCCC` (младший байт), где биты y перетасованы по адресу.
- Перемещение **на одну строку пикселей вниз** внутри знакоместа — это просто `INC H` (4 такта (T-state)). Пересечение границ знакомест и третей требует дополнительной логики.
- Классическая процедура **DOWN_HL** обрабатывает все случаи, но стоит до 65 тактов (T-state) на границах. Для полноэкранной итерации **циклы с раздельными счётчиками** (подход Introspec'а) снижают общую стоимость на 60% и устраняют нестабильность тайминга.
- Каждый байт атрибута кодирует **мерцание (flash), яркость (bright), фон (paper) и чернила (ink)** в формате `FBPPPIII`. Только **два цвета на ячейку 8x8** — это и есть конфликт атрибутов.
- Конфликт атрибутов — это не просто ограничение, а **творческое ограничение**, которое определило визуальную эстетику Spectrum и привело к эффективным демо-эффектам, работающим только с атрибутами.
- Цвет **бордюра** задаётся через `OUT ($FE), A` (биты 0--2), и изменения видны на следующей строке развёртки, что делает его **инструментом отладки тайминга** и холстом для растровых эффектов демосцены.
- **Agon Light 2** не имеет чересстрочной раскладки, конфликта атрибутов и прямого доступа к фреймбуферу — он заменяет головоломку на командный API через VDP.

---

*Далее: Глава 3 — Инструментарий демосценера. Развёрнутые циклы, самомодифицирующийся код, стек как канал данных и техники, позволяющие делать невозможное в рамках бюджета.*

1. **Map the addresses.** Pick 10 random (x, y) coordinates and calculate the screen address by hand using the `010TTSSS LLLCCCCC` bit layout. Then write a small Z80 routine that plots a single pixel at each coordinate and verify your calculations match.

2. **Visualise the interleave.** Modify `fill_screen.a80` to write different values to the first 8 rows. Write `$FF` (solid) to row 0 and `$00` (empty) to rows 1--7. Because rows 0--7 are at `$4000`, `$4100`, ..., `$4700`, you will need to change H to reach each row. The result should be a single bright line at the very top, with a gap of 7 empty lines before the next solid line at row 8.

3. **Time DOWN_HL.** Use the border-colour timing harness from Chapter 1. Call the classic DOWN_HL routine 191 times (for a full screen traversal) and measure the stripe. Then implement the split-counter version and compare. The split-counter version should produce a visibly shorter stripe.

4. **Attribute painter.** Write a routine that fills the attribute area with a gradient: column 0 gets colour 0, column 1 gets colour 1, and so on (cycling through 0--7). Each row should have the same pattern. Then modify it so each row shifts the pattern by one position -- a diagonal rainbow. This is the seed of an attribute-based demo effect.

5. **Border stripes.** After a `HALT`, execute a tight loop that changes the border colour on every scanline for 64 lines. Use the 8 border colours in sequence (0, 1, 2, 3, 4, 5, 6, 7, repeat). You should see horizontal rainbow stripes in the top border. Adjust the timing delay between `OUT` instructions until the stripes are clean and stable.

---

> **Источники:** Introspec «Ещё раз про DOWN_HL» (Hype, 2020); Introspec «GO WEST Part 1» (Hype, 2015) об эффектах спорной памяти по экранным адресам; Introspec «Making of Eager» (Hype, 2015) о проектировании эффектов на основе атрибутов; документация ULA Spectrum о логике раскладки памяти; Art-top (личное общение, 2026) об оптимизированных UP_HL и быстром преобразовании пиксельного адреса в адрес атрибута.

*Next: Chapter 3 -- The Demoscener's Toolbox. Unrolled loops, self-modifying code, the stack as a data pipe, and the techniques that let you do the impossible within the budget.*
