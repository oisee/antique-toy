# Глава 12: Цифровые барабаны и синхронизация с музыкой

> *"My brain is not coping with asynchronous coding well."*
> -- Introspec, file_id.diz пати-версии Eager (to live), 3BM Open Air 2015

---

Демо -- это не слайд-шоу эффектов. Демо -- это перформанс, в котором каждое визуальное событие попадает в бит, каждый переход дышит в такт с музыкой, а зритель никогда не подозревает, что за кулисами процессор на 3,5 МГц жонглирует полудюжиной конкурирующих задач без операционной системы, без потоков и без страховочной сети.

Эта глава -- об архитектуре, которая делает это жонглирование возможным. Мы потратили предыдущие главы на создание отдельных эффектов -- туннелей, зумеров, скроллеров, цветовых анимаций -- и в Главе 11 узнали, как чип AY производит музыку. Теперь мы должны связать всё вместе. Вопросы теперь не "как нарисовать туннель?" или "как воспроизвести ноту?", а: как воспроизвести барабанный сэмпл, потребляющий почти весь ЦП, сохраняя плавность визуальных эффектов? Как синхронизировать смену эффектов с битом музыки? Как структурировать двухминутное демо, чтобы оно надёжно работало от начала до конца?

Ответы приходят из трёх источников. Eager Introspec'а (2015) даёт нам цифровой синтез барабанов и асинхронную генерацию кадров. GABBA diver4d (2019) показывает радикально другой подход к синхронизации с музыкой, используя видеоредактор как инструмент таймлайна. А система потоков Robus'а (2015) демонстрирует, что честная многопоточность на Z80 возможна, хотя и редко необходима.

Вместе эти три техники представляют архитектурное мышление, которое отличает коллекцию эффектов от готового демо.

---

## 12.1 Цифровые барабаны на AY

### Проблема: AY не может воспроизводить сэмплы

AY-3-8910, как мы рассмотрели в Главе 11, -- это PSG (Programmable Sound Generator, программируемый генератор звука). Он генерирует прямоугольные волны, шум и формы огибающей. У него нет возможности воспроизведения сэмплов, нет ЦАП, нет памяти для волновых форм. Каждый звук, который он производит, строится из этих примитивных источников в реальном времени. Если тебе нужна реалистичная бас-бочка -- с резким переходным ударом, за которым следует резонансное затухание -- генератор шума и огибающая AY могут это аппроксимировать, но результат звучит безошибочно синтетически. Ему не хватает веса реального перкуссионного удара.

Но есть лазейка.

Регистры R8, R9 и R10 управляют громкостью каналов A, B и C. Каждый -- это 4-битное значение (0-15). Если ты записываешь в регистр громкости раз в кадр, получаешь статический уровень громкости. Но что если записывать в него тысячи раз за кадр? Что если использовать регистр громкости как грубый 4-битный ЦАП и подавать в него последовательные значения сэмпла из оцифрованной записи?

Получаешь воспроизведение PCM. Грубое, шумное, 4-битное, но узнаваемое. AY становится проигрывателем сэмплов -- не по замыслу, а грубой силой.

### Цена: уничтожение ЦП

Вот проблема. Чтобы воспроизвести оцифрованный барабанный сэмпл с приемлемым качеством, нужно обновлять регистр громкости с аудио-частотой. Частота дискретизации 8 кГц означает одно обновление каждые 125 микросекунд. При 3,5 МГц 125 микросекунд -- это приблизительно 437 тактов (T-state). Это плотно, но выполнимо -- между записями сэмплов можно делать полезную работу.

Но 8 кГц звучит ужасно. Для бочки с ударом нужно хотя бы ощущение более высокого качества. И тут экономика рушится. При более высоких эффективных частотах дискретизации нужно прерывание или тесный цикл опроса, срабатывающий каждые 125-250 тактов (T-state). На такой частоте для чего-либо ещё почти не остаётся процессорного времени. Пока воспроизводится барабанный сэмпл, процессор -- это выделенный аудио-движок. Генерация видео, скриптинг, обработка ввода -- всё останавливается.

Типичный сэмпл бас-бочки длится 20-40 миллисекунд для критической части атаки. При 50 Гц это 1-2 кадра. В течение этих кадров процессор занят.

### Решение n1k-o: гибридный барабан

n1k-o, музыкант, создавший саундтрек Eager, нашёл решение. Ключевое наблюдение: барабанный звук имеет две различные фазы. **Атака** -- начальный переходный процесс, резкий "щелчок" или "удар", придающий бас-бочке её пробивную силу -- короткая, сложная и невозможная для убедительного синтеза на AY. Но **затухание** -- резонансный хвост, следующий за ним -- это плавный спад громкости, именно то, что генератор огибающей AY обрабатывает естественно.

Гибридный подход: воспроизводи атаку как цифровой сэмпл (потребляя процессорное время на 1-2 кадра), затем передай управление генератору огибающей AY для затухания (потребляя ноль процессорного времени, поскольку аппаратура делает работу автоматически). Цифровая атака плюс AY-затухание равно барабанный звук с реалистичной пробивной силой сэмпла и плавным хвостом аппаратного синтеза.

На практике реализация работает так:

```z80 id:ch12_n1k_o_s_insight_the_hybrid
; Play hybrid kick drum
; 1. Start digital sample playback for attack phase
; 2. When sample ends, configure AY envelope for decay

play_kick_drum:
    di                        ; disable interrupts -- timing critical

    ; --- Digital attack phase ---
    ; Play ~800 samples at ~8kHz = ~100ms = ~2 frames
    ld   hl, kick_sample      ; pointer to 4-bit sample data
    ld   b, 0                 ; 256 samples per loop pass
    ld   c, $FD               ; low byte of AY data port ($BFFD)

    ; Select volume register R8 (channel A)
    ld   a, 8
    ld   bc, $FFFD
    out  (c), a               ; select R8
    ld   c, $FD               ; prepare for $BFFD writes

.sample_loop:
    ld   a, (hl)              ; 7 T  - load sample byte
    inc  hl                   ; 6 T  - advance pointer
    ld   b, $BF               ; 7 T  - high byte of $BFFD
    out  (c), a               ; 12 T - write volume = sample value
    ; ... timing padding to hit target sample rate ...
    djnz .sample_loop         ; 13 T (approx 45 T per sample)

    ; --- AY decay phase ---
    ; Configure envelope for smooth volume decay
    ; The AY takes over -- zero CPU cost from here

    ld   a, R_ENV_LO
    ld   e, 200               ; envelope period: moderate decay speed
    call ay_write
    ld   a, R_ENV_HI
    ld   e, 0
    call ay_write
    ld   a, R_ENV_SHAPE
    ld   e, $00               ; \___  single decay to silence
    call ay_write
    ld   a, R_VOL_A
    ld   e, $10               ; switch channel A to envelope mode
    call ay_write

    ei
    ret

kick_sample:
    ; 4-bit PCM data: attack portion of a kick drum
    ; Each byte = one sample, value 0-15
    DB 0, 2, 8, 15, 14, 12, 15, 13
    DB 10, 14, 11, 8, 12, 9, 6, 10
    ; ... (typically 400-800 bytes for the full attack)
```

Данные сэмпла -- эти 400-800 байт 4-битного PCM -- берутся из реальной записи барабана, передискретизированной и квантованной до 4 бит. Переходный процесс атаки сохраняет характер оригинального инструмента: удар колотушки по мембране, начальное сжатие воздуха, резкое начало, по которому наш слух идентифицирует звук. Огибающая AY затем обеспечивает чистое, плавное затухание, которое наш слух принимает за естественный резонанс корпуса барабана.

Результат убедителен. На чипе, у которого вообще нет возможности воспроизведения сэмплов, ты слышишь нечто, похожее на настоящую бас-бочку. Не студийного качества, даже не качества Amiga, но на порядки лучше чистого AY-синтеза.

Результат убедителен. На чипе, у которого вообще нет возможности воспроизведения сэмплов, ты слышишь нечто, похожее на настоящую бас-бочку. Не студийного качества, даже не качества Amiga, но на порядки лучше чистого AY-синтеза.

### Бюджет кадра: два кадра на удар

Стоимость в кадрах конкретна: два кадра на один удар барабана. В течение этих кадров приблизительно 140 000 тактов (T-state) (два полных периода кадра на Pentagon) потребляются циклом воспроизведения сэмпла. Процессор ничего другого не делает. Дисплей продолжает показывать то, что было в экранной памяти, но новые кадры не генерируются. Музыкальные данные не обрабатываются (барабан ЯВЛЯЕТСЯ музыкой на эти два кадра). Скриптовый движок не работает.

Два кадра при 50 Гц -- это 40 миллисекунд. Для музыкального трека с бас-бочкой на бит при 130 BPM это примерно один удар барабана каждые 23 кадра. Два кадра из каждых 23 потрачены на воспроизведение барабана -- около 9% общего процессорного времени, доставленного резкими всплесками, которые полностью монополизируют процессор.

> **Врезка: MCC -- больше 16 уровней с одного AY**
>
> Одноканальный подход, описанный выше, даёт 16 уровней громкости (4-битный ЦАП). Но у AY три канала, и их аналоговые выходы смешиваются перед подачей на динамик. Что, если записать разные значения громкости во все три канала одновременно? Комбинированный сигнал имеет больше ступеней амплитуды, чем любой отдельный канал.
>
> Это техника MCC (Mixed Channel Covox), документированная UnBEL!EVER'ом (Born Dead #09, 1999). Два «крайних» канала обеспечивают основной сигнал; центральный канал добавляет корректирующее значение. С предвычисленной таблицей подстановки, отображающей 8-битные значения сэмпла на три регистровых значения, можно синтезировать приблизительно 108 различных уровней амплитуды -- намного лучше, чем 16.
>
> Стандартный цикл воспроизведения MCC работает на ~24 КГц (144 такта (T-state) на сэмпл). Сверхбыстрый вариант от MOn5+Er (Born Dead #0G, 2000) использует SP как указатель данных сэмпла (`POP HL` читает два байта за 10 тактов) и `JP (IX)` для перехода цикла (8 тактов), достигая ~43,75 КГц при 80 тактах на сэмпл -- приближаясь к телефонному качеству от звукового чипа, рассчитанного на прямоугольные волны.
>
> **Подвох:** таблица подстановки MCC зависит от точных аналоговых уровней выхода каждого канала. AY-3-8910 и YM2149F имеют разные кривые громкости (YM ближе к линейной, AY -- более логарифмическая), и даже чипы одной модели различаются между производственными партиями. Таблица на 108 уровней от UnBEL!EVER'а была рассчитана для YM2149F. На другом чипе комбинированные уровни смещаются, и тщательно выверенные ступени амплитуды становятся неравномерными. Центральный канал вносит примерно 52% смешанного сигнала -- если это соотношение дрейфует, корректирующие значения искажают сигнал, а не улучшают его.
>
> Для демо, нацеленных на конкретную машину (скажем, Pentagon с YM2149F), MCC работает хорошо. Для кроссплатформенной совместимости одноканальный 4-битный подход безопаснее. А для экспериментов ради удовольствия -- например, прогонки формул AY-beat (Приложение I) через усреднённую таблицу MCC -- искажения становятся частью очарования.
>
> *Источники: UnBEL!EVER, "Воспроизведение оцифровок на AY (MCC)," Born Dead #09 (1999); MOn5+Er, Born Dead #0G (2000).*

---

> **Врезка: MCC — больше 16 уровней с одного AY**
>
> Одноканальный подход, описанный выше, даёт тебе 16 уровней громкости (4-битный ЦАП). Но у AY три канала, и их аналоговые выходы смешиваются перед тем, как попасть на динамик. Что, если записать разные значения громкости во все три канала одновременно? Суммарный сигнал имеет больше ступеней амплитуды, чем любой отдельный канал.
>
> Это техника MCC (Mixed Channel Covox), задокументированная UnBEL!EVER'ом (Born Dead #09, 1999). Два «крайних» канала обеспечивают основной сигнал; центральный канал добавляет корректирующее значение. С предвычисленной таблицей подстановки, отображающей 8-битные значения сэмпла на три регистровых значения, можно синтезировать приблизительно 108 различных уровней амплитуды — куда лучше, чем 16.
>
> Стандартный цикл воспроизведения MCC работает на ~24 КГц (144 такта на сэмпл). Сверхбыстрый вариант от MOn5+Er (Born Dead #0G, 2000) использует SP как указатель на данные сэмпла (`POP HL` читает два байта за 10 тактов) и `JP (IX)` для ветвления цикла (8 тактов), достигая ~43,75 КГц при 80 тактах на сэмпл — приближаясь к телефонному качеству на звуковом чипе, спроектированном для прямоугольных волн.
>
> **Подвох:** таблица подстановки MCC зависит от точных аналоговых уровней выхода каждого канала. У AY-3-8910 и YM2149F разные кривые громкости (YM ближе к линейной, AY более логарифмический), и даже чипы одной модели различаются между производственными партиями. Таблица UnBEL!EVER'а на 108 уровней рассчитана для YM2149F. На другом чипе комбинированные уровни сдвигаются, и тщательно откалиброванные ступени амплитуды становятся неравномерными. Центральный канал вносит примерно 52% смешанного сигнала — если это соотношение плывёт, корректирующие значения искажают выход, а не улучшают его.
>
> Для демо, нацеленного на конкретную машину (скажем, Pentagon с YM2149F), MCC работает хорошо. Для кроссплатформенной совместимости одноканальный 4-битный подход безопаснее. А для экспериментов ради удовольствия — например, пропустить AY-beat формулы (Приложение I) через усреднённую MCC-таблицу — искажения становятся частью шарма.
>
> *Источники: UnBEL!EVER, «Воспроизведение оцифровок на AY (MCC)», Born Dead #09 (1999); MOn5+Er, Born Dead #0G (2000).*

---

## 12.2 Асинхронная генерация кадров

### Наивный подход не работает

Простейшая архитектура демо синхронна: сгенерируй один кадр визуального эффекта, дождись HALT (vsync), отобрази его. Сгенерируй следующий кадр, HALT, отобрази. Это то, что мы строили в каждом практическом упражнении до сих пор. Работает идеально, когда генерация кадра занимает меньше одного периода кадра.

Теперь добавим цифровые барабаны. Музыкальный движок сигнализирует: "воспроизведи бочку на следующий бит". Подпрограмма воспроизведения сэмпла захватывает ЦП на два кадра. В течение этих двух кадров новые видеокадры не генерируются. Когда барабан заканчивается, дисплей показывал один и тот же кадр три обновления подряд (последний сгенерированный кадр был показан раз нормально, затем дважды во время удара барабана). Визуальный эффект заикается.

С одним ударом барабана каждые 23 кадра зритель видит короткое замирание каждые полсекунды. Это заметно. Это некрасиво. Это неприемлемо для конкурсного демо.

```text
Time ──────────────────────────────────────────────────►

Display:   [Frame 1] [Frame 2] [Frame 3] [Frame 4] [Frame 5]
Generator: ──gen F2──|──gen F3──|──gen F4──|── DRUM ──|──gen F5──
                                           ↑          ↑
                                      drum starts  drum ends

During the drum hit, the display shows Frame 4 (already generated).
Frame 5 generation resumes immediately after the drum finishes.
```

Архитектура Introspec'а в Eager разделяет генерацию кадров и их отображение. Визуальный движок не генерирует один кадр и сразу его показывает. Вместо этого он генерирует кадры в буфер -- столько, сколько влезет -- а система отображения показывает их с постоянной частотой 50 Гц независимо от того, что делает генератор.

Механизм -- это атрибутные кадры с двойной буферизацией. Две страницы атрибутных данных существуют в памяти. Пока одна страница отображается (ULA читает из неё во время обновления экрана), генератор записывает следующий кадр в другую страницу. Когда новый кадр готов, движок переключает страницы: только что сгенерированный кадр становится страницей экрана, а старая страница экрана становится новой целью генерации.

```text
Time ──────────────────────────────────────────────────►

Display:   [Frame 1] [Frame 2] [Frame 3] [Frame 4] [Frame 5]
Generator: ──gen F2──|──gen F3──|──gen F4──|── DRUM ──|──gen F5──
                                           ↑          ↑
                                      drum starts  drum ends

During the drum hit, the display shows Frame 4 (already generated).
Frame 5 generation resumes immediately after the drum finishes.
```

Но простая двойная буферизация даёт только один кадр запаса. Если барабан потребляет два кадра, нужно сгенерировать два кадра вперёд. Вот где асинхронная генерация Introspec'а по-настоящему расходится с простой двойной буферизацией: движок может **накапливать** несколько кадров впрок.

На 128K Spectrum переключение банков памяти обеспечивает пространство. Атрибутные кадры маленькие -- 768 байт каждый. Одна 16-килобайтная страница памяти может вместить примерно 20 атрибутных кадров. Генератор работает так быстро, как может, записывая кадр за кадром в буфер. Система отображения читает из буфера с постоянной частотой 50 Гц. Когда генератор быстрее реального времени (что обычно так, поскольку атрибутная плазма дешёвая), буфер наполняется. Когда удар барабана приостанавливает генерацию, система отображения расходует буфер. Пока буфер не опустеет, зритель видит плавную анимацию на 50 Гц.

### Динамика буфера

Думай об этом как о задаче производитель-потребитель, но на машине без параллелизма.

**Производитель** -- генератор эффекта плазмы/туннеля/зумера. Он производит атрибутные кадры с переменной частотой -- иногда быстрее 50 Гц (когда расчёт прост и барабаны не воспроизводятся), иногда ноль (во время воспроизведения барабана).

**Потребитель** -- система отображения, читающая один кадр за обновление экрана ровно при 50 Гц.

**Буфер** сидит между ними, поглощая разницу.

Динамика проста:

---

Критическое ограничение: **буфер никогда не должен опустеть во время удара барабана.** Если два удара происходят в быстрой последовательности -- скажем, бочка-малый с разрывом в два кадра -- буферу нужен запас минимум в четыре кадра. Скриптовый движок Introspec'а управляет этим, зная музыкальный таймлайн заранее. Когда приближается плотный барабанный пассаж, движок генерирует дополнительные кадры для наполнения буфера. Когда следует тихий фрагмент, буфер естественным образом заполняется.

Подвох: если барабанный паттерн слишком плотный -- слишком много ударов слишком близко друг к другу -- генератор не успевает. Буфер пустеет, и дисплей повторяет кадр. Это жёсткое ограничение архитектуры, и оно повлияло на композицию n1k-o. Музыка была написана со знанием ёмкости движка: удары барабанов расположены достаточно далеко друг от друга, чтобы генератор всегда мог восстановиться. Музыкант и кодер проектировали вместе, каждый понимая ограничения другого.

---

## 12.3 Скриптовый движок

### Зачем нужен скрипт

К этому моменту список вещей, требующих координации, длинный:

- Генератор визуального эффекта (какой эффект активен, какие параметры он использует)
- Музыкальный проигрыватель (какой паттерн воспроизводится, когда срабатывают барабаны)
- Буфер кадров (насколько он полон, когда генерировать больше)
- Переходы между эффектами (плавное затухание одного, плавное появление следующего)
- Общий таймлайн (демо длится две минуты -- что происходит когда)

```text
; Outer script (conceptual, not exact syntax)
EFFECT  tunnel, params_set_1     ; start the tunnel effect
WAIT    200                       ; run for 200 frames (4 seconds)
EFFECT  zoomer, params_set_1     ; switch to chaos zoomer
WAIT    150                       ; 3 seconds
EFFECT  tunnel, params_set_2     ; tunnel again, different colours
WAIT    250                       ; 5 seconds
; ... and so on for the full demo
```

### Внешний скрипт: последовательность эффектов

Внешний скрипт -- это линейная последовательность команд, управляющих общей структурой демо. Думай о нём как о сет-листе для концерта:

```text
; Outer script (conceptual, not exact syntax)
EFFECT  tunnel, params_set_1     ; start the tunnel effect
WAIT    200                       ; run for 200 frames (4 seconds)
EFFECT  zoomer, params_set_1     ; switch to chaos zoomer
WAIT    150                       ; 3 seconds
EFFECT  tunnel, params_set_2     ; tunnel again, different colours
WAIT    250                       ; 5 seconds
; ... and so on for the full demo
```

```text
; Inner script for tunnel effect (conceptual)
FRAME  0:   plasma_freq = 3, palette = warm
FRAME  50:  plasma_freq = 5                   ; frequency shift
FRAME  100: palette = cool                     ; colour change
FRAME  120: plasma_freq = 2, palette = hot     ; both change
```

### Внутренний скрипт: вариации внутри эффекта

Внутри одного эффекта параметры меняются со временем. Частоты плазмы туннеля смещаются, цветовая палитра вращается, скорость зума ускоряется. Эти вариации контролируются внутренним скриптом -- последовательностью изменений параметров для конкретного эффекта, привязанных к номерам кадров:

```text
; Inner script for tunnel effect (conceptual)
FRAME  0:   plasma_freq = 3, palette = warm
FRAME  50:  plasma_freq = 5                   ; frequency shift
FRAME  100: palette = cool                     ; colour change
FRAME  120: plasma_freq = 2, palette = hot     ; both change
```

Внутренний скрипт работает независимо от внешнего. Когда внешний скрипт говорит "запусти туннель на 200 кадров", внутренний скрипт управляет визуальной эволюцией в рамках этих 200 кадров.

### kWORK: ключевая команда

Самая важная команда в системе скриптинга -- то, что Introspec называет **kWORK**: "сгенерируй N кадров, затем показывай их независимо от генерации". Эта единственная команда -- мост между системой скриптинга и асинхронной архитектурой.

Когда движок встречает `kWORK 8`, он:

```z80 id:ch12_kwork_the_key_command
; Simplified engine loop (conceptual)
engine_loop:
    ; Check if drum is pending
    ld   a, (drum_pending)
    or   a
    jr   z, .no_drum
    call play_drum            ; consumes 2 frames of CPU time
    xor  a
    ld   (drum_pending), a

.no_drum:
    ; Generate a batch of frames
    call generate_batch       ; kWORK: produce N frames into buffer
    ; (generate_batch returns when batch is done)

    ; Check outer script for effect changes
    call advance_script

    jr   engine_loop
```

Это разделение -- генерируй сейчас, показывай потом -- фундаментальная основа для асинхронной работы. Без kWORK движок был бы заперт в синхронном цикле генерация-отображение-генерация-отображение без запаса для прерываний барабанами.

---

```z80 id:ch12_kwork_the_key_command
; Simplified engine loop (conceptual)
engine_loop:
    ; Check if drum is pending
    ld   a, (drum_pending)
    or   a
    jr   z, .no_drum
    call play_drum            ; consumes 2 frames of CPU time
    xor  a
    ld   (drum_pending), a

.no_drum:
    ; Generate a batch of frames
    call generate_batch       ; kWORK: produce N frames into buffer
    ; (generate_batch returns when batch is done)

    ; Check outer script for effect changes
    call advance_script

    jr   engine_loop
```

В 2019 году diver4d (из 4D+TBK) занял первое место на CAFe с GABBA, габбер-тематическим демо с беспощадно точной аудиовизуальной синхронизацией. Синхронизация была настолько точной, что каждый визуальный акцент попадал точно на музыкальный бит, каждый переход совпадал с границей фразы, и вся постановка ощущалась как музыкальный клип, а не демо.

---

## 12.4 Инновация GABBA: видеоредактор как инструмент таймлайна

В 2019 году diver4d (из 4D+TBK) занял первое место на CAFe с GABBA, габбер-тематическим демо с беспощадно точной аудиовизуальной синхронизацией. Синхронизация была настолько точной, что каждый визуальный акцент попадал точно на музыкальный бит, каждый переход совпадал с границей фразы, и вся постановка ощущалась как музыкальный клип, а не демо.

Технический сюрприз был в рабочем процессе, а не в коде.

### Проблема код-ориентированной синхронизации

Традиционный подход к синхронизации с музыкой в ZX-демо -- встраивание данных тайминга в код. Ты знаешь, что бочка ударяет на кадре 47, и пишешь команду скрипта, запускающую визуальное событие на кадре 47. Затем смотришь демо, решаешь, что тайминг слегка не совпадает, меняешь число на 49, перекомпилируешь, перетестируешь и повторяешь. Для двухминутного демо при 50 fps это 6 000 кадров потенциальных точек синхронизации. Подгонка их всех методом проб и ошибок занимает недели.

Eager Introspec'а был построен именно так, и разработка была изнурительной. Каждая поправка синхронизации требовала перекомпиляции -- ассемблирования Z80-кода, загрузки бинарника в эмулятор, просмотра соответствующего фрагмента, записи того, что не так, редактирования исходника и повторения. Цикл обратной связи измерялся минутами на итерацию.

### Ответ diver4d: Luma Fusion

diver4d полностью обошёл цикл код-редактирование-компиляция-тест. Он использовал **Luma Fusion**, видеоредактор для iOS, как инструмент синхронизации.

Рабочий процесс:

Идея проста: используй правильный инструмент для работы. Видеоредактор специально создан для покадровой мультимедийной синхронизации. Ассемблер Z80 -- нет. Выполняя творческую работу по синхронизации в редакторе, а реализацию -- в ассемблере, diver4d разделил художественные решения и инженерные ограничения.

2. **diver4d записал каждый визуальный эффект**, работающий при 50 fps в эмуляторе, и экспортировал записи как видеоклипы.

3. **В Luma Fusion** он расположил видеоклипы на таймлайне 50 fps рядом с аудиотреком. Он мог прокручивать демо покадрово, видя точно, как каждый визуальный элемент совпадает с каждым музыкальным событием. Перемещение перехода было так же просто, как перетаскивание клипа на таймлайне.

4. **Когда тайминг был правильным в редакторе**, он извлекал номера кадров для каждого перехода и смены эффекта и записывал эти числа в данные скрипта Z80.

---

### Что это меняет

Непосредственная выгода -- скорость. Подгонка тайминга синхронизации в видеоредакторе занимает секунды. Подгонка в ассемблере -- минуты. На сотнях точек синхронизации кумулятивная экономия времени огромна. Но более глубокая выгода -- творческая свобода. Когда итерация дешёвая, ты больше экспериментируешь. Ты пробуешь переход на два кадра раньше, смотришь, как ощущается, пробуешь на два кадра позже. Ты замечаешь, что визуальный эффект лучше работает, попадая чуть *до* бита (техника, заимствованная из кинообработки, где монтажные склейки на бит ощущаются запоздалыми из-за времени реакции человека). Ты никогда бы не обнаружил эту идею через код-ориентированную итерацию -- цикл обратной связи слишком медленный.

Ограничение в том, что этот рабочий процесс лучше всего работает для демо с фиксированным таймингом -- где демо всегда воспроизводится одинаково. Если нужны интерактивные или генеративные элементы, реагирующие на условия во время выполнения, нужен код-ориентированный подход. Но для подавляющего большинства ZX-демо, которые являются линейными постановками с фиксированным таймлайном, рабочий процесс через видеоредактор превосходит.

GABBA продемонстрировала, что инструменты производства демосцены не обязаны быть ретро. Z80-код из 1985 года. Рабочий процесс синхронизации может быть из 2019-го. Противоречия нет.

---

## 12.5 Потоки на Z80: другой путь

Robus, публикуясь в Hype в 2015 году, представил технику, атакующую проблему параллелизма с совершенно другого угла: настоящая многопоточность на Z80.

### Проблема, переформулированная

```z80 id:ch12_im2_based_context_switching
; SwitchThread: save current thread, resume next thread
; Called from within the IM2 interrupt handler
SwitchThread:
    ; Save current thread's stack pointer
    ld   (thread_sp_save), sp

    ; Save current memory page configuration
    ld   a, (current_7ffd)
    ld   (thread_page_save), a

    ; Load next thread's state
    ld   a, (next_thread_page)
    ld   (current_7ffd), a
    ld   bc, $7FFD
    out  (c), a               ; switch memory page

    ld   sp, (next_thread_sp)  ; switch stack pointer

    ; Execution continues in the next thread's context
    ; (it was previously suspended at this same point)
    ret
```

Что если Z80 мог бы выполнять две задачи одновременно?

### Переключение контекста на базе IM2

Он может, до некоторой степени. Прерывание IM2 на Z80 обеспечивает естественную точку переключения контекста. Каждый кадр срабатывает прерывание. Если обработчик прерывания сохраняет состояние текущей задачи и загружает состояние другой задачи, ты получаешь вытесняющую многопоточность.

Процедура `SwitchThread` Robus'а делает именно это:

```z80 id:ch12_im2_based_context_switching
; SwitchThread: save current thread, resume next thread
; Called from within the IM2 interrupt handler
SwitchThread:
    ; Save current thread's stack pointer
    ld   (thread_sp_save), sp

    ; Save current memory page configuration
    ld   a, (current_7ffd)
    ld   (thread_page_save), a

    ; Load next thread's state
    ld   a, (next_thread_page)
    ld   (current_7ffd), a
    ld   bc, $7FFD
    out  (c), a               ; switch memory page

    ld   sp, (next_thread_sp)  ; switch stack pointer

    ; Execution continues in the next thread's context
    ; (it was previously suspended at this same point)
    ret
```

Каждый поток получает собственный **128-байтный стек** и **выделенную страницу памяти** (один из восьми 16-килобайтных банков 128K Spectrum). Стек маленький, но достаточный -- Z80-код редко имеет глубокую вложенность. Выделенная страница памяти даёт каждому потоку собственное рабочее пространство без интерференции с другим.

### Как это работает на практике

В демо WAYHACK Robus'а два потока работают параллельно:

```text
Frame 1: Interrupt → save Thread 2 → restore Thread 1 → Thread 1 runs
Frame 2: Interrupt → save Thread 1 → restore Thread 2 → Thread 2 runs
Frame 3: Interrupt → save Thread 2 → restore Thread 1 → Thread 1 runs
...
```

Ни один поток не знает о другом. Каждый работает в собственной странице памяти с собственным стеком. Каждый кадр срабатывает прерывание IM2, и `SwitchThread` переключается между ними. Поток 1 получает один кадр процессорного времени, затем Поток 2 получает один кадр, и так далее.

Результат: текстовый скроллер работает на стабильных 25 Гц (каждый второй кадр), и визуальный эффект работает на 25 Гц. Ни одна задача не должна знать о существовании другой. Никакого кооперативного планирования, никаких точек уступки, никакого ручного чередования. Прерывание обрабатывает всё.

### Модель потоков

Модель проста:

```text
Frame 1: Interrupt → save Thread 2 → restore Thread 1 → Thread 1 runs
Frame 2: Interrupt → save Thread 1 → restore Thread 2 → Thread 2 runs
Frame 3: Interrupt → save Thread 2 → restore Thread 1 → Thread 1 runs
...
```

---

### Практические соображения

Собственная оценка Robus'а характерно честна: **"Честная многопоточность редко требует больше двух потоков"** на Z80. Накладные расходы на переключение контекста (сохранение и восстановление SP плюс переключение страницы памяти) скромны -- возможно, 100 тактов (T-state) -- но каждый дополнительный поток вдвое уменьшает доступное процессорное время на поток. С двумя потоками каждый получает 25 Гц. С тремя -- каждый получает примерно 16,7 Гц. На машине, где визуальная плавность требует близко к 50 Гц, два потока -- практический предел.

Подход потоков ортогонален подходу асинхронной буферизации Introspec'а. Их можно комбинировать: один поток генерирует кадры эффекта в буфер, другой обрабатывает музыку и воспроизведение барабанов. На практике такая комбинация редка -- две техники решают одну и ту же проблему (чередование ресурсоёмких задач) через разные механизмы, и большинство демо-кодеров выбирают одну или другую исходя из конкретных требований их постановки.

Потоки лучше всего работают, когда две задачи по-настоящему независимы и ни одна не требует больше 25 Гц. Подход с асинхронным буфером лучше всего работает, когда одна задача (визуальные эффекты) требует 50 Гц, а другая (барабаны) -- непредсказуемые всплески. Для архитектуры Eager, где визуальная плавность была первостепенна, а тайминг барабанов диктовался музыкой, победил подход с буфером. Для архитектуры WAYHACK, где две устойчивые задачи работали параллельно, победили потоки.

---

```text
$6000-$7FFF   Engine code + effect routines
$8000-$9FFF   Music player + song data
$A000-$AFFF   Sine tables, colour maps, sample data
$B000-$BFFF   Frame ring buffer (attribute frames)
$C000-$DFFF   Shadow screen (second display page)
$E000-$FFFF   Stack + IM2 vector table + workspace

Bank 0-3:     Not used (available for larger effects)
Bank 5:       Normal screen ($4000-$5AFF display)
Bank 7:       Shadow screen ($C000-$DAFF display)
```

Давай построим минимальный движок демо, связывающий вместе концепции из этой главы. Цель -- не уровень сложности Eager -- это каркас, демонстрирующий архитектуру.

```z80 id:ch12_the_timeline_script
; Timeline script: sequence of (effect_id, duration_frames, param_ptr)
timeline:
    DB  EFFECT_PLASMA,   0, 150   ; plasma for 150 frames (3 sec)
    DW  plasma_params_1
    DB  EFFECT_BARS,     0, 100   ; colour bars for 100 frames (2 sec)
    DW  bars_params_1
    DB  EFFECT_SCROLLER, 0, 200   ; text scroller for 200 frames (4 sec)
    DW  scroller_params_1
    DB  EFFECT_PLASMA,   0, 150   ; plasma again, different params
    DW  plasma_params_2
    DB  $FF                        ; end marker: loop from start

EFFECT_PLASMA   EQU 0
EFFECT_BARS     EQU 1
EFFECT_SCROLLER EQU 2
```

- **Три простых эффекта:** плазма (на атрибутах, из Главы 9), цветные полосы (горизонтальные атрибутные полосы) и текстовый скроллер.
- **AY-музыка**, воспроизводимая через прерывание IM2 (с использованием .pt3 проигрывателя, как описано в Главе 11).
- **Цифровой сэмпл бас-бочки**, воспроизводимый на бит, крадущий 2 кадра ЦП.
- **Простой скрипт таймлайна**, переключающий эффекты в определённых точках.
- **Атрибуты с двойной буферизацией** для поглощения пауз от ударов барабанов.

```z80 id:ch12_the_main_engine_loop
; Main engine loop
; Assumes IM2 is set up and music player runs in the ISR

engine_init:
    ; Set up display: fill pixel memory with checkerboard
    call fill_checkerboard

    ; Initialise ring buffer
    xor  a
    ld   (buf_write_idx), a
    ld   (buf_read_idx), a
    ld   (buf_count), a

    ; Load first effect from timeline
    ld   hl, timeline
    ld   (script_ptr), hl
    call load_next_effect

engine_main:
    ; === Step 1: Check for drum trigger ===
    ld   a, (drum_pending)
    or   a
    jr   z, .no_drum

    ; Play the drum -- this consumes ~2 frames
    call play_kick_drum
    xor  a
    ld   (drum_pending), a
    jr   .after_drum

.no_drum:
    ; === Step 2: Generate a frame into the buffer ===
    ld   a, (buf_count)
    cp   BUF_CAPACITY         ; buffer full?
    jr   nc, .buffer_full

    ; Generate one frame of the current effect
    call generate_frame       ; writes 768 bytes to ring buffer

    ; Advance buffer write pointer
    ld   a, (buf_write_idx)
    inc  a
    cp   BUF_CAPACITY
    jr   nz, .no_wrap_w
    xor  a
.no_wrap_w:
    ld   (buf_write_idx), a
    ld   a, (buf_count)
    inc  a
    ld   (buf_count), a

.buffer_full:
.after_drum:
    ; === Step 3: Advance timeline ===
    ld   hl, (frame_counter)
    inc  hl
    ld   (frame_counter), hl

    ; Check if current effect duration has elapsed
    ld   de, (effect_duration)
    or   a
    sbc  hl, de
    jr   c, .effect_continues

    ; Load next effect from timeline
    call load_next_effect
    ld   hl, 0
    ld   (frame_counter), hl

.effect_continues:
    ; === Step 4: Wait if we are ahead of display ===
    halt                      ; sync to frame boundary

    jr   engine_main
```

```text
$6000-$7FFF   Engine code + effect routines
$8000-$9FFF   Music player + song data
$A000-$AFFF   Sine tables, colour maps, sample data
$B000-$BFFF   Frame ring buffer (attribute frames)
$C000-$DFFF   Shadow screen (second display page)
$E000-$FFFF   Stack + IM2 vector table + workspace

Bank 0-3:     Not used (available for larger effects)
Bank 5:       Normal screen ($4000-$5AFF display)
Bank 7:       Shadow screen ($C000-$DAFF display)
```

```z80 id:ch12_the_display_isr
; IM2 interrupt handler: runs every frame (50 Hz)
frame_isr:
    push af
    push bc
    push de
    push hl

    ; Play music (updates AY registers)
    call music_play

    ; Check if music engine signals a drum hit
    ld   a, (music_drum_flag)
    or   a
    jr   z, .no_drum_signal
    xor  a
    ld   (music_drum_flag), a
    ld   a, 1
    ld   (drum_pending), a    ; signal main loop
.no_drum_signal:

    ; Display next frame from ring buffer
    ld   a, (buf_count)
    or   a
    jr   z, .no_frame         ; buffer empty, keep current frame

    ; Copy buffered attributes to display page
    call copy_buf_to_screen

    ; Advance read pointer
    ld   a, (buf_read_idx)
    inc  a
    cp   BUF_CAPACITY
    jr   nz, .no_wrap_r
    xor  a
.no_wrap_r:
    ld   (buf_read_idx), a
    ld   a, (buf_count)
    dec  a
    ld   (buf_count), a

.no_frame:
    pop  hl
    pop  de
    pop  bc
    pop  af
    ei
    reti

BUF_CAPACITY EQU 8           ; 8 frames of buffer (8 x 768 = 6,144 bytes)
```

```z80 id:ch12_the_timeline_script
; Timeline script: sequence of (effect_id, duration_frames, param_ptr)
timeline:
    DB  EFFECT_PLASMA,   0, 150   ; plasma for 150 frames (3 sec)
    DW  plasma_params_1
    DB  EFFECT_BARS,     0, 100   ; colour bars for 100 frames (2 sec)
    DW  bars_params_1
    DB  EFFECT_SCROLLER, 0, 200   ; text scroller for 200 frames (4 sec)
    DW  scroller_params_1
    DB  EFFECT_PLASMA,   0, 150   ; plasma again, different params
    DW  plasma_params_2
    DB  $FF                        ; end marker: loop from start

EFFECT_PLASMA   EQU 0
EFFECT_BARS     EQU 1
EFFECT_SCROLLER EQU 2
```

```z80 id:ch12_the_effect_generator_dispatch
; Generate one frame of the current effect
; Writes attribute data to the ring buffer
generate_frame:
    ld   a, (current_effect)
    or   a
    jr   z, .do_plasma
    cp   1
    jr   z, .do_bars
    cp   2
    jr   z, .do_scroller
    ret

.do_plasma:
    call calc_plasma          ; from Chapter 9 -- writes 768 bytes
    ret
.do_bars:
    call calc_colour_bars     ; horizontal attribute stripes
    ret
.do_scroller:
    call calc_text_scroll     ; text rendering into attributes
    ret
```

```z80 id:ch12_the_main_engine_loop
; Main engine loop
; Assumes IM2 is set up and music player runs in the ISR

engine_init:
    ; Set up display: fill pixel memory with checkerboard
    call fill_checkerboard

    ; Initialise ring buffer
    xor  a
    ld   (buf_write_idx), a
    ld   (buf_read_idx), a
    ld   (buf_count), a

    ; Load first effect from timeline
    ld   hl, timeline
    ld   (script_ptr), hl
    call load_next_effect

engine_main:
    ; === Step 1: Check for drum trigger ===
    ld   a, (drum_pending)
    or   a
    jr   z, .no_drum

    ; Play the drum -- this consumes ~2 frames
    call play_kick_drum
    xor  a
    ld   (drum_pending), a
    jr   .after_drum

.no_drum:
    ; === Step 2: Generate a frame into the buffer ===
    ld   a, (buf_count)
    cp   BUF_CAPACITY         ; buffer full?
    jr   nc, .buffer_full

    ; Generate one frame of the current effect
    call generate_frame       ; writes 768 bytes to ring buffer

    ; Advance buffer write pointer
    ld   a, (buf_write_idx)
    inc  a
    cp   BUF_CAPACITY
    jr   nz, .no_wrap_w
    xor  a
.no_wrap_w:
    ld   (buf_write_idx), a
    ld   a, (buf_count)
    inc  a
    ld   (buf_count), a

.buffer_full:
.after_drum:
    ; === Step 3: Advance timeline ===
    ld   hl, (frame_counter)
    inc  hl
    ld   (frame_counter), hl

    ; Check if current effect duration has elapsed
    ld   de, (effect_duration)
    or   a
    sbc  hl, de
    jr   c, .effect_continues

    ; Load next effect from timeline
    call load_next_effect
    ld   hl, 0
    ld   (frame_counter), hl

.effect_continues:
    ; === Step 4: Wait if we are ahead of display ===
    halt                      ; sync to frame boundary

    jr   engine_main
```

### Обработчик прерываний дисплея

```z80 id:ch12_the_display_isr
; IM2 interrupt handler: runs every frame (50 Hz)
frame_isr:
    push af
    push bc
    push de
    push hl

    ; Play music (updates AY registers)
    call music_play

    ; Check if music engine signals a drum hit
    ld   a, (music_drum_flag)
    or   a
    jr   z, .no_drum_signal
    xor  a
    ld   (music_drum_flag), a
    ld   a, 1
    ld   (drum_pending), a    ; signal main loop
.no_drum_signal:

    ; Display next frame from ring buffer
    ld   a, (buf_count)
    or   a
    jr   z, .no_frame         ; buffer empty, keep current frame

    ; Copy buffered attributes to display page
    call copy_buf_to_screen

    ; Advance read pointer
    ld   a, (buf_read_idx)
    inc  a
    cp   BUF_CAPACITY
    jr   nz, .no_wrap_r
    xor  a
.no_wrap_r:
    ld   (buf_read_idx), a
    ld   a, (buf_count)
    dec  a
    ld   (buf_count), a

.no_frame:
    pop  hl
    pop  de
    pop  bc
    pop  af
    ei
    reti

BUF_CAPACITY EQU 8           ; 8 frames of buffer (8 x 768 = 6,144 bytes)
```

### Диспетчер генератора эффектов

```z80 id:ch12_the_effect_generator_dispatch
; Generate one frame of the current effect
; Writes attribute data to the ring buffer
generate_frame:
    ld   a, (current_effect)
    or   a
    jr   z, .do_plasma
    cp   1
    jr   z, .do_bars
    cp   2
    jr   z, .do_scroller
    ret

.do_plasma:
    call calc_plasma          ; from Chapter 9 -- writes 768 bytes
    ret
.do_bars:
    call calc_colour_bars     ; horizontal attribute stripes
    ret
.do_scroller:
    call calc_text_scroll     ; text rendering into attributes
    ret
```

### Наблюдения

Этот каркас намеренно прост. Продакшн-движок добавил бы:

- **Внутренние скрипты** для вариации параметров внутри каждого эффекта.
- **Эффекты переходов** (кроссфейды между двумя атрибутными буферами).
- **Несколько звуков барабанов** (бочка, малый, хай-хэт), каждый со своими данными сэмпла.
- **Мониторинг уровня буфера**, чтобы генератор мог приоритизировать восстановление после плотных барабанных пассажей.
- **Переключение банков памяти** для хранения большего количества кадров и поддержки более объёмных данных эффектов.

Но даже в минимальной форме эта архитектура демонстрирует ключевые принципы:

---

2. **Удары барабанов поглощаются буфером.** Когда `play_kick_drum` потребляет два кадра, обработчик прерываний дисплея продолжает показывать буферизованные кадры. Зритель не видит заикания.

3. **Скрипт управляет таймлайном.** Добавление нового эффекта или изменение последовательности означает редактирование таблицы данных `timeline`, а не перестройку кода движка.

4. **Музыкальный проигрыватель работает в обработчике прерываний.** Он обновляет регистры AY каждый кадр независимо от того, что делает основной цикл. Единственное взаимодействие -- флаг `drum_pending` -- однобайтный "почтовый ящик" между обработчиком прерываний и основным циклом.

Это архитектура демо. Не эффекты, не музыка, не арт -- *сантехника*, которая заставляет всё это работать вместе. Это наименее видимая часть демо и самая сложная в реализации. Introspec потратил десять недель на Eager, и архитектура заняла больше времени, чем любой отдельный эффект.

---

## 12.7 Практические упражнения

---

**Упражнение 2: Добавь барабан.** Запиши (или синтезируй) 4-битный сэмпл бас-бочки (400-800 байт). Добавь подпрограмму `play_kick_drum` и запускай её каждые 25 кадров. Убедись, что дисплей остаётся плавным во время воспроизведения барабана. Какова максимальная частота ударов, прежде чем буфер опустеет?

**Упражнение 3: Многоэффектный таймлайн.** Добавь второй эффект (цветные полосы или текстовый скроллер). Напиши скрипт таймлайна, переключающий эффекты каждые 3-4 секунды. Убедись, что переходы происходят в правильный кадр.

**Упражнение 4: Синхронизация с музыкой.** Загрузи короткую .pt3 мелодию и модифицируй проигрыватель, чтобы он устанавливал `music_drum_flag`, когда происходит определённое событие паттерна (например, нота на канале C ниже определённой высоты). Теперь барабаны управляются музыкой, а не фиксированным счётчиком кадров. Это настоящая синхронизация с музыкой.

**Упражнение 5: Рабочий процесс через видеоредактор.** Запиши работающее демо в эмуляторе при 50 fps. Импортируй запись в видеоредактор (любой, поддерживающий покадровое редактирование). Подгони номера кадров скрипта таймлайна на основе того, что видишь в редакторе. Почувствуй разницу в скорости итерации по сравнению с синхронизацией через код.

---

## Итого

Эта глава была не об отдельном эффекте или технике. Она была об архитектуре -- невидимой структуре, которая позволяет демо существовать как связная, синхронизированная, двухминутная постановка, а не как коллекция разрозненных экранов.

---

Рассмотренные решения дополняют друг друга:
