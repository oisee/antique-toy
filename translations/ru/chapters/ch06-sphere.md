# Глава 6: Сфера --- Текстурный маппинг на 3.5 МГц

> *«Кодерские эффекты — это всегда эволюция вычислительной схемы.»*
> --- Introspec, 2017

---

1996 год, и демо под названием *Illusion* занимает первое место на ENLiGHT'96 в Санкт-Петербурге. Зрители наблюдают, как монохромное изображение оборачивается вокруг вращающейся сферы, плавно вращаясь в реальном времени, на ZX Spectrum, работающем на 3.5 МГц без какого-либо аппаратного ускорения. Ни блиттера. Ни GPU. Ни сопроцессора. Только Z80, 48 килобайт непрерывного ОЗУ и всё, что двадцатилетний кодер по имени Dark мог из них выжать.

Двадцать лет спустя, в марте 2017 года, Introspec садится с копией бинарника и дизассемблером. Он разбирает цикл рендеринга инструкцию за инструкцией, считает такты (T-state), сопоставляет адреса памяти со структурами данных и публикует свои находки на Hype. Далее следует один из самых детальных публичных разборов демосценового эффекта, когда-либо написанных для ZX Spectrum --- и в ветке комментариев, разгоревшейся под статьёй, дискуссия о том, что действительно важно в рендеринге реального времени на ограниченном оборудовании.

Эта глава следует анализу Introspec'а. Мы заглянем ему через плечо, пока он трассирует код, поймём, *почему* сфера работает именно так, а затем построим упрощённую версию сами.

---

## Проблема: круглый объект на квадратном экране

Сфера на экране --- не сфера. Это круг, заполненный искажённым изображением. Искажение следует правилам сферической проекции: пиксели вблизи экватора расположены равномерно, пиксели вблизи полюсов сжаты по горизонтали, и всё отображение изгибается, создавая иллюзию трёхмерной поверхности.

Исходное изображение в Illusion хранится как монохромная битовая карта --- один байт на пиксель, где каждый байт равен либо 0, либо 1. По стандартам Spectrum это расточительно, где экранная память упаковывает восемь пикселей в байт, но это даёт существенное преимущество: рендерящий код может обращаться с пикселями как с арифметическими значениями, а не с битовыми позициями.

Задача, таким образом, такова: читать пиксели из исходного изображения, выбирать их согласно сферической проекции, упаковать восемь из них в один экранный байт и записать этот байт в видеопамять. Сделать это для каждого видимого байта сферы. Сделать достаточно быстро для анимации. Сделать на Z80 частотой 3.5 МГц.

## Ключевая идея: код, который пишет код

Первый вопрос, который задаёт каждый Z80-программист: как выглядит внутренний цикл? На машине, где один `NOP` занимает 4 такта и бюджет кадра составляет примерно 70 000 тактов, внутренний цикл *и есть* программа. Всё остальное --- инициализация, генерация таблиц, управление кадрами --- это накладные расходы, выполняемые однократно или редко. Внутренний цикл работает тысячи раз за кадр.

Решение Dark'а --- не иметь фиксированного внутреннего цикла вообще.

Вместо этого рендерящий код *генерируется во время выполнения*. Для каждой горизонтальной линии сферы программа конструирует последовательность Z80-инструкций, настроенных под геометрию этой линии. Сгенерированный код читает исходные пиксели по порядку, накапливает их в экранные байты через сдвиги и сложения и продвигается по исходным данным на расстояния, меняющиеся с кривизной сферы. Разные линии сферы дают разный код.

Это техника, встречающаяся повсюду на демосцене: самогенерируемый код, иногда называемый «скомпилированные спрайты» при применении к рендерингу спрайтов, или «генерация развёрнутых циклов» в общем случае. Что делает версию для сферы отличительной --- вариативность. Скомпилированный спрайт фиксирован --- однажды сгенерированный, он рисует одну и ту же форму каждый раз. Код сферы меняется с углом вращения, потому что разные исходные пиксели становятся видны по мере поворота сферы.

## Внутри дизассемблера

Introspec отследил рендерящий движок до блока сгенерированного кода и набора таблиц подстановки, начинающихся с адреса `$6944`. Таблицы кодируют геометрию сферы как серию *расстояний пропуска*: для каждой позиции вдоль строки развёртки сферы --- сколько исходных пикселей пропустить перед выборкой следующего.

На экваторе расстояния пропуска примерно одинаковы --- исходное изображение отображается на сферу с минимальным искажением. Вблизи полюсов горизонтальное сжатие проекции означает большие пропуски между выбираемыми пикселями. На самом верху и низу видимы лишь несколько пикселей на линию, и пропуски могут быть значительными.

Сгенерированный внутренний цикл имеет повторяющуюся структуру. Для каждого экранного байта (восемь упакованных пикселей) он исполняет последовательность вроде этой:

```z80
; --- Accumulating 8 source pixels into one screen byte ---
; HL points into the source image (one byte per pixel)
; A is the accumulator, building the screen byte bit by bit

    add  a,a          ; shift accumulator left (make room for next pixel)
    add  a,(hl)       ; add source pixel (0 or 1) into lowest bit
    inc  l            ; advance to next source pixel
    ; ... possibly more INC L instructions here,
    ; depending on how many pixels to skip

    add  a,a          ; shift again
    add  a,(hl)       ; sample next pixel
    inc  l
    inc  l            ; skip one extra pixel (sphere curvature)

    add  a,a
    add  a,(hl)
    inc  l

    ; ... six more times, for 8 pixels total ...
```

Ключевая деталь: между каждым `add a,(hl)` количество инструкций `inc l` варьируется. В одной позиции может быть один `inc l` (выборка соседних пикселей). В другой --- три или четыре (пропуск сжатых областей проекции). Таблицы подстановки по адресу `$6944` кодируют точное количество `inc l` для каждой позиции.

Рассмотрим внимательнее, что происходит с одним пикселем:

```z80
    add  a,a          ;  4 T-states  (shift A left by 1)
    add  a,(hl)       ;  7 T-states  (add source pixel into bit 0)
    inc  l            ;  4 T-states  (advance source pointer)
```

Это минимальная стоимость: 15 тактов на сдвиг аккумулятора и выборку одного пикселя, плюс 4 такта за каждый пропущенный исходный байт. После восьми таких последовательностей аккумулятор содержит полный экранный байт.

Обрати внимание, что указатель исходных данных продвигается через `inc l`, а не `inc hl`. Это намеренно. `INC HL` занимает 6 тактов; `INC L` --- 4. Ограничивая исходные данные рамками одной 256-байтной страницы (чтобы менялся только младший байт адреса), Dark экономит 2 такта на каждое продвижение. Когда делаешь это тысячи раз за кадр, эти 2 такта набегают.

Здесь есть тонкость, которую легко упустить. Исходное изображение хранится как один байт на пиксель, и `INC L` оборачивается в пределах 256-байтной страницы. Это значит, что каждая строка исходных данных должна умещаться в 256 байт, а буфер исходных данных должен быть выровнен по странице. Ограничение определяет всю раскладку памяти демо.

## Подсчёт тактов

Introspec вычислил стоимость одного выходного байта:

**101 + 32x тактов**

где *x* --- среднее количество дополнительных инструкций `INC L` на пиксель сверх обязательной одной. Проверим.

Фиксированная стоимость на пиксель:

| Инструкция | Такты |
|-------------|----------|
| `add a,a`   | 4        |
| `add a,(hl)`| 7        |
| `inc l`     | 4        |
| **Промежуточный итог** | **15**  |

Для 8 пикселей фиксированная стоимость --- 8 x 15 = 120 тактов. Но есть дополнительные накладные расходы на байт: код должен записать собранный байт в экранную память и подготовиться к следующему. Допустим, последовательность вывода выглядит примерно так:

```z80
    ld   (de),a       ;  7 T-states  (write screen byte)
    inc  e            ;  4 T-states  (advance screen pointer)
```

Также может быть обнуление аккумулятора (`xor a` или подобное) в начале каждого байта. Принимая измеренную Introspec'ом цифру в 101 такт как фиксированную базовую стоимость на байт, накладные расходы сверх чистой выборки пикселей составляют примерно 101 - 120 = ... что означает, что базовая цифра уже включает инструкции вывода, и часть пиксельной работы чередуется иначе, чем наивный подсчёт предполагает.

Чистое прочтение формулы: 101 такт фиксированных накладных расходов (вывод, управление указателями, инициализация на байт), плюс 32 такта на каждый дополнительный пропуск. «32» возникает из 8 пикселей, умноженных на 4 такта за каждый дополнительный `INC L`, что даёт x как среднее количество дополнительных пропусков на позицию пикселя в этом байте. Когда сфера вблизи экватора, x мало --- проекция близка к равномерной. Вблизи полюсов x велико, и рендеринг замедляется. Но полюса также требуют меньше байтов (сфера там уже), так что общая нагрузка примерно сбалансирована.

Достаточно ли это быстро? Кадр Spectrum --- приблизительно 70 000 тактов (на Pentagon: 71 680). Сфера диаметром 56 пикселей занимает примерно 7 байт в самом широком месте. По всей высоте нужно отрендерить возможно 200–250 байт. При 101 такте на байт (экваториальном, x около нуля) это примерно 25 000 тактов --- комфортно укладывается в бюджет одного кадра, с запасом на очистку экрана, поиск по таблицам и прочую бухгалтерию. Даже вблизи полюсов, где x может в среднем составлять 2–3, стоимость байта растёт до 165–197 тактов, но рисовать нужно меньше байт. Арифметика сходится. Укладывается.

## Проход генерации кода

Перед работой внутреннего цикла его *генерирует* проход генерации кода. Этот проход читает таблицы подстановки по адресу `$6944`, кодирующие геометрию сферы для текущего угла вращения, и выдаёт Z80-инструкции в буфер:

1. Для каждой строки развёртки сферы прочитать расстояния пропуска из таблицы.
2. Выдать `add a,a`, за ним `add a,(hl)` для каждого пикселя.
3. Выдать соответствующее количество инструкций `inc l` на основе расстояния пропуска.
4. После каждых 8 пикселей выдать инструкцию вывода для записи собранного байта в экранную память.
5. В конце каждой строки выдать возврат или переход к обработчику следующей строки.

Сгенерированный блок кода затем вызывается напрямую. Процессор исполняет инструкции как обычную подпрограмму, но они были написаны мгновением ранее генератором кода. Это самомодифицирующийся код в самом буквальном смысле --- программа генерирует программу, которая рисует экран.

Проход генерации кода сам по себе не бесплатен, но он выполняется один раз за кадр (или один раз за шаг вращения), тогда как сгенерированный внутренний цикл работает сотни раз. Амортизированная стоимость пренебрежима.

## Что знал Dark: Spectrum Expert и строительные блоки

В этой истории есть деталь, превращающая её из технической диковинки в нарративную арку. Dark --- кодер, стоящий за эффектом сферы в Illusion --- это тот же Dark, который написал статьи «Алгоритмы программирования» в Spectrum Expert #01, опубликованном в 1997 году.

Эти статьи охватывают умножение (сдвиг-и-сложение vs. поиск по таблице квадратов), деление (восстанавливающее и логарифмическое), генерацию таблиц синуса через параболическую аппроксимацию и рисование линий по Брезенхэму с оптимизированными матричными блоками 8x8. Это учебный материал, написанный для сообщества программистов ZX Spectrum, объясняющий фундаментальные техники, которые нужны любому демо-кодеру.

И они, совершенно точно, являются строительными блоками, использованными в Illusion.

Сфера требует: тригонометрических таблиц подстановки для вычисления проекции (синус/косинус, параболическая аппроксимация из статьи Dark'а). Умножения с фиксированной точкой для масштабирования. Аккуратной раскладки памяти для скорости (та же дисциплина подсчёта тактов, которой Dark учит на протяжении всех статей). Подход с таблицами пропусков для кодирования геометрии сферы --- прямое применение мышления на основе предвычислений, которое Dark пропагандирует.

Dark опубликовал учебник. Затем написал демо, демонстрирующее каждую технику из него. Двадцать лет спустя Introspec дизассемблировал демо и нашёл именно те паттерны, которым Dark учил. У нас есть обе стороны истории: учитель, объясняющий свои методы, и аналитик, подтверждающий, что именно эти методы содержатся в готовом продукте.

## Дебаты на Hype: внутренние циклы vs. математика

Статья Introspec'а 2017 года на Hype вызвала длинную ветку комментариев. Среди наиболее содержательных обменов была дискуссия между kotsoft и Introspec'ом о том, где лежит настоящая работа эффекта вроде этого.

kotsoft утверждал, что математический подход к проекции --- то, как вычисляешь, какой исходный пиксель отображается на какую экранную позицию --- является ключевым проектным решением. Ошибись в проекции, или используй наивный алгоритм, и никакая оптимизация внутреннего цикла тебя не спасёт. Математическая модель определяет, *осуществим* ли вообще эффект на данном оборудовании.

Introspec возражал, что внутренний цикл --- это место, где такты реально расходуются. Можно иметь красивую математическую модель, но если рендерящий код стоит 200 тактов на байт вместо 100, ты сократил частоту кадров вдвое. Математический подход определяет, *что* вычислять; внутренний цикл определяет, *можно ли вычислить это вовремя*.

Оба правы, и напряжение между ними высвечивает нечто фундаментальное в демосценовом кодировании. Демо-эффект --- не чистая математика и не чистая инженерия. Это пересечение: элегантная вычислительная схема (проекция сферы, закодированная как таблицы пропусков), соединённая с эффективной стратегией исполнения (сгенерированные развёрнутые циклы с продвижениями `INC L`). По отдельности ни то, ни другое не достаточно.

Резюме Introspec'а схватывает суть: «кодерские эффекты --- это всегда эволюция вычислительной схемы.» Ключевое слово --- *эволюция*. Ты не берёшь алгоритм из учебника и оптимизируешь его, пока он не влезет. Ты эволюционируешь алгоритм и реализацию совместно, каждый ограничивает и обеспечивает другого, пока не найдёшь форму, работающую в рамках бюджета оборудования.

## Практика: упрощённая вращающаяся сфера 56x56

Набросаем, как ты бы построил упрощённую версию этого эффекта. Целевая сфера --- 56x56 пикселей --- 7 байт в ширину на экваторе, 56 строк в высоту. Цель --- не воспроизвести полноценный рендерящий движок Illusion, а понять ядро техники достаточно хорошо для реализации.

### Шаг 1: Предвычисление геометрии сферы

Для каждой строки развёртки *y* (от -28 до +27, центрированной на сфере) вычисляем видимую дугу:

```
radius_at_y = sqrt(R^2 - y^2)    ; where R = 28 (sphere radius in pixels)
```

Это даёт полуширину сферы на этой строке. Для каждой позиции пикселя *x* в пределах дуги вычисляем соответствующие долготу и широту на поверхности сферы:

```
latitude  = arcsin(y / R)
longitude = arcsin(x / radius_at_y) + rotation_angle
```

Это даёт координаты (u, v) в исходной текстуре для каждого экранного пикселя.

### Шаг 2: Построение таблиц пропусков

Вместо хранения полных пар (u, v) для каждого пикселя (непомерно дорого по памяти) вычисляем *разницу в позиции источника* между соседними экранными пикселями. Для каждой строки нужен список значений пропуска: сколько исходных пикселей пропустить между последовательными экранными выборками.

Вблизи экватора последовательные экранные пиксели соответствуют почти соседним исходным пикселям --- пропуски равны 1. Вблизи полюсов проекция сжимает, и ты пропускаешь больше исходных пикселей --- пропуски 2, 3 или более.

Сохраняем это как таблицу. Для нашей сферы 56x56 нужно максимум 56 записей на строку (самая широкая), умножить на 56 строк, умножить на один байт на запись. Это максимум 3 136 байт для одного угла вращения --- но на практике можно использовать вертикальную симметрию (верхняя половина зеркальна нижней) и хранить только половину таблицы.

Для анимации нужны таблицы пропусков для нескольких углов вращения. С 32 шагами вращения таблицы заняли бы 32 x 1 568 = около 49 КБ. Это переполняет доступную память, поэтому на практике используешь меньше шагов, грубее угловое разрешение или перегенерируешь таблицы на лету из компактного представления.

### Шаг 3: Генерация рендерящего кода

Для каждого кадра читаем таблицу пропусков текущего угла и генерируем Z80-код:

```z80
; Code generator pseudocode (in Z80 assembly, this would be
; a loop that writes opcodes into a buffer)

generate_sphere_code:
    ld   iy,skip_table        ; pointer to skip distances
    ld   ix,code_buffer       ; pointer to output code buffer

.line_loop:
    ; For each scan line...
    ld   b,bytes_this_line    ; number of output bytes (e.g. 7 at equator)

.byte_loop:
    ; For each output byte, emit code for 8 pixels:
    ld   c,8                  ; 8 pixels per byte

.pixel_loop:
    ; Emit: ADD A,A
    ld   (ix+0),$87           ; opcode for ADD A,A
    inc  ix

    ; Emit: ADD A,(HL)
    ld   (ix+0),$86           ; opcode for ADD A,(HL)
    inc  ix

    ; Emit INC L instructions based on skip distance
    ld   a,(iy+0)             ; read skip distance
    inc  iy

.emit_inc_l:
    or   a
    jr   z,.pixel_done
    ld   (ix+0),$2C           ; opcode for INC L
    inc  ix
    dec  a
    jr   nz,.emit_inc_l

.pixel_done:
    dec  c
    jr   nz,.pixel_loop

    ; Emit: LD (DE),A  (write byte to screen)
    ld   (ix+0),$12           ; opcode for LD (DE),A
    inc  ix
    ; Emit: INC E
    ld   (ix+0),$1C           ; opcode for INC E
    inc  ix

    dec  b
    jr   nz,.byte_loop

    ; Emit line transition code here (advance DE to next screen line)
    ; ...

    jr   .line_loop
```

Это упрощение --- реальный код Illusion более плотно интегрирован, и Dark, вероятно, использовал более компактный и эффективный генератор кода. Но принцип тот же: читать расстояния пропусков, выдавать опкоды.

### Шаг 4: Исполнение и отображение

Когда буфер кода заполнен, вызываем его как подпрограмму:

```z80
    ld   hl,source_image      ; source texture (page-aligned, 1 byte/pixel)
    ld   de,screen_address    ; start of sphere area in video memory
    call code_buffer          ; execute the generated rendering code
```

Сгенерированный код проходит через всю сферу, читая исходные пиксели, упаковывая их в экранные байты и записывая в видеопамять. По возвращении сфера нарисована.

Для анимации увеличиваем угол вращения, загружаем соответствующую таблицу пропусков (или перегенерируем её), перегенерируем код и рендерим заново.

### Шаг 5: Раскладка исходного изображения

Исходная текстура должна быть организована для быстрого последовательного доступа. Поскольку рендерящий код использует `INC L` для продвижения, текстура должна быть выровнена по странице (начинаться по адресу, где младший байт равен `$00`), и каждая строка должна умещаться в 256 байт. Текстура шириной 256 пикселей, хранящаяся как один байт на пиксель, идеально соответствует этому ограничению: каждая строка занимает одну страницу.

Для монохромного случая каждый пиксель --- `$00` или `$01`. Это значит, что `ADD A,(HL)` добавляет либо 0 (пиксель выключен), либо 1 (пиксель включен) к младшему биту аккумулятора, сразу после того как `ADD A,A` сдвинул всё вверх. Результат --- побитно упакованный экранный байт, где каждый бит соответствует одному выбранному исходному пикселю.

---

## Общий паттерн

Сфера в Illusion --- конкретный экземпляр общего демосценового паттерна, встречающегося на протяжении всей этой книги. Паттерн состоит из трёх частей:

**Предвычисление.** Дорогостоящая математическая работа --- проекция, тригонометрия, преобразования координат --- выполняется однократно (или раз за кадр) и сохраняется в компактных таблицах. Таблицы кодируют, *что* рендерить, не кодируя *как*.

**Генерация кода.** Сам рендерящий код генерируется из таблиц. Это устраняет ветвления, счётчики циклов и условную логику из внутреннего цикла. Каждая инструкция в сгенерированном коде выполняет полезную работу. Нет накладных расходов на «выяснение, что делать дальше» --- это решение было принято при генерации.

**Последовательный доступ к памяти.** Внутренний цикл читает данные последовательно, продвигая указатель однобайтными инкрементами. Это самый быстрый паттерн доступа на Z80, где косвенные загрузки через регистр (`LD A,(HL)`) дёшевы, а индексная адресация (`LD A,(IX+d)`) дорога.

Ротозумер в следующей главе использует тот же паттерн. Так же как и точечный скроллер в Главе 10. Так же как атрибутные туннели в Главе 9. Детали различаются --- разные таблицы, разный сгенерированный код, разные форматы данных --- но архитектура одна. Introspec понял это, когда написал, что кодерские эффекты --- это «эволюция вычислительной схемы». Сфера, ротозумер, туннель: все они эволюционировали из одного фундаментального подхода. Эволюция --- в деталях --- какое вычисление, какая раскладка таблицы, какой внутренний цикл --- но скелет общий.

Dark понимал это в 1996 году. Он закодировал это в своих статьях Spectrum Expert в 1997-м. Introspec подтвердил дизассемблированием в 2017-м. Паттерн столь же актуален сейчас, как и тогда, на любой платформе, где такты дефицитны и каждая инструкция должна оправдать своё присутствие.

---

## Итого

- Эффект сферы в Illusion отображает монохромное исходное изображение на вращающуюся сферу с помощью динамически сгенерированного Z80-кода.
- Таблицы подстановки кодируют геометрию сферы как расстояния пропуска пикселей. Рендерящий код генерируется из этих таблиц во время выполнения.
- Внутренний цикл использует `ADD A,A` и `ADD A,(HL)` для накопления пикселей в экранные байты, с переменным числом инструкций `INC L` для продвижения по исходным данным.
- Производительность: 101 + 32x тактов на выходной байт, где x зависит от позиции.
- Подход воплощает общий демосценовый паттерн: предвычислить геометрию, сгенерировать код, обращаться к памяти последовательно.
- Dark написал фундаментальные алгоритмы в Spectrum Expert (1997) и применил их в Illusion (1996). Introspec дизассемблировал результат двадцать лет спустя, подтвердив техники.

---

> **Источники:** Introspec, «Технический анализ Illusion от X-Trade» (Hype, 2017); Dark, «Алгоритмы программирования» (Spectrum Expert #01, 1997). Ветка комментариев на Hype включает вклады kotsoft, Raider и других.
