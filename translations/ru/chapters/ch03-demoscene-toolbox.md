# Глава 3: Инструментарий демосценера

В каждом ремесле есть свой набор приёмов --- паттернов, к которым мастера тянутся настолько инстинктивно, что перестают воспринимать их как приёмы. Демосценер на Z80 тянется к техникам из этой главы.

Эти паттерны --- развёрнутые циклы, самомодифицирующийся код, стек как канал данных, LDI-цепочки, генерация кода и RET-цепочки --- встречаются практически в каждом эффекте, который мы будем строить во второй части. Именно они отличают демо, укладывающееся в один кадр, от демо, которому нужно три. Освой их здесь --- и ты будешь узнавать их повсюду.

---

## Развёрнутые циклы и самомодифицирующийся код

### Стоимость цикла

Рассмотрим простейший внутренний цикл: заполнение нулями 256 байт памяти.

```z80
; Looped version: clear 256 bytes at (HL)
    ld   b, 0            ; 7 T   (B=0 means 256 iterations)
    xor  a               ; 4 T
.loop:
    ld   (hl), a         ; 7 T
    inc  hl              ; 6 T
    djnz .loop           ; 13 T  (8 on last iteration)
```

Каждая итерация стоит 7 + 6 + 13 = 26 тактов на запись одного байта. Из них лишь 7 тактов делают полезную работу --- остальное накладные расходы. Это 73% впустую. На 256 байт: 256 x 26 - 5 = 6 651 такт. На машине с бюджетом 69 888 тактов на кадр эти потерянные такты ощутимы.

### Развёртка: размен ROM на скорость

Решение жёсткое и эффективное: выписать тело цикла N раз и убрать цикл.

```z80
; Unrolled version: clear 256 bytes at (HL)
    xor  a               ; 4 T
    ld   (hl), a         ; 7 T
    inc  hl              ; 6 T
    ld   (hl), a         ; 7 T
    inc  hl              ; 6 T
    ld   (hl), a         ; 7 T
    inc  hl              ; 6 T
    ; ... repeated 256 times total
```

Теперь каждый байт стоит 7 + 6 = 13 тактов. Нет DJNZ. Нет счётчика. Итого: 256 x 13 = 3 328 тактов --- вдвое меньше цикловой версии.

Цена --- размер кода: 256 повторений занимают 512 байт против 7 у цикла. Ты размениваешь ROM на скорость.

**Когда развёртывать:** Внутренние циклы, выполняющиеся тысячи раз за кадр --- очистка экрана, отрисовка спрайтов, копирование данных.

**Когда НЕ развёртывать:** Внешние циклы, выполняющиеся один-два раза за кадр. Экономия 5 тактов на 24 итерациях даёт 120 тактов --- меньше трёх NOP. Не стоит раздувания.

Практический компромисс --- *частичная развёртка*: развернуть 8 или 16 итераций внутри цикла, оставить DJNZ для внешнего счётчика. Пример `push_fill.a80` в каталоге `examples/` этой главы делает именно это: 16 PUSH за итерацию, 192 итерации.

### Самомодифицирующийся код: секретное оружие Z80

У Z80 нет кэша инструкций, нет буфера предвыборки, нет конвейера. Когда процессор считывает байт инструкции из ОЗУ, он читает то, что там находится *прямо сейчас*. Если ты изменил этот байт один цикл назад, процессор увидит новое значение. Это гарантированное свойство архитектуры.

Самомодифицирующийся код (SMC) означает запись в байты инструкций во время выполнения. Классический паттерн --- подмена непосредственного операнда:

```z80
; Self-modifying code: fill with a runtime-determined value
    ld   a, (fill_value)       ; load the fill byte from somewhere
    ld   (patch + 1), a        ; overwrite the operand of the LD below
patch:
    ld   (hl), $00             ; this $00 gets replaced at runtime
    inc  hl
    ; ...
```

Инструкция `ld (patch + 1), a` записывает в непосредственный операнд следующей `ld (hl), $00`, превращая её в `ld (hl), $AA` или что угодно другое. Процессор выполняет те байты, которые находит. Вот несколько распространённых паттернов SMC:

**Подмена опкодов.** Можно заменить саму инструкцию. Нужен цикл, который иногда инкрементирует HL, а иногда декрементирует? Перед циклом запиши опкод INC HL ($23) или DEC HL ($2B) в байт инструкции. Внутри внутреннего цикла вообще нет ветвления --- нужная инструкция уже на месте. Сравни с подходом «ветвление на каждую итерацию», который стоил бы 12 тактов (JR NZ) на каждый пиксель.

**Сохранение и восстановление указателя стека.** Этот паттерн встречается постоянно при использовании PUSH-трюков (ниже):

```z80
    ld   (restore_sp + 1), sp     ; save SP into the operand below
    ; ... do stack tricks ...
restore_sp:
    ld   sp, $0000                ; self-modified: the $0000 was overwritten
```

Инструкция `ld (nn), sp` сохраняет текущий SP прямо в операнд последующей `ld sp, nn`. Никаких временных переменных. Это идиоматический код демосцены на Z80.

**Предупреждение.** SMC безопасен на Z80, eZ80 и любом клоне Spectrum. Он *не безопасен* на современных процессорах с кэшем (x86, ARM) без явного сброса кэша инструкций. Если будешь портировать на другую архитектуру, это первое, что сломается.

---

## Стек как канал данных

### Почему PUSH --- самая быстрая запись на Z80

Инструкция PUSH записывает 2 байта в память и декрементирует SP, всё за 11 тактов. Сравним альтернативы записи данных по экранному адресу:

| Метод | Записано байт | Такты | Тактов на байт |
|--------|--------------|----------|-------------------|
| `ld (hl), a` + `inc hl` | 1 | 13 | 13,0 |
| `ld (hl), a` + `inc l` | 1 | 11 | 11,0 |
| `ldi` | 1 | 16 | 16,0 |
| `ldir` (за байт) | 1 | 21 | 21,0 |
| `push hl` | 2 | 11 | **5,5** |

PUSH записывает два байта за 11 тактов --- 5,5 такта на байт. Почти в 4 раза быстрее LDIR. Подвох: PUSH пишет туда, куда указывает SP, а SP --- это обычно твой стек. Чтобы использовать PUSH как канал данных, нужно перехватить указатель стека.

### Техника

Паттерн всегда один и тот же:

1. Запретить прерывания (DI). Если прерывание сработает, пока SP указывает на экран, процессор протолкнёт адрес возврата в пиксельные данные. Наступит хаос.
2. Сохранить SP. Использовать самомодифицирующийся код, чтобы спрятать его.
3. Установить SP в *конец* целевой области. Стек растёт вниз --- PUSH декрементирует SP перед записью. Поэтому если хочешь заполнить с $4000 до $57FF, установи SP в $5800.
4. Загрузить данные в регистровые пары и PUSHить многократно.
5. Восстановить SP и разрешить прерывания (EI).

Вот суть примера `push_fill.a80` из каталога `examples/` этой главы:

```z80
stack_fill:
    di                          ; critical: no interrupts while SP is moved
    ld   (restore_sp + 1), sp   ; self-modifying: save SP

    ld   sp, SCREEN_END         ; SP points to end of screen ($5800)
    ld   hl, $AAAA              ; pattern to fill

    ld   b, 192                 ; 192 iterations x 16 PUSHes x 2 bytes = 6144
.loop:
    push hl                     ; 11 T  \
    push hl                     ; 11 T   |
    push hl                     ; 11 T   |
    push hl                     ; 11 T   |
    push hl                     ; 11 T   |
    push hl                     ; 11 T   |  16 PUSHes = 32 bytes
    push hl                     ; 11 T   |  = 176 T-states
    push hl                     ; 11 T   |
    push hl                     ; 11 T   |
    push hl                     ; 11 T   |
    push hl                     ; 11 T   |
    push hl                     ; 11 T   |
    push hl                     ; 11 T   |
    push hl                     ; 11 T   |
    push hl                     ; 11 T   |
    push hl                     ; 11 T  /
    djnz .loop                  ; 13 T (8 on last)

restore_sp:
    ld   sp, $0000              ; self-modified: restores original SP
    ei
    ret
```

Внутреннее тело из 16 PUSH записывает 32 байта за 176 тактов. Итого для всей пиксельной области в 6 144 байта: примерно 36 000 тактов. Сравни с LDIR: 6 144 x 21 - 5 = 129 019 тактов. Метод PUSH примерно в 3,6 раза быстрее --- разница между «укладывается в один кадр» и «вылезает в следующий».

### Где используются PUSH-трюки

- **Очистка экрана.** Самое распространённое применение. Каждому демо нужно очищать экран между эффектами.
- **Скомпилированные спрайты.** Спрайт компилируется в последовательность инструкций PUSH с предзагруженными регистровыми парами. Максимально быстрый вывод спрайтов на Z80.
- **Быстрый вывод данных.** Когда нужно перебросить блок данных в непрерывный диапазон адресов: заливки атрибутов, копирования буферов, построение списков вывода.

Цена: прерывания выключены. Если музыкальный плеер работает через прерывание IM2, он пропустит удар во время длинной последовательности PUSH. Демо-кодеры планируют с учётом этого --- размещают PUSH-заливки во время бордюра или разбивают их на несколько кадров.

---

## LDI-цепочки

### LDI vs LDIR

LDI копирует один байт из (HL) в (DE), инкрементирует оба и декрементирует BC. LDIR делает то же самое, но повторяет до BC = 0. Разница --- тайминг:

| Инструкция | Такты | Примечания |
|-------------|----------|-------|
| LDI | 16 | Копирует 1 байт, всегда 16 T |
| LDIR (за байт) | 21 | Копирует 1 байт, возвращается назад. Последний байт: 16 T |

LDIR стоит на 5 тактов больше за байт из-за внутренней проверки зацикливания. Эти 5 тактов быстро накапливаются.

Для 256 байт:
- LDIR: 255 x 21 + 16 = 5 371 такт
- 256 x LDI: 256 x 16 = 4 096 тактов
- Экономия: 1 275 тактов (24%)

Цепочка из отдельных инструкций LDI --- это просто 256 повторений двухбайтового опкода `$ED $A0`. Это 512 байт кода ради 24% экономии --- тот же размен ROM на скорость, что и при развёртке циклов.

### Когда LDI-цепочки блистают

Оптимальный случай --- копирование блоков известного размера. Цепочка из 32 LDI экономит 160 тактов по сравнению с LDIR для строки спрайта. На 24 строках это 3 840 тактов за кадр.

Но настоящая мощь проявляется при комбинации LDI-цепочек с *арифметикой точек входа*. Если у тебя цепочка из 256 LDI и нужно скопировать только 100 байт, прыгай в цепочку на позицию 156. Никакого счётчика цикла, никакой настройки. Эта техника использована в хаотическом зумере Introspec'а в Eager (2015):

```z80
; Chaos zoomer inner loop (simplified from Eager)
; Each line copies a different number of bytes from a source buffer.
; Entry point into the LDI chain is calculated per line.
    ld   hl, source_data
    ld   de, dest_screen
    ; ... calculate entry point based on zoom factor ...
    jp   (ix)             ; jump into the LDI chain at the right point

ldi_chain:
    ldi                   ; byte 255
    ldi                   ; byte 254
    ldi                   ; byte 253
    ; ... 256 LDIs total ...
    ldi                   ; byte 0
    ; falls through to next line setup
```

Это копирование переменной длины с нулевыми накладными расходами за байт --- техника, которую принципиально невозможно реализовать с LDIR. Это одна из причин, почему LDI --- лучший друг в демосценовом коде.

---

## Генерация кода

### Самая мощная техника

Всё вышеописанное --- фиксированные оптимизации: код работает одинаково в каждом кадре. Генерация кода идёт дальше: твоя программа пишет программу, которая рисует экран. Есть два варианта: офлайн (до ассемблирования) и рантайм (во время выполнения).

### Офлайн: генерация ассемблера из языка высокого уровня

Introspec использовал Processing (среду для творческого кодирования на Java) для генерации Z80-ассемблера хаотического зумера в Eager (2015). Хаотический зумер меняет масштаб каждый кадр --- разные исходные пиксели отображаются на разные экранные позиции. Вместо вычисления этих отображений в реальном времени скрипт Processing предвычислял каждое отображение и выдавал исходные файлы .a80, содержащие оптимизированные LDI-цепочки и инструкции LD.

Рабочий процесс: скрипт Processing вычисляет для каждого кадра, какой байт источника отображается на какой байт экрана. Он выдаёт исходный код Z80 --- последовательности `ld hl, source_addr` и `ldi` --- которые ассемблер (sjasmplus) собирает вместе с рукописным кодом движка. При выполнении движок просто вызывает предсгенерированный код для текущего кадра.

Это не «жульничество». Это фундаментальное понимание того, что разделение труда между временем компиляции и временем выполнения может полностью убрать ветвления, поиск и арифметику из внутреннего цикла. Скрипт Processing делает тяжёлую математику один раз, медленно, на современной машине. Z80 делает простую часть --- копирование байтов --- с максимально возможной скоростью.

### Рантайм: программа пишет машинный код во время выполнения

Иногда параметры меняются каждый кадр, и офлайн-генерации недостаточно. Процедура отображения сферы в Illusion от X-Trade (ENLiGHT'96) генерирует машинный код в буфер ОЗУ в реальном времени. Геометрия сферы меняется при вращении --- разным пикселям нужны разные расстояния пропуска. Перед каждым кадром движок эмитирует байты опкодов в буфер, а затем исполняет их:

```z80
; Runtime code generation (conceptual, simplified from Illusion)
; Generate an unrolled rendering loop for this frame's sphere slice

    ld   hl, code_buffer
    ld   de, sphere_table       ; per-frame skip distances

    ld   b, SPHERE_WIDTH
.gen_loop:
    ld   a, (de)                ; load skip distance for this pixel
    inc  de

    ; Emit: ld a, (hl) -- opcode $7E
    ld   (hl), $7E
    inc  hl

    ; Emit: add a, N   -- opcodes $C6, N
    ld   (hl), $C6
    inc  hl
    ld   (hl), a                ; the skip distance, as immediate operand
    inc  hl

    djnz .gen_loop

    ; Emit: ret -- opcode $C9
    ld   (hl), $C9

    ; Now execute the generated code
    call code_buffer
```

Сгенерированный код --- линейная последовательность без ветвлений, без поиска, без накладных расходов цикла, но это *разный код каждый кадр*. Вместо «if pixel_skip == 3 then...» по 12 тактов на ветвление ты эмитируешь точно нужные инструкции и исполняешь их без ветвлений.

**Когда генерировать код:** Если одни и те же операции выполняются каждый кадр и меняются только данные, самомодифицирующегося кода (подмены операндов) достаточно. Если меняется *структура* --- разное число итераций, разные последовательности инструкций --- генерируй код. Если вариации можно предвычислить на современной машине, предпочитай офлайн-генерацию: она отлаживаема, верифицируема и не стоит ничего в рантайме. Рантайм-генерация окупается, когда сгенерированный код выполняется гораздо чаще, чем стоит его генерация.

---

## RET-цепочки

### Превращение стека в таблицу диспетчеризации

В 2025 году DenisGrachev опубликовал на Hype технику, разработанную для его игры Dice Legends. Задача: отрисовка тайлового игрового поля требует вывода десятков тайлов за кадр. Наивный подход использует CALL:

```z80
; Naive approach: call each tile renderer
    call draw_tile_0
    call draw_tile_1
    call draw_tile_2
    ; ...
```

Каждый CALL стоит 17 тактов. Для игрового поля 30 x 18 (540 тайлов) это 9 180 тактов только на диспетчеризацию.

Идея DenisGrachev'а: установить SP на *список рендеринга* --- таблицу адресов --- и завершать каждую процедуру отрисовки тайла инструкцией RET. RET извлекает 2 байта из (SP) в PC. Если SP указывает на твой список рендеринга, RET не возвращается к вызывающему --- он переходит к следующей процедуре в списке.

```z80
; RET-chaining: zero call overhead
    di
    ld   (restore_sp + 1), sp   ; save SP
    ld   sp, render_list        ; SP points to our dispatch table

    ; "Call" the first tile routine by falling into it or using RET:
    ret                         ; pops first address from render_list

; Each tile routine ends with:
draw_tile_N:
    ; ... draw the tile ...
    ret                         ; pops NEXT address from render_list

; The render list is a sequence of addresses:
render_list:
    dw   draw_tile_42           ; first tile to draw
    dw   draw_tile_7            ; second tile
    dw   draw_tile_42           ; third tile (same tile type, different position)
    ; ... one entry per tile on screen ...
    dw   render_done            ; sentinel: address of cleanup code

render_done:
restore_sp:
    ld   sp, $0000              ; self-modified: restore SP
    ei
```

Теперь каждая диспетчеризация стоит 10 тактов (RET) вместо 17 (CALL). Для 540 тайлов: экономия 3 780 тактов. Но настоящий выигрыш --- бесплатная диспетчеризация: каждая запись может указывать на разную процедуру (широкий тайл, пустой тайл, анимированный тайл). Никакой таблицы переходов, никакого косвенного вызова. Список рендеринга *и есть* программа.

### Три стратегии для списка рендеринга

DenisGrachev исследовал три подхода к построению списка рендеринга:

1. **Карта как список рендеринга.** Тайловая карта сама является списком рендеринга: каждая ячейка содержит адрес процедуры отрисовки для данного типа тайла. Просто, но негибко --- смена тайла означает перезапись 2 байт в карте.

2. **Сегменты на основе адресов.** Экран делится на сегменты. Список рендеринга каждого сегмента --- блок адресов, скопированный из мастер-таблицы. Смена тайлов --- копирование нового блока адресов.

3. **Байтовый подход с 256-байтовыми таблицами поиска.** Каждый тип тайла --- один байт (индекс тайла). 256-байтовая таблица поиска отображает индексы тайлов в адреса процедур. Список рендеринга строится проходом по байтам тайловой карты с поиском каждого адреса. Этот подход DenisGrachev выбрал для Dice Legends.

Используя байтовый подход, он расширил игровое поле с 26 x 15 тайлов (предел предыдущего движка) до 30 x 18 тайлов, сохраняя целевую частоту кадров. Экономия от устранения накладных расходов CALL в сочетании с бесплатной диспетчеризацией освободила достаточно тактов для рендеринга на 40% больше тайлов.

### Компромиссы

Как и все стековые трюки, прерывания должны быть запрещены, пока SP перехвачен. Каждая процедура тайла должна быть самодостаточной --- заканчиваться RET и не использовать CALL, поскольку настоящий стек недоступен. На практике процедуры тайлов достаточно коротки, чтобы это не было ограничением.

---

## Врезка: «Код мёртв» (Introspec, 2015)

В январе 2015 года Introspec опубликовал на Hype короткое, провокационное эссе «Код мёртв» (Kod myortv). Аргумент проводит параллель с «Смертью автора» Ролана Барта: подобно тому как Барт утверждал, что смысл текста принадлежит читателю, а не автору, Introspec утверждает, что демо-код по-настоящему живёт только тогда, когда кто-то его читает --- в отладчике, в листинге дизассемблера, в исходниках, расшаренных на форуме.

Неудобная правда: современные демо потребляются как визуальный контент. Люди смотрят их на YouTube. Голосуют на Pouet по видеозаписям. Никто не видит внутренние циклы. Блестящая оптимизация, экономящая 3 такта на пиксель, невидима для 99% аудитории. «Писать код чисто ради него самого», --- написал Introspec, --- «потеряло актуальность».

И всё же.

Ты читаешь эту книгу. Мы открываем отладчик. Мы считаем такты. Мы заглядываем внутрь. Техники в этой главе --- не музейные экспонаты. Это живые инструменты, и то, что большинство людей их никогда не увидит, не умаляет их мастерства.

Эссе Introspec'а --- это вызов, а не капитуляция. После него он опубликовал одни из самых детальных технических анализов, которые ZX-сцена когда-либо видела --- включая разбор Illusion и бенчмарки компрессии, упоминаемые на протяжении всей этой книги. Код может быть мёртв для зрителя YouTube. Но для читателя с дизассемблером и пытливым умом он очень даже жив.

---

## Собираем всё вместе

Техники в этой главе не независимы. На практике они комбинируются:

- **Очистка экрана** сочетает *развёрнутые циклы* с *PUSH-трюками*: частично развёрнутый цикл из 16 PUSH за итерацию, с SP, перехваченным через *самомодифицирующийся код*.
- **Скомпилированные спрайты** сочетают *генерацию кода* (каждый спрайт компилируется в исполняемый код), *вывод через PUSH* (самый быстрый способ записать пиксельные данные) и *самомодификацию* (подмена экранных адресов каждый кадр).
- **Тайловые движки** сочетают *RET-цепочки* для диспетчеризации с *LDI-цепочками* внутри каждой процедуры тайла для быстрого копирования данных.
- **Хаотические зумеры** сочетают *офлайн-генерацию кода* (скрипты Processing, эмитирующие ассемблер) с *LDI-цепочками* (сгенерированный код --- в основном последовательности LDI) и *самомодификацией* (подмена адресов источника каждый кадр).

Общая нить: каждая техника убирает что-то из внутреннего цикла. Развёртка убирает счётчик цикла. Самомодификация убирает ветвления. PUSH убирает побайтовые накладные расходы. LDI-цепочки убирают штраф повтора LDIR. Генерация кода убирает само различие между кодом и данными. RET-цепочки убирают накладные расходы CALL.

Z80 работает на 3,5 МГц. У тебя 69 888 тактов на кадр. Каждый такт, который ты сэкономишь во внутреннем цикле --- это такт, который можно потратить на больше пикселей, больше цветов, больше движения. Инструментарий этой главы --- вот как туда добраться.

В последующих главах ты увидишь каждую из этих техник в работе в реальных демо --- текстурированная сфера Illusion, атрибутный туннель Eager, мультиколорный движок Old Tower. Цель этой главы --- дать тебе словарь. Теперь посмотрим, что мастера с ним построили.

---

## Попробуй сам

1. **Измерь разницу.** Возьми тестовую обвязку из главы 1 и измерь три версии заполнения 256 байт: (a) цикл `ld (hl), a : inc hl : djnz`, (b) полностью развёрнутая `ld (hl), a : inc hl` x 256, и (c) PUSH-заливка из `examples/push_fill.a80`. Сравни ширину бордюрных полос. Полоса PUSH-версии должна быть заметно короче.

2. **Построй самомодифицирующуюся очистку.** Напиши процедуру очистки экрана, принимающую паттерн заливки как параметр и подставляющую его в PUSH-цикл заливки через самомодифицирующийся код. Вызови её дважды с разными паттернами и наблюдай, как экран чередуется.

3. **Замерь LDI-цепочку.** Напиши 32-байтовое копирование с помощью LDIR и другое с помощью 32 x LDI. Измерь оба бордюрным методом. LDI-цепочка должна сэкономить 160 тактов --- это заметно, если запускать копирование в тесном цикле.

4. **Поэкспериментируй с точками входа.** Построй LDI-цепочку из 128 записей и маленькую процедуру, вычисляющую точку входа по значению в регистре A (0--128). Прыгай в цепочку в разных точках. Это упрощённая версия копирования переменной длины, используемого в настоящих хаотических зумерах.

> **Источники:** DenisGrachev «Tiles and RET» (Hype, 2025); Introspec «Making of Eager» (Hype, 2015); Introspec «Technical Analysis of Illusion» (Hype, 2017); Introspec «Код мёртв» (Hype, 2015)
