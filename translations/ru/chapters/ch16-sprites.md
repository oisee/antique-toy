# Глава 16: Быстрые спрайты

> *«Два цвета на ячейку? Ладно. Но эти два цвета будут двигаться.»*

---

Каждой игре нужны объекты, которые движутся. Пули, враги, персонаж игрока, взрывы. На любом железе с блиттером или GPU механика размещения маленького изображения в произвольной позиции на экране решена за тебя. На ZX Spectrum это твоя проблема.

У Spectrum нет аппаратных спрайтов, нет блиттера, нет сопроцессора. Каждый пиксель каждого спрайта размещается твоим Z80-кодом, по одной инструкции за раз, в ту самую экранную память, которую ULA читает 50 раз в секунду. А поскольку раскладка экранной памяти чересстрочная (Глава 2), «на одну строку вниз» означает `INC H` --- если только ты не пересекаешь границу знакоряда, и тогда это означает нечто значительно более уродливое.

В этой главе представлены шесть методов рисования спрайтов на Spectrum, от простейшей XOR-процедуры до скомпилированных спрайтов, которые работают на теоретически максимальной скорости железа. У каждого метода свои компромиссы. Мы также рассмотрим Agon Light 2, где VDP предоставляет аппаратные спрайты и вся проблема сводится к нескольким вызовам API.

---

## Метод 1: XOR-спрайты

### Простейший подход

XOR-рисование --- это минимально жизнеспособный спрайт. Он не требует данных маски, буфера сохранения фона и шага стирания. Ты рисуешь спрайт, применяя XOR его пиксельных данных к экрану, и стираешь его, применяя XOR тех же данных снова --- свойство XOR, что `A XOR B XOR B = A`, гарантирует восстановление фона.

Вот полная процедура 16x16 XOR-спрайта:

```z80
; Draw a 16x16 XOR sprite
; Input:  HL = screen address (top-left byte of sprite position)
;         IX = pointer to sprite data (32 bytes: 2 bytes x 16 rows)
;
xor_sprite_16x16:
    ld   b, 16              ;  7 T   16 rows

.row:
    ld   a, (ix+0)          ; 19 T   left byte of sprite row
    xor  (hl)               ;  7 T   combine with screen
    ld   (hl), a            ;  7 T   write back
    inc  l                  ;  4 T   move right one byte

    ld   a, (ix+1)          ; 19 T   right byte of sprite row
    xor  (hl)               ;  7 T
    ld   (hl), a            ;  7 T   write back
    dec  l                  ;  4 T   restore column

    inc  ix                 ; 10 T   \  advance sprite
    inc  ix                 ; 10 T   /  data pointer

    inc  h                  ;  4 T   move down one pixel row
    ld   a, h               ;  4 T   \
    and  7                  ;  7 T    | check character
    jr   nz, .no_boundary   ;  7 T   /  boundary crossing

    ; Character boundary: adjust HL
    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    jr   c, .no_fix         ;  7 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T
.no_fix:

.no_boundary:
    djnz .row               ; 13 T  (8 on last)
    ret                     ; 10 T
```

Внутренний цикл стоит 98 тактов на строку в обычном случае (без пересечения границы знакоряда) и до 131 такта на границах знакорядов. Для 16 строк: примерно 1 700 тактов на отрисовку. Чтобы стереть спрайт, вызови ту же процедуру снова с тем же адресом экрана --- XOR отменит сам себя.

Общая стоимость анимации одного XOR-спрайта: ~3 400 тактов на кадр (рисование + стирание).

### Когда XOR работает

XOR-спрайты идеальны для:

- **Курсоры.** Мигающий текстовый курсор, перекрестие, выделение. Всё, что лежит поверх статичного фона и не обязано выглядеть красиво.
- **Пули.** Снаряд 2x2 или 4x4, который движется достаточно быстро, чтобы визуальные глюки были незаметны.
- **Отладочные маркеры.** Отображение коллизионных рамок, позиций сущностей, узлов пути.

### Когда XOR не справляется

У XOR две серьёзные проблемы. Во-первых, визуальное качество низкое. Там, где спрайт накладывается на существующие данные экрана, пиксели инвертируются, а не замещаются. Белый спрайт, проходящий поверх белого текста, становится невидимым. Тщательно нарисованный персонаж превращается в мешанину инвертированных пикселей на детальном фоне.

Во-вторых, XOR не даёт тебе контроля над атрибутами. Цвет спрайта --- это любая комбинация ink/paper, которая оказалась в ячейках, на которые он попадает. Для пули или курсора это нормально. Для спрайта персонажа --- нет.

Несмотря на ограничения, XOR достаточно полезен, чтобы каждый игровой программист имел его в своём арсенале. Двадцать строк кода, ноль дополнительной памяти, и он просто работает.

---

## Метод 2: Маскированные спрайты OR+AND

### Отраслевой стандарт

Почти каждая коммерческая игра для Spectrum, выпущенная после 1984 года, использовала эту технику или её близкий вариант. Маскированный спрайт несёт два элемента данных для каждой строки: *маску* и *графику*. Маска определяет форму спрайта --- какие пиксели принадлежат спрайту, а какие прозрачны. Графика определяет внешний вид спрайта --- какие из формообразующих пикселей установлены.

Алгоритм рисования для каждого байта:

1. Прочитать байт экрана.
2. Применить AND с маской. Это очищает пиксели, где появится спрайт, оставляя остальной фон нетронутым.
3. Применить OR с графикой. Это впечатывает пиксели спрайта в очищенную область.

Результат: спрайт появляется на экране, а прозрачные области показывают фон сквозь себя. Никаких XOR-артефактов. Никаких инвертированных пикселей. Чистые, профессионально выглядящие спрайты.

### Формат данных

Для спрайта 16x16 каждая строка содержит 4 байта: маска-лево, графика-лево, маска-право, графика-право. Байт маски содержит `1` для прозрачных пикселей и `0` для непрозрачных (потому что AND с 1 сохраняет фон, AND с 0 очищает его). Общий размер данных на спрайт: 16 строк x 4 байта = 64 байта.

### Внутренний цикл

```z80
; Draw a 16x16 masked sprite (byte-aligned)
; Input:  HL = screen address
;         DE = pointer to sprite data
;              Format per row: mask_L, gfx_L, mask_R, gfx_R
;
masked_sprite_16x16:
    ld   b, 16              ;  7 T

.row:
    ; --- Left byte ---
    ld   a, (de)            ;  7 T   load mask
    and  (hl)               ;  7 T   clear sprite-shaped hole in background
    inc  de                 ;  6 T
    ld   c, a               ;  4 T   save masked background

    ld   a, (de)            ;  7 T   load graphic
    or   c                  ;  4 T   stamp sprite into hole
    ld   (hl), a            ;  7 T   write to screen
    inc  de                 ;  6 T
    inc  l                  ;  4 T   move right

    ; --- Right byte ---
    ld   a, (de)            ;  7 T   load mask
    and  (hl)               ;  7 T
    inc  de                 ;  6 T
    ld   c, a               ;  4 T

    ld   a, (de)            ;  7 T   load graphic
    or   c                  ;  4 T
    ld   (hl), a            ;  7 T
    inc  de                 ;  6 T
    dec  l                  ;  4 T   restore column

    ; --- Next row (DOWN_HL) ---
    inc  h                  ;  4 T
    ld   a, h               ;  4 T
    and  7                  ;  7 T
    jr   nz, .no_boundary   ;  7 T

    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    jr   c, .no_fix         ;  7 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T
.no_fix:
.no_boundary:
    djnz .row               ; 13 T
    ret                     ; 10 T
```

### Подсчёт тактов

Посчитаем обычный случай (без пересечения границы знакоряда):

| Секция | Инструкции | Такты |
|--------|-----------|-------|
| Левый байт: маска+рисование | `ld a,(de)` + `and (hl)` + `inc de` + `ld c,a` + `ld a,(de)` + `or c` + `ld (hl),a` + `inc de` + `inc l` | 52 |
| Правый байт: маска+рисование | Та же последовательность + `dec l` | 52 |
| Переход к строке | `inc h` + `ld a,h` + `and 7` + `jr nz` | 22 |
| Цикл | `djnz` | 13 |
| **Итого на строку** | | **139** |

Для 16 строк: 16 x 139 = **2 224 такта** (обычный случай). Прибавь накладные расходы на пересечение границ (~2 границы в 16-пиксельном спрайте): примерно **2 300 тактов** всего.

Но это только рисование спрайта. Тебе ещё нужно стереть спрайт предыдущего кадра, то есть восстановить фон --- мы рассмотрим это в Методе 6 (грязные прямоугольники). Пока заметь, что одно только рисование примерно на 35% дороже XOR, но визуальное качество несравнимо лучше.

### Побайтовое выравнивание и проблема сдвига

Процедура выше предполагает, что спрайт начинается на границе байта --- то есть координата x кратна 8. На практике игровые персонажи двигаются попиксельно, а не прыжками по 8 пикселей. Если позиция спрайта по x равна 53, он начинается в столбце байт 6, пиксель 5 внутри этого байта. Данные спрайта нужно сдвинуть вправо на 5 бит.

Можно сдвигать во время отрисовки:

```z80
; Shift mask and graphic right by A bits
; This adds significant cost per byte
    ld   a, (de)            ;  7 T   load mask byte
    ld   c, a               ;  4 T
    ld   a, b               ;  4 T   shift count
.shift:
    srl  c                  ;  8 T   \
    dec  a                  ;  4 T    | per-bit shift loop
    jr   nz, .shift         ; 12 T   /
```

Каждый бит сдвига стоит 24 такта на байт в этом наивном цикле. Для 5-битного сдвига на спрайте шириной 16 (3 байта на строку после сдвига, поскольку спрайт заползает в третий байт), ты получаешь дополнительные 5 x 24 x 3 = 360 тактов на строку --- удвоение стоимости отрисовки. Для 8 спрайтов при 25 fps один лишь этот сдвиг съедает примерно 46 000 тактов на кадр --- более 60% бюджета кадра.

Вот почему существуют предварительно сдвинутые спрайты.

---

## Метод 3: Предварительно сдвинутые спрайты

### Компромисс память-скорость

Идея проста: вместо сдвига данных спрайта во время отрисовки, предвычислить сдвинутые версии спрайта при загрузке (или при ассемблировании) и хранить их рядом с оригиналом. Когда нужно нарисовать спрайт со смещением 3 пикселя внутри байта, ты используешь версию, предварительно сдвинутую на 3 пикселя.

Есть две типичные конфигурации:

**4 сдвинутые копии** (сдвиг на 0, 2, 4, 6 пикселей). Это даёт горизонтальное разрешение в 2 пикселя. Спрайт привязывается к чётным пиксельным позициям, что часто приемлемо для игровых персонажей. Стоимость памяти: 4x от несдвинутых данных.

**8 сдвинутых копий** (сдвиг на 0, 1, 2, 3, 4, 5, 6, 7 пикселей). Полное попиксельное горизонтальное позиционирование. Стоимость памяти: 8x от несдвинутых данных. Но каждая сдвинутая версия также шире: спрайт шириной 16 пикселей, сдвинутый на 1--7 бит, заползает в третий столбец байтов, так что каждая сдвинутая копия занимает 3 байта в ширину вместо 2.

### Расчёт памяти

Для маскированного спрайта 16x16:

| Конфигурация | Байтов на строку | Строк | Копий | Итого |
|--------------|-----------------|-------|-------|-------|
| Только без сдвига | 4 (маска+графика x 2 байта) | 16 | 1 | 64 |
| 4 сдвига | 4 | 16 | 4 | 256 |
| 8 сдвигов (3 байта в ширину) | 6 (маска+графика x 3 байта) | 16 | 8 | 768 |

Для спрайта с 4 кадрами анимации умножь на 4:

| Конфигурация | На кадр | 4 кадра | 8 спрайтов |
|--------------|---------|---------|------------|
| Без сдвига + сдвиг в рантайме | 64 | 256 | 2 048 |
| 4 предсдвига | 256 | 1 024 | 8 192 |
| 8 предсдвигов | 768 | 3 072 | 24 576 |

24 КБ на 8 спрайтов с полным предварительным сдвигом. На 128K Spectrum это полтора банка памяти только под данные спрайтов. На 48K машине это почти половина доступной оперативной памяти. Компромисс жёсткий.

### Практический компромисс

Большинство игр используют 4 предварительно сдвинутые копии. Горизонтальное разрешение в 2 пикселя едва заметно в геймплее. Некоторые игры используют 8 копий для персонажа игрока (где плавность движения важнее всего) и 4 копии или даже сдвиг в рантайме для менее важных спрайтов.

Процедура отрисовки для предварительно сдвинутых спрайтов идентична процедуре побайтово выровненного маскированного спрайта --- ты просто выбираешь правильный набор предсдвинутых данных перед вызовом:

```z80
; Select pre-shifted sprite data
; Input:  A = x coordinate (0-255)
;         IY = base of pre-shift table (4 entries, each pointing to 16-row data)
; Output: DE = pointer to correct shifted sprite data
;
select_preshift:
    and  $06                ;  7 T   mask to shifts 0,2,4,6 (4 copies)
    ld   c, a               ;  4 T
    ld   b, 0               ;  7 T
    add  iy, bc             ; 15 T
    ld   e, (iy+0)          ; 19 T
    ld   d, (iy+1)          ; 19 T   DE = pointer to shifted data
    ret
```

Время отрисовки такое же, как в Методе 2: ~2 300 тактов. Но ты полностью устранил стоимость попиксельного сдвига. Цена заплачена памятью, а не тактами.

---

## Метод 4: Стековые спрайты (метод PUSH)

### Самый быстрый вывод на Z80

Мы видели в Главе 3, что PUSH записывает 2 байта за 11 тактов --- 5,5 такта на байт, самая быстрая операция записи на Z80. Стековые спрайты используют это для вывода спрайтов: устанавливают SP в нижнюю часть области спрайта на экране, загружают регистровые пары данными спрайта и выполняют PUSH на экран.

Техника требует критической подготовки:

1. **DI** --- запретить прерывания. Если прерывание сработает, пока SP указывает на экран, процессор запишет адрес возврата в твои пиксельные данные, повреждая изображение и, вероятно, вызывая сбой.
2. **Сохранить SP** --- спрятать настоящий указатель стека с помощью самомодифицирующегося кода (SMC).
3. **Установить SP** на нижний правый угол области спрайта на экране (PUSH работает вниз по адресам).
4. **Загрузить и PUSH** --- загрузить данные спрайта в регистровые пары и последовательно выполнить PUSH.
5. **Восстановить SP и EI** --- вернуть стек и снова разрешить прерывания.

### Внутренний цикл

Для спрайта 16x16 (2 байта в ширину) каждая строка --- это один PUSH:

```z80
; Stack sprite: 16x16, writes 2 bytes per row via PUSH
; Input:  screen_addr = pre-calculated bottom-right screen address
;         sprite_data = 32 bytes of pixel data (2 bytes x 16 rows,
;                       stored bottom-to-top because PUSH goes downward)
;
stack_sprite_16x16:
    di                           ;  4 T

    ld   (restore_sp + 1), sp    ; 20 T   save SP (self-mod)

    ld   sp, (screen_addr)       ; 20 T   SP = bottom of sprite on screen
    ld   ix, sprite_data         ; 14 T

    ; Row 15 (bottom) - each PUSH writes 2 bytes and decrements SP
    ld   h, (ix+31)              ; 19 T   \
    ld   l, (ix+30)              ; 19 T    | load bottom row
    push hl                      ; 11 T   /  write to screen

    ; But wait --- SP just decremented by 2, and the next row UP
    ; on the Spectrum screen is NOT at SP-2. The interleaved layout
    ; means "one row up" is at a completely different address.
    ;
    ; This is the fundamental problem with stack sprites on the
    ; Spectrum: the screen is not contiguous in memory.
```

И вот фундаментальная сложность. Метод PUSH --- это самая быстрая возможная запись, но чересстрочная раскладка экрана Spectrum означает, что последовательные строки экрана не находятся по последовательным адресам. SP уменьшается линейно, но строки экрана следуют паттерну `010TTSSS LLLCCCCC` из Главы 2.

### Как заставить работать: предвычисленная цепочка SP

Решение --- не полагаться на автоматическое уменьшение SP для навигации по строкам. Вместо этого ты явно устанавливаешь SP для каждой строки:

```z80
; Stack sprite: 16x16 with explicit SP per row
; This is the practical version --- each row gets SP set independently
;
stack_sprite_16x16:
    di                           ;  4 T
    ld   (restore_sp + 1), sp    ; 20 T

    ld   hl, (sprite_data + 0)   ; 16 T   row 0 data
    ld   sp, (row_addrs + 0)     ; 20 T   SP = screen addr for row 0 + 2
    push hl                      ; 11 T   write row 0
                                 ;        total per row: 47 T

    ld   hl, (sprite_data + 2)   ; 16 T   row 1 data
    ld   sp, (row_addrs + 2)     ; 20 T
    push hl                      ; 11 T
    ; ... repeated for all 16 rows ...

restore_sp:
    ld   sp, $0000               ; 10 T   self-modified
    ei                           ;  4 T
    ret                          ; 10 T
```

Каждая строка стоит 47 тактов. Для 16 строк: 16 x 47 = 752 такта, плюс настройка и завершение (~60 тактов). Итого: примерно **810 тактов**.

Сравни с ~2 300 тактами Метода 2. Стековый спрайт почти в 3 раза быстрее --- но он идёт с ограничениями.

### Цена

**Нет маскирования.** PUSH записывает 2 байта безусловно. Он перезаписывает всё, что было на экране. Нет шага AND-с-маской. Спрайт всегда является сплошным прямоугольником --- любые «прозрачные» пиксели покажут цвет фона спрайта, а не фон игры. Для спрайтов на однотонном фоне (многие классические игры для Spectrum использовали чёрный) это нормально. Для спрайтов поверх детального фона --- нет.

**Предвычисленные адреса строк.** Тебе нужна таблица экранных адресов для всех 16 строк спрайта, обновляемая при каждом перемещении спрайта. Это стоимость подготовки на каждый кадр --- не огромная, но и не бесплатная.

**Прерывания отключены.** Для 8 спрайтов примерно 6 500 тактов с отключёнными прерываниями. Если музыка работает через IM2, планируй отрисовку спрайтов сразу после HALT.

**Данные должны храниться в порядке PUSH.** Поскольку PUSH записывает старший байт по адресу (SP-1), а младший по адресу (SP-2), и SP уменьшается *перед* записью, раскладка данных требует внимания. Данные спрайта хранятся в обратном порядке: правый байт строки становится младшим байтом, загружаемым в регистр, левый --- старшим байтом.

### Когда использовать стековые спрайты

Стековые спрайты --- оружие выбора, когда нужна чистая скорость, а фон достаточно прост, чтобы перезапись полными прямоугольниками была приемлема. Аркадные игры с чёрным фоном, оверлеи очков и быстро движущиеся объекты --- естественное применение. Метод PUSH также используется для очистки экрана и массового вывода данных (Глава 3), где ограничение «нет маскирования» не имеет значения.

---

## Метод 5: Скомпилированные спрайты

### Спрайт --- это код

Скомпилированный спрайт доводит философию генерации кода из Главы 3 до логического завершения. Вместо таблицы данных, интерпретируемой процедурой отрисовки, спрайт *сам является* исполняемой процедурой. Каждый видимый пиксельный байт спрайта становится инструкцией `LD (HL), n`. Прозрачные участки становятся инструкциями `INC L` или `INC H` для пропуска. Весь спрайт отрисовывается вызовом `CALL`.

### Как это работает

Рассмотрим простой спрайт 8x8 с некоторыми прозрачными пикселями. В маскированном спрайте ты бы хранил пары маска+графика и выполнял цикл AND/OR. В скомпилированном спрайте ты генерируешь Z80-инструкции при ассемблировании (или при загрузке):

```z80
; Compiled sprite for a small arrow shape
; Input:  HL = screen address of top-left byte
; The sprite draws itself.
;
compiled_arrow:
    ; Row 0: one pixel byte
    ld   (hl), $18          ; 10 T   ..##....
    inc  h                  ;  4 T   next row

    ; Row 1: one pixel byte
    ld   (hl), $3C          ; 10 T   ..####..
    inc  h                  ;  4 T

    ; Row 2: one pixel byte
    ld   (hl), $7E          ; 10 T   .######.
    inc  h                  ;  4 T

    ; Row 3: one pixel byte
    ld   (hl), $FF          ; 10 T   ########
    inc  h                  ;  4 T

    ; Row 4: one pixel byte
    ld   (hl), $3C          ; 10 T   ..####..
    inc  h                  ;  4 T

    ; Row 5: one pixel byte
    ld   (hl), $3C          ; 10 T   ..####..
    inc  h                  ;  4 T

    ; Row 6: one pixel byte
    ld   (hl), $3C          ; 10 T   ..####..
    inc  h                  ;  4 T

    ; Row 7: one pixel byte
    ld   (hl), $3C          ; 10 T   ..####..

    ret                     ; 10 T

    ; Total: 8 x (10 + 4) + 10 = 122 T-states
    ; Compare: masked routine for 8x8 = ~600 T-states
```

Это 122 такта для спрайта 8x8. Маскированный подход занимает примерно в 5 раз больше.

### Скомпилированный спрайт 16x16

Для более широкого спрайта каждая строка может содержать несколько инструкций `LD (HL), n`, разделённых `INC L`:

```z80
; Compiled sprite: 16x16 (2 bytes wide)
; Input:  HL = screen address of top-left
;
compiled_sprite_16x16:
    ; Row 0
    ld   (hl), $3C          ; 10 T   left byte
    inc  l                  ;  4 T
    ld   (hl), $0F          ; 10 T   right byte
    dec  l                  ;  4 T   restore column
    inc  h                  ;  4 T   next row
                            ;        row cost: 32 T

    ; Row 1
    ld   (hl), $7E          ; 10 T
    inc  l                  ;  4 T
    ld   (hl), $1F          ; 10 T
    dec  l                  ;  4 T
    inc  h                  ;  4 T
                            ;        row cost: 32 T

    ; ... rows 2-6 similar ...

    ; Row 7 (character boundary)
    ld   (hl), $FF          ; 10 T
    inc  l                  ;  4 T
    ld   (hl), $FF          ; 10 T
    dec  l                  ;  4 T
    ; Character boundary crossing:
    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T   boundary cost: 30 T
    inc  h                  ;  4 T
                            ;        row cost: 62 T

    ; Rows 8-15 similar to 0-6, with another boundary at row 15
    ; ...
    ret                     ; 10 T
```

На строку (обычный случай): 32 такта. Для 16 строк с 1--2 пересечениями границ: примерно **570 тактов**.

### Компромиссы

**Достоинства:**
- Самый быстрый метод спрайтов с поддержкой маскирования. Ты можешь встроить AND-маскирование в скомпилированные спрайты --- каждый байт становится `ld a,(hl)` / `and mask` / `or graphic` / `ld (hl),a` вместо простого `ld (hl),n`. Даже с маскированием скомпилированный подход избегает накладных расходов на цикл, управление указателями данных и подсчёт строк.
- Нулевые накладные расходы на цикл. Код полностью линейный.
- Прозрачные области ничего не стоят, если они занимают целые байты --- ты просто пропускаешь их с помощью `INC L` или `INC H`.

**Недостатки:**
- **Размер кода.** Каждый видимый байт занимает 2 байта кода (`LD (HL), n`). С маскированием (4 инструкции на байт) размер кода примерно утраивается. Полный набор из 8 предсдвинутых скомпилированных спрайтов с 4 кадрами анимации может достигать нескольких килобайт на спрайт.
- **Нет изменения данных в рантайме.** Значения пикселей вкомпилированы в операнды инструкций. Анимация требует отдельной скомпилированной процедуры для каждого кадра.
- **Обработка границ вкомпилирована.** Пересечения границ знакорядов находятся на фиксированных позициях, поэтому спрайт должен поддерживать согласованное вертикальное выравнивание, или тебе нужны несколько скомпилированных версий.

### Скомпилированные спрайты с маскированием

Для спрайтов, которые должны появляться поверх детального фона, ты компилируешь маску в код:

```z80
; Compiled sprite with masking: one byte
; Instead of ld (hl),n, we do:
    ld   a, (hl)            ;  7 T   read screen
    and  $C3                ;  7 T   mask: clear sprite pixels
    or   $3C                ;  7 T   graphic: stamp sprite
    ld   (hl), a            ;  7 T   write back
                            ;        per-byte cost: 28 T
```

28 тактов на байт против 52 тактов на байт в универсальной маскированной процедуре (Метод 2). Экономия достигается за счёт устранения управления указателями, подсчёта циклов и загрузки данных --- значения маски и графики являются непосредственными операндами.

Для 16 строк x 2 байта: 16 x (28 + 28 + 4 + 4 + 4) = 16 x 68 = **1 088 тактов**. Это примерно вдвое дешевле универсальной маскированной процедуры, с полной поддержкой прозрачности.

| Метод | Стоимость отрисовки 16x16 | Маскирование | Примечания |
|-------|--------------------------|--------------|------------|
| XOR-спрайт | ~1 700 T | Нет | Рисование + стирание = ~3 400 T |
| Маскированный OR+AND | ~2 300 T | Да | Стандартный подход |
| Предсдвинутый маскированный | ~2 300 T | Да | Нет стоимости сдвига; 4--8x память |
| Стековый спрайт (PUSH) | ~810 T | Нет | Требуется DI; сплошной прямоугольник |
| Скомпилированный (без маски) | ~570 T | Нет | Код = спрайт; большой объём |
| Скомпилированный (с маской) | ~1 088 T | Да | Лучшее из обоих; наибольший объём |

![Sprite rendering methods comparison](illustrations/output/ch16_sprite_methods.png)

---

## Метод 6: Грязные прямоугольники

### Проблема фона

Методы 1--5 решают вопрос *размещения* пикселей на экране. Но спрайты двигаются. Каждый кадр спрайт оказывается в новой позиции. Прежде чем нарисовать спрайт на новой позиции, ты должен стереть его со старой --- или экран заполнится призрачными послеобразами.

Метод XOR справляется с этим неявно: применяешь XOR на старой позиции для стирания, XOR на новой для рисования. Но для всех остальных методов тебе нужен способ восстановить фон.

Есть три распространённых подхода:

**Полная очистка экрана.** Стирай пиксельную область каждый кадр (~36 000 тактов с PUSH из Главы 3), затем перерисовывай всё. Осуществимо, но дорого.

**Сохранение/восстановление фона.** Перед рисованием каждого спрайта сохрани экран под ним. Для стирания скопируй сохранённый буфер обратно. Стоимость O(размер_спрайта) на спрайт, а не O(размер_экрана).

**Отслеживание грязных прямоугольников.** Усовершенствование: отслеживай, какие прямоугольники были изменены, восстанавливай только их, затем рисуй новые спрайты (сохраняя новый фон по ходу).

### Цикл сохранения/восстановления

Практический подход для большинства игр на Spectrum --- посправтовое сохранение/восстановление фона. Вот цикл для одного спрайта на кадр:

1. **Восстановить** фон, сохранённый в прошлом кадре (скопировать сохранённый буфер на старую позицию экрана).
2. **Сохранить** фон на новой позиции экрана (скопировать экран в буфер сохранения).
3. **Нарисовать** спрайт на новой позиции.

Порядок важен. Ты восстанавливаешь перед сохранением, чтобы не перезаписать новый сохранённый фон устаревшими данными, если спрайты перекрываются.

### Процедура сохранения/восстановления

Для спрайта 16x16 (2 байта в ширину, 16 строк) буфер фона составляет 32 байта:

```z80
; Save background behind a 16x16 sprite
; Input:  HL = screen address (top-left)
;         DE = pointer to save buffer (32 bytes)
;
save_background_16x16:
    ld   b, 16              ;  7 T

.row:
    ld   a, (hl)            ;  7 T   read left byte
    ld   (de), a            ;  7 T   save it
    inc  de                 ;  6 T
    inc  l                  ;  4 T

    ld   a, (hl)            ;  7 T   read right byte
    ld   (de), a            ;  7 T   save it
    inc  de                 ;  6 T
    dec  l                  ;  4 T

    ; DOWN_HL (same as sprite routines)
    inc  h                  ;  4 T
    ld   a, h               ;  4 T
    and  7                  ;  7 T
    jr   nz, .no_boundary   ;  7 T
    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    jr   c, .no_fix         ;  7 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T
.no_fix:
.no_boundary:
    djnz .row               ; 13 T
    ret                     ; 10 T
```

Процедура восстановления идентична, только источник и назначение поменяны местами: чтение из буфера, запись на экран. Каждая процедура занимает примерно **1 400 тактов** для 16 строк.

### Полный бюджет кадра

Рассчитаем стоимость на кадр для 8 анимированных спрайтов 16x16 с маскированием OR+AND и сохранением/восстановлением фона:

| Операция | На спрайт | 8 спрайтов |
|----------|----------|------------|
| Восстановление фона | ~1 400 T | 11 200 T |
| Сохранение нового фона | ~1 400 T | 11 200 T |
| Отрисовка спрайта (маскированная) | ~2 300 T | 18 400 T |
| **Итого** | **~5 100 T** | **~40 800 T** |

На Pentagon (71 680 тактов на кадр): 40 800 T оставляют **30 880 T** на игровую логику, обработку ввода, музыку и всё остальное. При 25 fps бюджет вдвое больше (два кадра на обновление), давая ~103 000 тактов для неспрайтовой работы. Для игры это комфортно.

Если использовать скомпилированные маскированные спрайты:

| Операция | На спрайт | 8 спрайтов |
|----------|----------|------------|
| Восстановление фона | ~1 400 T | 11 200 T |
| Сохранение нового фона | ~1 400 T | 11 200 T |
| Отрисовка спрайта (скомпилированная, маскированная) | ~1 088 T | 8 704 T |
| **Итого** | **~3 888 T** | **~31 104 T** |

Это экономит почти 10 000 тактов на кадр --- ощутимое улучшение, которое даёт больше места для игровой логики или больше спрайтов.

### Порядок отрисовки и перекрытие

Когда несколько спрайтов перекрываются, порядок отрисовки важен. Простейший корректный подход:

1. Восстановить все фоны (в обратном порядке отрисовки, чтобы корректно обработать перекрытия).
2. Сохранить все новые фоны.
3. Нарисовать все спрайты.

Восстановление в обратном порядке гарантирует, что когда два спрайта перекрывались в прошлом кадре, буфер сохранения более раннего спрайта (который захватил чистый фон) восстанавливается последним, корректно очищая область перекрытия.

Логика: если спрайт A был нарисован поверх спрайта B, буфер сохранения A содержит пиксели B. Восстановление A первым открывает B, затем восстановление B показывает чистый фон. Восстановление в прямом порядке оставляет артефакты. Многие игры обходят это, предотвращая перекрытие или мирясь с мелкими глюками.

---

## Оптимизация внутренних циклов

### Устранение управления указателями

Процедуры выше тратят значительное время на управление указателями: `inc de`, `inc l`, `dec l` и логика пересечения границ DOWN_HL. Несколько оптимизаций могут снизить эти накладные расходы.

**Используй LDI вместо ручного копирования.** Для операций сохранения/восстановления LDI-цепочка (Глава 3) копирует байт из (HL) в (DE), инкрементирует оба и декрементирует BC --- всё за 16 тактов. По сравнению с нашими ручными `ld a,(hl)` + `ld (de),a` + `inc de` + `inc l` за 24 такта, LDI экономит 8 тактов на байт. Для спрайта 16x16 (32 байта) это 256 тактов экономии на операцию сохранения или восстановления.

```z80
; Save background using LDI (partial unroll, 2 bytes per row)
; HL = screen address, DE = save buffer
;
save_bg_ldi:
    ld   b, 16              ;  7 T
.row:
    ldi                     ; 16 T   copy left byte
    ldi                     ; 16 T   copy right byte
    dec  l                  ;  4 T   \
    dec  l                  ;  4 T   /  LDI advanced L by 2, undo it

    ; DOWN_HL
    inc  h                  ;  4 T
    ld   a, h               ;  4 T
    and  7                  ;  7 T
    jr   nz, .no_boundary   ;  7 T
    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    jr   c, .no_fix         ;  7 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T
.no_fix:
.no_boundary:
    djnz .row               ; 13 T
    ret                     ; 10 T
```

Стоимость строки в обычном случае: 16 + 16 + 4 + 4 + 4 + 4 + 7 + 7 + 13 = **75 тактов**. Для 16 строк: примерно **1 200 тактов** --- стоящее улучшение по сравнению с 1 400 тактами ручного подхода.

**Объедини сохранение и рисование.** Вместо сохранения-затем-рисования двумя отдельными проходами по области экрана, объедини их в один проход: для каждого байта прочитай экран (сохрани), затем запиши данные спрайта. Это вдвое сокращает количество операций продвижения по строкам и устраняет один полный обход DOWN_HL:

```z80
; Combined save-and-draw for masked sprite
; HL = screen address, DE = sprite data (mask, gfx pairs)
; IX = save buffer
;
save_and_draw_16x16:
    ld   b, 16              ;  7 T
.row:
    ; Left byte
    ld   a, (hl)            ;  7 T   read screen (for saving)
    ld   (ix+0), a          ; 19 T   save to buffer
    ld   c, a               ;  4 T

    ld   a, (de)            ;  7 T   load mask
    and  c                  ;  4 T   mask background
    inc  de                 ;  6 T
    ld   c, a               ;  4 T

    ld   a, (de)            ;  7 T   load graphic
    or   c                  ;  4 T   stamp sprite
    ld   (hl), a            ;  7 T   write to screen
    inc  de                 ;  6 T
    inc  l                  ;  4 T

    ; Right byte (similar)
    ld   a, (hl)            ;  7 T
    ld   (ix+1), a          ; 19 T
    ld   c, a               ;  4 T

    ld   a, (de)            ;  7 T
    and  c                  ;  4 T
    inc  de                 ;  6 T
    ld   c, a               ;  4 T

    ld   a, (de)            ;  7 T
    or   c                  ;  4 T
    ld   (hl), a            ;  7 T
    inc  de                 ;  6 T
    dec  l                  ;  4 T

    ; Advance IX and HL
    inc  ix                 ; 10 T
    inc  ix                 ; 10 T

    inc  h                  ;  4 T
    ld   a, h               ;  4 T
    and  7                  ;  7 T
    jr   nz, .no_boundary   ;  7 T
    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    jr   c, .no_fix         ;  7 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T
.no_fix:
.no_boundary:
    djnz .row               ; 13 T
    ret                     ; 10 T
```

Это объединяет сохранение и рисование в один проход. Стоимость на строку (обычный случай): примерно **200 тактов**. Для 16 строк: примерно **3 300 тактов** --- по сравнению с раздельными сохранением (~1 200 T) + рисованием (~2 300 T) = 3 500 тактов. Экономия скромная (~200 T на спрайт), но она накапливается по 8 спрайтам.

Для максимальной производительности развёрнутый цикл полностью: никакого DJNZ, явный код для каждой строки с вкомпилированными пересечениями границ на строках 7 и 15. Это устраняет накладные расходы на цикл и проверку границ, снижая итого до примерно **2 780 тактов** ценой ~300 байт кода на процедуру спрайта.

---

## Agon Light 2: аппаратные VDP-спрайты

Agon Light 2 использует принципиально другой подход. eZ80 общается с VDP (Video Display Processor) на ESP32, который обрабатывает всю отрисовку спрайтов аппаратно. Процессор загружает битмапы, затем отдаёт команды на позиционирование, показ, скрытие и анимацию спрайтов. VDP компонует спрайты во время собственного прохода рендеринга без нагрузки на процессор за каждый пиксель. Поддерживается до 256 слотов спрайтов.

Последовательность VDU-команд для определения и активации спрайта:

```
VDU 23, 27, 0, n                     ; Select sprite n
VDU 23, 27, 1, w, h, format          ; Create sprite: w x h pixels
; ... upload bitmap data ...
VDU 23, 27, 4, x_lo, x_hi, y_lo, y_hi  ; Set position
VDU 23, 27, 11                        ; Show sprite
```

На ассемблере eZ80 эти команды отправляются как последовательности байтов в VDP через `RST $10` (вывод символа MOS). Каждая команда --- это последовательность пар `ld a, byte : rst $10`.

### Перемещение спрайта

После определения перемещение спрайта --- это просто команда позиционирования:

```z80
; Agon: Move sprite 0 to (x, y)
; Input: BC = x, DE = y
;
move_sprite:
    ld   a, 23 : rst $10
    ld   a, 27 : rst $10
    ld   a, 4  : rst $10    ; move command
    ld   a, 0  : rst $10    ; sprite number

    ld   a, c  : rst $10    ; x low
    ld   a, b  : rst $10    ; x high
    ld   a, e  : rst $10    ; y low
    ld   a, d  : rst $10    ; y high
    ret
```

Стоимость для процессора при перемещении спрайта --- лишь отправка ~10 байт по последовательному интерфейсу. При скорости 1 152 000 бод каждый байт занимает примерно 9 микросекунд, так что перемещение одного спрайта занимает примерно 90 микросекунд --- около 1 660 тактов при 18,432 МГц. Перемещение 8 спрайтов: ~13 000 тактов. VDP берёт на себя всю пиксельную композицию, прозрачность и управление фоном аппаратно.

### Ограничения по строкам развёртки

У VDP есть практическое ограничение на количество пикселей спрайтов на одну горизонтальную строку развёртки. Когда слишком много спрайтов перекрываются на одной линии, некоторые могут мерцать --- то же явление, что наблюдается на NES и Master System. Разумная рекомендация --- 8--12 спрайтов 16x16 на строку развёртки. Для 8 спрайтов, распределённых по экрану, ты вряд ли столкнёшься с этим ограничением.

### Компромисс

Agon устраняет всю проблему отрисовки спрайтов. Никакого сохранения/восстановления, никакого маскирования, никакой навигации по чересстрочному экрану. Цена --- абстракция: никаких попиксельных трюков, никаких креативных манипуляций с данными и зависимость от возможностей прошивки VDP. Spectrum заставляет тебя строить всё с нуля. Agon освобождает тебя, чтобы потратить усилия на дизайн игры.

---

## Практика: 8 анимированных спрайтов при 25 fps

### Реализация на Spectrum

Наша цель: 8 анимированных спрайтов 16x16 с сохранением/восстановлением фона, работающих при 25 fps (обновление каждые 2 кадра) на ZX Spectrum 128K.

**Архитектура:**

Каждый спрайт имеет структуру данных:

```z80
; Sprite structure (12 bytes per sprite)
;
SPRITE_X        EQU 0       ; x coordinate (0-255)
SPRITE_Y        EQU 1       ; y coordinate (0-191)
SPRITE_OLD_X    EQU 2       ; previous x (for erase)
SPRITE_OLD_Y    EQU 3       ; previous y
SPRITE_FRAME    EQU 4       ; current animation frame (0-3)
SPRITE_DIR      EQU 5       ; direction / flags
SPRITE_DX       EQU 6       ; x velocity (signed)
SPRITE_DY       EQU 7       ; y velocity (signed)
SPRITE_GFX      EQU 8       ; pointer to sprite graphic data (2 bytes)
SPRITE_SAVE     EQU 10      ; pointer to background save buffer (2 bytes)

SPRITE_SIZE     EQU 12
NUM_SPRITES     EQU 8
```

**Цикл кадра (каждые 2 VBLANK):**

```z80
main_loop:
    halt                    ; wait for VBLANK
    halt                    ; wait again (25 fps = every 2nd frame)

    ; Phase 1: Restore all backgrounds (reverse order)
    ld   ix, sprites + (NUM_SPRITES - 1) * SPRITE_SIZE
    ld   b, NUM_SPRITES
.restore_loop:
    call restore_sprite_bg
    ld   de, -SPRITE_SIZE
    add  ix, de
    djnz .restore_loop

    ; Phase 2: Update positions
    ld   ix, sprites
    ld   b, NUM_SPRITES
.update_loop:
    call update_sprite_position
    ld   de, SPRITE_SIZE
    add  ix, de
    djnz .update_loop

    ; Phase 3: Save backgrounds and draw (forward order)
    ld   ix, sprites
    ld   b, NUM_SPRITES
.draw_loop:
    call save_and_draw_sprite
    ld   de, SPRITE_SIZE
    add  ix, de
    djnz .draw_loop

    ; Phase 4: Game logic, input, sound
    call process_input
    call update_game_logic
    call update_sound

    jr   main_loop
```

**Бюджет тактов:**

| Фаза | Стоимость |
|------|-----------|
| 2 x HALT | 0 T (ожидание) |
| Восстановление 8 фонов | 8 x 1 200 = 9 600 T |
| Обновление 8 позиций | 8 x 200 = 1 600 T |
| Сохранение + отрисовка 8 спрайтов | 8 x 3 300 = 26 400 T |
| Накладные расходы на циклы | ~2 000 T |
| **Итого работа со спрайтами** | **~39 600 T** |
| **Доступно для игровой логики** | **~103 000 T** |

При двухкадровом бюджете в 143 360 тактов (2 x 71 680 на Pentagon) у нас остаётся примерно 103 000 тактов на игровую логику, ввод и звук. Это щедро --- достаточно для ИИ сущностей (Глава 19), обнаружения столкновений с тайлами, воспроизведения музыки и обработки ввода.

Перед рисованием каждого спрайта рассчитай адрес экрана из (x, y) с помощью процедуры из Главы 2 и выбери правильные предсдвинутые данные на основе `x AND $06` (для 4 уровней сдвига). Логика выбора предсдвига из Метода 3 применяется напрямую.

### Реализация на Agon

На Agon главный цикл становится тривиально простым: ждёшь VSync, обновляешь позиции, отправляешь команды перемещения `VDU 23,27,4` для каждого спрайта и переходишь к игровой логике. Никакого сохранения/восстановления, никакого маскирования, никаких вычислений адресов экрана, никакой навигации по чересстрочным строкам. VDP берёт на себя всё.

Контраст поучителен. На Spectrum рендеринг спрайтов --- доминирующая статья расходов: 40 000 тактов на кадр, где каждый сэкономленный такт во внутреннем цикле напрямую конвертируется в больше спрайтов или больше игровой логики. На Agon рендеринг спрайтов фактически бесплатен с точки зрения процессора, и твои инженерные усилия уходят в дизайн игры, а не перемещение пикселей. Оба подхода по-своему удовлетворяют.

---

## Итого

- **XOR-спрайты** --- простейший метод: XOR для рисования, повторный XOR для стирания. ~1 700 тактов для отрисовки спрайта 16x16. Нет маски, не нужно сохранение фона. Визуальное качество низкое (инвертированные пиксели поверх детального фона). Хороши для курсоров, пуль и отладочных маркеров.

- **Маскированные спрайты OR+AND** --- отраслевой стандарт. Каждый байт проходит через последовательность AND-с-маской, OR-с-графикой, которая даёт чистую прозрачность. ~2 300 тактов для спрайта 16x16. Именно это использовало большинство коммерческих игр для Spectrum.

- **Предварительно сдвинутые спрайты** устраняют стоимость попиксельного сдвига, храня 4 или 8 предвычисленных сдвинутых копий данных спрайта. Время отрисовки такое же, как у маскированной процедуры. Стоимость памяти масштабируется от 4x (4 сдвига, разрешение 2 пикселя) до 8x (8 сдвигов, полное пиксельное разрешение). Стандартный компромисс память-скорость.

- **Стековые спрайты (метод PUSH)** --- самый быстрый необработанный вывод: ~810 тактов для спрайта 16x16. Требуют DI/EI, явного управления SP для каждой строки и создают сплошные прямоугольники (нет маскирования). Лучше всего подходят для игр с простым фоном.

- **Скомпилированные спрайты** превращают спрайт в исполняемый код. Каждый пиксельный байт становится инструкцией `LD (HL),n`. ~570 тактов без маскирования, ~1 088 тактов с вкомпилированным маскированием. Самый быстрый маскированный метод, ценой большого размера кода. Анимация требует отдельных скомпилированных процедур для каждого кадра.

- **Грязные прямоугольники** с сохранением/восстановлением фона --- стандартная техника для анимации спрайтов. Сохрани фон перед рисованием, восстанови его перед рисованием следующего кадра. Восстанавливай в обратном порядке отрисовки для корректной обработки перекрывающихся спрайтов. Объединённый подход сохранения-и-рисования снижает стоимость на спрайт до ~3 300 тактов.

- **8 спрайтов при 25 fps** на Spectrum 128K стоят примерно 40 000 тактов на цикл обновления (каждые 2 кадра), оставляя ~103 000 тактов на игровую логику --- комфортный бюджет для настоящей игры.

- **Аппаратные спрайты Agon Light 2** устраняют всю проблему рендеринга. Определи спрайты один раз, перемещай их VDU-командами. Нагрузка на процессор ничтожна. Компромисс --- абстракция: ты получаешь производительность, но теряешь возможность попиксельных трюков с данными спрайтов.

- Выбор метода спрайтов зависит от требований твоей игры: сложность фона, количество спрайтов, потребности анимации, доступная память и целевая частота кадров. Большинство игр для Spectrum используют маскирование OR+AND с предсдвигом и грязными прямоугольниками. Демосценовые продукции и игры, критичные к производительности, прибегают к скомпилированным спрайтам или методу PUSH.

---

## Попробуй сам

1. **Реализуй все шесть методов.** Возьми простой дизайн спрайта 8x8 и реализуй версии XOR, маскированную и скомпилированную. Используй тестовую обвязку с цветом бордюра из Главы 1, чтобы сравнить стоимость отрисовки. Разница должна быть отчётливо видна.

2. **Генератор предсдвигов.** Напиши утилиту (на Python, Processing или Z80 ассемблере), которая принимает маскированный спрайт и генерирует 4 предварительно сдвинутые версии. Сохрани их в памяти и напиши процедуру отрисовки, которая выбирает правильную версию на основе x-координаты.

3. **Демо сохранения/восстановления фона.** Размести маскированный спрайт на узорчатом фоне (шахматная доска из практики Главы 2). Перемещай спрайт с клавиатуры. Убедись, что фон корректно восстанавливается при движении спрайта. Затем добавь второй спрайт и проверь, что области перекрытия обрабатываются корректно.

4. **Испытание 8 спрайтов.** Реализуй полную систему из 8 спрайтов с сохранением/восстановлением фона и анимацией. Начни с маскированного подхода OR+AND. Измерь бюджет тактов цветами бордюра. Если останется запас, переключись на скомпилированные маскированные спрайты и измерь улучшение.

5. **Сравнение с Agon.** Если у тебя есть Agon Light 2, реализуй ту же анимацию 8 спрайтов с использованием аппаратных VDP-спрайтов. Сравни сложность кода и бюджет процессора, доступный для игровой логики.

---

> **Источники:** фольклор программирования графики на Spectrum, широко документированный в ZX-сообществе; Глава 3 этой книги для PUSH-трюков и самомодифицирующегося кода; Глава 2 для раскладки экрана и DOWN_HL; документация VDP Agon Light 2 (прошивка Quark, FabGL sprite API); главы по разработке игр из *book-plan.md* для фреймворка из шести методов и практических целей.
