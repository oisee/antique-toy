# Глава 4: Математика, которая реально нужна

> *«Прочитайте учебник математики — производные, интегралы. Они вам понадобятся.»*
> -- Dark, Spectrum Expert #01 (1997)

В 1997 году подросток в Санкт-Петербурге сел писать журнальную статью об умножении. Не о том, которому учат в школе, — а о том, которое заставляет каркасный куб вращаться на ZX Spectrum со скоростью 50 кадров в секунду. Его звали Dark, он кодил в группе X-Trade, и его демо *Illusion* уже заняло первое место на ENLiGHT'96. Теперь он писал *Spectrum Expert*, электронный журнал, распространяемый на дискетах, и собирался подробно объяснить, как работают его алгоритмы.

Всё, что следует далее, взято непосредственно из статьи Dark'а «Алгоритмы программирования» в Spectrum Expert #01. Это подпрограммы, которые приводили в движение *Illusion* — то самое умножение, что вращало вершины, та самая таблица синусов, что управляла ротозумером, тот самый рисовальщик линий, что рендерил каркасные фигуры на полной частоте кадров. Когда Introspec двадцать лет спустя дизассемблировал *Illusion* в блоге Hype, он обнаружил именно эти алгоритмы в работе внутри бинарника.

---

## Умножение на Z80

У Z80 нет инструкции умножения. Каждый раз, когда тебе нужно A умножить на B — для матриц вращения, перспективной проекции, текстурного маппинга — приходится синтезировать умножение из сдвигов и сложений. Dark представляет два метода и с характерной честностью рассуждает о компромиссе между ними.

### Метод 1: Сдвиг-и-сложение от LSB

Классический подход. Проходим по битам множителя от младшего к старшему. Для каждого установленного бита прибавляем множимое к аккумулятору. После каждого бита сдвигаем аккумулятор вправо. После восьми итераций аккумулятор содержит полное произведение.

Вот беззнаковое умножение 8x8 от Dark'а. Вход: B умножить на C. Результат в A (старший байт) и C (младший байт):

```z80
; MULU112 -- 8x8 unsigned multiply
; Input:  B = multiplicand, C = multiplier
; Output: A:C = B * C (16-bit result, A=high, C=low)
; Cost:   196-204 T-states (Pentagon)
;
; From Dark / X-Trade, Spectrum Expert #01 (1997)

mulu112:
    ld   a, 0           ; clear accumulator (high byte of result)
    ld   d, 8           ; 8 bits to process

.loop:
    rr   c              ; shift LSB of multiplier into carry
    jr   nc, .noadd     ; if bit was 0, skip addition
    add  a, b           ; add multiplicand to accumulator
.noadd:
    rra                 ; shift accumulator right (carry into bit 7,
                        ;   bit 0 into carry -- this carry feeds
                        ;   back into C via the next RR C)
    dec  d
    jr   nz, .loop
    ret
```

Изучи это внимательно. Инструкция `RRA` сдвигает A вправо, но также выталкивает младший бит A в флаг переноса. На следующей итерации `RR C` вдвигает этот перенос в старший бит C. Таким образом, младшие биты произведения постепенно собираются в C, а старшие накапливаются в A. После восьми итераций полный 16-битный результат лежит в A:C.

Стоимость — от 196 до 204 тактов (T-state) в зависимости от того, сколько бит множителя установлено: каждый установленный бит добавляет один `ADD A,B` (4 такта). Пример в `chapters/ch04-maths/examples/multiply8.a80` показывает вариант с результатом в HL.

Для 16x16 с 32-битным результатом подпрограмма Dark'а MULU224 работает за 730–826 тактов. На практике демосценовые 3D-движки избегают полного 16x16 умножения, храня координаты в формате с фиксированной точкой 8.8 и используя умножение 8x8 где возможно.

![Пошаговое выполнение умножения 8x8 сдвигом-и-сложением](illustrations/output/ch04_multiply_walkthrough.png)

### Метод 2: Поиск по таблице квадратов

Второй метод Dark'а обменивает память на скорость, используя алгебраическое тождество, которое рано или поздно открывает каждый демосценер:

```
A * B = ((A+B)^2 - (A-B)^2) / 4
```

Заранее вычисляем таблицу значений n^2/4, и умножение становится двумя поисками по таблице и вычитанием — примерно 61 такт, более чем втрое быстрее сдвига-и-сложения.

Нужна 512-байтная таблица (n^2/4) для n = 0..511, выровненная по странице для индексации одним регистром. Таблица должна быть 512 байт, потому что (A+B) может достигать 510.

```z80
; MULU_FAST -- Square table multiply
; Input:  B, C = unsigned 8-bit factors
; Output: HL = B * C (16-bit result)
; Cost:   ~61 T-states (Pentagon)
; Requires: sq_table = 512-byte table of n^2/4, page-aligned
;
; A*B = ((A+B)^2 - (A-B)^2) / 4

mulu_fast:
    ld   h, sq_table >> 8  ; high byte of table address
    ld   a, b
    add  a, c              ; A = B + C (may overflow into carry)
    ld   l, a
    ld   e, (hl)           ; look up (B+C)^2/4 low byte
    inc  h
    ld   d, (hl)           ; look up (B+C)^2/4 high byte

    ld   a, b
    sub  c                 ; A = B - C (may go negative)
    jr   nc, .pos
    neg                    ; take absolute value
.pos:
    ld   l, a
    dec  h
    ld   a, e
    sub  (hl)              ; subtract (B-C)^2/4 low byte
    ld   e, a
    inc  h
    ld   a, d
    sbc  a, (hl)           ; subtract (B-C)^2/4 high byte
    ld   d, a

    ex   de, hl            ; HL = result
    ret
```

Компромисс? Dark с характерной честностью говорит: **«Выбирай: скорость или точность.»** Таблица хранит целочисленные значения n^2/4, поэтому ошибка округления составляет до 0.25 на каждый поиск. Для больших значений это пренебрежимо мало. Для малых приращений координат при 3D-вращении ошибка вызывает заметное дрожание вершин. С методом сдвига-и-сложения вращение идеально плавное.

Для текстурного маппинга, плазмы, скроллеров — используй быстрое умножение. Для каркасного 3D, где глаз отслеживает отдельные вершины — оставайся на сдвиге-и-сложении. Dark знал это, потому что пробовал оба варианта в *Illusion*.

**Генерация таблицы квадратов** — одноразовая затрата при инициализации. Dark предлагает метод производных: поскольку d(x^2)/dx = 2x, можно строить таблицу инкрементально, прибавляя линейно растущую дельту на каждом шаге. На практике большинство кодеров вычисляют таблицу в BASIC-загрузчике или подпрограмме инициализации и идут дальше.

---

## Деление на Z80

Деление на Z80 ещё мучительнее умножения. Нет инструкции деления, и алгоритм по своей природе последователен — каждый бит частного зависит от предыдущего вычитания. Dark снова представляет два метода: точный и быстрый.

### Метод 1: Сдвиг-и-вычитание (восстанавливающее деление)

Двоичное деление столбиком. Начинаем с обнулённого аккумулятора. Делимое сдвигается справа, по одному биту за итерацию. Пробуем вычесть делитель; если получается — устанавливаем бит частного. Если нет — восстанавливаем аккумулятор, отсюда и название «восстанавливающее деление».

```z80
; DIVU111 -- 8-bit unsigned divide
; Input:  B = dividend, C = divisor
; Output: B = quotient, A = remainder
; Cost:   236-244 T-states (Pentagon)
;
; From Dark / X-Trade, Spectrum Expert #01 (1997)

divu111:
    xor  a               ; clear accumulator (remainder workspace)
    ld   d, 8            ; 8 bits to process

.loop:
    sla  b               ; shift dividend left -- MSB into carry
    rla                  ; shift carry into accumulator
    cp   c               ; try to subtract divisor
    jr   c, .too_small   ; if accumulator < divisor, skip
    sub  c               ; subtract divisor from accumulator
    inc  b               ; set bit 0 of quotient (B was just shifted,
                         ;   so bit 0 is free)
.too_small:
    dec  d
    jr   nz, .loop
    ret                  ; B = quotient, A = remainder
```

`INC B` для установки бита частного — изящный трюк: B только что был сдвинут влево инструкцией `SLA B`, поэтому бит 0 гарантированно нулевой. `INC B` устанавливает его, не затрагивая остальные биты — дешевле, чем `OR` или `SET`.

16-битная версия (DIVU222) стоит от 938 до 1034 тактов. Тысяча тактов на одно деление. При бюджете кадра ~70 000 тактов можно позволить себе примерно 70 делений на кадр — не делая больше ничего. Вот почему демосценовые 3D-движки идут на крайние меры, чтобы избежать деления.

### Метод 2: Логарифмическое деление

Более быстрая альтернатива Dark'а использует таблицы логарифмов:

```
Log(A / B) = Log(A) - Log(B)
A / B = AntiLog(Log(A) - Log(B))
```

С двумя 256-байтными таблицами подстановки — Log и AntiLog — деление превращается в два поиска по таблице, вычитание и третий поиск. Стоимость падает примерно до 50–70 тактов. Для перспективного деления (деление на Z для проецирования 3D-точек на экран) — это революция.

**Генерация таблицы логарифмов** — тут становится интересно. Dark предлагает строить её через производные — тот же инкрементальный метод, что и для таблицы квадратов. Производная log2(x) равна 1/(x * ln(2)), поэтому ты накапливаешь дробные приращения шаг за шагом, начиная с log2(1) = 0 и двигаясь вверх. Константу 1/ln(2) = 1.4427 нужно масштабировать, чтобы уместить в 8-битный диапазон таблицы.

И тут проявляется честность Dark'а. Выведя формулу генерации, он пытается вычислить поправочный коэффициент для масштабирования таблицы и получает 0.4606. Затем пишет — в публикуемой журнальной статье — *«Что-то тут не так, поэтому рекомендуется написать аналогичную самостоятельно.»*

Семнадцатилетний парень в 1997 году, публикуясь в дисковом журнале, который читают его коллеги по всей российской Spectrum-сцене, открыто говорит: я заставил это работать, но в моём выводе есть дыра — разберитесь с чистой версией сами. Такая честность редка в техническом тексте любого уровня, и это одна из вещей, которые делают Spectrum Expert таким замечательным документом.

На практике таблицы логарифмов работают. Ошибки округления при сжатии непрерывной функции в 256 байт приемлемы для перспективной проекции. 3D-движок Dark'а в *Illusion* использует именно этот метод.

---

## Синус и косинус

Вращение, скроллинг, плазма — каждому эффекту с кривизной нужна тригонометрия. На Z80 ты заранее вычисляешь таблицу подстановки. Подход Dark'а красиво прагматичен: парабола достаточно близка к синусоиде для демосценовых целей.

### Параболическая аппроксимация

Половина периода косинуса, от 0 до pi, изгибается от +1 вниз до -1. Парабола y = 1 - 2*(x/pi)^2 следует почти тем же путём. Максимальная ошибка — около 5.6% — ужасно для инженерных расчётов, незаметно в демо при разрешении 256x192.

Dark генерирует 256-байтную знаковую таблицу косинуса (-128..+127), индексируемую углом: 0 = 0 градусов, 64 = 90 градусов, 128 = 180 градусов, 256 оборачивается в 0. Период, равный степени двойки, означает, что индекс угла оборачивается естественно при 8-битном переполнении, а косинус становится синусом прибавлением 64.

```z80
; Generate 256-byte signed cosine table (-128..+127)
; using parabolic approximation
;
; The table covers one full period: cos(n * 2*pi/256)
; scaled to signed 8-bit range.
;
; Approach: for the first half (0..127), compute
;   y = 127 - (x^2 * 255 / 128^2)
; approximated via incrementing differences.
; Mirror for second half.

gen_cos_table:
    ld   hl, cos_table
    ld   b, 0              ; x = 0
    ld   de, 0             ; running delta (fixed-point)

    ; First quarter: cos descends from +127 to 0
    ; Second quarter: continues to -128
    ; ...build via incremental squared differences

    ; In practice, the generation loop runs ~30 bytes
    ; and produces the table in a few hundred cycles.
```

Ключевая идея: не нужно вычислять x^2 для каждой записи. Поскольку (x+1)^2 - x^2 = 2x + 1, ты строишь параболу инкрементально — начинаешь с вершины, вычитаешь линейно растущую дельту. Никакого умножения, деления, никакой плавающей точки.

Получившаяся таблица — кусочно-параболическая аппроксимация. Наложи её на истинный синус, и разницу будет сложно увидеть. Для каркасного 3D или прыгающего скроллера — более чем достаточно.

> **Врезка: 9 заповедей Raider'а о таблицах синусов**
>
> В комментариях Hype к анализу *Illusion* Introspec'ом ветеран-кодер Raider выложил список правил проектирования таблиц синусов, ставший неформально известным как «9 заповедей». Основные принципы:
>
> - Используй размер таблицы, равный степени двойки (256 записей — каноничный размер).
> - Выравнивай таблицу по границе страницы, чтобы `H` хранил базу, а `L` был чистым углом — индексация бесплатна.
> - Храни знаковые значения для прямого использования в координатной арифметике.
> - Пусть угол оборачивается естественно через 8-битное переполнение — никаких проверок границ.
> - Косинус — это просто синус со смещением на четверть периода: загрузи угол, прибавь 64, сделай поиск.
> - Если нужна повышенная точность, используй 16-битную таблицу (512 байт), но это редко требуется.
> - Генерируй таблицу при запуске, а не храни в бинарнике — экономит место, ничего не стоит.
> - Для 3D-вращения предварительно умножь на масштабный коэффициент и храни масштабированные значения.
> - Никогда не вычисляй тригонометрию в реальном времени. Если тебе кажется, что нужно — ты ошибаешься.
>
> Эти заповеди отражают десятилетия коллективного опыта. Следуй им, и твои таблицы синусов будут быстрыми, компактными и корректными.

---

## Рисование линий по Брезенхэму

Каждое ребро каркасного объекта — это линия от (x1,y1) до (x2,y2), и рисовать её нужно быстро. Раздел Dark'а в Spectrum Expert #01, посвящённый рисованию линий, — самый объёмный в статье; он проходит через три последовательно ускоряющихся подхода.

### Классический алгоритм и модификация Xopha

Алгоритм Брезенхэма шагает вдоль главной оси по одному пикселю за раз, поддерживая аккумулятор ошибки для шагов по второстепенной оси. На Spectrum «поставить пиксель» — дорогая операция: черезстрочная раскладка экрана означает, что вычисление адреса байта и битовой позиции стоит реальных тактов. Подпрограмма ПЗУ тратит более 1000 тактов на пиксель. Даже ручной оптимизированный цикл Брезенхэма стоит ~80 тактов на пиксель.

Dark упоминает улучшение Xopha: поддерживать указатель на экранную память (HL) и продвигать его инкрементально, а не пересчитывать с нуля. Движение вправо — ротация битовой маски; движение вниз — многоинструкционная корректировка DOWN_HL. Лучше, но коренная проблема остаётся.

### Матричный метод Dark'а: сетки 8x8 пикселей

Затем Dark делает ключевое наблюдение: **«87.5% проверок тратятся впустую.»**

В цикле Брезенхэма на каждом пикселе ты спрашиваешь: нужно ли шагнуть вбок? Для почти горизонтальной линии ответ почти всегда — нет. В среднем семь из восьми проверок не дают бокового шага. Ты сжигаешь такты на условном переходе, который почти никогда не срабатывает.

Решение Dark'а: предвычислить паттерн пикселей для каждого наклона линии в пределах сетки 8x8 пикселей и развернуть цикл рисования, чтобы выводить целые ячейки сетки за раз. Сегмент линии в пределах области 8x8 полностью определяется наклоном. Для каждого из восьми октантов перечисляются все возможные 8-пиксельные паттерны как прямые последовательности инструкций `SET bit,(HL)` с приращениями адреса между ними.

```z80
; Example: one unrolled 8-pixel segment of a nearly-horizontal line
; (octant 0: moving right, gently sloping down)
;
; The line enters at the left edge of an 8x8 character cell
; and exits at the right edge, dropping one pixel row partway through.

    set  7, (hl)        ; pixel 0 (leftmost bit in byte)
    set  6, (hl)        ; pixel 1
    set  5, (hl)        ; pixel 2
    set  4, (hl)        ; pixel 3
    set  3, (hl)        ; pixel 4
    ; --- step down one pixel row ---
    inc  h              ; next screen row (within character cell)
    set  2, (hl)        ; pixel 5
    set  1, (hl)        ; pixel 6
    set  0, (hl)        ; pixel 7 (rightmost bit in byte)
```

Никаких условных переходов. Никакого аккумулятора ошибки. `SET bit,(HL)` занимает 15 тактов; восемь таких инструкций плюс пара `INC H` дают ~130 тактов на 8-пиксельный сегмент, или около 16 тактов на пиксель. С учётом поиска по таблице подстановки и перехода между ячейками Dark достигает примерно **48 тактов на пиксель** — почти вдвое дешевле классического Брезенхэма.

Цена — память: отдельная развёрнутая подпрограмма для каждого наклона в каждом октанте, всего около **3 КБ**. На 128K Spectrum — скромное вложение ради колоссального ускорения.

### Завершение через ловушку

Вместо проверки счётчика цикла на каждом пикселе Dark размещает маркер-ловушку там, где линия заканчивается. Когда рисующий код натыкается на маркер, он выходит — полностью устраняя накладные расходы `DEC counter / JR NZ`.

Полная система — выбор октанта, поиск сегмента, развёрнутое рисование, завершение через ловушку — один из самых впечатляющих фрагментов кода в Spectrum Expert #01. Когда Introspec дизассемблировал *Illusion* в 2017 году, он обнаружил именно этот матричный метод за рисованием каркасных фигур на полной частоте кадров.

---

## Арифметика с фиксированной точкой

Каждый алгоритм в этой главе подразумевает то, о чём мы ещё не сказали явно: числа с фиксированной точкой.

У Z80 нет блока плавающей точки. Каждый регистр хранит целое число. Но демо-эффектам нужны дробные значения — углы вращения, субпиксельные скорости, масштабные коэффициенты. Решение — фиксированная точка: выбираешь соглашение о том, где находится «десятичная точка» внутри целого числа, а затем выполняешь всю арифметику в целых числах, мысленно отслеживая масштаб.

### Формат 8.8

Самый распространённый формат на Z80 — **8.8**: старший байт = целая часть, младший байт = дробная часть. Одна 16-битная регистровая пара хранит одно число с фиксированной точкой:

```
H = integer part    (-128..+127 signed, or 0..255 unsigned)
L = fractional part (0..255, representing 0/256 to 255/256)
```

`HL = $0180` представляет 1.5 (H=1, L=128, и 128/256 = 0.5). `HL = $FF80` знаковое — это -0.5 (H=$FF = -1 в дополнительном коде, L=$80 добавляет 0.5).

Красота в том, что **сложение и вычитание бесплатны** — обычные 16-битные операции:

```z80
; Fixed-point 8.8 addition: result = a + b
; HL = first operand, DE = second operand
    add  hl, de          ; that's it. 11 T-states.

; Fixed-point 8.8 subtraction: result = a - b
    or   a               ; clear carry
    sbc  hl, de          ; 15 T-states.
```

Процессору всё равно, что ты трактуешь эти числа как фиксированную точку. Двоичное сложение одинаково, представляют ли биты целые числа или значения 8.8.

### Умножение с фиксированной точкой

Умножение двух чисел 8.8 даёт результат 16.16 — 32 бита. Тебе нужно обратно 8.8, поэтому берёшь биты 8..23 произведения (фактически сдвигая вправо на 8). На практике, с малыми целыми частями (координаты, коэффициенты вращения между -1 и +1), можно разложить умножение на частичные произведения:

```z80
; Fixed-point 8.8 multiply (simplified)
; Input:  BC = first operand (B.C in 8.8)
;         DE = second operand (D.E in 8.8)
; Output: HL = result (H.L in 8.8)
;
; Full product = BC * DE (32 bits), we want bits 8..23
;
; Decomposition:
;   BC * DE = (B*256+C) * (D*256+E)
;           = B*D*65536 + (B*E + C*D)*256 + C*E
;
; In 8.8 result (bits 8..23):
;   H.L = B*D*256 + B*E + C*D + (C*E)/256
;
; For small B,D (say -1..+1), B*D*256 is the dominant term.
; C*E/256 is a rounding correction.
; Total cost: ~200 T-states using the shift-and-add multiplier.

fixmul88:
    ; Multiply B*E -> add to result high
    ld   a, b
    call mul8             ; A = B*E (assuming 8x8->8 truncated)
    ld   h, a

    ; Multiply C*D -> add to result
    ld   a, c
    ld   b, d
    call mul8             ; A = C*D
    add  a, h
    ld   h, a

    ; For higher precision, also compute B*D and C*E
    ; and combine. In practice, the two middle terms
    ; are often sufficient for demo work.

    ld   l, 0             ; fractional part (approximate)
    ret
```

Для вращения на базе таблиц синусов, где значения синуса — 8-битные знаковые (-128..+127, представляющие -1.0..+0.996), умножение 8-битной координаты на значение синуса через `mulu112` даёт 16-битный результат уже в формате 8.8 — старший байт — повёрнутая целая координата, младший — дробная часть.

### Почему фиксированная точка важна

Формат 8.8 — оптимальный выбор для Z80: умещается в регистровую пару, сложение/вычитание бесплатны, умножение стоит ~200 тактов, и точности хватает для эффектов экранного разрешения. Существуют и другие форматы — 4.12 для большей дробной точности, 12.4 для большего целочисленного диапазона — но 8.8 покрывает подавляющее большинство случаев. Главы по разработке игр далее в этой книге используют исключительно 8.8.

---

## Теория и практика

Эти алгоритмы — не изолированные приёмы. Они образуют систему. Умножение питает матрицу вращения. Вращение выдаёт координаты, нуждающиеся в перспективном делении. Деление использует таблицы логарифмов. Спроецированные вершины соединяются линиями, нарисованными матричным методом. Всё работает на арифметике с фиксированной точкой, со значениями синуса из параболической таблицы.

Dark проектировал их как компоненты единого движка — движка, приводившего в действие *Illusion*. Каркасный куб, вращающийся на полной частоте кадров, задействует каждую подпрограмму из этой главы:

1. **Считываем угол вращения** из таблицы синусов (параболическая аппроксимация, ~20 тактов на поиск)
2. **Умножаем** координаты вершин на коэффициенты вращения (сдвиг-и-сложение для точности или таблица квадратов для скорости — ~200 или ~60 тактов на умножение, 12 умножений на вершину)
3. **Делим** на Z для перспективной проекции (таблицы логарифмов, ~60 тактов на деление)
4. **Рисуем линии** между спроецированными вершинами (матричный Брезенхэм, ~48 тактов на пиксель)

Для простого куба (8 вершин, 12 рёбер) суммарная стоимость на кадр составляет примерно:

- Вращение: 8 вершин x 12 умножений x 200 тактов = 19 200 тактов
- Проекция: 8 вершин x 1 деление x 60 тактов = 480 тактов
- Рисование линий: 12 рёбер x ~40 пикселей x 48 тактов = 23 040 тактов
- **Итого: ~42 720 тактов** — комфортно укладывается в бюджет кадра ~70 000 тактов

Переключись на быстрое умножение через таблицу квадратов, и вращение падает до 5 760 тактов. Вершины слегка дрожат, но зато появляется запас для более сложных объектов. Скорость или точность — в демо этот выбор делаешь для каждого эффекта, каждого кадра.

---

## Что Dark сделал правильно

Оглядываясь на Spectrum Expert #01 с дистанции почти в тридцать лет, поражает не только качество алгоритмов, но и качество мышления. Dark представляет каждый из них, честно объясняет компромиссы, признаёт, когда в его выводе есть пробелы, и доверяет читателю заполнить их.

Он писал для Spectrum-кодеров в России конца 1990-х — сообщества, создававшего одни из самых впечатляющих 8-битных демо в мире на оборудовании, которое остальной мир уже забросил. Это строительные блоки, которые они использовали. Когда ты будешь писать свой первый 3D-движок для Spectrum, именно эти подпрограммы сделают это возможным.

В следующей главе Dark и STS расширяют этот математический фундамент до полноценной 3D-системы: метод средней точки для интерполяции вершин, отсечение задних граней и рендеринг закрашенных полигонов. Математика здесь — фундамент. Глава 5 — архитектура, построенная на нём.

---

## Случайные числа: когда таблицы не помогают

Всё рассмотренное до сих пор в этой главе детерминировано. При одинаковых входных данных одно и то же умножение, один и тот же поиск синуса, одна и та же линия — дают одинаковый результат. Именно это и нужно для вращающегося каркасного куба или плавной плазмы.

Но иногда нужен хаос. Мерцающие звёзды в звёздном поле. Частицы, разлетающиеся от взрыва. Шумовые текстуры для генерации ландшафта. Перемешанный порядок для загрузочных экранов. В соревнованиях по sizecoding (256 байт или меньше) хороший генератор случайных чисел может создавать удивительно сложные визуальные эффекты почти из ничего.

У Z80 нет аппаратного генератора случайных чисел. Приходится синтезировать случайность из арифметики, и качество этой арифметики важнее, чем может показаться.

### Трюк с регистром R

У Z80 есть встроенный источник энтропии, к которому многие кодеры обращаются в первую очередь: регистр R. Он автоматически инкрементируется при каждом цикле выборки инструкции (каждый цикл M1), перебирая значения 0–127. Прочитать его можно за 9 тактов:

```z80
    ld   a, r              ; 9 T -- read refresh counter
```

Это *не* ГПСЧ. Регистр R полностью детерминирован — он увеличивается на единицу с каждой инструкцией, и его значение в любой точке определяется исключительно путём исполнения кода с момента сброса. В демо с фиксированным главным циклом R выдаёт одну и ту же последовательность каждый раз. Зато он полезен как источник начального значения (seed): прочитай R один раз при запуске (когда тайминг зависит от того, сколько пользователь ждал перед нажатием клавиши) и используй это непредсказуемое значение для инициализации настоящего ГПСЧ.

Некоторые кодеры подмешивают R в свой генератор при каждом вызове, добавляя настоящую энтропию от тайминга инструкций. Генератор Ion ниже использует именно этот трюк.

### Четыре генератора от сообщества

В 2024 году Gogin (из российской ZX-сцены) собрал коллекцию подпрограмм ГПСЧ для Z80 и поделился ими для оценки. Gogin протестировал их систематически, заполняя большие растровые изображения для выявления статистических паттернов. Результаты поучительны — не все «случайные» подпрограммы одинаково случайны.

Вот четыре генератора из этой коллекции, упорядоченные от лучшего к худшему качеству.

#### CMWC-генератор Patrik Rak (лучшее качество)

Это генератор **Complement Multiply-With-Carry** от Patrik Rak, использующий множитель 253 и кольцевой буфер из 8 байт. Математика CMWC хорошо изучена: Джордж Марсалья доказал, что определённые комбинации множителя и буфера дают последовательности с огромными периодами. С множителем 253 и буфером размера 8 теоретический период составляет (253^8 - 1) / 254 — примерно 2^66 значений до повторения.

```z80
; Patrik Rak's CMWC PRNG
; Quality: Excellent -- passes visual bitmap tests
; Size:    ~30 bytes code + 8 bytes table
; Output:  A = pseudo-random byte
; Period:  ~2^66

patrik_rak_cmwc_rnd:
    ld   hl, .table
.smc_idx:
    ld   bc, 0              ; 10 T -- i (self-modifying)
    add  hl, bc             ; 11 T
    ld   a, c               ; 4 T
    inc  a                  ; 4 T
    and  7                  ; 7 T -- wrap index to 0-7
    ld   (.smc_idx+1), a    ; 13 T -- store new index
    ld   c, (hl)            ; 7 T -- y = q[i]
    ex   de, hl             ; 4 T
    ld   h, c               ; 4 T -- t = 256 * y
    ld   l, b               ; 4 T
    sbc  hl, bc             ; 15 T -- t = 255 * y
    sbc  hl, bc             ; 15 T -- t = 254 * y
    sbc  hl, bc             ; 15 T -- t = 253 * y
.smc_car:
    ld   c, 0               ; 7 T -- carry (self-modifying)
    add  hl, bc             ; 11 T -- t = 253 * y + c
    ld   a, h               ; 4 T
    ld   (.smc_car+1), a    ; 13 T -- c = t / 256
    ld   a, l               ; 4 T -- x = t % 256
    cpl                     ; 4 T -- x = ~x (complement)
    ld   (de), a            ; 7 T -- q[i] = x
    ret                     ; 10 T

.table:
    DB   82, 97, 120, 111, 102, 116, 20, 12
```

Алгоритм умножает текущий элемент буфера на 253, прибавляет значение переноса, сохраняет новый перенос и дополняет результат. Кольцевой буфер из 8 байт означает, что пространство состояний генератора огромно — 8 байт буфера плюс 1 байт переноса плюс индекс дают куда больше внутреннего состояния, чем может достичь любой одно-регистровый генератор.

Вердикт Gogin'а: **лучшее качество** в коллекции. При заполнении растра 256x192 видимых паттернов не возникает даже в крупном масштабе.

#### Ion Random (второе место)

Изначально из Ion Shell для калькулятора TI-83, адаптирован для Z80. Этот генератор подмешивает регистр R в цикл обратной связи, достигая удивительно хорошей случайности всего в ~15 байтах:

```z80
; Ion Random
; Quality: Good -- minor patterns visible only at extreme scale
; Size:    ~15 bytes
; Output:  A = pseudo-random byte
; Origin:  Ion Shell (TI-83), adapted for Z80

ion_rnd:
.smc_seed:
    ld   hl, 0              ; 10 T -- seed (self-modifying)
    ld   a, r               ; 9 T -- read refresh counter
    ld   d, a               ; 4 T
    ld   e, (hl)            ; 7 T
    add  hl, de             ; 11 T
    add  a, l               ; 4 T
    xor  h                  ; 4 T
    ld   (.smc_seed+1), hl  ; 16 T -- update seed
    ret                     ; 10 T
```

Инъекция регистра R означает, что этот генератор даёт разные последовательности в зависимости от контекста вызова — количество исполненных инструкций между вызовами влияет на R, который возвращается в состояние. Для главного цикла демо с фиксированным таймингом R изменяется предсказуемо, но нелинейное смешивание (ADD + XOR) всё равно даёт хороший результат. В игре, где пользовательский ввод меняет паттерн вызовов, вклад R добавляет настоящую непредсказуемость.

Вердикт Gogin'а: **второе место**. Очень компактный, хорошее качество для своего размера.

#### XORshift 16 бит (посредственный)

16-битный XORshift-генератор — адаптация для Z80 из известного семейства Марсальи:

```z80
; 16-bit XORshift PRNG
; Quality: Mediocre -- visible diagonal patterns in bitmap tests
; Size:    ~25 bytes
; Output:  A = pseudo-random byte (H or L)
; Period:  65535

xorshift_rnd:
.smc_state:
    ld   hl, 1              ; 10 T -- state (self-modifying, must not be 0)
    ld   a, h               ; 4 T
    rra                     ; 4 T
    ld   a, l               ; 4 T
    rra                     ; 4 T
    xor  h                  ; 4 T
    ld   h, a               ; 4 T
    ld   a, l               ; 4 T
    rra                     ; 4 T
    ld   a, h               ; 4 T
    rra                     ; 4 T
    xor  l                  ; 4 T
    ld   l, a               ; 4 T
    xor  h                  ; 4 T
    ld   h, a               ; 4 T
    ld   (.smc_state+1), hl ; 16 T -- update state
    ret                     ; 10 T
```

XORshift-генераторы быстры и просты, но при всего 16 битах состояния период составляет максимум 65 535. Что ещё хуже, паттерн ротации битов создаёт видимые диагональные полосы при отображении на пиксели. Для быстрого звёздного поля или эффекта частиц это может быть приемлемо. Для заполнения больших областей экрана «шумом» паттерны становятся очевидными.

#### Вариант CMWC от Raxoft (посредственный)

Вариант CMWC от Raxoft, схожий по принципу с версией Patrik Rak, но с другой организацией буфера. Gogin обнаружил, что он создаёт **видимые паттерны в крупном масштабе** — вероятно, из-за взаимодействия распространения переноса с индексацией буфера. Мы включаем его в компилируемый пример (`examples/prng.a80`) для полноты, но для продакшена версия Patrik Rak строго лучше.

### Подход Tribonacci из Elite

Заслуживает краткого упоминания: легендарная *Elite* (1984) использовала последовательность, подобную Трибоначчи, для процедурно генерируемой галактики. Три регистра замыкаются друг на друга в цикле обратной связи, создавая детерминированные, но хорошо распределённые последовательности. Ключевая идея — воспроизводимость: при одном и том же начальном значении генерируется одна и та же галактика, что позволяло всей вселенной «поместиться» в нескольких байтах состояния генератора. Дэвид Брэбен и Йен Белл использовали это для генерации 8 галактик по 256 звёздных систем из горстки байтов-seeds. Техника ближе к хэш-функции, чем к ГПСЧ, но принцип — малое состояние, большая видимая сложность — тот же, что движет демосценовым sizecoding.

### Генератор галактик Elite: подробнее

Подход Tribonacci заслуживает более детального рассмотрения, поскольку иллюстрирует глубокий принцип: **ГПСЧ — это не просто источник случайных чисел, это алгоритм сжатия.**

Дэвиду Брэбену и Йену Беллу нужны были 8 галактик по 256 звёздных систем, каждая со своим названием, позицией, экономикой, типом правления и уровнем технологий. Хранить всё это явно потребовало бы килобайты. Вместо этого они хранили лишь 6-байтовый seed на галактику и детерминированный генератор, который разворачивал каждый seed в полные данные звёздных систем. Генератор был цикличной обратной связью из трёх регистров — каждый шаг вращает и XOR'ит три 16-битных значения:

```
; Elite's galaxy generator (conceptual, 6502 origin):
;   seed = [s0, s1, s2]  (three 16-bit words)
;   twist: s0' = s1, s1' = s2, s2' = s0 + s1 + s2  (mod 65536)
;   repeat twist for each byte of star system data
```

На Z80 тот же принцип работает с тремя регистровыми парами. Операция «twist» выдаёт детерминированные, но хорошо распределённые значения. Ключевое свойство: при одном и том же seed генерируется одна и та же галактика. Навигация между звёздами — это просто пересев и перегенерация.

Эта идея — **малое состояние, большая видимая сложность** — движет и демосценовым sizecoding. 256-байтное интро, заполняющее экран замысловатыми паттернами, делает ровно то же, что делала Elite: разворачивает крошечный seed в большой, сложный результат через детерминированный процесс.

### Формирование случайности

Иногда нужны числа случайные, но следующие определённому распределению. Равномерный ГПСЧ даёт каждому значению равную вероятность, но реальные явления редко бывают равномерными: частота появления врагов, скорости частиц, высоты ландшафта — всё стремится кластеризоваться вокруг предпочтительных значений.

Распространённые трюки на Z80:

- **Треугольное распределение** — сложи два равномерных случайных байта и сдвинь вправо. Сумма концентрируется вокруг центра (128), создавая «естественно выглядящую» вариацию. Стоимость: два вызова ГПСЧ + ADD + SRL = ~20 лишних тактов.

```z80
; Triangular random: result clusters around 128
    call patrik_rak_cmwc_rnd  ; A = uniform random
    ld   b, a
    call patrik_rak_cmwc_rnd  ; A = another uniform random
    add  a, b                 ; sum (wraps at 256)
    rra                       ; divide by 2 → triangular distribution
```

- **Метод отклонения** — генерируешь случайное число, отбрасываешь значения вне нужного диапазона. Для диапазонов, равных степеням двойки, это бесплатно (просто AND с маской). Для произвольных диапазонов — цикл, пока значение не попадёт.

- **Взвешенные таблицы** — храни 256-байтную таблицу подстановки, где каждое выходное значение встречается пропорционально желаемой вероятности. Индексируй равномерным случайным байтом. Таблица стоит 256 байт, но поиск мгновенен (7 тактов). Идеально, когда распределение сложное и фиксированное.

- **ГПСЧ как хэш-функция** — пропусти структурированные данные (координаты, номера кадров) через ГПСЧ, чтобы получить детерминированный шум. Именно так работают плазма и шумовые текстуры в sizecoding: `random(x XOR y XOR frame)` даёт разное на вид значение для каждого пикселя каждого кадра, но оно полностью воспроизводимо.

### Seeds и воспроизводимость

В демо воспроизводимость обычно желательна: эффект должен выглядеть одинаково при каждом запуске, потому что кодер выстроил визуальный ряд под музыку. Инициализируй ГПСЧ один раз фиксированным значением — и последовательность будет детерминированной.

В игре важна непредсказуемость. Распространённые стратегии инициализации:

- **Системная переменная FRAMES ($5C78)** — ПЗУ Spectrum поддерживает 3-байтный счётчик кадров по адресу $5C78, который инкрементируется каждую 1/50 секунды от включения. Чтение даёт зависящий от времени seed, варьирующийся в зависимости от того, сколько машина работает. Art-top рекомендует использовать его для инициализации таблицы CMWC Patrik Rak:

```z80
; Seed Patrik Rak CMWC from FRAMES system variable
    ld   hl, $5C78            ; FRAMES (3 bytes, increments at 50 Hz)
    ld   a, (hl)              ; low byte -- most variable
    ld   de, patrik_rak_cmwc_rnd.table
    ld   b, 8
.seed_loop:
    xor  (hl)                 ; mix with FRAMES
    ld   (de), a              ; write to table
    inc  de
    rlca                      ; rotate for variety
    add  a, b                 ; add loop counter
    djnz .seed_loop
```

- **Чтение R в момент пользовательского ввода** — точное число инструкций между сбросом и нажатием клавиши варьируется от запуска к запуску. `LD A,R` в этот момент захватывает энтропию тайминга.
- **Накопление счётчика кадров** — XOR регистра R в аккумулятор каждый кадр во время экрана-заставки; использовать накопленное значение как seed при старте игры.
- **Комбинация нескольких источников** — XOR вместе R, младший байт FRAMES и байт с «плавающей шины» (на 48K Spectrum чтение определённых портов возвращает то, что ULA в данный момент читает из ОЗУ — источник позиционной энтропии).

Для демо просто инициализируй состояние генератора известным значением и оставь как есть. Компилируемый пример (`examples/prng.a80`) показывает все четыре генератора с фиксированными seeds.

### Сравнительная таблица

| Алгоритм | Размер (байт) | Скорость (такты) | Качество | Период | Примечания |
|-----------|-------------|-------------------|---------|--------|-------|
| Patrik Rak CMWC | ~30 + 8 таблица | ~170 | Отличное | ~2^66 | Лучший в целом; 8-байтный буфер |
| Ion Random | ~15 | ~75 | Хорошее | Зависит от R | Компактный; подмешивает регистр R |
| XORshift 16 | ~25 | ~90 | Посредственное | 65 535 | Видимые диагональные паттерны |
| Raxoft CMWC | ~35 + 10 таблица | ~180 | Посредственное | ~2^66 | Паттерны видны в крупном масштабе |
| LD A,R в одиночку | 2 | 9 | Плохое | 128 | НЕ ГПСЧ; используй только как seed |

Для большинства демосценовых задач **CMWC Patrik Rak** — безоговорочный победитель: отличное качество, разумный размер и период настолько длинный, что он никогда не повторится за время демо. Если критичен размер кода (sizecoding, 256-байтные интро), **Ion Random** упаковывает замечательное качество в 15 байт. XORshift — запасной вариант, когда нужно что-то быстрое и неважно визуальное качество.

> **Авторы:** Коллекция ГПСЧ, оценка качества и растровое тестирование — **Gogin**. CMWC-генератор Patrik Rak основан на теории Complementary Multiply-With-Carry Джорджа Марсальи. Ion Random берёт начало из **Ion Shell** для калькулятора TI-83.

---

*Все подсчёты тактов в этой главе — для тайминга Pentagon (без wait-состояний). На стандартном 48K Spectrum или Scorpion со спорной памятью ожидай более высокие значения для кода, исполняемого в нижних 32 КБ ОЗУ. См. Приложение A для полной справки по таймингу.*
