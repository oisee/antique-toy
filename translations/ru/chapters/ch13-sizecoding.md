# Глава 13: Мастерство sizecoding

> "It was like playing puzzle-like games -- constant reshuffling of code to find shorter encodings."
> -- UriS, о написании NHBF (2025)

Существует категория соревнований демосцены, где ограничение -- не время, а *пространство*. Вся твоя программа -- код, рисующий экран, производящий звук, обрабатывающий покадровый цикл, хранящий необходимые данные -- должна уместиться в 256 байт. Или 512. Или 1K, или 4K, или 8K. Ни байтом больше. Файл измеряется, и если он 257 байт, он дисквалифицируется.

Это **sizecoding**-соревнования, и они производят одни из самых выдающихся работ на ZX Spectrum-сцене. 256-байтное интро, заполняющее экран анимированными паттернами и воспроизводящее узнаваемую мелодию -- это форма сжатия настолько экстремальная, что граничит с магией. Разрыв между тем, что видит зритель, и размером файла, который это производит -- этот разрыв и есть искусство.

Эта глава о мышлении, техниках и конкретных трюках, которые делают sizecoding возможным.

---

## 13.1 Что такое sizecoding?

Демо-соревнования обычно предлагают несколько категорий с ограничением по размеру:

| Категория | Лимит | Что влезает |
|-----------|-------|-------------|
| 256 байт | 256 | Один плотный эффект, может быть простой звук |
| 512 байт | 512 | Эффект с базовой музыкой или два простых эффекта |
| 1K интро | 1 024 | Несколько эффектов, полноценная музыка, переходы |
| 4K интро | 4 096 | Короткое демо с несколькими частями |
| 8K интро | 8 192 | Полированное мини-демо |

Лимиты абсолютны. Файл измеряется в байтах, и торговли нет.

Что делает sizecoding захватывающим -- оно инвертирует обычную иерархию оптимизации. В мире демосценических эффектов с подсчётом тактов ты оптимизируешь на *скорость* -- развёртываешь циклы, дублируешь данные, генерируешь код, всё обменивая пространство на время. Sizecoding инвертирует это. Скорость не важна. Читаемость не важна. Единственный вопрос: можно ли сделать это на один байт короче?

UriS, написавший 256-байтное интро NHBF для Chaos Constructions 2025, описал процесс как "playing puzzle-like games". Описание точное. Sizecoding -- это головоломка, где фигуры -- инструкции Z80, поле -- 256 байт ОЗУ, а лучшие решения включают ходы, решающие несколько задач одновременно.

Сдвиг мышления:

- **Каждый байт драгоценен.** 3-байтная инструкция там, где достаточно 2-байтной -- это 0,4% всей программы. На 256 байт один сэкономленный байт -- это как сэкономить 250 байт в 64K-программе.

- **Код и данные перекрываются.** Одни и те же байты, выполняемые как инструкции, могут служить данными. Z80 не видит разницы -- только путь счётчика команд через память различает код и данные.

- **Выбор инструкций диктуется размером, не скоростью.** `RST $10` стоит 1 байт. `CALL $0010` делает то же самое за 3 байта. В обычном демо ты бы и не заметил. В 256 байтах эти 2 байта -- разница между наличием звука и его отсутствием.

- **Начальное состояние -- бесплатные данные.** После загрузки регистры имеют известные значения. Память по определённым адресам содержит известные данные. Sizecoding-мастер использует каждый бит этого бесплатного состояния.

- **Самомодифицирующийся код (SMC) -- не трюк, а необходимость.** Когда ты не можешь позволить себе отдельную переменную, ты модифицируешь операнд инструкции на месте.

---

## 13.2 Анатомия 256-байтного интро: NHBF

**NHBF** (No Heart Beats Forever) создано UriS для Chaos Constructions 2025, вдохновлённое RED REDUX с Multimatograf 2025. Оно производит текст с экранными эффектами и музыку -- зацикленные пауэр-аккорды прямоугольной волной со случайными мелодическими нотами пентатоники -- всё в 256 байтах.

### Музыка

При 256 байтах ты не можешь включить проигрыватель трекера или таблицу нот. NHBF управляет чипом AY напрямую. Пауэр-аккорды захардкодены как непосредственные значения в инструкциях записи регистров AY -- те же байты, что формируют операнд `LD A, n`, *являются* музыкальной нотой. Канал мелодии использует псевдослучайный генератор (обычно `LD A, R` -- чтение регистра обновления -- с последующим AND для маскирования диапазона) для выбора из пентатонической шкалы. Пентатоническая шкала звучит приятно независимо от того, какие ноты оказываются рядом, поэтому мелодия звучит намеренно, хотя она случайна. Два байта на "случайное" число; пять нот, которые никогда не конфликтуют.

### Визуальная часть

Печать текста через ПЗУ -- `RST $10` выводит символ за 1 байт на вызов -- самый дешёвый способ получить пиксели на экране. Но даже 20-символьная строка стоит 40 байт (коды символов + вызовы RST). Sizecoding-мастера ищут способы сжать ещё: перекрытие строковых данных с другим кодом или вычисление символов по формуле.

### Головоломка: поиск перекрытий

UriS описывает основной процесс как постоянное перестановку. Ты пишешь первую версию на 300 байт, затем вглядываешься в неё. Ты замечаешь, что счётчик цикла визуального эффекта в итоге содержит значение, нужное тебе как номер регистра AY. Убери `LD A, 7`, который бы его установил -- цикл и так оставил 7 в A. Два байта сэкономлены. Подпрограмма очистки экрана использует LDIR, который обнуляет BC. Расположи код так, чтобы следующему фрагменту нужен BC = 0, и сэкономь `LD BC, 0` -- ещё 3 байта.

Каждая инструкция производит побочные эффекты -- значения регистров, состояния флагов, содержимое памяти -- и искусство заключается в расположении инструкций так, чтобы побочные эффекты одной подпрограммы были входами другой.

### Открытие Art-Top

Во время разработки Art-Top заметил нечто замечательное: значения регистров, оставшиеся от подпрограммы очистки экрана, случайно совпали с точной длиной, нужной для текстовой строки. Не запланировано. UriS написал очистку экрана, затем вывод текста, и два фрагмента случайно разделили состояние регистра, что устранило отдельный счётчик длины.

Такое случайное совпадение перекрытий -- сердцевина 256-байтного кодинга. Ты не можешь это запланировать. Ты можешь только создать условия, при которых это может произойти, постоянно переставляя код и наблюдая за случайными совпадениями. Когда находишь одно -- это как обнаружить, что два кусочка пазла из разных головоломок идеально подходят друг к другу.

### Ключевые техники на 256 байтах

**1. Используй начальное состояние регистров и памяти.** После стандартной загрузки с ленты регистры содержат известные значения: A часто содержит последний загруженный байт, BC -- длину блока, HL указывает вблизи конца загруженных данных. Область системных переменных ($5C00-$5CB5) содержит известные значения. Экранная память чиста после CLS. Каждое известное значение, которое ты используешь вместо явной загрузки, экономит 1-3 байта.

**2. Перекрывай код и данные.** Байт $3E -- опкод для `LD A, n` и также значение 62 -- ASCII-символ, координата экрана или значение регистра AY. Если твоя программа выполняет этот байт как инструкцию *и* читает его как данные из другого пути кода, ты заставил один байт делать две работы. Типичный паттерн: непосредственный операнд `LD A, n` одновременно служит данными, которые другая подпрограмма читает через `LD A, (addr)`, указывая на instruction_address + 1.

**3. Выбирай инструкции по размеру.**

| Большая кодировка | Маленькая кодировка | Экономия |
|-------------------|---------------------|----------|
| `CALL $0010` (3 байта) | `RST $10` (1 байт) | 2 байта |
| `JP label` (3 байта) | `JR label` (2 байта) | 1 байт |
| `LD A, 0` (2 байта) | `XOR A` (1 байт) | 1 байт |
| `CP 0` (2 байта) | `OR A` (1 байт) | 1 байт |

Инструкции RST критичны. `RST n` -- это 1-байтный CALL к одному из восьми адресов ($00, $08, $10, $18, $20, $28, $30, $38). На Spectrum `RST $10` вызывает вывод символа через ПЗУ, `RST $28` входит в калькулятор. В обычном демо эти подпрограммы ПЗУ слишком медленны. На 256 байтах экономия 2 байт на CALL -- это всё.

**Каждый JP в 256-байтном интро должен быть JR** -- вся программа помещается в диапазон -128..+127.

**4. Самомодифицирующийся код (SMC) для повторного использования последовательностей.** Нужна подпрограмма, оперирующая двумя разными адресами? Захардкодь первый и запатчь операнд для второго вызова. Дешевле, чем передача параметров.

**5. Математические соотношения между константами.** Если твоей музыке нужен период тона 200 и эффекту нужен счётчик цикла 200, используй один и тот же регистр. Если одно значение вдвое больше другого, используй `ADD A, A` (1 байт) вместо загрузки второй константы (2 байта).

---

## 13.3 Трюк LPRINT

В 2015 году diver4d опубликовал "Secrets of LPRINT" на Hype, документируя технику старше самой демосцены -- впервые появившуюся в пиратских загрузчиках кассетного софта в 1980-х.

### Как это работает

Системная переменная по адресу 23681 ($5C81) управляет тем, куда подпрограммы вывода BASIC направляют данные. Обычно она указывает на буфер принтера. Измени её, чтобы она указывала на экранную память, и LPRINT пишет прямо на экран:

```basic
10 POKE 23681,64: LPRINT "HELLO"
```

Этот единственный POKE перенаправляет канал принтера на $4000 -- начало экранной памяти.

### Эффект транспозиции

Визуальный результат -- не просто текст на экране -- это *транспонированный* текст. Экранная память Spectrum чересстрочная (Глава 2), но драйвер принтера пишет последовательно. Данные попадают в экранную память согласно линейной логике драйвера, но *отображаются* согласно чересстрочной раскладке. Результат проходит через 8 визуальных состояний по мере продвижения через трети экрана -- каскад данных, который строится горизонтальными полосами, смещаясь и рекомбинируя.

С другими символьными данными -- графическими символами, UDG или тщательно подобранными ASCII-последовательностями -- транспозиция производит поразительные визуальные паттерны. Оператор LPRINT обрабатывает всю адресацию экрана, рендеринг символов и продвижение курсора. Твоя программа предоставляет только данные.

### От пиратских загрузчиков к демо-арту

diver4d проследил трюк до пиратских загрузчиков с кассет. Пираты, добавлявшие собственные загрузочные экраны, нуждались в визуальных эффектах в очень малом количестве байт BASIC -- LPRINT был идеален. Техника вышла из употребления, когда сцена перешла на машинный код.

Но в 2011 году JtN и 4D выпустили **BBB** -- демо, намеренно вернувшееся к LPRINT как художественному высказыванию. Старый трюк пиратских загрузчиков, оформленный с намерением, стал демо-артом. Ограничение -- BASIC, хак перенаправления принтера, без машинного кода -- стало медиумом.

### Почему это важно для sizecoding

LPRINT достигает сложного вывода на экран при почти нулевом расходе твоего собственного кода. ПЗУ делает тяжёлую работу. Твой вклад: POKE для перенаправления вывода, данные для печати и `RST $10` (или LPRINT) для запуска. Ты используешь 16K ПЗУ Spectrum как "бесплатный" движок вывода на экран -- код, который не считается в твой лимит размера.

---

## 13.4 512-байтные интро: пространство для дыхания

Удвоение с 256 до 512 байт -- это не вдвое больше -- это качественно другое. На 256 ты борешься за каждую инструкцию, и звук минимален. На 512 ты можешь иметь полноценный эффект *и* полноценный звук, или два эффекта с переходом.

### Типичные 512-байтные паттерны

**Плазма через суммы синусов.** Таблица синусов -- дорогая часть. Полная 256-байтная таблица потребляет половину бюджета. Решения: 64-элементная четвертьволновая таблица, зеркалируемая в рантайме (экономит 192 байта), или генерация таблицы при запуске с использованием параболической аппроксимации из Главы 4 (~20 байт кода вместо 256 байт данных).

**Туннель через lookup угла/расстояния.** На 512 байт ты вычисляешь угол и расстояние на лету, используя грубые аппроксимации. Визуальное качество ниже, чем у туннеля Eager (Глава 9), но распознаваемо как туннель.

**Огонь через клеточный автомат.** Каждая ячейка усредняет соседей снизу минус затухание. Несколько инструкций на пиксель, убедительная анимация, и на 512 байт можно добавить атрибуты для цвета *и* звук бипера.

### Самомодифицирующиеся трюки

Самомодификация становится структурной на 512 байтах. Встрой счётчик кадров *внутрь* инструкции:

```z80
frame_ld:
    ld   a, 0               ; this 0 is the frame counter
    inc  a
    ld   (frame_ld + 1), a  ; update the counter in place
```

Никакой отдельной переменной. Счётчик живёт в потоке инструкций.

Патч смещений переходов для переключения между эффектами:

```z80
effect_jump:
    jr   effect_1               ; this offset gets patched
    ; ...
effect_1:
    ; render effect 1, then:
    ld   a, effect_2 - effect_jump - 2
    ld   (effect_jump + 1), a   ; next frame jumps to effect 2
```

### Трюк с ORG

Выбирай адрес ORG своей программы так, чтобы байты адреса сами были полезными данными. Размести код по адресу $4000, и каждый JR/DJNZ, нацеленный на метки вблизи начала, генерирует маленькие байты смещения -- пригодные как счётчики циклов, значения цвета или номера регистров AY. Если твоему эффекту нужен $40 (старший байт экранной памяти) как константа, размести код по адресу, где $40 естественно появляется в операнде адреса. *Кодировка самого кода* предоставляет данные, нужные тебе в другом месте.

Это самый глубокий уровень головоломки sizecoding.

---

## 13.5 Практика: пишем 256-байтное интро пошагово

Начни с работающей атрибутной плазмы (~400 байт) и оптимизируй до 256.

### Шаг 1: Неоптимизированная версия

Простая атрибутная плазма: заполни 768 байт атрибутной памяти значениями из сумм синусов, смещёнными счётчиком кадров. Звук: циклическая мелодия на канале A AY. Эта версия чистая, читаемая и примерно 400 байт -- таблица синусов (32 байта), таблица нот (16 байт), инлайн-записи AY и цикл плазмы с табличными поисками.

### Шаг 2: Замени CALL на RST

Любой вызов к адресу ПЗУ, совпадающему с вектором RST, экономит 2 байта за каждое использование. Для вывода AY замени шесть многословных инлайн-записей регистров (~60 байт) маленькой подпрограммой:

```z80
ay_write:                      ; register in A, value in E
    ld   bc, $FFFD
    out  (c), a
    ld   b, $BF
    out  (c), e
    ret                        ; 8 bytes total
```

Шесть вызовов (5 байт каждый: загрузка A + загрузка E + CALL) = 30 + 8 = 38 байт. Экономия: ~22 байта.

### Шаг 3: Перекрой данные с кодом

32-байтная таблица синусов в точке входа декодируется как в основном безвредные инструкции Z80 ($00=NOP, $06=LD B,n, $0C=INC C...). Размести её в начале программы. При первом выполнении ЦП спотыкается через эти "инструкции", портя некоторые регистры. Основной цикл затем перепрыгивает через таблицу и больше не выполняет её -- но данные остаются для поиска. Байты таблицы служат двойной цели.

### Шаг 4: Используй состояние регистров

После того как цикл плазмы записал 768 атрибутов, HL = $5B00 и BC = 0 (от любого LDIR, использованного при инициализации). Если следующей операции нужны эти значения, пропусти явные загрузки. Открытие Art-Top в NHBF было именно этим: значения регистров от очистки экрана совпали с длиной текстовой строки. Не запланировано. Замечено.

После каждого прохода оптимизации аннотируй, что содержит каждый регистр в каждой точке. Состояние регистров -- это разделяемый ресурс -- фундаментальная валюта sizecoding.

### Шаг 5: Меньшие кодировки везде

- `LD A, 0` -> `XOR A` (экономия 1 байт)
- `LD HL, nn` + `LD A, (HL)` -> `LD A, (nn)` (экономия 1 байт, если HL не нужен)
- `JP` -> `JR` везде (экономия 1 байт каждый)
- `CALL sub : ... : RET` -> проваливание напрямую (экономия 4 байта)
- `PUSH AF` для временного сохранения вместо `LD (var), A` (экономия 2 байта)

### Финальный рывок

Последние 10-20 байт -- самые трудные. Структурная перестановка: переставь код так, чтобы проваливания устраняли инструкции JR. Объедини звуковой и визуальный циклы. Встрой байты данных в поток инструкций -- если тебе нужен $07 как данные и тебе также нужен `RLCA` (опкод $07), устрой так, чтобы один служил обоим.

Ты вглядываешься в hex-дамп. Ты пробуешь переместить звуковую подпрограмму перед визуальной. Ты пробуешь заменить таблицу синусов на рантайм-генератор. Каждая попытка перетасовывает байты. Иногда всё сходится.

Удовлетворение от вмещения связного аудиовизуального опыта в 256 байт -- от решения головоломки -- реальное и особенное, и не похожее ни на какое другое чувство в программировании.

---

## 13.6 Sizecoding как искусство

Есть момент в sizecoding -- и making-of UriS'а передаёт его идеально -- когда программа 260 байт и нужно срезать 4. Ты мог бы убрать визуальную фичу. Ты мог бы упростить звук. Или ты мог бы найти кодировку, где одни и те же байты служат обеим целям. Когда ты находишь эту кодировку, это не просто техническое решение. Это *элегантно*. Код красивее оттого, что он меньше.

Вот почему sizecoding-соревнования живут. Практическая полезность 256-байтной программы -- ноль. Мастерство -- это суть. Ограничение -- это холст. Результаты -- крошечные бинарники, производящие музыку и движение из пространства меньше, чем этот абзац -- настоящее искусство.

Статья diver4d о LPRINT делает сходное наблюдение с противоположного направления. Трюк LPRINT не эффективен. Он производит визуальный шум, который едва квалифицируется как "эффект". Но когда JtN и 4D использовали его в BBB, обрамив технику художественным намерением, результат стал демо, которое люди запомнили. Ограничение стало медиумом. Ограничения стали стилем.

Sizecoding учит вещам, которые улучшают всё твоё кодирование. Дисциплина сомнения в каждом байте обостряет осознание кодирования инструкций. Привычка искать перекрытия переносится на любую оптимизационную работу. Практика использования начального состояния и побочных эффектов делает тебя лучшим системным программистом. А опыт решения головоломок -- нахождения расположения, где всё подходит -- применим далеко за пределами 256 байт.

---

## Итого

- **Sizecoding**-соревнования требуют полных программ в 256, 512, 1K, 4K или 8K байт -- строгие лимиты, требующие принципиально другого подхода к программированию.
- **NHBF** (UriS, CC 2025) демонстрирует мышление на 256 байт: каждый байт работает за двоих, состояния регистров одной подпрограммы питают следующую, выбор инструкций диктуется исключительно размером кодировки.
- **Трюк LPRINT** (diver4d, 2015) перенаправляет вывод принтера BASIC на экранную память через адрес 23681, производя сложные визуальные паттерны в считанных байтах -- от пиратских загрузчиков с кассет до демо-арта.
- **На 512 байтах** самомодифицирующийся код (SMC) становится структурным (патч целей переходов, встраивание счётчиков в операнды), и эффекты вроде плазмы, туннеля и огня становятся осуществимы наряду со звуком.
- **Процесс оптимизации** идёт от структурных изменений (устранение таблиц, слияние циклов) к выбору кодировок (RST вместо CALL, JR вместо JP, XOR A вместо LD A,0) к случайным находкам (состояния регистров, совпадающие с потребностями в данных).
- **Трюк с ORG** -- выбор адреса загрузки так, чтобы байты адреса служили полезными данными -- представляет самый глубокий уровень головоломки.

---

## Попробуй сам

1. **Начни большим, ужми маленьким.** Напиши атрибутную плазму со счётчиком кадров. Заставь работать на любом размере. Затем оптимизируй до 512 байт, отслеживая каждый сэкономленный байт и как.

2. **Исследуй LPRINT.** В BASIC попробуй `POKE 23681,64 : FOR i=1 TO 500 : LPRINT CHR$(RND*96+32); : NEXT i`. Наблюдай, как транспонированные данные заполняют экран. Экспериментируй с разными диапазонами символов.

3. **Картографируй состояние регистров.** Напиши маленькую программу и аннотируй, что содержит каждый регистр в каждой точке. Ищи места, где выход одной подпрограммы совпадает с нужным входом другой.

4. **Изучи векторы RST.** Дизассемблируй ПЗУ Spectrum по адресам $0000, $0008, $0010, $0018, $0020, $0028, $0030, $0038. Это твои "бесплатные" подпрограммы.

5. **Вызов на 256 байт.** Доведи практику из этой главы до 256 байт. Тебе придётся принимать трудные решения о том, что оставить, а что отбросить. В этом и суть.

---

*Далее: Глава 14 -- Сжатие: больше данных в меньшем пространстве. Мы переходим от программ, умещающихся в 256 байт, к задаче вмещения килобайтов данных в килобайты хранилища, с исчерпывающим бенчмарком Introspec'а 10 упаковщиков в качестве руководства.*

> **Источники:** UriS "NHBF Making-of" (Hype, 2025); diver4d "LPRINT Secrets" (Hype, 2015)
