# Глава 13: Мастерство sizecoding

> "It was like playing puzzle-like games -- constant reshuffling of code to find shorter encodings."
> -- UriS, о написании NHBF (2025)

Существует категория соревнований демосцены, где ограничение -- не время, а *пространство*. Вся твоя программа -- код, рисующий экран, производящий звук, обрабатывающий покадровый цикл, хранящий необходимые данные -- должна уместиться в 256 байт. Или 512. Или 1K, или 4K, или 8K. Ни байтом больше. Файл измеряется, и если он 257 байт, он дисквалифицируется.

Это **sizecoding**-соревнования, и они производят одни из самых выдающихся работ на ZX Spectrum-сцене. 256-байтное интро, заполняющее экран анимированными паттернами и воспроизводящее узнаваемую мелодию -- это форма сжатия настолько экстремальная, что в неё трудно поверить, пока не прочитаешь код. Разрыв между тем, что видит зритель, и размером файла, который это производит -- этот разрыв и есть искусство.

Эта глава о мышлении, техниках и конкретных трюках, которые делают sizecoding возможным.

---

## 13.1 Что такое sizecoding?

Демо-соревнования обычно предлагают несколько категорий с ограничением по размеру:

| Категория | Лимит | Что влезает |
|-----------|-------|-------------|
| 256 байт | 256 | Один плотный эффект, может быть простой звук |
| 512 байт | 512 | Эффект с базовой музыкой или два простых эффекта |
| 1K интро | 1 024 | Несколько эффектов, полноценная музыка, переходы |
| 4K интро | 4 096 | Короткое демо с несколькими частями |
| 8K интро | 8 192 | Полированное мини-демо |

Лимиты абсолютны. Файл измеряется в байтах, и торговли нет.

Что делает sizecoding захватывающим -- оно инвертирует обычную иерархию оптимизации. В мире демосценических эффектов с подсчётом тактов ты оптимизируешь на *скорость* -- развёртываешь циклы, дублируешь данные, генерируешь код, всё обменивая пространство на время. Sizecoding инвертирует это. Скорость не важна. Читаемость не важна. Единственный вопрос: можно ли сделать это на один байт короче?

UriS, написавший 256-байтное интро NHBF для Chaos Constructions 2025, описал процесс как "playing puzzle-like games". Описание точное. Sizecoding -- это головоломка, где фигуры -- инструкции Z80, поле -- 256 байт ОЗУ, а лучшие решения включают ходы, решающие несколько задач одновременно.

Сдвиг мышления:

- **Каждый байт драгоценен.** 3-байтная инструкция там, где достаточно 2-байтной -- это 0,4% всей программы. На 256 байт один сэкономленный байт -- это как сэкономить 250 байт в 64K-программе.

- **Код и данные перекрываются.** Одни и те же байты, выполняемые как инструкции, могут служить данными. Z80 не видит разницы -- только путь счётчика команд через память различает код и данные.

- **Выбор инструкций диктуется размером, не скоростью.** `RST $10` стоит 1 байт. `CALL $0010` делает то же самое за 3 байта. В обычном демо ты бы и не заметил. В 256 байтах эти 2 байта -- разница между наличием звука и его отсутствием.

- **Начальное состояние -- бесплатные данные.** После загрузки регистры имеют известные значения. Память по определённым адресам содержит известные данные. Sizecoding-мастер использует каждый бит этого бесплатного состояния.

- **Самомодифицирующийся код (SMC) -- не трюк, а необходимость.** Когда ты не можешь позволить себе отдельную переменную, ты модифицируешь операнд инструкции на месте.

### Инструментарий сайзкодера на Z80

Некоторые трюки встречаются в размерно-оптимизированных интро настолько часто, что образуют общий словарь. Знать их наизусть -- их стоимость в байтах, их побочные эффекты -- это необходимое условие для серьёзного sizecoding.

**Предположения об инициализации регистров.** Когда программа на Spectrum запускается из BASIC (через `RANDOMIZE USR`), состояние процессора не случайно. После `CLEAR` и перед вызовом USR A обычно равен 0, BC содержит адрес USR, DE и HL имеют известные значения из интерпретатора BASIC, указатель стека установлен на адрес CLEAR, и прерывания разрешены. Многие из этих значений достаточно стабильны, чтобы на них полагаться. Если твоей программе нужен A = 0 в начале, не пиши `XOR A` -- он уже ноль. Если тебе нужен 16-битный счётчик, начинающийся с 0, проверь, не содержит ли уже DE или HL ноль или полезное значение. Один байт сэкономлен здесь, два байта там -- они складываются в разницу между 260 байтами и 256.

Область системных переменных ($5C00-$5CB5) -- ещё один источник бесплатных данных. Интерпретатор BASIC поддерживает более 100 байт состояния по известным адресам. Если тебе нужно значение 2, ты можешь найти его по адресу, где хранится номер текущего потока. Если нужен $FF, несколько полей системных переменных содержат его. Чтение с фиксированного адреса стоит 3 байта (`LD A, (nn)`), но если оно заменяет 2-байтную загрузку *плюс* некоторые вычисления, ты выигрываешь.

**DJNZ как короткий обратный переход.** `DJNZ label` занимает 2 байта, столько же, сколько `JR label` -- но при этом ещё и декрементирует B. Если B ненулевой и тебе нужен обратный переход, `DJNZ` делает и то, и другое бесплатно. Даже когда тебе не нужен декремент B, `DJNZ` всё равно 2 байта, та же стоимость, что и `JR`. Но если B достигает нуля в точности в тот момент, когда ты хочешь провалиться дальше, ты объединил счётчик цикла и переход в одну инструкцию. Сайзкодеры регулярно строят циклы так, чтобы естественный обратный отсчёт B совпадал с условием выхода.

**RST как 1-байтный CALL.** Z80 резервирует восемь адресов рестарта: $00, $08, $10, $18, $20, $28, $30, $38. `RST n` помещает адрес возврата в стек и прыгает по целевому адресу -- то же самое, что `CALL n` -- но в 1 байт вместо 3. На Spectrum ROM размещает полезные подпрограммы по нескольким из этих адресов:

- `RST $10` -- печать символа (подпрограмма ROM по адресу $0010)
- `RST $20` -- получение следующего символа из BASIC (менее полезно для демо)
- `RST $28` -- вход в калькулятор с плавающей точкой (полезно для математики)
- `RST $38` -- обработчик маскируемого прерывания (IM 1 прыгает сюда)

В обычном демо эти подпрограммы ROM слишком медленны для вызова в плотном цикле. В 256-байтном интро экономия 2 байт на вызов стоит потери скорости. Если твоя программа вызывает `RST $10` шесть раз для печати символов, это 12 байт экономии по сравнению с шестью инструкциями `CALL $0010`. Двенадцать байт -- это почти 5% от 256.

**Перекрывающиеся инструкции.** Z80 декодирует инструкции побайтно, без требований к выравниванию. Если ты прыгнешь в середину многобайтовой инструкции, процессор начнёт декодирование заново с этой точки. Это значит, что ты можешь спрятать одну инструкцию внутри другой:

```z80 id:ch13_the_z80_size_coder_s_toolkit
    ld   a, $AF              ; opcode $3E, operand $AF
                              ; BUT: $AF is XOR A
```

Если процессор выполняет код с начала, он видит `LD A, $AF` (2 байта). Если другой путь исполнения прыгает на второй байт, он видит `XOR A` (1 байт). Один байт служит двум целям. Техника хрупкая -- она требует идеального контроля над всеми путями исполнения -- но в соревновательном коде хрупкость допустима.

Распространённый паттерн: байт `$18` -- это `JR d` (относительный переход). Если тебе нужно значение $18 как данные *и* нужен переход в этом месте, один и тот же байт делает и то, и другое. Операнд, следующий за ним, одновременно является смещением перехода и (с другой точки зрения) следующим фрагментом данных.

**Эксплуатация состояния флагов.** Каждая арифметическая и логическая инструкция устанавливает флаги. Сайзкодеры запоминают, какие флаги затрагивает каждая инструкция, и используют результаты вместо того, чтобы вычислять их отдельно. После `DEC B` флаг нуля сообщает, достиг ли B нуля -- никакого `CP 0` не нужно. После `ADD A, n` флаг переноса сообщает, вышел ли результат за 255. После `AND mask` флаг нуля сообщает, были ли установлены какие-либо замаскированные биты.

Самый глубокий трюк с флагами -- `SBC A, A`: если перенос установлен, A становится $FF; если перенос сброшен, A становится $00. Один байт, без ветвления, полная битовая маска из флага. Сравни с альтернативой через ветвление:

```z80 id:ch13_the_z80_size_coder_s_toolkit_2
    ; With branching: 6 bytes
    jr   nc, .zero            ; 2
    ld   a, $FF               ; 2
    jr   .done                ; 2
.zero:
    xor  a                    ; 1
.done:

    ; With SBC A,A: 1 byte
    sbc  a, a                 ; 1 — carry -> $FF, no carry -> $00
```

Пять байт сэкономлено. В 256-байтном интро это два процента от всей программы.

---

## 13.2 Анатомия 256-байтного интро: NHBF

**NHBF** (No Heart Beats Forever) создано UriS для Chaos Constructions 2025, вдохновлённое RED REDUX с Multimatograf 2025. Оно производит текст с экранными эффектами и музыку -- зацикленные пауэр-аккорды прямоугольной волной со случайными мелодическими нотами пентатоники -- всё в 256 байтах.

### Музыка

При 256 байтах ты не можешь включить проигрыватель трекера или таблицу нот. NHBF управляет чипом AY напрямую. Пауэр-аккорды захардкодены как непосредственные значения в инструкциях записи регистров AY -- те же байты, что формируют операнд `LD A, n`, *являются* музыкальной нотой. Канал мелодии использует псевдослучайный генератор (обычно `LD A, R` -- чтение регистра обновления -- с последующим AND для маскирования диапазона) для выбора из пентатонической шкалы. Пентатоническая шкала звучит приятно независимо от того, какие ноты оказываются рядом, поэтому мелодия звучит намеренно, хотя она случайна. Два байта на "случайное" число; пять нот, которые никогда не конфликтуют.

### Визуальная часть

Печать текста через ПЗУ -- `RST $10` выводит символ за 1 байт на вызов -- самый дешёвый способ получить пиксели на экране. Но даже 20-символьная строка стоит 40 байт (коды символов + вызовы RST). Sizecoding-мастера ищут способы сжать ещё: перекрытие строковых данных с другим кодом или вычисление символов по формуле.

### Головоломка: поиск перекрытий

UriS описывает основной процесс как постоянное перестановку. Ты пишешь первую версию на 300 байт, затем вглядываешься в неё. Ты замечаешь, что счётчик цикла визуального эффекта в итоге содержит значение, нужное тебе как номер регистра AY. Убери `LD A, 7`, который бы его установил -- цикл и так оставил 7 в A. Два байта сэкономлены. Подпрограмма очистки экрана использует LDIR, который обнуляет BC. Расположи код так, чтобы следующему фрагменту нужен BC = 0, и сэкономь `LD BC, 0` -- ещё 3 байта.

Каждая инструкция производит побочные эффекты -- значения регистров, состояния флагов, содержимое памяти -- и искусство заключается в расположении инструкций так, чтобы побочные эффекты одной подпрограммы были входами другой.

### Открытие Art-Top

Во время разработки Art-Top заметил нечто замечательное: значения регистров, оставшиеся от подпрограммы очистки экрана, случайно совпали с точной длиной, нужной для текстовой строки. Не запланировано. UriS написал очистку экрана, затем вывод текста, и два фрагмента случайно разделили состояние регистра, что устранило отдельный счётчик длины.

Такое случайное совпадение перекрытий -- сердцевина 256-байтного кодинга. Ты не можешь это запланировать. Ты можешь только создать условия, при которых это может произойти, постоянно переставляя код и наблюдая за случайными совпадениями. Когда находишь одно -- это как обнаружить, что два кусочка пазла из разных головоломок идеально подходят друг к другу.

### Байтовый бюджет

При работе на 256 байт примерный бюджет помогает спланировать до написания хотя бы одной инструкции. Вот реалистичная раскладка для типичного 256-байтного интро для ZX Spectrum с визуальной частью и звуком:

| Компонент | Байты | Примечания |
|-----------|-------|------------|
| Заливка пикселей (дизеринг/очистка) | 18-25 | LD HL, LDIR или компактный цикл заполнения |
| Инициализация AY | 16-22 | Микшер, громкость, начальный тон -- через запись в порты |
| Синхронизация с кадром в главном цикле | 1 | HALT |
| Обновление тона AY за кадр | 10-14 | Выбор регистра, запись периода тона |
| Ядро визуального эффекта | 30-50 | Внутренний цикл, вычисляющий и записывающий атрибуты |
| Внешний цикл / управление строками | 8-12 | Счётчик строк, счётчик столбцов, переходы |
| Обновление счётчика кадров (SMC) | 6-8 | Чтение, инкремент, запись обратно в инструкцию |
| Возврат к началу главного цикла | 2 | JR main_loop |
| **Итого каркас** | **~91-134** | До любого кода, специфичного для эффекта |

Остаётся 122-165 байт на собственно творческое содержание -- визуальную формулу, таблицы данных, дополнительную звуковую логику, текстовые строки или что угодно ещё, что делает интро *твоим*. Каркас стоит дорого. Вот почему сайзкодеры так отчаянно борются за каждый байт в обвязке: каждый байт, сэкономленный в каркасе -- это байт, выигранный для искусства.

Посмотри на сопровождающий пример `intro256.a80`. Его цикл заливки пикселей занимает 18 байт. Настройка AY -- 20 байт. Каркас главного цикла (HALT, чтение счётчика кадров, обновление бордюра) -- 8 байт. Обновление тона AY -- 13 байт. Визуальный эффект -- паттерн интерференции Муара, вычисленный исключительно из регистровой арифметики -- занимает 36 байт. Запись счётчика кадров и переход на начало цикла -- 8 байт. Итого: около 103 байт каркаса и 36 байт эффекта. Это соотношение -- примерно 3:1 каркас к эффекту -- типично. Чем лучше ты сожмёшь каркас, тем больше места останется для творческого самовыражения.

![Вывод 256-байтного интро -- анимированный паттерн интерференции Муара с цветовым циклированием, сгенерированный исключительно из регистровой арифметики](../../build/screenshots/ch13_intro256.png)

### Ключевые техники на 256 байтах

**1. Используй начальное состояние регистров и памяти.** После стандартной загрузки с ленты регистры содержат известные значения: A часто содержит последний загруженный байт, BC -- длину блока, HL указывает вблизи конца загруженных данных. Область системных переменных ($5C00-$5CB5) содержит известные значения. Экранная память чиста после CLS. Каждое известное значение, которое ты используешь вместо явной загрузки, экономит 1-3 байта.

**2. Перекрывай код и данные.** Байт $3E -- опкод для `LD A, n` и также значение 62 -- ASCII-символ, координата экрана или значение регистра AY. Если твоя программа выполняет этот байт как инструкцию *и* читает его как данные из другого пути кода, ты заставил один байт делать две работы. Типичный паттерн: непосредственный операнд `LD A, n` одновременно служит данными, которые другая подпрограмма читает через `LD A, (addr)`, указывая на instruction_address + 1.

**3. Выбирай инструкции по размеру.**

| Большая кодировка | Маленькая кодировка | Экономия |
|-------------------|---------------------|----------|
| `CALL $0010` (3 байта) | `RST $10` (1 байт) | 2 байта |
| `JP label` (3 байта) | `JR label` (2 байта) | 1 байт |
| `LD A, 0` (2 байта) | `XOR A` (1 байт) | 1 байт |
| `CP 0` (2 байта) | `OR A` (1 байт) | 1 байт |

Инструкции RST критичны. `RST n` -- это 1-байтный CALL к одному из восьми адресов ($00, $08, $10, $18, $20, $28, $30, $38). На Spectrum `RST $10` вызывает вывод символа через ПЗУ, `RST $28` входит в калькулятор. В обычном демо эти подпрограммы ПЗУ слишком медленны. На 256 байтах экономия 2 байт на CALL -- это всё.

**Каждый JP в 256-байтном интро должен быть JR** -- вся программа помещается в диапазон -128..+127.

**4. Самомодифицирующийся код (SMC) для повторного использования последовательностей.** Нужна подпрограмма, оперирующая двумя разными адресами? Захардкодь первый и запатчь операнд для второго вызова. Дешевле, чем передача параметров.

**5. Математические соотношения между константами.** Если твоей музыке нужен период тона 200 и эффекту нужен счётчик цикла 200, используй один и тот же регистр. Если одно значение вдвое больше другого, используй `ADD A, A` (1 байт) вместо загрузки второй константы (2 байта).

---

## 13.3 Знаменитые 256-байтные интро: что делало их гениальными

Категория 256-байтных интро для ZX Spectrum имеет богатую историю. Изучение победивших работ показывает, какие эффекты помещаются в 256 байт и какие творческие стратегии приводят к успеху.

**Атрибутные эффекты доминируют.** Причина арифметическая: область атрибутов Spectrum -- это 768 байт (32 x 24), и её можно заполнить вычисленным паттерном, используя плотный вложенный цикл из 15-20 байт. Пиксельные эффекты требуют адресации 6144 байт чересстрочной экранной памяти -- значительно больше кода только на вычисление адреса. На 256 байтах ты просто не можешь позволить себе эти накладные расходы. Поэтому подавляющее большинство 256-байтных интро работают в пространстве атрибутов: цветовые плазмы, интерференционные паттерны, градиентные анимации, циклирование цветов. Пиксельная память либо остаётся пустой, либо получает одноразовую заливку дизерингом, либо остаётся с тем, что туда записал ROM.

**Генеративный звук побеждает секвенсированный.** Таблица нот для мелодии стоит байтов -- даже простая 8-нотная последовательность это 8 байт плюс логика индексации. На 256 байтах выигрышная стратегия -- выводить звук из состояния эффекта. Используй счётчик кадров как период тона (высота непрерывно меняется). Используй байт из визуального вычисления как параметр шума. Или используй `LD A, R` -- чтение регистра обновления Z80, который инкрементируется при каждом считывании инструкции -- как псевдослучайный источник, а затем замаскируй его до пентатонического диапазона. Звук не будет композицией, но он будет *присутствовать*, и зрители запомнят "то крохотное интро, в котором была музыка".

**ROM -- твоя библиотека.** Каждый байт 16-килобайтного ROM Spectrum доступен и не считается в твой лимит размера. `RST $10` печатает символы, используя полный шрифтовой рендеринг ROM -- 96 печатных символов, 8x8 пикселей каждый, с управлением курсором. Это тысячи байт кода рендеринга, доступных за 1 байт на вызов. `RST $28` открывает доступ к калькулятору с плавающей точкой, который умеет вычислять синус, косинус и квадратные корни -- операции, которые стоили бы десятков байт для самостоятельной реализации. Цена -- скорость (подпрограммы ROM медленные), но в 256-байтном интро, работающем на 50fps с простым эффектом, у тебя часто есть такты в запасе.

**Побеждают те работы, которые выглядят невозможными при своём размере.** Судьи и зрители реагируют на разрыв между воспринимаемой сложностью и размером файла. 256-байтное интро с плавной цветовой плазмой и узнаваемой мелодией вызывает больше аплодисментов, чем интро с чуть лучшей визуальной частью, но без звука. Трюк в том, чтобы выбрать эффект, который *выглядит* сложным, но *кодируется* дёшево. Интерференционные паттерны на основе XOR идеальны: визуально замысловатые, математически тривиальные. Циклирование цветов через атрибуты -- ещё один: глаз воспринимает движение и глубину, но код -- это просто инкремент значений в цикле. Диагональные скроллинговые паттерны, шахматные анимации, расширяющиеся кольца -- всё это можно произвести менее чем из 20 байт кода внутреннего цикла, если формула выбрана аккуратно.

---

## 13.4 Трюк LPRINT

В 2015 году diver4d опубликовал "Secrets of LPRINT" на Hype, документируя технику старше самой демосцены -- впервые появившуюся в пиратских загрузчиках кассетного софта в 1980-х.

### Как это работает

Системная переменная по адресу 23681 ($5C81) управляет тем, куда подпрограммы вывода BASIC направляют данные. Обычно она указывает на буфер принтера. Измени её, чтобы она указывала на экранную память, и LPRINT пишет прямо на экран:

```basic
10 POKE 23681,64: LPRINT "HELLO"
```

Этот единственный POKE перенаправляет канал принтера на $4000 -- начало экранной памяти.

### Эффект транспозиции

Визуальный результат -- не просто текст на экране -- это *транспонированный* текст. Экранная память Spectrum чересстрочная (Глава 2), но драйвер принтера пишет последовательно. Данные попадают в экранную память согласно линейной логике драйвера, но *отображаются* согласно чересстрочной раскладке. Результат проходит через 8 визуальных состояний по мере продвижения через трети экрана -- каскад данных, который строится горизонтальными полосами, смещаясь и рекомбинируя.

С другими символьными данными -- графическими символами, UDG или тщательно подобранными ASCII-последовательностями -- транспозиция производит поразительные визуальные паттерны. Оператор LPRINT обрабатывает всю адресацию экрана, рендеринг символов и продвижение курсора. Твоя программа предоставляет только данные.

### От пиратских загрузчиков к демо-арту

diver4d проследил трюк до пиратских загрузчиков с кассет. Пираты, добавлявшие собственные загрузочные экраны, нуждались в визуальных эффектах в очень малом количестве байт BASIC -- LPRINT был идеален. Техника вышла из употребления, когда сцена перешла на машинный код.

Но в 2011 году JtN и 4D выпустили **BBB** -- демо, намеренно вернувшееся к LPRINT как художественному высказыванию. Старый трюк пиратских загрузчиков, оформленный с намерением, стал демо-артом. Ограничение -- BASIC, хак перенаправления принтера, без машинного кода -- стало медиумом.

### Почему это важно для sizecoding

LPRINT достигает сложного вывода на экран при почти нулевом расходе твоего собственного кода. ПЗУ делает тяжёлую работу. Твой вклад: POKE для перенаправления вывода, данные для печати и `RST $10` (или LPRINT) для запуска. Ты используешь 16K ПЗУ Spectrum как "бесплатный" движок вывода на экран -- код, который не считается в твой лимит размера.

---

## 13.5 512-байтные интро: пространство для дыхания

Удвоение с 256 до 512 байт -- это не вдвое больше -- это качественно другое. На 256 ты борешься за каждую инструкцию, и звук минимален. На 512 ты можешь иметь полноценный эффект *и* полноценный звук, или два эффекта с переходом.

### Что позволяет каждый размерный уровень

Переход между размерными категориями не линейный. Каждое удвоение открывает качественно новые возможности:

**256 байт** -- это один эффект и, может быть, примитивный звук. Ты не можешь позволить себе таблицу данных длиннее примерно 16 байт. Каждая переменная живёт в регистре или в потоке инструкций (самомодифицирующийся код). Текстовый вывод ограничен несколькими символами. У тебя есть место для одного вложенного цикла с 2-3 арифметическими операциями во внутреннем теле. Визуальная часть будет атрибутной, сгенерированной исключительно из арифметики. Звук, если он есть -- это свип тона или случайные ноты.

**512 байт** позволяют добавить таблицу синусов (32-64 байта), настоящий музыкальный движок AY (мелодия + бас на двух каналах) или второй визуальный эффект с переходом. Ты можешь позволить себе полноценный конечный автомат с подсчётом кадров, переключающий между двумя частями. Самомодифицирующийся код (SMC) становится структурным, а не отчаянным. У тебя может даже остаться место для короткой текстовой строки (10-20 символов), выводимой через `RST $10`.

**1K (1024 байта)** -- это другой мир. Ты можешь иметь трекерный проигрыватель музыки со сжатым паттерном (один канал с 32-шаговым циклом занимает около 80-120 байт, включая проигрыватель). Множественные эффекты с переходами становятся нормой. Пиксельные эффекты -- простая плазма в пиксельном пространстве, скроллинг текста, растровые полосы -- становятся осуществимы, потому что ты можешь позволить себе вычисление адреса экранной памяти. Ты можешь включить 256-байтную таблицу синусов или сгенерировать её при старте и хранить в буфере. На 1K ограничение всё ещё формирует каждое решение, но решения уже о том, *какие возможности включить*, а не о том, *какие инструкции ты можешь себе позволить*.

Интро на **4K и 8K** приближаются к территории коротких демо. На 4K сжатие становится жизнеспособным, и ты можешь вместить многоэффектные композиции с музыкой -- качественный скачок, рассмотренный в разделе 13.6. 8K-интро -- это отполированное мини-демо, где ограничение больше касается сжатия данных, чем трюков на уровне инструкций. Техники из этой главы по-прежнему применимы, но фокус смещается с "могу ли я сэкономить один байт?" на "могу ли я сжать этот поток данных?"

Оптимальная точка для обучения sizecoding -- 256 байт. На этом размере каждая техника из данной главы обязательна. На 512 у тебя достаточно места для выбора. На 1K мышление сайзкодера помогает, но не доминирует.

### Типичные 512-байтные паттерны

**Плазма через суммы синусов.** Таблица синусов -- дорогая часть. Полная 256-байтная таблица потребляет половину бюджета. Решения: 64-элементная четвертьволновая таблица, зеркалируемая в рантайме (экономит 192 байта), или генерация таблицы при запуске с использованием параболической аппроксимации из Главы 4 (~20 байт кода вместо 256 байт данных).

**Туннель через lookup угла/расстояния.** На 512 байт ты вычисляешь угол и расстояние на лету, используя грубые аппроксимации. Визуальное качество ниже, чем у туннеля Eager (Глава 9), но распознаваемо как туннель.

**Огонь через клеточный автомат.** Каждая ячейка усредняет соседей снизу минус затухание. Несколько инструкций на пиксель, убедительная анимация, и на 512 байт можно добавить атрибуты для цвета *и* звук бипера.

### Самомодифицирующиеся трюки

Самомодификация становится структурной на 512 байтах. Встрой счётчик кадров *внутрь* инструкции:

```z80 id:ch13_self_modifying_tricks
frame_ld:
    ld   a, 0               ; this 0 is the frame counter
    inc  a
    ld   (frame_ld + 1), a  ; update the counter in place
```

Никакой отдельной переменной. Счётчик живёт в потоке инструкций.

Патч смещений переходов для переключения между эффектами:

```z80 id:ch13_self_modifying_tricks_2
effect_jump:
    jr   effect_1               ; this offset gets patched
    ; ...
effect_1:
    ; render effect 1, then:
    ld   a, effect_2 - effect_jump - 2
    ld   (effect_jump + 1), a   ; next frame jumps to effect 2
```

### Трюк с ORG

Выбирай адрес ORG своей программы так, чтобы байты адреса сами были полезными данными. Размести код по адресу $4000, и каждый JR/DJNZ, нацеленный на метки вблизи начала, генерирует маленькие байты смещения -- пригодные как счётчики циклов, значения цвета или номера регистров AY. Если твоему эффекту нужен $40 (старший байт экранной памяти) как константа, размести код по адресу, где $40 естественно появляется в операнде адреса. *Кодировка самого кода* предоставляет данные, нужные тебе в другом месте.

Это самый глубокий уровень головоломки sizecoding.

---

## 13.6 4K-интро: мини-демо

4096 байт -- это точка, где sizecoding переходит от "одного трюка" к "мини-демо". На 256 байтах у тебя есть место для единственного эффекта и, может быть, примитивного звука. На 512 или 1K ты можешь иметь полноценный эффект с музыкой. На 4K ты можешь иметь несколько эффектов, переходы между ними, полный саундтрек и связную повествовательную арку. Разница между 1K и 4K -- качественная, а не просто количественная: это разница между "умным трюком" и "крохотной продукцией".

### Сжатие становится жизнеспособным

Самое крупное изменение на 4K -- сжатие данных начинает окупаться. Хороший Z80-распаковщик -- ZX0, Exomizer или аналогичный -- стоит примерно 150-200 байт кода. На 256 или 512 байтах эти накладные расходы катастрофичны. На 4K это менее 5% твоего бюджета, а отдача огромна: 4K-интро может содержать 6-8K несжатых кода и данных, упакованных до допустимого предела. Твоё фактическое рабочее пространство почти удваивается.

Рабочий процесс превращается в цикл обратной связи: пишешь код, ассемблируешь в сырой бинарник, сжимаешь ZX0, проверяешь размер выходного файла, итерируешь. Число, которое теперь имеет значение -- это не размер ассемблированного файла, а *сжатый* размер. Это меняет твою стратегию оптимизации. Ты больше не считаешь отдельные байты инструкций. Ты думаешь о том, что хорошо сжимается.

Код с повторяющимися паттернами сжимается лучше, чем код с высокой энтропией. Таблица значений синуса сжимается хорошо (гладкая, предсказуемая). Таблица случайных байт -- нет. Код эффекта, повторно использующий похожие последовательности инструкций в разных подпрограммах, сжимается лучше, чем код, где каждая подпрограмма имеет уникальную структуру. Это тонкий сдвиг: ты оптимизируешь не просто ради *маленького кода*, а ради *сжимаемого кода*.

### Музыка помещается

На 256 байтах звук -- роскошь: свип тона или случайные пентатонические ноты. На 4K ты можешь иметь настоящий саундтрек. Крошечный движок проигрывателя AY -- что-то вроде вывода Beepola или собственного минимального трекера -- занимает 200-400 байт. Добавь 500-1000 байт данных паттернов (в сжатом виде), и у тебя полноценная трёхканальная AY-композиция с мелодией, басом и ударными. Эти числа хорошо сжимаются, потому что данные музыкальных паттернов высокоповторяемы.

Влияние на аудиторию непропорционально велико. Звук превращает sizecoding-работу из визуального курьёза в *переживание*. На показах компо интро с музыкой набирают значительно больше голосов, чем молчаливые работы равного визуального качества. Если у тебя есть 4K для работы и ты не включаешь музыку, ты упускаешь очки.

### Многоэффектная структура

В отличие от 256 байт, где ты привязан к единственному визуалу, 4K даёт место для 2-4 различных эффектов с переходами. Структурный каркас весит немного: таблица сцен, отображающая указатели на эффекты к длительностям, стоит, пожалуй, 30 байт:

```z80 id:ch13_multi_effect_structure
scene_table:
    DW effect_plasma    ; pointer to effect routine
    DB 150              ; duration in frames (3 seconds at 50fps)
    DW effect_tunnel
    DB 200
    DW effect_scroller
    DB 250
    DB 0                ; end marker

scene_runner:
    ld   hl, scene_table
.next_scene:
    ld   e, (hl)
    inc  hl
    ld   d, (hl)        ; DE = effect routine address
    inc  hl
    ld   a, (hl)        ; A = duration
    or   a
    ret  z              ; end of table
    inc  hl
    push hl             ; save table pointer
    ld   b, a           ; B = frame counter
.frame_loop:
    push bc
    push de
    call .call_effect
    pop  de
    pop  bc
    halt                ; wait for vsync
    djnz .frame_loop
    pop  hl
    jr   .next_scene

.call_effect:
    push de
    ret                 ; jump to DE via push+ret trick
```

Каждый отдельный эффект может занимать 500-1000 байт кода. На 4K в сжатом виде ты можешь позволить себе три существенных эффекта, таблицу сцен, проигрыватель музыки и логику переходов (затемнение в чёрный между сценами стоит дёшево -- просто обнуляешь область атрибутов).

### GOA4K, inal и Megademica

**GOA4K** от Exploder^XTM -- это знаковое 4K-интро для ZX Spectrum 128K, демонстрирующее, чего можно достичь, когда сжатие встречается с умным кодированием. Оно упаковывает чанковый ротозумер и другие эффекты в 4096 байт -- визуальная часть, которая выглядела бы достойно в полноразмерном демо, сжатая до размера, который поместился бы в один дисковый сектор.

На этом история не заканчивается. **SerzhSoft** взял GOA4K и переделал его в **inal** -- версию только для 48K, всего в 2980 байт. Тот же визуальный удар, на более ограниченной машине, в меньшем количестве байт. Так работает sizecoding-сообщество: один кодер устанавливает планку, другой берёт её с более трудной стартовой позиции.

SerzhSoft продолжил и выиграл компо 4K-интро на **Revision 2019** с **Megademica** -- соревнуясь не в ZX-специфичной категории, а против всех платформ на крупнейшем демосценовском мероприятии мира. ZX Spectrum 4K-интро, судимое наравне с PC и Amiga работами, заняло первое место. Вот траектория, которую открывает sizecoding на 4K: от локальной техники сцены к мировому признанию.

Изучение таких работ выявляет закономерность: лучшие 4K-интро выбирают эффекты, которые визуально впечатляющи *и* хорошо сжимаются, а затем выжимают каждый байт через плотный цикл упаковка-тест-итерация.

### Компромиссы на 4K

Работа на 4K вводит компромиссы, которых не существует при меньших размерах:

**Степень сжатия определяет выбор эффекта.** Не все эффекты сжимаются одинаково. Плазма, опирающаяся на гладкую таблицу синусов, сжимается превосходно -- данные таблицы предсказуемы, а цикл рендеринга повторно использует похожие шаблоны инструкций. Эффект псевдослучайного дизеринга, где каждый пиксель вычисляется по другой формуле, производит код с высокой энтропией, который почти не сжимается. На 4K ты выбираешь эффекты отчасти по их визуальным достоинствам и отчасти по тому, насколько хорошо их реализация пакуется.

**Время загрузки заметно.** Распаковка занимает реальное время -- обычно 1-3 секунды на 3,5 МГц Z80 для нескольких килобайт данных. Зритель видит паузу перед началом интро. Большинство 4K-интро маскируют это простым загрузочным эффектом: заполняют бордюр циклированием цветов, рисуют быстрый паттерн в атрибутах или показывают однокадровый титульный экран. Сам распаковщик работает из небольшого несжатого заглушки в начале файла. Как только распаковка завершается, заглушка прыгает к распакованному коду и начинается настоящее шоу.

**Ты оптимизируешь для упакованного размера, а не для скорости выполнения.** В 256-байтном интро тот же код, что выполняется -- это код, который ты измеряешь. На 4K ты пишешь код, который распаковывается в RAM и затем выполняется оттуда. Ограничения ROM исчезают -- твой распакованный код лежит в свободной RAM. Но цель оптимизации смещается: тебя волнует, сколько байт занимает упакованный бинарник, а не сырой ассемблированный размер. Эффект, который ассемблируется в 900 байт, но сжимается до 400 -- лучше, чем тот, что ассемблируется в 600, но сжимается до 500.

**Подсчёт упакованных байтов.** Процесс сборки получает шаг сжатия. Ассемблируй в бинарник, сожми ZX0 (или выбранным тобой упаковщиком), проверь размер выходного файла. С sjasmplus:

```sh
sjasmplus --nologo --raw=build/intro4k.bin intro4k.a80
zx0 build/intro4k.bin build/intro4k.zx0
ls -l build/intro4k.zx0    # this is the number that must be <= 4096
```

Заглушка распаковщика, добавляемая перед финальным файлом, тоже должна помещаться в лимит 4096 байт. Общий файл = заглушка распаковщика + сжатые данные. Типичный распаковщик ZX0 занимает около 70 байт в своей минимальной форме, оставляя примерно 4026 байт для сжатых данных.

### Категории соревнований

Демосценовские пати предлагают различные категории с ограничением размера помимо классических 256. Распространённые соревновательные уровни включают 4K, 8K и иногда 16K, наряду с меньшими 256 и 512. Конкретные категории варьируются от пати к пати -- Chaos Constructions, DiHalt и Forever все проводили 4K-компо для Spectrum. Некоторые пати объединяют платформы (компо "4K-интро", принимающее работы для любой 8-битной платформы), другие специфичны для Spectrum. Проверяй правила пати перед началом работы -- метод измерения (сырой размер файла против образа загруженной памяти) и точный лимит в байтах имеют значение.

На 8K и 16K подход по сути тот же, что и на 4K, но с большим простором. 8K-интро -- это отполированное мини-демо, где конвейер сжатия стандартен, а творческий вызов -- больше в арт-дирекции, чем в подсчёте байтов. На 16K ты по сути делаешь короткое демо, которое умещается в 16K -- ограничение размера формирует твою амбицию, но не диктует выбор инструкций. Техники sizecoding из этой главы по-прежнему помогают при этих больших бюджетах, но их влияние пропорционально меньше.

---

## 13.7 Практика: пишем 256-байтное интро пошагово

Начни с работающей атрибутной плазмы (~400 байт) и оптимизируй до 256.

### Шаг 1: Неоптимизированная версия

Простая атрибутная плазма: заполни 768 байт атрибутной памяти значениями из сумм синусов, смещёнными счётчиком кадров. Звук: циклическая мелодия на канале A AY. Эта версия чистая, читаемая и примерно 400 байт -- таблица синусов (32 байта), таблица нот (16 байт), инлайн-записи AY и цикл плазмы с табличными поисками.

### Шаг 2: Замени CALL на RST

Любой вызов к адресу ПЗУ, совпадающему с вектором RST, экономит 2 байта за каждое использование. Для вывода AY замени шесть многословных инлайн-записей регистров (~60 байт) маленькой подпрограммой:

```z80 id:ch13_step_2_replace_call_with_rst
ay_write:                      ; register in A, value in E
    ld   bc, $FFFD
    out  (c), a
    ld   b, $BF
    out  (c), e
    ret                        ; 8 bytes total
```

Шесть вызовов (5 байт каждый: загрузка A + загрузка E + CALL) = 30 + 8 = 38 байт. Экономия: ~22 байта.

### Шаг 3: Перекрой данные с кодом

32-байтная таблица синусов в точке входа декодируется как в основном безвредные инструкции Z80 ($00=NOP, $06=LD B,n, $0C=INC C...). Размести её в начале программы. При первом выполнении ЦП спотыкается через эти "инструкции", портя некоторые регистры. Основной цикл затем перепрыгивает через таблицу и больше не выполняет её -- но данные остаются для поиска. Байты таблицы служат двойной цели.

### Шаг 4: Используй состояние регистров

После того как цикл плазмы записал 768 атрибутов, HL = $5B00 и BC = 0 (от любого LDIR, использованного при инициализации). Если следующей операции нужны эти значения, пропусти явные загрузки. Открытие Art-Top в NHBF было именно этим: значения регистров от очистки экрана совпали с длиной текстовой строки. Не запланировано. Замечено.

После каждого прохода оптимизации аннотируй, что содержит каждый регистр в каждой точке. Состояние регистров -- это разделяемый ресурс -- фундаментальная валюта sizecoding.

### Шаг 5: Меньшие кодировки везде

- `LD A, 0` -> `XOR A` (экономия 1 байт)
- `LD HL, nn` + `LD A, (HL)` -> `LD A, (nn)` (экономия 1 байт, если HL не нужен)
- `JP` -> `JR` везде (экономия 1 байт каждый)
- `CALL sub : ... : RET` -> проваливание напрямую (экономия 4 байта)
- `PUSH AF` для временного сохранения вместо `LD (var), A` (экономия 2 байта)

### Шаг 6: Точный подсчёт байтов

Интуиция о "сколько это весит" ненадёжна. Нужно считать. Есть три метода, и серьёзные сайзкодеры используют все три.

**Вывод ассемблера.** sjasmplus может сообщить размер ассемблированного файла. Директива `DISPLAY` печатает в консоль во время ассемблирования, а `ASSERT` обеспечивает соблюдение лимита:

```z80 id:ch13_step_6_counting_bytes
intro_end:
    ASSERT intro_end - init <= 256, "Intro exceeds 256 bytes!"
    DISPLAY "Intro size: ", /D, intro_end - init, " bytes"
```

Запускай ассемблер после каждого изменения. Строка DISPLAY показывает, где ты находишься; ASSERT ловит превышения до того, как ты потратишь время на тестирование сломанного бинарника.

**Анализ файла символов.** Ассемблируй с `--sym=build/intro.sym`, чтобы получить таблицу символов. Сравнивай адреса меток, чтобы определить, сколько байт занимает каждая секция. Когда твоё интро -- 262 байта и тебе нужно срезать 6, файл символов покажет, что инициализация AY -- 22 байта (можешь ли ты убрать 2?), цикл эффекта -- 38 байт (можно ли объединить счётчики строк и столбцов?), обратная запись счётчика кадров -- 8 байт (можно ли реструктурировать до 5?). Без этой раскладки ты гадаешь.

**Инспекция hex-дампа.** После ассемблирования изучи сырой бинарник в hex-редакторе (или `xxd build/intro.bin`). Hex-дамп показывает тебе реальные байты, которые процессор будет выполнять. Ты заметишь избыточности, невидимые в исходнике: две последовательные загрузки, которые можно объединить в одну, опкод, значение которого совпадает с данными, нужными в другом месте, последовательность NOP, оставленную случайным выравниванием. Hex-дамп -- это истина. Исходник -- абстракция над ней.

### Финальный рывок

Последние 10-20 байт -- самые трудные. Структурная перестановка: переставь код так, чтобы проваливания устраняли инструкции JR. Объедини звуковой и визуальный циклы. Встрой байты данных в поток инструкций -- если тебе нужен $07 как данные и тебе также нужен `RLCA` (опкод $07), устрой так, чтобы один служил обоим.

На этом этапе веди лог. Записывай каждое изменение, которое пробуешь: "переместил инициализацию AY перед заливкой пикселей: сэкономил 2 байта (повторное использование регистра C), потерял 1 байт (нужен дополнительный LD B). Итого: +1 байт." Многие изменения не помогают. Некоторые делают хуже. Без лога ты попробуешь один и тот же тупик дважды. С логом ты строишь карту пространства решений.

Пробуй радикальную реструктуризацию. Может ли цикл визуального эффекта заодно обновлять AY? Если внутренний цикл итерирует 768 раз (по одному на каждую ячейку атрибутов), и ты записываешь новое значение тона каждые 32 итерации (раз в строку), обновление звука происходит внутри визуального цикла ценой одной проверки `BIT 4, E` / `JR NZ` -- 4 байта, чтобы объединить две подпрограммы, которым раньше нужен был отдельный каркасный код. Иногда слияние экономит 10 байт; иногда стоит 5. Ты не узнаешь, пока не попробуешь.

**Запасной выход: выбери другой эффект.** Если твоя плазма требует таблицу синусов и ты на 30 байт превышаешь лимит, никакая микрооптимизация тебя не спасёт. Переключись на эффект, генерирующий визуал из чистой регистровой арифметики: XOR-паттерны, модулярная арифметика, битовые манипуляции. Интерференционный паттерн на основе XOR, как в `intro256.a80`, не требует ни одного байта данных. Визуал менее плавный, чем синусная плазма, но он помещается. На 256 байтах "помещается" -- единственный критерий, который имеет значение.

Ты вглядываешься в hex-дамп. Ты пробуешь переместить звуковую подпрограмму перед визуальной. Ты пробуешь заменить таблицу синусов на рантайм-генератор. Каждая попытка перетасовывает байты. Иногда всё сходится.

Удовлетворение от вмещения связного аудиовизуального опыта в 256 байт -- от решения головоломки -- реальное и особенное, и не похожее ни на какое другое чувство в программировании.

---

## 13.8 Sizecoding-музыка: Bytebeat на AY

В PC-демосцене **bytebeat** -- это формульный подход к звуку: единственное выражение вроде `t*((t>>12|t>>8)&63&t>>4)` генерирует PCM-сэмплы, производя удивительно сложную музыку из нескольких байт кода. Концепция была популяризирована Viznut (Ville-Matias Heikkilä) в 2011 году, и 256-байтные PC-интро регулярно используют bytebeat для своих саундтреков.

На ZX Spectrum ситуация другая. AY-3-8910 -- это не ЦАП, а генератор тона и шума с регистрами периода и громкости для каждого канала. Ты не можешь подавать ему PCM-сэмплы в традиционном смысле (воспроизведение сэмплов через регистр громкости существует, но стоит слишком много тактов для sizecoding-интро). Вместо этого "AY bytebeat" означает вычисление **периодов тона и огибающих громкости по математическим формулам**, управляемым счётчиком кадров.

Принцип тот же, что и в PC bytebeat: замени хранимые музыкальные данные формулой. Цель вывода другая.

### Минимальный формульный движок AY

Типичный подход в 256-байтном интро:

```z80 id:ch13_the_minimal_ay_formula_engine
; Frame-driven AY "bytebeat" — ~20 bytes
; A = frame counter (incremented each HALT)
    ld   e, a
    and  $1F              ; period = low 5 bits of frame
    ld   d, a             ; D = tone period low
    ld   a, e
    rrca
    rrca
    rrca
    and  $0F              ; volume = bits 5-7 of frame, shifted
    ; Write to AY: register 0 = tone period low, register 8 = volume
```

Это производит циклический тон, плавающий по периодам и затухающий/нарастающий -- не музыку в каком-либо традиционном смысле, но узнаваемо структурированный звук. Трюк в том, чтобы выбрать формулы, производящие **музыкально интересные паттерны** из простых побитовых операций.

### Техники для более качественного звука из формул

**Пентатоническое маскирование.** Сырые побитовые формулы производят хроматический шум. Пропусти значение периода через пентатоническую таблицу подстановки (5 байт: интервалы нот), чтобы ограничить вывод приятной гаммой. Пять байт данных покупают музыкально связный звук.

**Многоканальные формулы.** AY имеет три тональных канала. Используй разные битовые ротации одного и того же счётчика кадров для каждого канала -- они произведут связанные, но различные паттерны, создавая впечатление гармонии:

```z80 id:ch13_techniques_for_better
    ld   a, (frame)
    call .write_ch_a      ; channel A: raw formula
    ld   a, (frame)
    rrca
    rrca                  ; channel B: frame >> 2
    call .write_ch_b
    ld   a, (frame)
    add  a, a             ; channel C: frame << 1
    call .write_ch_c
```

**Шумовая перкуссия.** Включай генератор шума на определённых интервалах кадров (каждый 8-й или 16-й кадр) для ритмического пульса. Стоимость: один `AND` + один `OUT` -- около 6 байт для базового паттерна бочки.

**LD A,R как энтропия.** Регистр R (счётчик обновления памяти) фактически случаен с музыкальной точки зрения. Смешай его со счётчиком кадров: `ld a,r : xor (frame)` производит эволюционирующие текстуры, которые никогда полностью не повторяются. Полезно для эмбиентных или экспериментальных звуковых ландшафтов.

### Bytebeat против секвенсированной музыки

| | Bytebeat (формула) | Секвенсированная (данные паттернов) |
|---|---|---|
| **Байты** | 10-30 (только код) | 200-400 (проигрыватель) + 500+ (паттерны) |
| **Музыкальное качество** | Абстрактное, генеративное, инопланетное | Мелодичное, структурированное, человеческое |
| **Лучше всего для** | 256b, 512b | 1K, 4K |
| **Звук** | Ритмический шум, свипы, дроны | Настоящие мелодии |

На 256 байтах bytebeat -- твой единственный реалистичный вариант: для проигрывателя паттернов нет места. На 512 ты можешь позволить себе крошечный секвенсор с 4-8 нотами. На 4K используй настоящий проигрыватель. Подход bytebeat не уступает -- он производит *другой вид* звука, соответствующий эстетике крошечных программ. Некоторые из самых запоминающихся 256-байтных интро запомнились именно потому, что их звук был инопланетным и генеративным, а не потому, что он имитировал конвенциональную музыку.

---

## 13.9 Процедурная графика: компо Rendered GFX

Некоторые демосценовские пати проводят соревнование **rendered graphics** (или **procedural graphics**): подай программу, которая генерирует статичное изображение. Никаких предварительно нарисованных битмапов, никаких загруженных данных -- каждый пиксель должен быть вычислен. Визуальный результат оценивается как произведение искусства, но он должен быть рождён из кода.

На Spectrum это значит, что твоя программа заполняет 6912-байтную область экрана (битмап + атрибуты) алгоритмически, а затем останавливается. Изображение остаётся на экране для оценки. Лимиты размера файла варьируются -- некоторые компо допускают любой размер, другие устанавливают ограничение в 256 байт или 4K, превращая это в гибрид sizecoding и цифрового искусства.

### Почему Spectrum интересен для этого

Ограничения дисплея Spectrum -- 1-битные пиксели с 8x8 атрибутным цветом -- делают процедурную графику подлинно другим вызовом по сравнению с 256-цветным VGA или 24-битным фреймбуфером. Ты не можешь просто вычислить RGB-значения для каждого пикселя. Ты должен думать в терминах:

- **Пиксельные паттерны** внутри 8x8 знакомест (дизеринг, полутон)
- **Атрибутный цвет** на знакоместо (2 цвета из палитры в 15)
- **Взаимодействие** пиксельного паттерна и атрибута -- для градиента нужны и плавный дизеринг, И плавные переходы атрибутов

Это ограничение создаёт характерный визуальный стиль. Процедурная графика на Spectrum не похожа ни на что другое -- цветовая сетка придаёт ей мозаичное качество, которое является частью эстетики, а не недостатком, который нужно скрывать.

### Распространённые подходы

**Множества Мандельброта и Жюлиа.** Классический выбор. Цикл итерации компактен (~30-50 байт для ядра), а фрактальная детализация бесконечна -- координаты масштабирования и количество итераций -- единственные параметры. Сопоставь количество итераций с паттерном дизеринга для пиксельных данных, сопоставь с индексом палитры для атрибутов. Рендерер Мандельброта комфортно помещается в 256 байт и производит изображения, которые выглядят нарисованными вручную.

**Интерференционные паттерны.** Множество наложенных друг на друга синусоидальных или косинусоидальных волн, дискретизированных в каждой позиции пикселя. `pixel = sin(x*freq1 + phase1) + sin(y*freq2 + phase2) > threshold`. Производит органические, текучие формы. На Spectrum пороговое значение суммы даёт пиксельный бит, квантование даёт атрибутный цвет.

**Поля расстояний.** Вычисли расстояние от каждого пикселя до набора фигур (кругов, линий, кривых Безье). Пороговое значение расстояния для пиксельных данных, отображение на цвет для атрибутов. Несколько фигур могут произвести удивительно сложные изображения -- одних наложенных кругов достаточно для создания замысловатых паттернов.

**L-системы и фракталы.** Рекурсивные ветвящиеся структуры (деревья, папоротники, треугольники Серпинского). Рекурсия естественно ложится на стековый Z80-код, а визуальный результат имеет органическую сложность при минимальном коде. Рендерер треугольника Серпинского -- это около 20 байт; ветвящееся дерево со случайными углами -- пожалуй, 80.

### Байтовый бюджет для искусства

В компо rendered GFX с ограничением размера каждый байт идёт на визуальную сложность. Нет цикла кадров, нет звука, нет анимации -- только прямолинейная программа, заполняющая экран и останавливающаяся. Это значит, что весь твой бюджет идёт на код рендеринга и генерацию координат. На 256 байтах ты можешь произвести детальный фрактал. На 4K (со сжатием) ты можешь генерировать изображения с множеством слоёв, вычисленными текстурами и тщательным дизерингом, приближающимся к качеству ручной работы.

Критерий оценки -- чисто визуальный: зрители голосуют за изображение, а не за код. Но ограничение по коду формирует эстетику. Процедурная графика на Spectrum имеет узнаваемый вид: математическая точность, фрактальная детализация и характерная цветовая сетка атрибутного рендеринга. Лучшие работы принимают эти ограничения как стиль, а не борются с ними.

---

## 13.10 Sizecoding как искусство

Sizecoding учит вещам, которые улучшают всё твоё кодирование: дисциплина сомнения в каждом байте обостряет осознание кодирования инструкций, привычка искать перекрытия переносится на любую оптимизационную работу, а практика использования начального состояния и побочных эффектов делает тебя лучшим системным программистом.

---

## Итого

- **Sizecoding**-соревнования требуют полных программ в 256, 512, 1K, 4K или 8K байт -- строгие лимиты, требующие принципиально другого подхода к программированию.
- **Инструментарий сайзкодера** включает предположения об инициализации регистров, DJNZ как совмещённый декремент-и-переход, RST как 1-байтный CALL, перекрывающиеся инструкции и эксплуатацию флагов через SBC A,A -- трюки, экономящие 1-5 байт каждый, но накапливающиеся по всей программе.
- **NHBF** (UriS, CC 2025) демонстрирует мышление на 256 байт: каждый байт работает за двоих, состояния регистров одной подпрограммы питают следующую, выбор инструкций диктуется исключительно размером кодировки.
- **Байтовый бюджет** типичного 256-байтного интро выделяет ~90-130 байт на каркас (заливка экрана, инициализация AY, синхронизация с кадром, структура цикла), оставляя 120-160 байт на собственно творческий эффект.
- **Выбор правильного эффекта** важнее микрооптимизации: атрибутные визуалы с арифметическими формулами (XOR, модулярная математика) кодируются дёшево; пиксельные эффекты и таблицы данных потребляют слишком много байт на 256.
- **Трюк LPRINT** (diver4d, 2015) перенаправляет вывод принтера BASIC на экранную память через адрес 23681, производя сложные визуальные паттерны в считанных байтах -- от пиратских загрузчиков с кассет до демо-арта.
- **Каждый размерный уровень качественно отличается:** 256 байт позволяют один эффект с минимальным звуком; 512 добавляют таблицы синусов и двухканальную музыку; 1K открывают пиксельные эффекты, трекерную музыку и несколько частей; 4K пересекают порог территории мини-демо со сжатием, полными саундтреками и многоэффектными композициями.
- **4K-интро** -- это порог, где сжатие становится жизнеспособным: ~200-байтный распаковщик разблокирует 6-8K рабочего пространства, проигрыватели музыки с данными паттернов комфортно помещаются, а таблицы сцен позволяют создать 2-4 различных эффекта с переходами. Цель оптимизации смещается от сырого ассемблированного размера к сжатому упакованному размеру.
- **AY bytebeat** заменяет хранимые музыкальные данные формулами: вычисляй периоды тона и громкости из счётчика кадров, используя побитовую арифметику. На 256 байтах формульный звук (10-30 байт) -- единственный вариант; на 4K переключайся на настоящий проигрыватель паттернов. Пентатоническое маскирование, многоканальная битовая ротация и шумовая перкуссия добавляют музыкальности за минимум байтов.
- **Процедурная графика** (rendered GFX) -- соревнования, требующие вычисления каждого пикселя, а не его загрузки. 1-битные пиксели Spectrum с 8x8 атрибутным цветом делают это уникальным вызовом -- множества Мандельброта, интерференционные паттерны, поля расстояний и L-системы -- все они дают характерные результаты в эстетике атрибутной сетки.
- **Процесс оптимизации** идёт от структурных изменений (устранение таблиц, слияние циклов) к выбору кодировок (RST вместо CALL, JR вместо JP, XOR A вместо LD A,0) к случайным находкам (состояния регистров, совпадающие с потребностями в данных).
- **Точный подсчёт байтов** -- через DISPLAY/ASSERT ассемблера, анализ файла символов и инспекцию hex-дампа -- необходим. Интуиция о размере кода ненадёжна.
- **Трюк с ORG** -- выбор адреса загрузки так, чтобы байты адреса служили полезными данными -- представляет самый глубокий уровень головоломки.

---

## Попробуй сам

1. **Начни большим, ужми маленьким.** Напиши атрибутную плазму со счётчиком кадров. Заставь работать на любом размере. Затем оптимизируй до 512 байт, отслеживая каждый сэкономленный байт и как.

2. **Исследуй LPRINT.** В BASIC попробуй `POKE 23681,64 : FOR i=1 TO 500 : LPRINT CHR$(RND*96+32); : NEXT i`. Наблюдай, как транспонированные данные заполняют экран. Экспериментируй с разными диапазонами символов.

3. **Картографируй состояние регистров.** Напиши маленькую программу и аннотируй, что содержит каждый регистр в каждой точке. Ищи места, где выход одной подпрограммы совпадает с нужным входом другой.

4. **Изучи векторы RST.** Дизассемблируй ПЗУ Spectrum по адресам $0000, $0008, $0010, $0018, $0020, $0028, $0030, $0038. Это твои "бесплатные" подпрограммы.

5. **Вызов на 256 байт.** Доведи практику из этой главы до 256 байт. Тебе придётся принимать трудные решения о том, что оставить, а что отбросить. В этом и суть.

---

*Далее: Глава 14 -- Сжатие: больше данных в меньшем пространстве. Мы переходим от программ, умещающихся в 256 байт, к задаче вмещения килобайтов данных в килобайты хранилища, с исчерпывающим бенчмарком Introspec'а 10 упаковщиков в качестве руководства.*

> **Источники:** UriS "NHBF Making-of" (Hype, 2025); diver4d "LPRINT Secrets" (Hype, 2015)
