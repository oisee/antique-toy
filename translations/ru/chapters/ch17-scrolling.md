# Глава 17: Скроллинг

> «Экран шириной 256 пикселей. Уровень — 8 000. Каким-то образом игрок должен пройти через него.»

---

Каждой игре с боковым скроллингом нужно двигать мир. Игрок бежит вправо, фон сдвигается влево. Выглядит просто. На оборудовании с регистром скроллинга — NES, Mega Drive, Agon Light 2 — это *действительно* просто: запиши смещение, и железо сделает остальное. На ZX Spectrum регистра скроллинга нет. Нет никакой аппаратной поддержки. Чтобы прокрутить экран, ты двигаешь байты сам. Все 6 144.

Эта глава разбирает все практические методы скроллинга на Spectrum, от самого дешёвого до самого дорогого: скроллинг атрибутов (768 байт, тривиально), вертикальный пиксельный скроллинг (непросто из-за чересстрочной раскладки экрана из Главы 2), горизонтальный пиксельный скроллинг (дорого — каждый байт в каждой строке нужно сдвинуть) и комбинированный метод, который используют настоящие игры для плавного горизонтального скроллинга в рамках приемлемого бюджета. Мы подсчитаем каждый такт (T-state), построим сравнительные таблицы и покажем, как трюк с теневым экраном на 128K делает всё это без разрывов.

Затем мы посмотрим, как Agon Light 2 решает ту же задачу с помощью аппаратных смещений скроллинга и поддержки тайлмапов — полезное сравнение, которое показывает, что на самом деле означает «один и тот же ISA, но другое железо».

---

## Бюджет

Прежде чем мы напишем хоть одну инструкцию, давай определим, с чем мы работаем.

На Pentagon (модель тайминга, на которую ориентируется большинство демо и игр для Spectrum) один кадр — это **71 680 тактов (T-state)**. На стандартном 48K/128K Spectrum — 69 888. Мы будем использовать цифры Pentagon на протяжении всей главы, но анализ применим к обоим — разница составляет около 2,5%.

Полноэкранный скроллинг означает перемещение данных по всем 6 144 байтам экранной памяти (и, возможно, 768 байтам области атрибутов). Вопрос всегда один и тот же: можем ли мы уложиться в один кадр, и если да, сколько тактов останется на всё остальное — игровую логику, отрисовку спрайтов, музыку, ввод?

Вот чистая стоимость одного только *прохода* по каждому байту пиксельной области разными методами:

| Метод | На байт | 6 144 байта | % кадра |
|--------|----------|-------------|------------|
| `ldir` | 21 T | 129 019 T | 180% |
| LDI-цепочка | 16 T | 98 304 T | 137% |
| `ld a,(hl)` + `ld (de),a` + `inc hl` + `inc de` | 24 T | 147 456 T | 206% |
| `push` (2 байта) | 5,5 T/байт | 33 792 T | 47% |

Первые три метода не могут переместить всю пиксельную область за один кадр. Даже LDI-цепочки, самый быстрый метод копирования после PUSH, превышают бюджет на 37%. А скроллинг — это не просто копирование: горизонтальный скроллинг требует операции *сдвига* для каждого байта, что увеличивает стоимость на байт.

Вот почему скроллинг на Spectrum — это задача проектирования, а не просто кодирования. Нельзя решить полноэкранный пиксельный скроллинг на 50fps грубой силой. Нужно выбирать метод исходя из того, что может себе позволить твоя игра.

---

## Вертикальный пиксельный скроллинг

Вертикальный скроллинг перемещает содержимое экрана вверх или вниз на одну или несколько строк пикселей. Концептуально это просто: скопировать каждую строку на позицию строки выше (для скроллинга вверх) или ниже (для скроллинга вниз). На линейном фреймбуфере это было бы одно блочное копирование. На Spectrum чересстрочная раскладка экрана (Глава 2) делает задачу значительно интереснее.

### Проблема чересстрочности

Вспомни структуру адресов экрана из Главы 2:

```text
High byte:  0 1 0 T T S S S
Low byte:   L L L C C C C C
```

Где TT = треть (0–2), SSS = строка развёртки внутри знакоряда (0–7), LLL = знакоряд внутри трети (0–7), CCCCC = байт столбца (0–31).

Чтобы прокрутить вверх на один пиксель, нужно скопировать содержимое строки N в строку N-1 для каждой строки от 1 до 191. Адреса источника и приёмника для соседних строк пикселей *не* разделены постоянным смещением. Внутри знакоряда последовательные строки отличаются на $0100 в старшем байте (просто `INC H` / `DEC H`). Но на границах знакоряда — каждую 8-ю строку — соотношение меняется: нужно добавить 32 к L и сбросить биты строки развёртки в H. На границах третей (каждую 64-ю строку) корректировка снова другая.

### Алгоритм: сдвиг вверх на один пиксель

Подход, который работает *с* чересстрочностью, а не против неё, использует структуру раздельных счётчиков из Главы 2. Поддерживай два указателя (источник и приёмник) и продвигай оба, используя естественную иерархию экрана: 3 трети, 8 знакорядов на треть, 8 строк развёртки на знакоряд. Внутри каждого знакоряда перемещение между строками развёртки — это просто `INC H` / `INC D` для источника и приёмника. На границах знакорядов нужно сбросить биты строки развёртки и добавить 32 к L. На границах третей — добавить 8 к H и сбросить L. Внутренний цикл копирует 32 байта на строку с помощью LDIR или LDI-цепочки, а продвижение указателей встроено в структуру внешнего цикла.

### Анализ стоимости

Для каждой из 191 копии строки мы должны скопировать 32 байта из источника в приёмник. С использованием LDIR:

- На строку: 32 байта x 21 такт (T-state) - 5 = 667 тактов на LDIR, плюс накладные расходы на управление указателями.
- Управление указателями (сохранение/восстановление источника и приёмника, продвижение строки развёртки): примерно 60 тактов на строку внутри знакоряда, больше на границах.

**Итого с LDIR: примерно 143 000 тактов.** Это примерно **два полных кадра**. Вертикальный пиксельный скроллинг на одну строку с использованием LDIR не умещается в один кадр.

Можно лучше. Заменим LDIR на LDI-цепочку — 32 инструкции LDI на строку:

- На строку: 32 x 16 = 512 тактов на LDI, плюс ~50 тактов на управление указателями.
- Итого: 191 x 562 = **107 342 такта.** Всё ещё превышает бюджет примерно на 50%.

PUSH-трюк здесь неудобен, потому что нам нужно копировать *между* двумя несмежными областями с непостоянным соотношением. PUSH записывает по последовательным убывающим адресам, что не соответствует чересстрочной схеме источника/приёмника.

### Частичный скроллинг: практичный подход

В реальности большинство игр не прокручивают весь экран из 192 строк. Типичная игра резервирует:

- Верхние 2 знакоряда (16 пикселей) под строку состояния — не прокручиваются.
- Нижний 1 знакоряд (8 пикселей) под строку очков — не прокручивается.
- Середина: 21 знакоряд = 168 строк пикселей = область скроллинга.

168 строк вертикального пиксельного скроллинга с LDI-цепочками: 168 x 562 = **94 416 тактов**, или 132% кадра. Всё ещё слишком много для одного кадра, если ты хочешь оставить время на что-то ещё.

Вот почему чистый вертикальный пиксельный скроллинг по 1 пикселю за кадр — редкость в играх для Spectrum. Распространённые подходы:

1. **Скроллинг на 8 пикселей (один знакоряд):** Перемещаем атрибуты и выровненные по знакорядам пиксельные данные. Это гораздо дешевле, потому что копируешь только 21 знакоряд x 8 строк развёртки = 168 строк, но можно использовать трюк с блочным копированием: внутри каждой трети знакоряды хранятся непрерывными блоками. Стоимость: около 40 000–50 000 тактов с LDIR. Выполнимо.

2. **Скроллинг на 1 пиксель с помощью счётчика:** Визуально скроллим на 1 пиксель за кадр, комбинируя посимвольный скроллинг (дёшево, каждые 8 кадров) со счётчиком пиксельного смещения (рисуем новое содержимое со смещением внутри 8-пиксельного знакоряда). Мы рассмотрим этот комбинированный подход в разделе горизонтального скроллинга ниже, потому что там он нужен гораздо чаще.

3. **Использование теневого экрана (только 128K):** Рисуем сдвинутое содержимое в задний буфер, затем переключаем. Это устраняет разрывы и позволяет распределить работу по кадрам. Мы рассмотрим это далее в главе.

### Скроллинг на 8 пикселей (один знакоряд)

Скроллинг на целый знакоряд драматически дешевле, потому что источник и приёмник связаны простым смещением внутри каждой трети. Знакоряды внутри трети расположены через 32 байта в L. Так что скроллинг на один знакоряд вверх означает копирование из L+32 в L для каждой строки развёртки и каждой трети.

Для скроллинга игровой области на один знакоряд ключевое наблюдение в том, что в пределах одной строки развёртки знакоряды хранятся непрерывно (через 32 байта). Строка развёртки 0 знакорядов 0–7 в трети лежит по адресам `$xx00`, `$xx20`, `$xx40`, ..., `$xxE0`. Скроллинг N знакорядов вверх на одну позицию в пределах одной строки развёртки — это, таким образом, одно блочное копирование (N-1) x 32 байт.

Для 20-знакорядной игровой области данные одной строки развёртки — это 20 x 32 = 640 байт. Скроллинг этой строки развёртки означает копирование 19 x 32 = 608 байт вперёд на 32. Мы делаем это для каждой из 8 строк развёртки, обрабатывая границы третей отдельно.

**Примерная стоимость:** 8 строк развёртки x ~12 700 тактов на строку развёртки (608 байт через LDIR) + обработка границ третей = примерно **105 000 тактов**. Это 146% кадра.

Даже посимвольный скроллинг всей игровой области за один кадр — это впритык. Игры справляются с этим, используя:

- **Скроллинг во время гашения (бордюра).** Верхний и нижний бордюр на Pentagon дают примерно 14 000 тактов свободного времени, когда нет конфликтов.
- **Разделение на два кадра.** Скроллим верхнюю половину в одном кадре, нижнюю — в следующем. Визуальный результат — 25fps скроллинг с 8-пиксельными прыжками.
- **Использование теневого экрана** (см. ниже).

---

## Горизонтальный пиксельный скроллинг

Горизонтальный скроллинг — хлеб с маслом для игр с боковым скроллингом: мир сдвигается влево или вправо по мере движения игрока. И это самый дорогой тип скроллинга на Spectrum, потому что он требует не просто копирования байтов, а их *сдвига*.

### Почему горизонтальный скроллинг дорог

Когда ты прокручиваешь экран влево на один пиксель, каждый байт в каждой строке должен сдвинуть свои биты влево на одну позицию, и бит, выпавший с левого края одного байта, должен стать самым правым битом его левого соседа. Это цепочка вращения с переносом по всем 32 байтам каждой строки.

Инструкция Z80 `RL` (вращение влево через перенос) — инструмент для этого. Для скроллинга влево каждый пиксель сдвигается на одну позицию влево. Бит 7 — самый левый пиксель в байте, бит 0 — самый правый. Сдвиг влево означает, что бит 7 каждого байта выходит и должен войти в бит 0 байта слева. Флаг переноса связывает соседние байты, поэтому мы обрабатываем строку **справа налево**:

```z80 id:ch17_why_horizontal_scrolling_is
; Scroll one pixel row left by 1 pixel
; HL points to byte 31 (rightmost) of the row
;
; Process right to left. Each byte rotates left; carry propagates.
;
    or   a                    ; 4 T   clear carry (no pixel entering from right)

    ; Byte 31 (rightmost)
    rl   (hl)                 ; 15 T  shift left, bit 7 -> carry, carry -> bit 0
    dec  hl                   ; 6 T
    ; Byte 30
    rl   (hl)                 ; 15 T
    dec  hl                   ; 6 T
    ; ...repeat for bytes 29 down to 0...
    ; Byte 0 (leftmost)
    rl   (hl)                 ; 15 T  bit 7 of byte 0 is lost (scrolled off screen)
```

Каждый байт обходится в: 15 (RL (HL)) + 6 (DEC HL) = **21 такт (T-state)** на байт. Для 32 байт в строке: 32 x 21 - 6 = **666 тактов** на строку (последний DEC HL нам не нужен).

На самом деле первому байту нужен `OR A` (4 T) для сброса переноса. Итого одна строка стоит: 4 + 32 x 15 + 31 x 6 = 4 + 480 + 186 = **670 тактов**.

Для 192 строк: 192 x 670 = **128 640 тактов**. Это **179% кадра**.

Полноэкранный горизонтальный пиксельный скроллинг на один пиксель не умещается в один кадр с использованием цепочек RL. И это *только сдвиг* — мы ещё не нарисовали новое содержимое на правом краю.

![Прототип горизонтального скроллинга --- тайловая игровая область с визуализацией побайтового сдвига, показывающей, как цепочка RL распространяет флаг переноса по смежным байтам](../../build/screenshots/proto_ch17_scrolling.png)

### Полный расчёт бюджета

Давай разложим полную стоимость на строку со всеми накладными расходами на навигацию по чересстрочному экрану:

| Операция | Тактов на строку |
|-----------|-----------------|
| Установить HL на начало строки (или продвинуть от предыдущей) | ~15 |
| Установить HL на крайний правый байт: `ld a, l : or $1F : ld l, a` | 15 |
| Сбросить перенос: `or a` | 4 |
| 32 x `rl (hl)` | 480 |
| 31 x `dec hl` (между байтами) | 186 |
| Продвинуться к следующей строке (`inc h` или переход через границу) | 4–77 |
| **Итого на строку (типично)** | **~704** |

Для 192 строк: 192 x 704 = **135 168 тактов** = **189% одного кадра**.

Для 168-строчной игровой области: 168 x 704 = **118 272 такта** = **165% одного кадра**.

Не существует способа выполнить полноэкранный горизонтальный пиксельный скроллинг на один пиксель за один кадр стандартными методами на Z80 с тактовой частотой 3,5 МГц. Это фундаментальное ограничение, которое определяет каждый метод скроллинга в этой главе.

### Можно ли сделать лучше?

Можно подумать, что развёртка циклов или альтернативные режимы адресации помогут. Не помогут. `RL (IX+d)` стоит 23 такта — *больше*, чем `RL (HL)` с его 15 T. Последовательность загрузка-вращение-запись (`LD A,(HL) : RLA : LD (HL),A` при 18 T на байт, плюс 6 T на `DEC HL` = 24 T) тоже медленнее. Цепочка `RL (HL) : DEC HL` при 21 T/байт — это, по сути, оптимум для горизонтального пиксельного скроллинга на Z80.

**Итог:** единственный способ сделать горизонтальный скроллинг доступным — уменьшить количество строк или байтов, которые ты прокручиваешь.

---

## Скроллинг атрибутов (посимвольный)

Если пиксельный скроллинг дорог, то скроллинг атрибутов почти бесплатен по сравнению с ним. Скроллинг атрибутов перемещает изображение прыжками по 8 пикселей (одна ячейка атрибутов). Ты перемещаешь только 768 байт области атрибутов и соответствующие выровненные по знакорядам блоки пикселей — или, что чаще, перемещаешь только атрибуты и перерисовываешь игровую область из тайлмапа.

### Скроллинг атрибутов с помощью LDIR

Область атрибутов линейна: 32 байта на строку, 24 строки, последовательно от `$5800` до `$5AFF`. Скроллинг влево на один столбец символов означает копирование байтов 1–31 на позиции 0–30 в каждой строке, затем запись нового столбца на позицию 31.

Для всей 24-строчной области атрибутов:

```z80 id:ch17_scrolling_attributes_with
; Scroll all attributes left by 1 character column
; New column data in a 24-byte table at new_col_data
;
scroll_attrs_left:
    ld   hl, $5801          ; 10 T  source: column 1
    ld   de, $5800          ; 10 T  dest: column 0
    ld   bc, 767            ; 10 T  768 - 1 bytes
    ldir                    ; 767*21 + 16 = 16,123 T

    ; Now fill the rightmost column with new data
    ld   hl, new_col_data   ; 10 T
    ld   de, $581F          ; 10 T  column 31 of row 0
    ld   b, 24              ; 7 T
.fill_col:
    ld   a, (hl)            ; 7 T
    ld   (de), a            ; 7 T
    inc  hl                 ; 6 T
    ; advance DE by 32 (next attribute row)
    ld   a, e               ; 4 T
    add  a, 32              ; 7 T
    ld   e, a               ; 4 T
    jr   nc, .no_carry      ; 12/7 T
    inc  d                  ; 4 T
.no_carry:
    djnz .fill_col          ; 13 T
    ret

    ; Total LDIR: ~16,123 T
    ; Total column fill: ~24 * 50 = ~1,200 T
    ; Grand total: ~17,323 T = 24.2% of frame
```

**17 323 такта на полноэкранный скроллинг атрибутов.** Это около 24% кадра. Сравни с 135 000+ тактами для пиксельного скроллинга. Скроллинг атрибутов почти в 8 раз дешевле.

Подвох: скроллинг прыгает на 8 пикселей за раз. Визуальный результат — грубый и дёрганый. Для текстовых скроллеров в демо это часто приемлемо — зритель читает текст, а не плавность. Для игры 8-пиксельные прыжки ощущаются ужасно. Вот тут и вступает комбинированный метод.

---

## Комбинированный метод: посимвольный скроллинг + пиксельное смещение

Это техника, которую на самом деле используют большинство игр с боковым скроллингом на Spectrum. Идея проста и мощна:

1. Поддерживай счётчик **пиксельного смещения** от 0 до 7. Каждый кадр увеличивай смещение.
2. Когда смещение достигает 8, сбрось его в 0 и выполни **посимвольный скроллинг** — дешёвую операцию.
3. Каждый кадр рендери игровую область с применённым текущим пиксельным смещением. Это смещение сдвигает весь дисплей на 0–7 пикселей внутри текущих позиций столбцов символов.

Пиксельное смещение можно применить двумя способами:

**Метод A: сдвиг нового столбца.** Сдвигай только один столбец пиксельных данных (столбец, входящий в поле зрения) на текущее смещение. Остальная часть экрана рисуется из тайлов с выравниванием по знакорядам. Это работает, когда у тебя есть тайловый рендерер, перерисовывающий из карты.

**Метод B: виртуальное смещение в стиле железа.** Поддерживай смещение рендеринга, которое контролирует, с какого места внутри каждого знакоряда начинаются данные тайла. Это концептуально похоже на аппаратный регистр скроллинга, но реализовано программно.

Метод A более распространён на практике. Давай разберём его.

### Как это работает

Представь, что игровая область имеет ширину 20 символов (160 пикселей) и высоту 20 символов. Данные уровня — это тайлмап, где каждый тайл имеет размер 8x8 пикселей (одна ячейка атрибутов).

Состояние скроллинга состоит из:
- `scroll_tile_x`: какой столбец тайлов находится на левом краю экрана (целое число, увеличивается на 1 каждые 8 кадров).
- `scroll_pixel_x`: пиксельное смещение внутри текущего тайла (0–7, увеличивается на 1 каждый кадр).

Каждый кадр:

1. **Если `scroll_pixel_x` равен 0:** Перерисовать всю игровую область из тайлмапа с выравниванием по знакорядам. Это тайловый рендерер, который можно сделать быстрым с помощью LDIR или LDI-цепочек (каждая строка тайла — это 1 байт или несколько байт данных, копируемых по правильному адресу экрана). Стоимость: 20 столбцов x 20 строк x ~100 T на тайл = ~40 000 T. Доступно.

2. **Если `scroll_pixel_x` равен 1–7:** Перерисовать игровую область, сдвинутую на `scroll_pixel_x` пикселей. Для большей части игровой области тайлы выровнены по знакорядам и могут быть нарисованы нормально — пиксельное смещение влияет только на **крайний левый и крайний правый видимые столбцы**, где тайл виден частично.

Подожди — это эффективная интерпретация, но она требует тайлового рендерера, который обрезает на субсимвольных границах. Более простой (и более распространённый) подход:

### Простой комбинированный метод

1. Каждые 8 кадров выполняй посимвольный скроллинг (LDIR атрибутов и пиксельных данных влево на один столбец). Стоимость: ~17 000 T для атрибутов + ~40 000 T для пиксельных данных = ~57 000 T. Выполняется раз в 8 кадров.

2. Каждый кадр сдвигай **узкое окно** на 1 пиксель. Это окно шириной всего 1 столбец (32 байта) или 2 столбца (64 байта) — шов между старыми данными и входящим новым столбцом.

3. **Между посимвольными скроллингами** дисплей показывает последнюю позицию после посимвольного скроллинга со смещением 0–7 пикселей, применённым к краевому столбцу. Игрок воспринимает плавный скроллинг по 1 пикселю за кадр.

Вот разбивка стоимости по кадрам:

| Операция | Тактов | Частота |
|-----------|----------|-----------|
| Посимвольный скроллинг (вся игровая область) | ~57 000 | Каждый 8-й кадр |
| Пиксельный сдвиг 1–2 краевых столбцов (20 строк x 2 стлб. x 21 T/байт x 8 строк развёртки) | ~6 720 | Каждый кадр |
| Отрисовка нового столбца тайлов на правом краю | ~5 000 | Каждый 8-й кадр |
| Обновление столбца атрибутов | ~1 200 | Каждый 8-й кадр |

**В 7 из 8 кадров:** ~6 720 тактов на краевой пиксельный сдвиг. Это менее 10% бюджета кадра. Достаточно места для игровой логики, спрайтов и музыки.

**Каждый 8-й кадр:** ~6 720 + 57 000 + 5 000 + 1 200 = ~69 920 тактов. Это 97,5% бюджета кадра. Впритык, но выполнимо — особенно если разбить посимвольный скроллинг на два кадра или использовать теневой экран.

### Реализация: пиксельный сдвиг краевого столбца

Ключевая внутренняя подпрограмма сдвигает 1 или 2 столбца пиксельных данных на 1 пиксель. Для 2-столбцового (16-пиксельного) окна в каждой строке нужно сдвинуть 2 байта:

```z80 id:ch17_implementation_the_edge
; Shift 2 bytes left by 1 pixel with carry propagation
; HL points to the right byte of the pair
;
    or   a                ; 4 T    clear carry
    rl   (hl)             ; 15 T   right byte: shift left, bit 7 -> carry
    dec  hl               ; 6 T
    rl   (hl)             ; 15 T   left byte: carry -> bit 0, bit 7 lost
                          ; total: 40 T per row (for 2-byte window)
```

Для 160 строк (20 знакорядов x 8 строк развёртки): 160 x 40 = **6 400 тактов**. С накладными расходами на продвижение указателей (~20 T на строку) итого около **9 600 тактов** за кадр. Очень доступно.

### Конвейер рендеринга

Вот полная покадровая последовательность для комбинированного горизонтального скроллера:

```z80 id:ch17_the_rendering_pipeline
frame_loop:
    halt                         ; wait for interrupt

    ; --- Always: advance pixel offset ---
    ld   a, (scroll_pixel_x)
    inc  a
    cp   8
    jr   nz, .no_char_scroll

    ; --- Every 8th frame: character scroll ---
    xor  a                       ; reset pixel offset to 0
    ld   (scroll_pixel_x), a

    ; Advance tile position
    ld   hl, (scroll_tile_x)
    inc  hl
    ld   (scroll_tile_x), hl

    ; Scroll pixel data left by 1 column (8 pixels)
    call scroll_pixels_left_char

    ; Scroll attributes left by 1 column
    call scroll_attrs_left

    ; Draw new tile column on right edge
    call draw_right_column

    jr   .scroll_done

.no_char_scroll:
    ld   (scroll_pixel_x), a

    ; Shift the edge columns by 1 pixel
    call shift_edge_columns

.scroll_done:
    ; --- Game logic, sprites, music ---
    call update_entities
    call draw_sprites
    call play_music

    jr   frame_loop
```

Это скелет реального скроллера для Spectrum. Ключевое наблюдение: плавный скроллинг по 1 пикселю достигается *без* сдвига всего экрана каждый кадр. Дорогой посимвольный скроллинг происходит только раз в 8 кадров, а покадровая работа минимальна.

---

## Скроллинг пиксельных данных на один столбец символов

Посимвольный пиксельный скроллинг (шаг 2 в конвейере выше) сдвигает данные на 8 пикселей влево для каждой строки. Поскольку 8 пикселей = 1 байт, это *побайтовое* копирование, а не побитовое вращение. Каждые 32 байта строки сдвигаются влево на 1 байт: byte[1] переходит в byte[0], byte[2] в byte[1], ..., byte[31] в byte[30], а byte[31] очищается или заполняется новыми данными.

Для одной строки это LDIR на 31 байт:

```z80 id:ch17_scrolling_the_pixel_data_by
; Shift one pixel row left by 8 pixels (1 byte)
; HL = address of byte 1 (source), DE = address of byte 0 (dest)
; BC = 31
;
    ldir                     ; 31*21 - 5 = 646 T per row... wait.
                             ; Actually: 30*21 + 16 = 646 T. Yes.
```

Для всей игровой области (168 строк): 168 x 646 = 108 528 тактов + накладные расходы на навигацию по строкам.

Лучший подход использует тот факт, что в пределах каждой строки развёртки знакоряда байты идут непрерывно. Для 20 столбцов символов данные одной строки развёртки — это 20 непрерывных байт. Скроллинг этой строки развёртки влево на 1 байт означает LDIR из 19 байт:

```z80 id:ch17_scrolling_the_pixel_data_by_2
; Scroll one scan line of the play area left by 1 character column
; Play area is 20 columns wide (columns 2-21, for example)
; Source: column 3, Dest: column 2, count: 19
;
    ld   hl, row_addr + 3    ; source = byte 3 of this scan line
    ld   de, row_addr + 2    ; dest   = byte 2
    ld   bc, 19              ; 19 bytes to copy
    ldir                     ; 18*21 + 16 = 394 T
```

Для 160 строк: 160 x 394 = 63 040 тактов. Добавим ~20 T на строку для навигации указателей: 160 x 414 = **66 240 тактов**. Это 92% кадра. Выполнимо, но впритык по бюджету «каждый 8-й кадр».

С LDI-цепочками (19 LDI на строку): 19 x 16 = 304 T на строку. Для 160 строк: 160 x 324 = **51 840 тактов** = 72% кадра. Теперь у нас остаётся 28% на отрисовку нового столбца и обновление атрибутов.

---

## Трюк с теневым экраном

ZX Spectrum 128K имеет возможность, которая преображает задачу скроллинга: **два экранных буфера**. Стандартный экран живёт по адресу `$4000` на странице 5 (всегда отображается в `$4000`–`$7FFF`). Теневой экран живёт по адресу `$C000` на странице 7 (отображается в `$C000`–`$FFFF`, когда страница 7 подключена).

Порт `$7FFD` управляет тем, какой экран отображается:

```z80 id:ch17_the_shadow_screen_trick
; Bit 3 of port $7FFD selects the display screen:
;   Bit 3 = 0: display page 5 (standard screen at $4000)
;   Bit 3 = 1: display page 7 (shadow screen at $C000)

    ld   a, (current_bank)
    or   %00001000           ; set bit 3: display shadow screen
    ld   bc, $7FFD
    out  (c), a
```

Трюк для скроллинга:

1. **Кадр N:** Игрок видит стандартный экран (страница 5). Тем временем ты рисуешь содержимое *следующего* кадра со скроллингом в теневой экран (страница 7, по адресу `$C000`).
2. **Кадр N+1:** Переключи отображение на теневой экран. Игрок теперь видит свежеотрисованный кадр без разрывов. Тем временем ты начинаешь рисовать кадр N+2 в теперь скрытый стандартный экран.

Этот подход с двойной буферизацией полностью устраняет разрывы и даёт тебе полный кадр (или больше) на подготовку каждого сдвинутого кадра. Цена — необходимость поддерживать два полных состояния экрана, и каждый «скроллинг» на самом деле представляет собой полную перерисовку игровой области в задний буфер.

```z80 id:ch17_the_shadow_screen_trick_2
; Flip displayed screen and return back buffer address in HL
;
; screen_flag:  0 = showing page 5, drawing to page 7
;               1 = showing page 7, drawing to page 5
;
flip_screens:
    ld   a, (screen_flag)
    xor  1                   ; 7 T   toggle (XOR with immediate)
    ld   (screen_flag), a

    ld   hl, $C000           ; assume drawing to page 7
    or   a
    jr   z, .show_page5

    ; Now showing page 7, draw to page 5
    ld   hl, $4000
    ld   a, (current_bank)
    or   %00001000           ; bit 3 set: display page 7
    jr   .do_flip

.show_page5:
    ld   a, (current_bank)
    and  %11110111           ; bit 3 clear: display page 5

.do_flip:
    ld   bc, $7FFD
    out  (c), a
    ld   (current_bank), a
    ret                      ; HL = back buffer address
```

### Стратегия скроллинга с теневым экраном

С двойной буферизацией подход к скроллингу меняется:

**Вместо скроллинга активного экрана на месте** (что вызывает разрывы и должно завершиться за один кадр), ты **перерисовываешь игровую область из тайлмапа** в задний буфер на новой позиции скроллинга. Это принципиально другой подход. Ты не *перемещаешь* существующие данные экрана — ты *рендеришь заново* из карты.

Это больше работы за кадр (ты перерисовываешь всю игровую область, а не просто сдвигаешь), но у этого есть значительные преимущества:

1. **Нет разрывов.** Игрок никогда не видит наполовину прокрученный экран.
2. **Нет сдвига краевого столбца.** Ты рендеришь каждый тайл с правильным субсимвольным смещением напрямую.
3. **Гибкая скорость скроллинга.** Можно прокручивать на 1, 2 или 3 пикселя за кадр без изменения логики рендеринга.
4. **Более простой код.** Тайловый рендерер проще, чем комбинированный скроллер со сдвигом и копированием.

Стоимость полной перерисовки игровой области из тайлов зависит от твоего тайлового рендерера. При 20 x 20 тайлах, каждый тайл из 8 байт (8 строк развёртки x 1 байт), с использованием LDI-цепочек:

- 400 тайлов x 8 байт x 16 T на LDI = 51 200 тактов на вывод данных.
- Плюс вычисления адресов тайлов и экрана: ~20 T на тайл x 400 = 8 000 T.
- **Итого: ~59 200 тактов** = 82% кадра.

Остаётся 18% (~12 900 тактов) для спрайтов, игровой логики и музыки. Впритык, но рабочий вариант.

### Сравнение: методы скроллинга на ZX Spectrum

| Метод | Тактов/кадр | % кадра | Визуальное качество | Примечания |
|--------|---------------|------------|----------------|-------|
| Полный пиксельный скроллинг (гориз., 1px) | ~135 000 | 189% | Плавный | Невозможно на 50fps |
| Полный пиксельный скроллинг (верт., 1px) | ~107 000 | 149% | Плавный | Невозможно на 50fps |
| Только скроллинг атрибутов | ~17 000 | 24% | Дёрганый (прыжки 8px) | Очень дёшево |
| Комбинированный (посимв. + пиксельный край) | ~10 000 средн., ~70 000 пик. | 14%/98% | Плавный | Лучший метод для одного буфера |
| Теневой экран + тайловая перерисовка | ~59 000 | 82% | Плавный, без разрывов | Требует 128K |
| Посимвольный скроллинг (прыжки 8px) | ~52 000–66 000 | 73–92% | Дёрганый | Для скроллинга текста/статуса |

<!-- figure: ch17_scroll_costs -->
![Scrolling technique cost comparison](illustrations/output/ch17_scroll_costs.png)

---

## Скроллинг вправо (и проблема направления)

Всё описанное выше относится к скроллингу влево (игрок двигается вправо, мир сдвигается влево). А как насчёт скроллинга вправо?

Для скроллинга атрибутов — меняем направление LDIR. Копируем байты 0–30 на позиции 1–31, справа налево. LDIR копирует вперёд (от младших адресов к старшим), поэтому для скроллинга вправо нужен LDDR (копирование назад):

```z80 id:ch17_scrolling_right_and_the
; Scroll attributes right by 1 character column
;
scroll_attrs_right:
    ld   hl, $5ADE          ; source: last row, column 30
    ld   de, $5ADF          ; dest: last row, column 31
    ld   bc, 767            ; 768 - 1 bytes
    lddr                    ; 767*21 + 16 = 16,123 T
    ret
```

Для побитового пиксельного сдвига скроллинг вправо использует `RR (HL)` вместо `RL (HL)`, обрабатывая строку слева направо:

```z80 id:ch17_scrolling_right_and_the_2
; Scroll one pixel row RIGHT by 1 pixel
; HL points to byte 0 (leftmost)
;
    or   a                ; 4 T    clear carry
    rr   (hl)             ; 15 T   shift right, bit 0 -> carry
    inc  hl               ; 6 T
    rr   (hl)             ; 15 T   carry -> bit 7
    inc  hl               ; 6 T
    ; ... 32 bytes total ...
```

Стоимость на байт идентична: 21 такт (T-state). Скроллинг вправо стоит столько же, сколько скроллинг влево. Комбинированный метод работает в обоих направлениях с одинаковым бюджетом.

Для двунаправленного скроллинга (игрок может идти и влево, и вправо) нужны две версии подпрограмм посимвольного скроллинга и краевого сдвига, переключаемые в зависимости от направления. Самомодифицирующийся код (SMC) здесь полезен: перед скроллингом пропатчи опкод RL/RR и направление INC/DEC в подпрограмме сдвига. Это позволяет избежать ветвления внутри внутреннего цикла (см. паттерн SMC в Главе 3).

---

## Agon Light 2: аппаратный скроллинг

VDP (Video Display Processor) в Agon Light 2 обрабатывает скроллинг совершенно иначе, чем Spectrum. Там, где программист Spectrum должен двигать байты вручную, Agon предоставляет аппаратную поддержку смещений скроллинга и тайлмапов.

### Аппаратные смещения скроллинга

VDP поддерживает смещение окна просмотра для растровых режимов. Задавая регистры смещения скроллинга, ты сдвигаешь всё отображаемое изображение без перемещения пиксельных данных. eZ80 отправляет команду VDP через последовательный канал:

```z80 id:ch17_hardware_scroll_offsets
; Agon: set horizontal scroll offset
; VDU 23, 0, &C3, x_low, x_high
;
    ld   a, 23
    call vdu_write      ; VDU command prefix
    ld   a, 0
    call vdu_write
    ld   a, $C3         ; set scroll offset command
    call vdu_write
    ld   a, (scroll_x)
    call vdu_write      ; x offset low byte
    ld   a, (scroll_x+1)
    call vdu_write      ; x offset high byte
```

Железо применяет это смещение при чтении фреймбуфера для отображения. Пиксельные данные не перемещаются, тактов процессора на сдвиг байтов не тратится, и скроллинг идеально плавный на любой скорости. Стоимость для процессора — лишь накладные расходы на последовательную связь (несколько сотен тактов на последовательность VDU-команд).

### Тайлмаповый скроллинг

Тайлмаповый режим VDP обеспечивает встроенный тайловый рендеринг. Ты определяешь набор тайлов (паттерны 8x8 или 16x16 пикселей), строишь массив карты, ссылающийся на индексы тайлов, и железо рендерит карту во время отображения. Скроллинг достигается изменением смещения окна просмотра тайлмапа:

```z80 id:ch17_tilemap_scrolling
; Agon: set tilemap scroll offset
; VDU 23, 27, <tilemap_scroll_command>, offset_x, offset_y
;
    ld   a, 23
    call vdu_write
    ld   a, 27
    call vdu_write
    ld   a, 14          ; set tilemap scroll offset
    call vdu_write
    ; ... send x and y offsets ...
```

Тайлмап автоматически заворачивается. По мере того как окно просмотра прокручивается за край карты, железо оборачивается на начало (или ты можешь обновить краевой столбец новыми индексами тайлов — техника загрузки столбцов через кольцевой буфер).

### Загрузка столбцов через кольцевой буфер

Для бесконечно прокручиваемого уровня тайлмап действует как кольцевой буфер. Карта шире экрана как минимум на один столбец. По мере скроллинга игрока вправо:

1. Аппаратное смещение скроллинга продвигается на 1 пиксель за кадр (или с любой нужной скоростью).
2. Когда новый столбец тайлов вот-вот войдёт в поле зрения, eZ80 записывает новые индексы тайлов в столбец, который только что ушёл за левый край.
3. Тайлмап оборачивается, и свежезаписанный столбец появляется справа.

```z80 id:ch17_ring_buffer_column_loading
; Ring-buffer column loading (Agon, conceptual)
;
; tilemap is 40 columns wide, screen shows 32
; scroll_col tracks which column is at the left edge
;
ring_buffer_load:
    ld   a, (scroll_col)
    add  a, 32              ; column about to appear on right
    and  39                  ; wrap to tilemap width (mod 40)
    ld   c, a               ; C = column index to update

    ; Load new tile data for this column from the level map
    ; (level_map is a wider array of tile indices)
    ld   hl, (level_ptr)     ; pointer into the level data
    ld   b, 20               ; 20 rows
.load_col:
    ld   a, (hl)             ; read tile index from level
    inc  hl
    ; Write tile index to tilemap at (C, row)
    call set_tilemap_cell    ; VDP command to set one cell
    djnz .load_col

    ld   (level_ptr), hl
    ret
```

Работа процессора за кадр минимальна: запись 20 индексов тайлов через VDP-команды, порядка 2 000–3 000 тактов всего. Остаток кадра доступен для игровой логики. Сравни с 59 000+ тактами Spectrum для тайловой перерисовки при скроллинге. Аппаратный тайлмап Agon даёт примерно 20-кратное снижение нагрузки на процессор для скроллинга.

### Сравнение: Spectrum против Agon — скроллинг

| Аспект | ZX Spectrum | Agon Light 2 |
|--------|-------------|---------------|
| Гранулярность скроллинга | Ограничена программно; 1px возможно, но дорого | 1px нативно, нулевая нагрузка на CPU |
| Нагрузка на CPU за кадр | 10 000–135 000 T | 500–3 000 T |
| Разрывы | Видимы без двойной буферизации | Нет (VDP обеспечивает синхронизацию) |
| Смена направления | Требует альтернативных подпрограмм или SMC | Поменять знак смещения |
| Предел размера карты | Ограничен RAM, нет аппаратной поддержки | Размер тайлмапа ограничен памятью VDP |
| Цвет на тайл | 2 цвета на ячейку 8x8 (атрибут) | Полноцветный, попиксельный |

Контраст разительный. То, на что программист Spectrum тратит бо́льшую часть бюджета кадра --- перемещение пиксельных данных по перемешанной раскладке памяти --- Agon решает записью в регистр. Решения в проектировании железа пронизывают все уровни программного обеспечения. Ограничения Spectrum вынудили разработку комбинированного метода скроллинга, тайловых движков и трюков с теневым экраном. Ограничения Agon лежат в другой плоскости (задержки последовательного VDP, накладные расходы на команды для сложных сцен).

---

## Практика: горизонтальный скроллинг уровня

### Версия для Spectrum: комбинированный посимвольный + пиксельный скроллинг

Построим горизонтальный скроллер с игровой областью 20x20 символов, который прокручивается плавно со скоростью 1 пиксель за кадр. Данные уровня — это тайлмап, хранящийся в банке памяти.

Вот полная структура:

```z80 id:ch17_spectrum_version_combined
; Side-scroller engine — ZX Spectrum 128K
; Uses combined character + pixel method with shadow screen.
;
    ORG $8000

PLAY_X      EQU 2           ; play area starts at column 2
PLAY_Y      EQU 2           ; play area starts at char row 2
PLAY_W      EQU 20          ; play area width in characters
PLAY_H      EQU 20          ; play area height in characters

scroll_pixel_x:   DB 0      ; pixel offset 0-7
scroll_tile_x:    DW 0      ; tile column at left edge
screen_flag:      DB 0      ; which screen is visible
current_bank:     DB 0      ; current $7FFD value

; --- Main loop ---
main:
    halt                     ; 4 T   sync to frame

    ; Advance scroll
    ld   a, (scroll_pixel_x) ; 13 T
    inc  a                   ; 4 T
    cp   8                   ; 7 T
    jr   c, .pixel_only      ; 12/7 T

    ; Character scroll frame
    xor  a
    ld   (scroll_pixel_x), a

    ; Advance tile position
    ld   hl, (scroll_tile_x)
    inc  hl
    ld   (scroll_tile_x), hl

    ; Get back buffer address
    call get_back_buffer     ; HL = $4000 or $C000

    ; Redraw full play area from tilemap into back buffer
    call render_play_area    ; ~50,000 T

    ; Flip screens
    call flip_screens        ; ~30 T

    jr   .frame_done

.pixel_only:
    ld   (scroll_pixel_x), a

    ; Shift edge columns in current (non-displayed) buffer
    call get_back_buffer
    call shift_edge_columns  ; ~9,600 T

    call flip_screens

.frame_done:
    call update_player       ; ~2,000 T
    call draw_sprites        ; ~5,000 T
    call play_music          ; ~3,000 T (IM2 handler)

    jr   main

; --- Render full play area from tilemap ---
; Input: HL = base address of target screen ($4000 or $C000)
;
render_play_area:
    ; For each tile in the play area:
    ;   Look up tile index from tilemap
    ;   Copy 8 bytes of tile data to screen, navigating interleave
    ;
    ; 20 columns x 20 rows = 400 tiles
    ; Each tile: 8 scan lines x 1 byte = 8 LDI operations
    ; Per tile: lookup (20 T) + 8 x (LDI 16 T + INC H 4 T) = 180 T
    ; Total: 400 x 180 = 72,000 T
    ;
    ; (Actual implementation uses PUSH tricks and
    ;  pre-computed screen address tables for ~55,000 T)
    ret

; --- Shift edge columns by 1 pixel ---
; Shifts the 2 rightmost columns of the play area left by 1 pixel
;
shift_edge_columns:
    ; For each of 160 pixel rows in the play area:
    ;   Navigate to the correct screen address
    ;   RL (HL) on the 2 edge bytes, right to left
    ;
    ; Per row: 40 T (2 bytes shifted) + 20 T (navigation)
    ; Total: 160 x 60 = 9,600 T
    ret
```

![Горизонтальный пиксельный скроллер, демонстрирующий плавный комбинированный скроллинг знакоместами и пикселями поверх тайловой игровой области](../../build/screenshots/ch17_hscroll.png)

### Версия для Agon: аппаратный тайлмаповый скроллинг

Версия для Agon драматически проще. Главный цикл вызывает `vsync`, увеличивает 16-битное смещение скроллинга, отправляет его в VDP через подпрограмму `set_scroll_offset` (несколько вызовов `vdu_write`), и каждые 8 пикселей вызывает `ring_buffer_load` для обновления одного столбца индексов тайлов. Весь скроллинг обходится менее чем в 3 000 тактов за кадр, оставляя 365 000+ тактов для игровой логики, ИИ, физики и рендеринга. Версия для Spectrum — это тщательное упражнение в подсчёте тактов, где каждая техника из Глав 2 и 3 сходится воедино, чтобы достичь того, что Agon делает записью в аппаратный регистр.

---

## Вертикальный + горизонтальный: комбинированный скроллинг

Некоторые игры прокручивают экран одновременно в обоих направлениях. На Spectrum применяй комбинированный метод к обеим осям: посимвольный скроллинг + пиксельное смещение (0–7) для каждой. Посимвольный скроллинг по каждому направлению происходит раз в 8 кадров. Совпадение обоих в одном кадре — это вероятность 1/64 (примерно раз в 1,3 секунды) — либо смирись с одним пропущенным кадром, либо разбей работу. Покадровая стоимость краевого сдвига по обеим осям: горизонтальные краевые столбцы (~9 600 T) + вертикальные краевые строки (~6 400 T) = ~16 000 T = 22% кадра. Управляемо.

---

## Советы по оптимизации

### 1. Используй таблицу подстановки экранных адресов

Предвычисли таблицу из 192 экранных адресов (по одному на строку пикселей) в RAM. Стоимость: 384 байта. Выигрыш: 16-битная подстановка из таблицы (около 30 тактов) заменяет вычисление адреса с перетасовкой битов (91 такт).

### 2. Прокручивай только видимое

Если спрайты закрывают часть игровой области, можно пропустить скроллинг строк за непрозрачными спрайтами. Отслеживай, какие строки нужно прокручивать, с помощью битовой карты «грязных строк». Эта оптимизация окупается, когда спрайты покрывают значительную часть игровой области.

### 3. Используй PUSH для посимвольного скроллинга

Для посимвольного скроллинга пиксельных данных (копирование 19 байт влево на строку развёртки) хорошо работает PUSH-трюк. Установи SP на конец данных игровой области для каждой строки развёртки, сделай POP 10 байт, сдвинь содержимое регистров и сделай PUSH обратно со смещением на один байт. Это сложно в настройке, но снижает стоимость на строку развёртки на 30–40%.

### 4. Разбей посимвольный скроллинг по кадрам

Если посимвольный скроллинг (каждый 8-й кадр) слишком дорог для одного кадра, разбей его: прокрути верхнюю половину игровой области в кадре N, а нижнюю — в кадре N+1. Визуальный артефакт (верхняя половина сдвигается на 1 кадр раньше нижней) практически незаметен при 50fps.

### 5. Трюки с палитрой и атрибутами

Для скроллинга только атрибутов (без пиксельных данных) рассмотри использование изменений FLASH или BRIGHT для создания иллюзии движения на статичной пиксельной сетке. Вращающийся набор цветов атрибутов на выровненных по символам тайлах может имитировать поток, воду или конвейерные ленты без перемещения пиксельных данных вообще.

---

## Итого

- **Полноэкранный пиксельный скроллинг на ZX Spectrum невозможен на 50fps.** Горизонтальный пиксельный скроллинг стоит ~135 000 тактов для 192 строк (189% бюджета кадра). Вертикальный — ~107 000 тактов (149%). Чересстрочная раскладка экрана усложняет вертикальный скроллинг, а отсутствие цилиндрического сдвигателя делает горизонтальный скроллинг по природе дорогим.

- **Скроллинг атрибутов дёшев** — ~17 000 тактов (24% кадра), но сдвигает с грубым шагом в 8 пикселей.

- **Комбинированный метод** — это то, что используют настоящие игры: посимвольный скроллинг (каждые 8 кадров) плюс покадровый пиксельный сдвиг 1–2 краевых столбцов. Средняя покадровая стоимость — менее 10 000 тактов. Пик на кадрах посимвольного скроллинга (~70 000 T) можно сгладить теневым экраном или разбиением на кадры.

- **Теневой экран** (128K, страница 7) обеспечивает двойную буферизацию без разрывов. Рисуй следующий кадр в задний буфер, затем переключай отображение. Это меняет стратегию скроллинга с «сдвигать существующие данные» на «перерисовывать из тайлмапа», что концептуально проще и устраняет разрывы.

- **Направление горизонтального скроллинга** не меняет стоимость. Скроллинг вправо использует `RR (HL)` вместо `RL (HL)`, слева направо вместо справа налево, с теми же 21 тактами на байт.

- **Вертикальный пиксельный скроллинг** осложнён чересстрочной раскладкой экрана Spectrum. Перемещение на одну строку пикселей вниз означает навигацию по адресной структуре `010TTSSS LLLCCCCC` с различными корректировками указателей на границах знакорядов и третей. Подход с раздельными счётчиками из Главы 2 здесь незаменим.

- **Agon Light 2** предоставляет аппаратные смещения скроллинга и тайловый рендеринг, которые снижают нагрузку на CPU до нескольких VDP-команд за кадр (~500–3 000 тактов). Загрузка столбцов через кольцевой буфер поддерживает тайлмап в актуальном состоянии по мере появления нового ландшафта. То, что программист Spectrum строит за 70 000 тактов, Agon решает записью в регистр.

- **Ключевые техники из предыдущих глав** здесь незаменимы: чересстрочная раскладка экрана и навигация раздельными счётчиками (Глава 2), LDI-цепочки и PUSH-трюки для быстрого перемещения данных (Глава 3), а также самомодифицирующийся код (SMC) для подпрограмм скроллинга с переключением направления (Глава 3).

---

> **Источники:** Introspec «Ещё раз про DOWN_HL» (Hype, 2020) — навигация по чересстрочному экрану; Introspec «GO WEST Part 1» (Hype, 2015) — стоимость спорной памяти; DenisGrachev «Ringo Render 64x48» (Hype, 2022) — скроллинг со смещением на полсимвола; ZX Spectrum 128K Technical Manual — порт `$7FFD` и теневой экран; документация VDP для Agon Light 2 — тайлмапы и команды смещения скроллинга.
