# Глава 1: Мыслить тактами

> «Кодерские эффекты — это всегда про эволюцию вычислительной схемы.»
> -- Introspec (spke), Life on Mars

У тебя есть 71 680 тактов. Это твой холст, твой бюджет, весь твой мир. Каждая инструкция, которую ты пишешь, стоит часть этих тактов. Каждый кадр счётчик обнуляется, и ты получаешь ещё 71 680 — ни больше, ни меньше. Не уложился в дедлайн — экран рвётся, музыка заикается, иллюзия рушится.

Эта глава о том, как научиться видеть свой код глазами демосценера на Z80: не как текст, не как алгоритм, а как *бюджет*.

---

## T-state: Валюта Z80

Процессор Z80 не выполняет инструкции одинаковыми порциями. Каждая инструкция занимает определённое число **тактов** (T-state) — элементарных тактовых циклов процессора. На частоте 3,5 МГц один такт длится примерно 286 наносекунд. Это число не важно. Важно то, что инструкции стоят *очень* по-разному, и эти стоимости нужно знать наизусть.

Вот горстка инструкций, которые ты будешь использовать постоянно:

| Инструкция | Что делает | Такты |
|-------------|-------------|----------|
| `NOP` | Ничего | 4 |
| `LD A,B` | Копирует B в A | 4 |
| `LD A,(HL)` | Загружает байт по адресу в HL | 7 |
| `LD (HL),A` | Записывает A по адресу в HL | 7 |
| `LD A,n` | Загружает непосредственный байт в A | 7 |
| `INC HL` | Инкремент HL | 6 |
| `ADD A,B` | Складывает B с A | 4 |
| `PUSH HL` | Кладёт HL на стек | 11 |
| `DJNZ label` | Декремент B, переход если не ноль | 13 (переход) / 8 (проваливается) |
| `LDIR` | Блочное копирование, за байт | 21 (повтор) / 16 (последний байт) |
| `OUT (n),A` | Пишет A в порт ввода-вывода | 11 |

Посмотри на разброс. Регистровое `LD A,B` стоит 4 такта — минимум для любой инструкции. Чтение из памяти `LD A,(HL)` стоит 7, потому что процессору нужны дополнительные машинные циклы, чтобы выставить адрес на шину и дождаться ответа от ОЗУ. `LDIR`, инструкция блочного копирования, к которой каждый спектрумист тянется инстинктивно, стоит 21 такт за копируемый байт (кроме последнего, который стоит 16). Это более чем в пять раз дороже NOP.

![Стоимость в тактах для типичных инструкций Z80](illustrations/output/ch01_tstate_costs.png)

Почему это важно? Потому что когда ты заполняешь экран, обновляешь данные спрайтов или вычисляешь следующий кадр плазмы, каждая инструкция отъедает от бюджета. Разница между инструкцией в 4 такта и в 7 тактов, умноженная на десять тысяч итераций внутреннего цикла — это разница между эффектом, работающим на 50 кадрах в секунду, и эффектом, который не успевает.

### Машинные циклы и доступ к памяти

Каждый такт (T-state) — это один тик процессорного генератора, но Z80 не обращается к памяти на каждом тике. Инструкции разбиты на **машинные циклы** (M-циклы), каждый из которых занимает 3–6 тактов. Первый машинный цикл каждой инструкции — это **выборка опкода** (M1), которая всегда занимает 4 такта: процессор выставляет счётчик команд на адресную шину, считывает байт опкода и одновременно обновляет DRAM (регенерация).  Последующие машинные циклы считывают дополнительные байты (операнды, данные из памяти) или записывают результаты.

Вот почему `LD A,B` занимает ровно 4 такта — это однобайтовая инструкция, которая целиком завершается в фазе выборки опкода. А `LD A,(HL)` занимает 7 тактов: 4 на выборку опкода, затем ещё 3 на цикл чтения памяти, когда процессор выставляет HL на адресную шину и считывает байт по этому адресу.

Не нужно запоминать внутреннюю разбивку машинных циклов каждой инструкции. Но понимание паттерна — выборка опкода + чтение операндов + обращения к памяти = общая стоимость — помогает выработать интуицию, *почему* инструкции стоят столько, сколько стоят. `PUSH HL` в 11 тактов обретает смысл, когда понимаешь, что процессору нужно выполнить выборку опкода (5T в данном случае, потому что одновременно декрементируется SP), а затем два отдельных цикла записи в память (по 3T каждый) для сохранения старшего и младшего байтов HL на стеке.

---

## Кадр: Твой холст

ZX Spectrum формирует PAL-видеосигнал с частотой примерно 50 кадров в секунду. Каждый кадр микросхема ULA считывает видеопамять и отрисовывает экран строка за строкой. В конце каждого кадра ULA генерирует маскируемое прерывание. Процессор выполняет инструкцию `HALT`, чтобы дождаться этого прерывания, делает свою работу, а затем снова `HALT` — ждёт следующий кадр. Это сердцебиение каждой программы для Spectrum.

Число тактов между одним прерыванием и следующим — **бюджет кадра** — зависит от машины:

| Машина | Тактов на кадр | Строк развёртки | Гц |
|---------|-------------------|-----------|-----|
| ZX Spectrum 48K | 69 888 | 312 | 50,08 |
| ZX Spectrum 128K | 70 908 | 311 | 50,02 |
| Pentagon 128 | 71 680 | 320 | 48,83 |

Это *общее* число тактов между прерываниями. Практический бюджет меньше — вычти стоимость обработчика прерывания (музыкальный плеер PT3 обычно потребляет 3 000–5 000 тактов на кадр), накладные расходы на HALT и, на машинах не-Pentagon, штрафы за спорную память. На Pentagon с музыкальным плеером рассчитывай примерно на 66 000–68 000 тактов для основного цикла. В главе 15 есть подробные тактовые карты.

![Распределение бюджета кадра по моделям ZX Spectrum](illustrations/output/ch01_frame_budget.png)

Если твой основной цикл — обработка ввода, игровая логика, обновление звука, отрисовка экрана — занимает больше тактов, чем один кадр, ты теряешь кадры. Всё замедляется. Трюк с полоской бордюра, который мы построим далее в этой главе, сделает это болезненно наглядным.

Для масштаба: одна `LDIR`, копирующая 6 912 байт (полный экран пиксельных данных), стоит примерно 6 912 x 21 = 145 152 такта. Это больше двух целых кадров на 48K Spectrum. Ты не можешь даже скопировать экран целиком за один кадр простейшим способом. Именно такие ограничения заставляют быть изобретательным.

---

## Pentagon против «ждущих» машин

Ты заметил, что бюджеты кадра в таблице выше различаются. Разница не только в числах — она отражает фундаментальное архитектурное расхождение, которое определило ZX Spectrum демосцену.

### Оригинальные машины Sinclair

На оригинальных 48K и 128K Spectrum экранная память расположена по адресам `$4000`–`$5AFF` (пиксельные данные) и `$5800`–`$5B00` (атрибуты цвета). Этот регион памяти — а фактически весь диапазон `$4000`–`$7FFF` — является **спорной памятью** (contended memory). ULA (Uncommitted Logic Array), формирующая видеосигнал, должна читать эту память для отрисовки экрана. Процессор и ULA разделяют одну шину памяти, и когда оба хотят читать одновременно, ULA побеждает. Процессор вынужден ждать.

Во время отрисовки 192 активных строк экрана каждое обращение процессора к диапазону `$4000`–`$7FFF` потенциально задерживается. Задержка следует повторяющемуся 8-тактовому паттерну: 6, 5, 4, 3, 2, 1, 0, 0 дополнительных тактов ожидания, циклически по каждой строке развёртки. Инструкция, которая должна занимать 7 тактов, может занять 13, если попадёт на худшую фазу цикла конкуренции.

Это превращает подсчёт тактов на оригинальных Spectrum в кошмар. Тщательно просчитанный внутренний цикл работает с разной скоростью в зависимости от того, где в кадре он выполняется и попадает ли его код или данные в спорный диапазон. Introspec задокументировал это в статьях «GO WEST» на Hype (2015): во время отрисовки экрана каждое обращение к спорной памяти обходится в среднем в 2,625 дополнительных такта. Для стековых операций, пишущих в экранную память, рассчитывай примерно на 1,3 дополнительных такта на байт.

### Pentagon: Чистый тайминг

Pentagon 128, самый популярный советский клон ZX Spectrum, пошёл другим путём. Его разработчики дали ULA собственное окно доступа к памяти, не конфликтующее с процессором. **На Pentagon нет спорной памяти.** Каждая инструкция занимает ровно столько тактов, сколько указано в даташите, независимо от того, где находится код и к какой памяти он обращается.

Вот почему у Pentagon другая длина кадра — 71 680 тактов, 320 строк развёртки. Тайминг ULA немного отличается, потому что нет необходимости чередовать доступ CPU и ULA. Но выигрыш огромен: ты можешь считать такты с абсолютной уверенностью. Когда твой внутренний цикл заявляет 36 тактов на итерацию — он стоит 36 тактов на итерацию, каждый раз, в любом месте кадра.

Этот чистый тайминг — причина того, что Pentagon стал стандартной платформой для ZX Spectrum демосцены, особенно на постсоветском пространстве, где эти клоны были повсеместны. Когда ты смотришь демо от групп X-Trade, 4th Dimension или Life on Mars — они в подавляющем большинстве рассчитаны на тайминг Pentagon. Когда Introspec писал свой легендарный технический разбор Illusion от X-Trade, он указывал тактовые подсчёты для Pentagon.

Для обучения модель Pentagon идеальна: можно сосредоточиться на понимании стоимости инструкций, не беспокоясь об эффектах конкуренции. Все таблицы тактов в этой книге предполагают тайминг Pentagon, если не указано иное. Когда потребуется обсудить различия (а мы это сделаем в главе 15), мы скажем об этом явно.

**Практическое правило:** размещай критичный по времени код в неспорной памяти (`$8000`–`$FFFF` на 48K), и твои подсчёты тактов будут верны как на Pentagon, так и на оригинальных Spectrum.

---

## Мыслить бюджетами

Теперь, когда ты знаешь размер кадра, можно начинать арифметику, которая определяет мышление Z80-демосценера.

Допустим, ты хочешь каждый кадр заполнять весь экран вычисленным цветом — простой эффект плазмы, обновляя только 768 байт области атрибутов по адресу `$5800`. На 50 fps тебе нужно вычислить и записать 768 цветовых значений за каждые 71 680 тактов.

Если внутренний цикл на один байт атрибута выглядит так:

```z80
    ld   a,c        ; 4T   column index
    add  a,b        ; 4T   add row index (diagonal pattern)
    add  a,d        ; 4T   add frame counter (animation)
    and  7          ; 7T   clamp to 0-7
    ld   (hl),a     ; 7T   write attribute
    inc  hl         ; 6T   next attribute address
                    ; --- 32T per byte
```

Это 32 такта на байт. На 768 байт: 32 x 768 = 24 576 тактов. Добавь накладные расходы цикла (поддержание счётчиков строк и столбцов, `DJNZ` для внутреннего цикла), и получится примерно 28 000–30 000 тактов. Остаётся более 40 000 тактов на всё остальное — проигрывание музыки, обработку ввода, что угодно.

Но что если ты захочешь обновить каждый *пиксельный* байт — все 6 144? При 32 тактах на байт это 196 608 тактов — почти три кадра. Внезапно ты смотришь на частоту обновления 17 fps вместо 50 fps. Тебе нужен либо более быстрый внутренний цикл, либо меньшая область обновления, либо совершенно другой подход.

Так думают программисты Z80. Каждое проектное решение начинается с арифметики: сколько байт, сколько тактов на байт, сколько тактов в бюджете кадра, уложится ли? Когда не укладывается, ты тянешься не к более быстрой машине — а к более хитрому алгоритму.

---

> **Врезка: Agon Light 2**
>
> Agon Light 2 работает на Zilog eZ80 с частотой 18,432 МГц. eZ80 выполняет тот же набор инструкций Z80 (это прямой архитектурный потомок), но большинство инструкций выполняются за меньшее число тактов — многие однобайтовые инструкции завершаются за 1 такт вместо 4. На частоте 18,432 МГц при 50 Гц ты получаешь приблизительно **368 640 тактов на кадр**.
>
> Это чуть больше, чем в 5 раз превышает бюджет Pentagon. Тот же язык ассемблера Z80, те же регистры, те же мнемоники инструкций — но в пять раз больше пространства для манёвра. Внутренний цикл, потребляющий 70% кадра Pentagon, может занять лишь 14% кадра Agon.
>
> Это не делает Agon «лёгким». У него свои ограничения: нет видеопамяти в стиле ULA (дисплеем управляет сопроцессор ESP32, выполняющий VDP), плоская 24-битная адресация вместо банковой памяти и совершенно другая модель ввода-вывода. Но если ты когда-нибудь мечтал о *чуть большем запасе* в бюджете кадра для чего-то амбициозного, Agon — это место, где то же мышление Z80 масштабируется вверх.
>
> На протяжении всей книги мы будем отмечать, где больший бюджет Agon меняет расклад. Пока просто запомни число: **~368 000 тактов**. Тот же ISA, в пять раз больше холст.

---

## Практика: Настройка среды разработки

Прежде чем писать первую тестовую обвязку, тебе нужен рабочий набор инструментов. Описанная здесь настройка следует руководству sq с Hype (2019), ставшему стандартом сообщества.

### Что понадобится

1. **VS Code** — редактор и интегрированная среда.
2. **Z80 Macro Assembler extension** от mborik (`mborik.z80-macroasm`) — подсветка синтаксиса, автодополнение, разрешение символов для ассемблера Z80. Устанавливается из маркетплейса VS Code.
3. **Z80 Assembly Meter** от Nestor Sancho — показывает количество байт и тактов выделенной инструкции (или блока инструкций) в строке состояния. Незаменим. Выдели блок кода и мгновенно увидишь его суммарную стоимость в тактах.
4. **sjasmplus** — собственно ассемблер. Кроссплатформенный, с открытым исходным кодом, поддерживает макросы, скрипты Lua, множество выходных форматов. Скачай с https://github.com/z00m128/sjasmplus и размести бинарник в PATH.
5. **Unreal Speccy** (Windows) или **Fuse** (кроссплатформенный) — эмулятор. Unreal Speccy предпочтителен для разработки демо, потому что точно эмулирует тайминг Pentagon и имеет встроенный отладчик.

### Структура проекта

Создай каталог для экспериментов по главе 1. Минимальный проект выглядит так:

```
ch01/
  main.a80          -- исходный файл
  build.bat         -- (Windows) sjasmplus main.a80
  Makefile           -- (macOS/Linux) цель для make
```

### Конфигурация сборки

В VS Code настрой задачу сборки (`.vscode/tasks.json`), чтобы компилировать по Ctrl+Shift+B:

```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Assemble Z80",
      "type": "shell",
      "command": "sjasmplus",
      "args": [
        "--fullpath",
        "--nologo",
        "--msg=war",
        "${file}"
      ],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "problemMatcher": {
        "owner": "z80",
        "fileLocation": "absolute",
        "pattern": {
          "regexp": "^(.*)\\((\\d+)\\):\\s+(error|warning):\\s+(.*)$",
          "file": 1,
          "line": 2,
          "severity": 3,
          "message": 4
        }
      }
    }
  ]
}
```

Нажми Ctrl+Shift+B. Если sjasmplus в PATH и нет ошибок, ты получишь файл `.sna` или `.tap` (в зависимости от директив в исходнике), который можно открыть прямо в эмуляторе.

Для интеграции с Unreal Speccy расширение Alex_Rider (2024) добавляет привязку F5-для-запуска — эмулятор автоматически открывает скомпилированный снапшот. Если ты на macOS или Linux и используешь Fuse, то же самое делает простое правило в Makefile:

```makefile
run: main.sna
	fuse --machine pentagon main.sna
```

---

## Практика: Тестовая обвязка

Это самый важный инструмент отладки, который ты построишь за всю книгу. Он до абсурда прост, не требует специального оборудования, и ты будешь использовать его постоянно.

Идея: сменить цвет бордюра на красный непосредственно перед измеряемым кодом и обратно на чёрный сразу после. Бордюр Spectrum отрисовывается ULA в реальном времени, синхронно с электронным лучом. Более широкая красная полоса означает больше тактов, потраченных в твоём коде.

Вот полная обвязка:

```z80
    ORG $8000

start:
    ; Wait for the frame interrupt
    halt

    ; --- Border RED: code under test begins ---
    ld   a, 2          ; 7T  red = colour 2
    out  ($FE), a      ; 11T write to border port

    ; ===== CODE UNDER TEST =====
    ; Replace this block with whatever you want to measure.
    ; Example: 256 iterations of a NOP loop.

    ld   b, 0          ; 7T  B=0 wraps to 256 iterations
.loop:
    nop                ; 4T
    nop                ; 4T
    nop                ; 4T
    nop                ; 4T  -- 16T per iteration body
    djnz .loop         ; 13T taken, 8T on final iteration
    ; Total: 256 * (16+13) - 5 = 7,419 T-states

    ; ===== END CODE UNDER TEST =====

    ; --- Border BLACK: idle ---
    xor  a             ; 4T  A=0 (black), shorter than LD A,0
    out  ($FE), a      ; 11T

    ; Loop forever
    jr   start
```

Загрузи это в эмулятор. Ты увидишь красную полосу поперёк бордюра. Высота этой полосы прямо пропорциональна числу тактов, затраченных тестируемым кодом.

### Чтение полосы

Каждая строка развёртки занимает 224 такта (на Pentagon). Если твоя красная полоса высотой N строк, твой код занял примерно N x 224 тактов. Пример выше использует около 7 419 тактов, что составляет примерно 33 строки — ты увидишь красную полосу примерно на одну шестую высоты бордюра.

Теперь попробуй заменить цикл NOP чем-то потяжелее. Замени четыре NOP на:

```z80
.loop:
    ld   a,(hl)        ; 7T
    add  a,(hl)        ; 7T
    ld   (de),a        ; 7T
    inc  hl            ; 6T   -- 27T per iteration body
    djnz .loop         ; 13T taken
    ; Total: 256 * (27+13) - 5 = 10,235 T-states
```

Красная полоса заметно вырастет. Эта визуальная разница — без отладчика, без профайлера, вообще без инструментов — составляет 2 816 тактов. Около 12 строк развёртки.

Именно так кодеры демо на Spectrum профилировали свои эффекты с 1980-х. Бордюр — твой осциллограф.

### Вариации

Можно использовать разные цвета для маркировки разных фаз кода:

```z80
    ld   a, 2          ; red
    out  ($FE), a
    call render_sprites
    ld   a, 1          ; blue
    out  ($FE), a
    call update_music
    ld   a, 4          ; green
    out  ($FE), a
    call game_logic
    xor  a             ; black
    out  ($FE), a
```

Теперь бордюр показывает красную полосу (отрисовка спрайтов), затем синюю (музыка), затем зелёную (игровая логика), затем чёрную (время простоя). Одним взглядом видно, какая подсистема пожирает бюджет кадра.

Замечание о `xor a` против `ld a, 0`: оба устанавливают A в ноль. `XOR A` занимает 4 такта и 1 байт. `LD A, 0` — 7 тактов и 2 байта. В тестовой обвязке разница ничтожна, но это стоит заметить — именно из такой микро-осведомлённости и состоит программирование на Z80.

---

## Что помещается в кадр?

Давай используем бюджетную арифметику, чтобы ответить на несколько практических вопросов.

**Сколько спрайтов можно нарисовать за кадр?** Маскированный спрайт 16x16 методом OR+AND занимает примерно 16 строк x (прочитать маску + прочитать спрайт + прочитать экран + комбинировать + записать на экран) на байт. Разумная оценка — около 1 200 тактов на спрайт. На Pentagon это 71 680 / 1 200 = ~59 спрайтов, если отрисовка — *единственное*, чем ты занимаешься. На практике, с музыкой, игровой логикой и всем прочим, 8–12 полноразмерных спрайтов за кадр — типичная цифра.

**Сколько байт может скопировать LDIR за кадр?** При 21 такте на байт: 71 680 / 21 = 3 413 байт. Даже не половина экрана.

**Сколько умножений?** Быстрое табличное умножение 8x8 занимает около 54 тактов. 71 680 / 54 = 1 327 умножений за кадр. Для вращения одной 3D-точки нужно 9 умножений. Значит, можно повернуть примерно 147 точек за кадр, *если больше ничего не делать*. Практический предел при полноценном демо-движке: 30–50 точек.

Каждый проектный вопрос сводится к этой арифметике. Смогу ли я это сделать? Сколько штук? От чего придётся отказаться, чтобы освободить место?

---

## Историческая заметка: Совет Dark'а

В 1997 году программист по имени Dark из группы X-Trade опубликовал серию статей в *Spectrum Expert* #01, российском электронном журнале для разработчиков ZX Spectrum. Эти статьи охватывали умножение, деление, генерацию синуса/косинуса и алгоритмы рисования линий на ассемблере Z80 — фундаментальные строительные блоки, на которых работает каждый демо-эффект.

Dark начал с такого совета:

> «Прочитайте учебник математики — производные, интегралы. Зная их, вы сможете создать таблицу практически любой функции в ассемблере.»

Это была не пустая теория. Dark был не просто автором — он был кодером. Демо *Illusion* от X-Trade, выпущенное на ENLiGHT'96, включало текстурированную вращающуюся сферу, ротозумер, 3D-движок и прыгающий точечный скроллер — и всё это работало на Z80 с частотой 3,5 МГц. Алгоритмы, которые Dark описывал в журнальных статьях, были теми же алгоритмами, которые приводили в движение эффекты его демо.

Двадцать лет спустя Introspec (spke) опубликовал детальный технический разбор Illusion на Hype, анализируя внутренние циклы инструкция за инструкцией, подсчитывая каждый такт. Журнальные статьи 1997 года и обратная разработка 2017 года рассказывают одну и ту же историю с двух сторон: автор объясняет свои строительные блоки, а коллега измеряет готовую машину. Мы будем следовать этой нити на протяжении всей книги.

Совет Dark'а остаётся в силе: математика не опциональна. Не нужна степень в математике, но нужно понимать, как превратить математическую функцию в таблицу, как приближать дорогие операции дешёвыми и как думать о компромиссе между точностью и скоростью. Глава 4 детально разберёт алгоритмы Dark'а. Пока запомни его совет. Это отправная точка всего.

---

## Вычислительная схема

Introspec, размышляя о том, что делает хороший демо-эффект, свёл философию в одно предложение:

> «Кодерские эффекты — это всегда про эволюцию вычислительной схемы.»

Это самый глубокий тезис этой главы. Демо-эффект — это не картинка, это *процесс*. Каждый кадр вычислительная схема порождает следующее состояние из предыдущего. Искусство — в выборе схемы, которая производит визуально убедительную эволюцию и при этом укладывается в бюджет кадра.

Плазма — это вычислительная схема: суммирование синусоид в каждой точке сетки со сдвигом по времени. Туннель — это вычислительная схема: выборка угла и расстояния из предвычисленных таблиц со сдвигом по времени. Вращающийся 3D-объект — это вычислительная схема: умножение координат вершин на матрицу вращения, которая меняется каждый кадр. Конкретная схема определяет визуальный результат, стоимость в тактах и требования к памяти — всё сразу, всё взаимосвязано.

Когда ты садишься писать эффект, ты спрашиваешь не «как мне нарисовать эту картинку». Ты спрашиваешь «какое вычисление, эволюционирующее кадр за кадром, порождает этот визуал?» Этот сдвиг мышления — от изображения к процессу, от результата к схеме — и есть мировоззрение Z80-программиста.

И первое ограничение для любой схемы — бюджет. 71 680 тактов. Сможешь ли ты развернуть своё вычисление в рамках этого бюджета? Если нет — можешь ли найти более дешёвую схему, дающую похожий визуал? Можешь ли предвычислить часть схемы в таблицы? Можешь ли распределить вычисление на несколько кадров? Можешь ли использовать симметрию, чтобы вычислить половину экрана и отзеркалить вторую?

Эти вопросы движут каждой главой этой книги. Они начинаются здесь, с подсчёта тактов.

---

## Итого

- У каждой инструкции Z80 есть определённая стоимость в тактах. Выучи основные наизусть: `NOP` = 4, `LD A,B` = 4, `LD A,(HL)` = 7, `PUSH HL` = 11, `LDIR` = 21/16, `OUT (n),A` = 11.
- **Бюджет кадра** — твоё жёсткое ограничение: 69 888 тактов (48K), 70 908 (128K) или 71 680 (Pentagon). На 50 fps всё должно уложиться.
- **Pentagon не имеет спорной памяти**, что делает подсчёт тактов надёжным и предсказуемым. Именно поэтому он стал стандартом демосцены.
- **Agon Light 2** (eZ80 @ 18,432 МГц) даёт ~368 000 тактов на кадр — тот же набор инструкций, в пять раз больше пространства.
- **Тестовая обвязка с цветом бордюра** — твой осциллограф: красный перед, чёрный после, читай ширину полосы.
- Программирование Z80 — это **бюджетная арифметика**: байты x тактов на байт против бюджета кадра. Каждое проектное решение начинается отсюда.
- Эффекты — это **вычислительные схемы, эволюционирующие во времени**. Искусство — в нахождении схемы, которая укладывается в бюджет и хорошо выглядит.

---

## Попробуй сам

1. Собери тестовую обвязку из этой главы. Замени цикл NOP на `LDIR`, копирующую 256 байт, и сравни ширину полосы с NOP-версией. Рассчитай ожидаемую разницу в тактах и проверь её визуально.

2. Напиши цикл, заполняющий все 768 байт области атрибутов (`$5800`–`$5AFF`) одним значением цвета. Измерь его обвязкой. Теперь попробуй заполнить с помощью `LDIR` вместо побайтового цикла. Что быстрее? На сколько строк развёртки?

3. Открой Z80 Assembly Meter в VS Code. Выделяй разные блоки кода и следи за счётчиком тактов в строке состояния. Привыкни проверять стоимость на ходу.

4. Настрой многоцветный бордюрный профайлер (красный / синий / зелёный / чёрный) с тремя фиктивными циклами разной длины. Подбери количество итераций, пока не сможешь визуально различить все три полосы. Это калибровочное упражнение для чтения тайминга по бордюру.

---

*Далее: Глава 2 — Экран как головоломка. Мы погрузимся в печально известную перепутанную раскладку видеопамяти Spectrum и узнаем, почему `INC H` перемещает на один пиксель вниз.*
