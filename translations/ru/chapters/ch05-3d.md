# Глава 5: 3D на 3.5 МГц

> *«Вычисляй только то, что необходимо. Остальное выводи.»*
> --- Dark & STS, Spectrum Expert #02 (1998)

Предыдущая глава дала тебе строительные блоки: умножение, деление, таблицы синусов, рисование линий. Теперь мы собираем их вместе. Цель — вращающийся трёхмерный объект с закрашенными полигонами на ZX Spectrum: заполненные грани, отсечение задних граней, корректная сортировка по глубине — на приемлемой частоте кадров.

Именно здесь ты упираешься в стену.

---

## Проблема: двенадцать умножений на вершину

Вращение точки в трёхмерном пространстве вокруг всех трёх осей требует серии тригонометрических умножений. Если вращать последовательно — сначала вокруг Z, затем Y, затем X — каждая ось требует четырёх умножений и двух сложений для преобразования двух координат. Три оси, четыре умножения каждая: двенадцать умножений на вершину.

Возьмём умножение сдвигом-и-сложением из Главы 4, которое стоит примерно 200 тактов (T-state). Двенадцать таких дают 2 400 тактов на вращение одной вершины. У простого куба 8 вершин: 19 200 тактов только на вращение. Глава 4 показала, что это умещается в бюджет кадра — едва-едва.

Теперь попробуй что-нибудь посложнее. Сферу, аппроксимированную 20 вершинами и 36 гранями:

```text
20 vertices x 2,400 T-states = 48,000 T-states
```

Это 67% бюджета кадра Pentagon в 71 680 тактов, потраченные до того, как ты нарисовал хоть один пиксель. Ещё нужна перспективная проекция, отсечение задних граней, сортировка полигонов и собственно заливка. Места нет. Объект не может быть сложнее куба, если не найти принципиально более дешёвый способ вычисления позиций вершин.

Dark и STS его нашли.

---

## Метод средней точки

Суть — в геометрии. Не каждая вершина объекта несёт независимую информацию. Многие вершины находятся в структурно предсказуемых позициях — средних точках рёбер, центрах граней, отражениях других вершин. Если выразить эти связи явно, можно заменить дорогие умножения дешёвым усреднением.

### Куб как основа

Рассмотрим куб, центрированный в начале координат. У него 8 вершин, но это не 8 независимых точек. Это 4 пары диаметрально противоположных вершин. Если знаешь одну вершину пары, другая — её отрицание через центр:

```text
v0 = ( x,  y,  z)    →    v7 = (-x, -y, -z)
v1 = ( x,  y, -z)    →    v6 = (-x, -y,  z)
v2 = ( x, -y,  z)    →    v5 = (-x,  y, -z)
v3 = ( x, -y, -z)    →    v4 = (-x,  y,  z)
```

Поверни 4 вершины полной процедурой с 12 умножениями. Отрицай их, чтобы получить остальные 4. Отрицание на Z80 — это `NEG` — 8 тактов на одну координату, 24 такта на все три. Сравни с 2 400 тактами полного вращения. Ты сократил вычисление вершин почти вдвое.

Но метод средней точки идёт гораздо дальше отражения.

### Вывод вершин усреднением

Ключевая операция — среднее: имея две уже вычисленные точки, их средняя точка — просто среднее их координат.

```text
v_new = (v_a + v_b) / 2
```

На Z80 это сложение и сдвиг:

```z80 id:ch05_deriving_vertices_by_2
; Average two signed 8-bit coordinates
; A = first coordinate, B = second coordinate
; Result in A = (A + B) / 2

    add  a, b           ;  4 T-states
    sra  a              ;  8 T-states
                        ; ----
                        ; 12 T-states total
```

`SRA` (Shift Right Arithmetic) сохраняет знаковый бит, поэтому работает корректно для отрицательных координат. Для всех трёх координат (x, y, z) усреднение стоит 36 тактов на производную вершину. Сравни с 2 400 тактами полного вращения.

Соотношение: усреднение в **66 раз дешевле** вращения.

Это означает, что можно строить сложные объекты из небольшого набора «базисных» вершин, которые вращаешь полностью, а затем выводишь все остальные вершины через цепочки усреднений. Чем больше вершин можно вывести, тем больше времени экономишь.

### Построение сложных объектов

Допустим, тебе нужен объект из 20 вершин. С методом средней точки:

1. Полное вращение 4 базисных вершин: 4 x 2 400 = 9 600 тактов
2. Зеркальное отражение 4 вершин: 4 x 24 = 96 тактов
3. Вывод 12 вершин усреднением: 12 x 36 = 432 такта
4. **Итого: 10 128 тактов**

Без метода средней точки те же 20 вершин стоили бы 48 000 тактов. Ты сэкономил 37 872 такта — более половины бюджета кадра высвобождено для проекции, отсечения и рендеринга.

Ограничение — топологическое: можно вывести вершину усреднением, только если она действительно лежит в средней точке двух других вершин (или достаточно близко, чтобы ошибка была невидима при разрешении 256x192). Это определяет, как ты проектируешь 3D-модели. Ты не моделируешь свободно, а потом оптимизируешь — ты проектируешь модель *вокруг* структуры средних точек с самого начала.

Dark и STS приводят примеры цепочек вывода:

```text
v8  = (v4 + v5) / 2
v9  = (v3 + v7) / 2
v10 = (v2 + v6) / 2
v11 = (v8 + v9) / 2     ; derived from two already-derived vertices
```

Заметь, что v11 выведена из v8 и v9, которые сами являются производными. Цепочки могут уходить на несколько уровней вглубь. Каждый уровень добавляет лишь 36 тактов на вершину, так что стоимость остаётся пренебрежимой независимо от глубины.

---

## Виртуальный процессор

Здесь Dark делает нечто, что кажется анахронизмом для 1998 года. Вместо жёсткого кодирования цепочек вывода для каждого конкретного объекта он проектирует крошечный интерпретатор — виртуальный процессор, — который исполняет «программы», описывающие, как вычислять вершины.

### Архитектура

Виртуальный процессор имеет:

- **Один регистр** (рабочий регистр, хранящий одну 3D-точку — три байта: x, y, z)
- **64 ячейки ОЗУ** (каждая ячейка хранит одну 3D-точку — всего 192 байта)
- **4 инструкции**

| Опкод | Биты | Имя | Операция |
|--------|------|------|-----------|
| 00 | `00nnnnnn` | **Load** | регистр <-- ячейка[n] |
| 01 | `01nnnnnn` | **Store** | ячейка[n] <-- регистр |
| 10 | `10nnnnnn` | **Average** | регистр <-- (регистр + ячейка[n]) / 2 |
| 11 | `11------` | **End** | остановка выполнения |

Каждая инструкция закодирована в одном байте: 2 бита на опкод, 6 бит на номер ячейки (0–63). Весь набор инструкций умещается в 256 возможных значений.

### Исполнение

Цикл интерпретатора компактен:

```z80 id:ch05_execution
; Virtual processor main loop
; IX points to the program (sequence of 1-byte instructions)
; Point RAM at a fixed address, 3 bytes per cell

vp_loop:
    ld   a, (ix+0)        ; fetch instruction
    inc  ix
    ld   b, a             ; save full instruction
    and  %11000000        ; extract opcode (top 2 bits)

    cp   %11000000        ; END?
    ret  z                ; yes — halt

    ld   a, b
    and  %00111111        ; extract cell number (bottom 6 bits)
    ; ... compute cell address from cell number ...
    ; ... dispatch based on opcode ...

    jr   vp_loop
```

Инструкция **Load** копирует значения x, y, z ячейки в рабочий регистр. **Store** копирует рабочий регистр обратно в ячейку. **Average** складывает координаты ячейки с рабочим регистром и сдвигает каждый результат вправо на один бит — операция средней точки. **End** завершает программу.

### Написание программ

Цепочка вывода вершин становится простой последовательностью байтов. Dark использует компактную нотацию в статье:

```z80 id:ch05_writing_programs
; Example: derive v8 = (v4 + v5) / 2, then store it
; Cell 4 = v4, Cell 5 = v5, Cell 8 = destination

    DB  4           ; LOAD cell[4]     (opcode 00, cell 4)
    DB  128+5       ; AVG  cell[5]     (opcode 10, cell 5 = %10000101)
    DB  64+8        ; STORE cell[8]    (opcode 01, cell 8 = %01001000)
```

Нотация `128+5` кодирует `%10000101` — опкод 10 (Average) с номером ячейки 5. `64+8` кодирует `%01001000` — опкод 01 (Store) с номером ячейки 8. Чистые числа, упакованные в байты данных, формирующие крошечную предметно-ориентированную программу.

Полное описание объекта может выглядеть так:

```z80 id:ch05_writing_programs_2
; Midpoint program for a 12-vertex object
; Cells 0-3: basis vertices (rotated by main code)
; Cells 4-7: mirrored vertices (negated by main code)
; Cells 8-11: derived via midpoint averaging

midpoint_program:
    DB  0               ; LOAD v0
    DB  128+1           ; AVG  v1           -> register = (v0+v1)/2
    DB  64+8            ; STORE v8

    DB  2               ; LOAD v2
    DB  128+3           ; AVG  v3           -> register = (v2+v3)/2
    DB  64+9            ; STORE v9

    DB  4               ; LOAD v4
    DB  128+5           ; AVG  v5           -> register = (v4+v5)/2
    DB  64+10           ; STORE v10

    DB  6               ; LOAD v6
    DB  128+7           ; AVG  v7           -> register = (v6+v7)/2
    DB  64+11           ; STORE v11

    DB  192             ; END               (%11000000)
```

Тринадцать байт описывают вычисление четырёх производных вершин. Виртуальный процессор исполняет их примерно за 13 x 30 = 390 тактов (каждая инструкция занимает приблизительно 25–35 тактов в зависимости от типа). Четыре полностью повёрнутые вершины стоили бы 9 600 тактов. Экономия огромна.

### Зачем виртуальный процессор?

Можно спросить: зачем не написать код усреднения прямо на Z80-ассемблере? Встроить сложения и сдвиги, пропустить накладные расходы интерпретатора. Это было бы чуть быстрее на вершину.

Ответ — гибкость. Виртуальный процессор отделяет *описание* топологии объекта от *исполнения* вычисления вершин. Сменить объект? Напиши новую программу — новую последовательность байтов данных. Код интерпретатора остаётся тем же. Можно хранить программы для нескольких объектов и переключаться между ними без затрат на код. Можно даже генерировать программы алгоритмически.

По сути, это предметно-ориентированный интерпретатор байткода — паттерн, который современные программисты узнают из игровых движков, шейдерных компиляторов и скриптовых языков. Dark спроектировал его в 1998 году, на ZX Spectrum, чтобы сэкономить такты на вычислении вершин. Архитектура чиста.

---

## Вращение

С методом средней точки, обрабатывающим большинство вершин, тебе всё ещё нужно правильно вращать базисные вершины. Dark и STS используют последовательное вращение вокруг трёх осей в порядке: Z, затем Y, затем X. Каждое вращение использует таблицы синуса и косинуса из Главы 4.

### Вращение вокруг оси Z

Вращение вокруг Z влияет только на X и Y:

```text
X' = X * cos(Az) + Y * sin(Az)
Y' = -X * sin(Az) + Y * cos(Az)
```

На Z80-ассемблере, используя знаковое умножение 8x8 и 256-элементные таблицы синуса/косинуса:

```z80 id:ch05_z_axis_rotation_2
; Rotate point around Z axis
; Input:  (px), (py) = coordinates; (angle_z) = rotation angle
; Output: (px), (py) updated
; Uses:   cos_table, sin_table (page-aligned, signed 8-bit)

rotate_z:
    ld   a, (angle_z)
    ld   l, a
    ld   h, cos_table >> 8
    ld   d, (hl)            ; D = cos(Az)
    ld   h, sin_table >> 8
    ld   e, (hl)            ; E = sin(Az)

    ; X' = X*cos(Az) + Y*sin(Az)
    ld   a, (px)
    ld   b, a
    ld   c, d               ; B=X, C=cos
    call mul_signed          ; HL = X * cos(Az)
    push hl

    ld   a, (py)
    ld   b, a
    ld   c, e               ; B=Y, C=sin
    call mul_signed          ; HL = Y * sin(Az)
    pop  de
    add  hl, de             ; HL = X*cos + Y*sin
    ld   a, h               ; take high byte as new X'
    ld   (px), a

    ; Y' = -X*sin(Az) + Y*cos(Az)
    ld   a, (px_original)   ; need the original X, not the updated one
    neg
    ld   b, a
    ld   c, e               ; B=-X, C=sin
    call mul_signed          ; HL = -X * sin(Az)
    push hl

    ld   a, (py)
    ld   b, a
    ld   c, d               ; B=Y, C=cos
    call mul_signed          ; HL = Y * cos(Az)
    pop  de
    add  hl, de             ; HL = -X*sin + Y*cos
    ld   a, h
    ld   (py), a

    ret
```

Тот же паттерн повторяется для вращения вокруг оси Y (затрагивая X и Z) и вокруг оси X (затрагивая Y и Z). Dark оборачивает все три в единую процедуру `ROTATE`, которая принимает три параметра угла и преобразует точку на месте.

Обрати внимание на деталь о сохранении исходного значения X. Вторая формула использует X до вращения, а не только что вычисленный X'. Типичная ошибка — использовать уже обновлённую координату, что даёт искажённое вращение. Dark явно говорит об этом в статье.

### Стоимость на базисную вершину

Каждое вращение по оси требует 4 умножения и 2 сложения. При 200 тактах на умножение и 11 тактах на 16-битное сложение:

```text
Per axis:  4 x 200 + 2 x 11 = 822 T-states
Three axes: 3 x 822 = 2,466 T-states per vertex
```

С 4 базисными вершинами: примерно 9 864 такта на вращение. Добавь исполнение программы средней точки — и ты получаешь полное вычисление вершин для произвольно сложного объекта за долю наивной стоимости.

---

## Проекция

Когда все вершины повёрнуты в 3D-пространстве, нужно спроецировать их на 2D-экран.

### Параллельная проекция

Простейший подход: полностью игнорировать координату Z. Просто использовать X и Y как экранные координаты (со сдвигом для центровки объекта).

```z80 id:ch05_parallel_projection
; Parallel projection: screen coords = rotated X, Y + offset
    ld   a, (px)
    add  a, 128             ; center horizontally (128 = half of 256)
    ld   (screen_x), a

    ld   a, (py)
    add  a, 96              ; center vertically (96 = half of 192)
    ld   (screen_y), a
```

Стоимость: практически нулевая. Результат выглядит плоско — объекты не кажутся уходящими вдаль. Параллельная проекция полезна для каркасных превью и эффектов, где само вращение создаёт иллюзию глубины, но ей не хватает убедительности перспективы.

### Перспективная проекция

Перспектива делает ближние объекты крупнее, а дальние — мельче, создавая ощущение глубины, которое делает 3D убедительным:

```text
Xscreen = (X * Scale) / (Z + Zdistance) + Xoffset
Yscreen = (Y * Scale) / (Z + Zdistance) + Yoffset
```

`Scale` контролирует угол обзора. `Zdistance` — расстояние от камеры до плоскости проекции — предотвращает деление на ноль, когда Z приближается к камере, и управляет интенсивностью масштабирования по глубине. `Xoffset` и `Yoffset` центрируют проекцию на экране.

Дорогая операция здесь — деление. Одно деление на координату, две координаты на вершину. С логарифмическим делением из Главы 4 (~60 тактов на деление) стоимость умеренна:

```z80 id:ch05_perspective_projection_2
; Perspective projection for one vertex
; Input:  (px), (py), (pz) = rotated 3D coordinates
; Output: (screen_x), (screen_y)

perspective:
    ; Compute denominator: Z + Zdistance
    ld   a, (pz)
    add  a, ZDISTANCE       ; Z + viewing distance
    ld   c, a               ; C = denominator

    ; Xscreen = (X * Scale) / (Z + Zdist) + Xoffset
    ld   a, (px)
    ld   b, SCALE
    call mul_signed          ; HL = X * Scale
    ld   a, h               ; take high byte as numerator
    call log_divide          ; A = A / C (using log tables)
    add  a, XOFFSET
    ld   (screen_x), a

    ; Yscreen = (Y * Scale) / (Z + Zdist) + Yoffset
    ld   a, (py)
    ld   b, SCALE
    call mul_signed          ; HL = Y * Scale
    ld   a, h
    call log_divide          ; A = A / C
    add  a, YOFFSET
    ld   (screen_y), a

    ret
```

Каждая вершина стоит два умножения (400 тактов) и два логарифмических деления (120 тактов), плюс накладные расходы — примерно 600 тактов на вершину. Для 20 вершин: 12 000 тактов. В сочетании с вращением методом средней точки мы оказываемся примерно на 22 000 тактах за все вычисления вершин и проекцию. Меньше трети бюджета кадра.

---

## Закрашенные полигоны

Каркасный объект — это набор рёбер. Закрашенный объект — набор заполненных полигонов. Переход от каркаса к сплошному объекту требует трёх дополнительных возможностей: определение видимых граней, сортировка по глубине и заливка пикселями.

### Отсечение задних граней

У замкнутого 3D-объекта есть грани, обращённые к зрителю, и грани, обращённые от него. Задние грани скрыты и не нуждаются в рисовании. Их пропуск экономит время рендеринга и создаёт корректный сплошной вид без полного буфера глубины.

Тест геометрический. Для каждой грани вычисляем Z-компоненту нормали поверхности через векторное произведение двух рёберных векторов:

```text
Given three vertices of a face: v0, v1, v2

Edge vectors:
    V = v1 - v0 = (Vx, Vy)    (in screen coordinates)
    W = v2 - v0 = (Wx, Wy)

Z-component of normal = Vx * Wy - Vy * Wx
```

Если результат положительный, грань обращена к зрителю — рисуем. Если отрицательный — грань отвёрнута, отбрасываем. Если ноль — грань видна с ребра и невидима.

```z80 id:ch05_backface_culling_2
; Backface culling test for one face
; Input: three projected vertices (x0,y0), (x1,y1), (x2,y2)
; Output: carry flag set if face is back-facing (should be culled)

backface_test:
    ; V = v1 - v0
    ld   a, (x1)
    sub  (ix+x0)
    ld   d, a               ; D = Vx = x1 - x0

    ld   a, (y1)
    sub  (ix+y0)
    ld   e, a               ; E = Vy = y1 - y0

    ; W = v2 - v0
    ld   a, (x2)
    sub  (ix+x0)
    ld   b, a               ; B = Wx = x2 - x0

    ld   a, (y2)
    sub  (ix+y0)
    ld   c, a               ; C = Wy = y2 - y0

    ; Normal Z = Vx * Wy - Vy * Wx
    ld   a, d
    call mul_signed_c        ; HL = Vx * Wy (D * C)
    push hl

    ld   a, e
    ld   c, b
    call mul_signed_c        ; HL = Vy * Wx (E * B)

    pop  de
    ex   de, hl
    or   a
    sbc  hl, de             ; HL = Vx*Wy - Vy*Wx

    bit  7, h               ; check sign
    ret                     ; carry/sign indicates facing
```

Два умножения и вычитание на грань. При 400 тактах на умножения плюс накладные расходы, тест стоит примерно 500 тактов на грань. Для объекта с 12 гранями это 6 000 тактов — и за каждую отброшенную грань ты экономишь всю стоимость её заливки.

На типичном вращающемся объекте примерно половина граней в любой момент обращена от зрителя. Их отсечение вдвое снижает нагрузку заливки.

### Сортировка по Z

Для выпуклого объекта (куб, тетраэдр) одного отсечения задних граней достаточно для корректного результата: каждая видимая грань полностью видна, перекрытий нет. Для невыпуклых или многообъектных сцен нужно рисовать грани в порядке от дальних к ближним, чтобы ближние перезаписывали дальние — алгоритм художника.

Dark и STS вычисляют значение глубины для каждой видимой грани (обычно среднее Z её вершин) и сортируют список граней соответственно. Простая сортировка вставками подходит для малого количества граней — сортировка 6–12 граней занимает пренебрежимое время по сравнению с их заливкой.

```z80 id:ch05_z_sorting
; Simplified depth sort: compute average Z for each visible face,
; sort face indices by descending Z (farthest first)

sort_faces:
    ; For each visible face:
    ;   average_z = (z[v0] + z[v1] + z[v2] + z[v3]) / 4
    ;   store (average_z, face_index) in sort buffer
    ; Then insertion-sort the buffer by average_z
    ; ...
```

### Заливка выпуклых полигонов

Когда известно, какие грани рисовать и в каком порядке, нужно их залить. Выпуклый полигон (все внутренние углы менее 180 градусов) можно залить простым построчным подходом:

1. Найди верхнюю и нижнюю вершины.
2. Двигайся вниз по левому и правому ребру одновременно, строка за строкой.
3. Для каждой строки рисуй горизонтальную линию от левого ребра до правого.

Проход по рёбрам использует инкрементальное шагание в стиле Брезенхэма — без деления на строку, только сложения и условные инкременты. Сама горизонтальная заливка — плотный цикл записи байтов:

```z80 id:ch05_convex_polygon_filling
; Fill one scan line from x_left to x_right at screen row Y
; Screen address already computed in HL

fill_scanline:
    ld   a, (x_right)
    sub  (ix+x_left)
    ret  c                  ; nothing to fill if right < left
    ret  z
    ld   b, a               ; B = pixel count

    ; For byte-aligned fills: write whole bytes
    ld   a, $FF             ; solid fill
.fill_loop:
    ld   (hl), a
    inc  l                  ; next byte (within same screen line)
    djnz .fill_loop
    ret
```

Это упрощение — реальные заливщики полигонов должны обрабатывать неполные байты на левом и правом краях, где граница полигона проходит внутри байта, а не по его границе. Эти крайние случаи добавляют сложности, но не много стоимости, поскольку встречаются лишь дважды на строку.

---

## Собираем всё вместе

Полный цикл кадра для вращающегося 3D-объекта с закрашенными полигонами следует такой последовательности:

<!-- figure: ch05_3d_pipeline -->
![3D rendering pipeline: model, rotation, projection, screen](illustrations/output/ch05_3d_pipeline.png)

```text
1. Update rotation angles (Az, Ay, Ax)
2. For each basis vertex:
     Rotate through Z, Y, X axes         [~2,400 T per vertex]
3. Negate basis vertices to get mirrors   [~24 T per vertex]
4. Run midpoint program to derive rest    [~36 T per derived vertex]
5. Project all vertices (perspective)     [~600 T per vertex]
6. For each face:
     Backface test                        [~500 T per face]
     If visible: compute average Z
7. Sort visible faces by Z               [~200 T for small lists]
8. For each visible face (back to front):
     Fill polygon                         [varies with area]
9. Wait for next frame (HALT)
```

Для объекта из 20 вершин и 18 граней с 4 базисными вершинами, бюджет кадра распределяется так:

| Этап | Вершин/Граней | Стоимость ед. | Итого |
|-------|---------------|----------|-------|
| Вращение (базис) | 4 | 2 466 | 9 864 |
| Отрицание (зеркала) | 4 | 24 | 96 |
| Вывод средних точек | 12 | 36 | 432 |
| Проекция | 20 | 600 | 12 000 |
| Тест задних граней | 18 | 500 | 9 000 |
| Сортировка по Z | ~9 видимых | - | ~200 |
| Заливка полигонов | ~9 видимых | ~1 500 ср. | ~13 500 |
| **Итого** | | | **~45 092** |

Сорок пять тысяч тактов из 71 680 доступных. Плотно, но рабочо — остаётся 26 000 тактов на очистку экрана, обновление углов и рисование линий или контуров, которые придают объекту чёткость. И это для объекта из 20 вершин, куда более сложного, чем всё, что ты мог бы себе позволить при наивном вращении.

---

## Форма объектов

Метод средней точки влияет на то, как ты думаешь о 3D-моделях. Ты не проектируешь полигональную сетку, а потом оптимизируешь — ты начинаешь с топологии, которую метод требует.

Хороший объект для метода средней точки начинается с малого базиса. Четыре полностью повёрнутые точки определяют тетраэдро-подобный скелет. Отрицание удваивает их до восьми. Усреднение средних точек заполняет остальное. Искусство — в выборе базисных вершин, дающих полезные производные точки.

Рассмотрим построение объекта из 14 вершин с нуля:

```text
Basis:    v0, v1, v2, v3         (4 fully rotated)
Mirrors:  v4, v5, v6, v7         (4 negated)
Derived:
  v8  = (v0 + v1) / 2           edge midpoint
  v9  = (v2 + v3) / 2           edge midpoint
  v10 = (v4 + v5) / 2           edge midpoint on mirrored side
  v11 = (v6 + v7) / 2           edge midpoint on mirrored side
  v12 = (v0 + v2) / 2           cross-edge midpoint
  v13 = (v8 + v10) / 2          second-level derivation
```

Программа виртуального процессора для этого — 19 байт:

```z80 id:ch05_the_shape_of_objects_2
object_14v_program:
    DB  0, 128+1, 64+8      ; v8  = avg(v0, v1)
    DB  2, 128+3, 64+9      ; v9  = avg(v2, v3)
    DB  4, 128+5, 64+10     ; v10 = avg(v4, v5)
    DB  6, 128+7, 64+11     ; v11 = avg(v6, v7)
    DB  0, 128+2, 64+12     ; v12 = avg(v0, v2)
    DB  8, 128+10, 64+13    ; v13 = avg(v8, v10)
    DB  192                  ; END
```

Девятнадцать байт данных заменяют 14 400 тактов умножений при вращении 6 производных вершин.

Можно пойти дальше. Второй уровень усреднения (вывод из уже выведенных точек) не стоит ничего дополнительно на инструкцию — виртуальному процессору всё равно, содержит ячейка повёрнутую или производную точку. Dark и STS описывают цепочки глубиной три-четыре уровня, создавая объекты с 30 и более вершинами из всего 3–4 базисных точек.

Ограничение — точность. Каждый шаг усреднения вносит ошибку округления до 0.5 единицы (от целочисленного сдвига). После трёх уровней вывода кумулятивная ошибка может достичь 1.5 единицы — заметно на объекте размером 60 пикселей, невидимо на 120. Проектируй объекты достаточно крупными, чтобы округление было ниже разрешения экрана.

---

## Практика: вращающийся закрашенный объект

Вот план построения полноценного вращающегося 3D-объекта с использованием всего из этой главы.

### Шаг 1: Определение объекта

Начинаем с базисных вершин. Усечённый октаэдр хорошо подходит для метода средней точки:

```z80 id:ch05_step_1_define_the_object
; 4 basis vertices in signed 8-bit coordinates
basis_vertices:
    DB   30,   0,  30     ; v0 (x, y, z)
    DB    0,  30,  30     ; v1
    DB   30,  30,   0     ; v2
    DB    0,   0,   0     ; v3 (at origin for center reference)
```

### Шаг 2: Программа средней точки

```z80 id:ch05_step_2_write_the_midpoint
midpoint_prog:
    ; Mirrors: cells 4-7 are pre-negated by the main loop
    ; Derive additional vertices:
    DB  0, 128+1, 64+8        ; v8  = avg(v0, v1)
    DB  2, 128+3, 64+9        ; v9  = avg(v2, v3)
    DB  0, 128+2, 64+10       ; v10 = avg(v0, v2)
    DB  1, 128+3, 64+11       ; v11 = avg(v1, v3)
    DB  192                    ; END
```

### Шаг 3: Определение граней

```z80 id:ch05_step_3_define_faces
; Face table: each face is a list of vertex indices + attribute byte
; Vertex order must be consistent (clockwise when front-facing)
face_table:
    DB  4, 0, 1, 8, 10        ; face 0: quad (4 vertices)
    DB  4, 2, 3, 9, 11        ; face 1: quad
    ; ... remaining faces ...
    DB  0                      ; end marker
```

### Шаг 4: Цикл кадра

```z80 id:ch05_step_4_the_frame_loop
main_loop:
    halt                       ; wait for vsync (IM1)

    ; Clear the screen area (or use double buffering)
    call clear_viewport

    ; Update angles
    ld   hl, angle_z
    inc  (hl)
    ld   hl, angle_x
    ld   a, (hl)
    add  a, 2
    ld   (hl), a

    ; Rotate basis vertices
    ld   b, 4                  ; 4 basis vertices
    ld   ix, basis_vertices
    ld   iy, point_ram         ; cell 0 onwards
.rotate_basis:
    push bc
    call rotate_xyz            ; rotate point at (IX) by current angles
                               ; store result at (IY)
    ld   bc, 3
    add  ix, bc
    add  iy, bc
    pop  bc
    djnz .rotate_basis

    ; Negate for mirrors (cells 4-7 = negation of cells 0-3)
    call negate_basis

    ; Run midpoint program
    ld   ix, midpoint_prog
    call virtual_processor

    ; Project all vertices
    call project_all

    ; Backface cull and sort
    call cull_and_sort

    ; Draw visible faces
    call draw_faces

    jr   main_loop
```

Это каркас. Каждый `call` скрывает процедуру, построенную из техник этой главы и Главы 4. Сам цикл кадра чист — обновить, вычислить, нарисовать, повторить.

![Вращающийся каркасный куб, отрендеренный на ZX Spectrum методом средней точки и перспективной проекцией](../../build/screenshots/ch05_wireframe_cube.png)

---

## Исторический контекст: от журнала к демо

Dark и STS опубликовали метод средней точки в Spectrum Expert #02 в 1998 году. Они были молодыми кодерами в Санкт-Петербурге, писавшими для дискового журнала, распространявшегося внутри российского ZX Spectrum-сообщества. Статьи написаны в прямом, практичном стиле людей, обучающих своих коллег: вот проблема, вот трюк, вот код.

Но Spectrum Expert не был академическим упражнением. Dark был из X-Trade, той самой группы, что выпустила *Illusion* — демо, занявшее первое место на ENLiGHT'96. Алгоритмы в журнале — не теоретические предложения; это строительные блоки реального, побеждавшего на соревнованиях демо-кода. Таблицы синусов из Главы 4 управляли ротозумером. Рисовальщик линий рендерил каркасы. А метод средней точки приводил в движение 3D-объекты.

Подход с виртуальным процессором особенно впечатляет в ретроспективе. В 1998 году доминирующие парадигмы в профессиональной разработке игр смещались в сторону аппаратного ускорения и прочь от программного рендеринга. На Spectrum аппаратного ускорения не существовало. Всё было программным, и программное обеспечение приходилось *проектировать* — не просто писать, а архитектурно выстраивать. Байткодовый интерпретатор Dark'а для вычисления вершин — архитектурное решение, которое не выглядело бы чуждо в анимационной системе или шейдерном компиляторе современного игрового движка. Он отделяет данные от исполнения, позволяет быстро итерировать над дизайном объектов и поддерживает компактность горячего цикла.

Связь с *Illusion* глубже общего авторства. Когда Introspec дизассемблировал *Illusion* двадцать лет спустя, он обнаружил ту же самую математическую инфраструктуру: умножитель сдвигом-и-сложением, параболическую таблицу синусов, делитель на логарифмических таблицах. Метод средней точки и виртуальный процессор — расширения этой инфраструктуры — то же мышление, применённое к другой задаче. Dark не просто публиковал алгоритмы; он документировал инженерную философию, стоящую за его собственным демо-победителем.

В следующей главе мы вблизи рассмотрим один из самых впечатляющих эффектов *Illusion*: текстурированную сферу. Она использует те же таблицы синусов и ту же арифметику с фиксированной точкой из Главы 4, в сочетании с техниками самомодифицирующегося кода из Главы 3 и совершенно иным подходом к задаче рендеринга. Метод средней точки и сфера — родственники, рождённые одним кодером, одними инструментами, одним неослабевающим стремлением уместить невозможное в 71 680 тактов.

---

## Итого

- Наивное вращение 3D-объектов требует 12 умножений на вершину — слишком дорого для сложных объектов на 3.5 МГц Z80.
- **Метод средней точки** полностью вращает лишь несколько базисных вершин, а остальные выводит через усреднение. Усреднение стоит ~36 тактов на вершину против ~2 400 при полном вращении — в 66 раз дешевле.
- **Виртуальный процессор** с 4 инструкциями (Load, Store, Average, End) исполняет компактные «программы», описывающие цепочки вывода вершин. Топология объекта — это данные, а не код.
- **Вращение** использует последовательные Z/Y/X-преобразования с таблицами синуса/косинуса из Главы 4.
- **Перспективная проекция** использует логарифмическое деление из Главы 4 для деления на Z.
- **Отсечение задних граней** через тест нормали векторным произведением устраняет невидимые грани по ~500 тактов каждая.
- **Сортировка по Z** с алгоритмом художника обрабатывает перекрывающиеся грани для невыпуклых объектов.
- Закрашенный объект из 20 вершин можно отрендерить за ~45 000 тактов на кадр — плотно, но выполнимо в рамках бюджета в 71 680 тактов.
- Эти техники были опубликованы в Spectrum Expert #02 (1998) той же командой, что создала *Illusion*. Журнальные статьи документируют инженерию, стоящую за демо.

---

*Все подсчёты тактов в этой главе — для тайминга Pentagon (без wait-состояний). На стандартном 48K Spectrum со спорной памятью ожидай более высокие значения для кода, исполняемого в нижних 32 КБ ОЗУ. См. Приложение A для полной справки по таймингу.*

> **Источники:** Dark & STS, «Программирование: 3D-графика» (Spectrum Expert #01, 1997); Dark & STS, «Программирование: 3D-графика — Метод средней точки» (Spectrum Expert #02, 1998). Конструкция виртуального процессора и примеры вывода средних точек взяты непосредственно из статьи SE#02.
