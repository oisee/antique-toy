# Глава 10: Точечный скроллер и 4-фазная цветовая анимация

> *«Два обычных кадра и два инвертированных кадра. Глаз видит среднее.»*
> -- Introspec, Making of Eager (2015)

---

ZX Spectrum отображает два цвета на ячейку 8x8. Текст прокручивается по экрану с той скоростью, которую может обеспечить процессор. Это фиксированные ограничения — аппаратура делает то, что делает, и никакая изобретательность не изменит кремний.

Но изобретательность может изменить то, что *воспринимает* зритель.

Эта глава объединяет две техники из двух разных демо, разделённых почти двадцатью годами, но связанных общим принципом. Точечный скроллер из *Illusion* от X-Trade (ENLiGHT'96) отрисовывает текст как подпрыгивающее облако отдельных точек, каждая из которых размещается ценой всего 36 тактов (T-states). 4-фазная цветовая анимация из *Eager* от Introspec (3BM Open Air 2015) чередует четыре тщательно подготовленных кадра на частоте 50 Гц, чтобы обмануть глаз и заставить его видеть цвета, которые оборудование не в состоянии воспроизвести. Одна техника эксплуатирует пространственное разрешение — размещая точки где угодно, без привязки к знакоместам. Другая эксплуатирует временное разрешение — циклически меняя кадры быстрее, чем глаз может уследить. Вместе они демонстрируют две главные оси обмана на ограниченном оборудовании: пространство и время.

---

## Часть 1: Точечный скроллер

### Что видит зритель

Представь сообщение — «ILLUSION BY X-TRADE» — отрисованное не сплошными блочными символами, а как поле отдельных точек, каждая точка — один пиксель. Текст плавно дрейфует по экрану горизонтально. Но точки не лежат на плоских строках развёртки. Они подпрыгивают. Всё точечное поле волнообразно колеблется по синусоиде, каждый столбец смещён по вертикали относительно соседних, создавая впечатление текста, рябящего на поверхности воды.

### Шрифт как текстура

Шрифт хранится в памяти как битовая текстура — один бит на точку. Если бит равен 1, точка появляется на экране. Если бит равен 0, ничего не происходит. Ключевое слово здесь — *прозрачность*. В обычном рендерере ты записываешь каждую пиксельную позицию. В точечном скроллере прозрачные пиксели практически бесплатны. Ты проверяешь бит, и если он нулевой — пропускаешь. Только установленные пиксели требуют записи в видеопамять.

Это означает, что стоимость отрисовки пропорциональна числу видимых точек, а не общей площади. Типичный символ 8x8 может иметь 20 установленных пикселей из 64. Для большого прокручиваемого сообщения эта экономия крайне важна. BC указывает на данные шрифта; RLA сдвигает каждый бит во флаг переноса для определения — рисовать или нет.

### Адресные таблицы на основе стека

В обычном скроллере экранная позиция каждого пикселя вычисляется из координат (x, y) по формуле чересстрочной адресации Spectrum. Это вычисление включает сдвиги, маски и обращения к таблицам. Делать это для тысяч пикселей за кадр поглотило бы весь бюджет кадра.

Решение Dark'а: предварительно вычислить каждый экранный адрес и сохранить их как таблицу, по которой проходит указатель стека. POP читает 2 байта и автоматически инкрементирует SP, всё за 10 тактов (T-states). Направь SP на таблицу вместо реального стека, и POP становится самым быстрым способом извлечения адресов — ни индексных регистров, ни адресной арифметики, ни накладных расходов.

Подпрыгивающее движение целиком закодировано в адресной таблице. Каждая запись — экранный адрес, уже включающий вертикальное синусоидальное смещение. «Прыжок» не происходит во время отрисовки. Он произошёл, когда таблица была построена. Все три измерения анимации — позиция прокрутки, волна отскока, форма символа — сворачиваются в единую линейную последовательность 16-битных адресов, потребляемую на полной скорости через POP.

### Внутренний цикл

Анализ Introspec'а 2017 года раскрывает внутренний цикл Illusion. Один байт шрифтовых данных содержит 8 бит — 8 пикселей. `LD A,(BC)` читает байт один раз, затем RLA сдвигает по одному биту через 8 развёрнутых итераций:

```z80
; Dotfield scroller inner loop (unrolled for one font byte)
; BC = pointer to font/texture data, SP = pre-built address table

    ld   a,(bc)      ;  7 T  read font byte (once per 8 pixels)
    inc  bc          ;  6 T  advance to next font byte

    ; Pixel 7 (MSB)
    pop  hl          ; 10 T  get screen address from stack
    rla              ;  4 T  shift texture bit into carry
    jr   nc,.skip7   ; 12/7 T  skip if transparent
    set  7,(hl)      ; 15 T  plot the dot
.skip7:
    ; Pixel 6
    pop  hl          ; 10 T
    rla              ;  4 T
    jr   nc,.skip6   ; 12/7 T
    set  6,(hl)      ; 15 T
.skip6:
    ; ... pixels 5 through 0 follow the same pattern,
    ; with SET 5 through SET 0 ...
```

Стоимость на пиксель, без учёта амортизированного чтения байта:

| Путь | Инструкции | Такты (T-states) |
|------|-----------|------------------|
| Непрозрачный пиксель | `pop hl` + `rla` + `jr nc` (не взят) + `set ?,(hl)` | **36** |
| Прозрачный пиксель | `pop hl` + `rla` + `jr nc` (взят) | **26** |

`LD A,(BC)` и `INC BC` стоят 13 тактов (T-states), амортизированных на 8 пикселей — около 1,6 такта на пиксель. «36 тактов на пиксель» из анализа Introspec'а — это стоимость наихудшего случая в пределах развёрнутого байта, без учёта этих накладных расходов.

Позиция бита в SET меняется для каждого пикселя (7, 6, 5 ... 0), поэтому цикл развёрнут 8 раз, а не повторяется. Нельзя параметризовать позицию бита в SET без индексации через IX/IY (слишком медленно) или самомодифицирующегося кода (SMC) (лишние накладные расходы). Развёрнутый цикл — чистое решение.

### Арифметика бюджета кадра

Бюджет кадра Pentagon — 71 680 тактов (T-states). При условии, что 60-70% доступно для скроллера (остальное уходит на музыку, очистку экрана, построение таблицы), это примерно 45 000 тактов.

Рассмотрим 4096 точек (8 символов по 8x8). Типичный шрифт заполнен примерно на 30%: 1200 непрозрачных точек по 36 тактов каждая, 2900 прозрачных по 26 тактов каждая. Итого: 43 200 + 75 400 + 6 656 (накладные на чтение байтов) = приблизительно 125 000 тактов. Это около 1,75 кадра — скроллер обновляется примерно с частотой 28 fps, вполне плавно.

Цифры работают, потому что две оптимизации дают кумулятивный эффект. Адресация через стек устраняет все вычисления координат. Текстурная прозрачность устраняет все записи для пустых пикселей.

### Как закодирован отскок

Адресная таблица — это то место, где живёт искусство. Чтобы создать подпрыгивающее движение, таблица синусов смещает вертикальную позицию каждого столбца:

```
y_offset = sin_table[(column * 8 + scroll_pos * 2) & 255]
```

Умножение на 8 управляет пространственной частотой; множитель 2 для позиции прокрутки управляет скоростью фазы. По координатам каждой точки (x, y + y_offset) вычисляется экранный адрес Spectrum и сохраняется в таблице. Код построения таблицы выполняется один раз за кадр, вне внутреннего цикла. Внутренний цикл видит лишь поток предварительно вычисленных адресов.

---

## Часть 2: 4-фазная цветовая анимация

### Проблема цвета

Каждая ячейка 8x8 имеет один цвет чернил (0-7) и один цвет бумаги (0-7). В пределах одного кадра ты получаешь ровно два цвета на ячейку. Но Spectrum работает на частоте 50 кадров в секунду, и человеческий глаз не различает отдельные кадры на такой частоте. Он видит среднее.

### Трюк

4-фазная техника Introspec'а циклически переключается между четырьмя кадрами:

1. **Нормальный A:** ink = C1, paper = C2. Пиксельные данные = паттерн A.
2. **Нормальный B:** ink = C3, paper = C4. Пиксельные данные = паттерн B.
3. **Инвертированный A:** ink = C2, paper = C1. Пиксельные данные = паттерн A (те же пиксели, цвета поменяны местами).
4. **Инвертированный B:** ink = C4, paper = C3. Пиксельные данные = паттерн B (те же пиксели, цвета поменяны местами).

На частоте 50 Гц каждый кадр отображается в течение 20 миллисекунд. Четырёхкадровый цикл завершается за 80 мс — 12,5 циклов в секунду, выше порога слияния мерцания на CRT-дисплеях.

### Математика восприятия

Проследим один пиксель, который «включён» в паттерне A и «выключен» в паттерне B:

| Кадр | Состояние пикселя | Отображаемый цвет |
|------|------------------|--------------------|
| Нормальный A | вкл (ink) | C1 |
| Нормальный B | выкл (paper) | C4 |
| Инвертированный A | вкл (ink) | C2 |
| Инвертированный B | выкл (paper) | C3 |

Глаз воспринимает среднее: (C1 + C2 + C3 + C4) / 4.

Теперь проверим: пиксель, «включённый» в обоих паттернах, видит C1, C3, C2, C4. Пиксель, «выключенный» в обоих, видит C2, C4, C1, C3. Во всех случаях получается одно и то же среднее. Пиксельный паттерн не влияет на воспринимаемый оттенок — на него влияет только выбор C1 до C4.

Тогда зачем два паттерна? Потому что *промежуточные* переходы имеют значение. Пиксель, чередующийся между ярко-красным и ярко-зелёным, заметно мерцает на 12,5 Гц. Пиксель, чередующийся между близкими оттенками, едва мерцает. Паттерны дизеринга — шахматные, полутоновые, упорядоченные матрицы — управляют *текстурой* мерцания. Introspec подобрал паттерны так, чтобы переходы между кадрами давали минимальное видимое колебание. Это антиконфликтный подбор пикселей: тщательная расстановка «включённых» и «выключенных» битов, чтобы ни один пиксель не переключался между кардинально различающимися цветами в последовательных кадрах.

### Почему инверсия необходима

Без шага инверсии «включённые» пиксели всегда показывали бы ink, а «выключенные» — всегда paper. Ты получил бы ровно два видимых цвета на ячейку, мерцающих между двумя разными парами. Инверсия гарантирует, что и ink, и paper вносят вклад в оба состояния пикселей на протяжении цикла, смешивая все четыре цвета в воспринимаемый результат.

На Spectrum инверсия обходится дёшево — достаточно поменять местами биты ink и paper в байте атрибутов, или предварительно рассчитать оба буфера (нормальный и инвертированный) и циклически переключаться между ними.

### Практическая стоимость

Четыре предварительно построенных буфера атрибутов, циклически переключаемых раз за кадр. Стоимость за кадр — блочное копирование 768 байт в область атрибутов: около 16 000 тактов (T-states) через LDIR, или около 4500 тактов с помощью PUSH-трюка. Менее четверти бюджета кадра в любом случае.

Память: 4 x 768 = 3072 байта на буферы. Пиксельные паттерны (A и B) записываются один раз при инициализации и больше не затрагиваются.

### Текстовый оверлей

В Eager поверх цветовой анимации прокручивается текст. Простейший подход — зарезервировать определённые ячейки под текст, исключив их из цветового цикла — фиксированные атрибуты белый-на-чёрном с реальными глифами шрифта. Более изощрённый подход интегрирует текст в фазовую анимацию: формы глифов переопределяют конкретные биты в паттернах A и B, обеспечивая видимость текста в каждом кадре, пока окружающие пиксели продолжают циклическую смену. В результате текст как будто парит над анимированным фоном, с цветовым «подтеканием» к краям каждой буквы.

---

## Общий принцип: временной обман

Точечный скроллер использует 50 кадров в секунду для *пространственной* гибкости. Каждый кадр — это снимок позиций точек в один момент; мозг зрителя интерполирует между снимками, воспринимая плавное движение. Задача процессора — *расставить* точки как можно быстрее, читая предварительно вычисленные адреса из стека.

4-фазная цветовая анимация использует 50 кадров в секунду для *цветовой* гибкости. Каждый кадр показывает одно из четырёх цветовых состояний; сетчатка зрителя усредняет их. Ни один отдельный кадр не содержит воспринимаемого результата — он существует только в инерции зрительного восприятия.

Обе техники эксплуатируют одну и ту же физическую реальность: ЭЛТ обновляется на частоте 50 Гц, и зрительная система человека не в состоянии различить отдельные кадры на этой частоте. *Временное* разрешение Spectrum значительно богаче его пространственного или цветового разрешения. Демосценовые кодеры обнаружили, что временное разрешение — самая дешёвая ось для эксплуатации.

Обе техники сводят свои внутренние циклы к абсолютному минимуму. Скроллер — до 36 тактов на точку. Цветовая анимация — до одного копирования буфера за кадр. Обе выносят сложность из внутреннего цикла в предварительные вычисления. И обе дают результаты, которые, на взгляд обычного зрителя, кажутся невозможными для этого оборудования.

Вот что делает демосцену искусством времени. Скриншот точечного скроллера — россыпь пикселей. Скриншот 4-фазной цветовой анимации — два цвета на ячейку, ровно как предписывает аппаратура. Надо видеть их *в движении*, чтобы увидеть, как они работают. Красота — в последовательности, а не в отдельном кадре.

---

## Практика 1: Текстовый скроллер с подпрыгивающей точечной матрицей

Построй упрощённый точечный скроллер: короткое текстовое сообщение, отрисованное как подпрыгивающее точечное поле с адресацией на основе POP.

**Структуры данных.** Выровненный по странице растровый шрифт 8x8 (подойдёт ROM-шрифт по адресу `$3D00`). 256-байтная таблица синусов для смещения отскока. RAM-буфер для адресной таблицы (до 4096 x 2 байт).

**Построение таблицы.** Перед каждым кадром итерируй по видимым символам. Для каждого бита в каждом байте шрифта вычисли экранный адрес с учётом синусоидального смещения и сохрани его в адресной таблице. Это выполняется один раз за кадр, вне внутреннего цикла.

**Отрисовка.** Запрети прерывания. Сохрани SP через самомодифицирующийся код (SMC). Направь SP на адресную таблицу. Выполни развёрнутый внутренний цикл: `ld a,(bc) : inc bc`, затем 8 повторений `pop hl : rla : jr nc,skip : set N,(hl)` с N от 7 до 0. Восстанови SP. Разреши прерывания.

**Основной цикл.** `halt` (синхронизация с 50 Гц), очистка экрана (PUSH-очистка из главы 3), построение адресной таблицы, отрисовка точечного поля, продвижение позиции прокрутки и фазы отскока.

**Расширения.** Частичная очистка экрана (отслеживание ограничивающего прямоугольника). Двойная буферизация через теневой экран на 128K. Множественные гармоники отскока. Переменная плотность точек для более разреженного, эфемерного вида.

---

## Практика 2: 4-фазная анимация цветового цикла

Построй 4-фазную цветовую анимацию, создающую плавные градиенты.

**Пиксельные паттерны.** Заполни область растра двумя комплементарными паттернами дизеринга. Простейший вариант: чётные пиксельные строки заполняются `$55` (01010101), нечётные — `$AA` (10101010). Для продакшен-качества используй упорядоченную матрицу Байера 4x4.

**Буферы атрибутов.** Предварительно рассчитай четыре 768-байтных буфера. Буферы 0 и 1 содержат нормальные атрибуты с двумя различными цветовыми схемами (изменяющиеся ink/paper по экрану для диагонального градиента). Буферы 2 и 3 — инвертированные версии: биты ink и paper поменяны местами. Перестановка выполняется битовой ротацией: три RRCA для перемещения битов ink на позицию paper, три RLCA в обратном направлении, маска и объединение.

**Основной цикл.** Каждый кадр: `halt`, индекс в 4-элементную таблицу указателей на буферы с помощью счётчика фаз (AND 3), LDIR 768 байт в `$5800`, инкремент счётчика фаз. Это весь движок времени выполнения — около 16 000 тактов (T-states) за кадр.

**Анимация.** Для движущегося градиента перегенерируй один буфер за кадр (тот, который скоро станет самым старым в 4-кадровом цикле) с продвигающимся цветовым смещением. Это поддерживает конвейер: отображай кадр N, генерируя кадр N+4. Альтернативно — предварительно рассчитай все буферы по банкам 128K для нулевой стоимости в рантайме.

---

## Итого

- **Точечный скроллер** отрисовывает текст как отдельные точки. Внутренний цикл — `pop hl : rla : jr nc,skip : set ?,(hl)` — стоит 36 тактов (T-states) на непрозрачный пиксель, 26 — на прозрачный.
- **Адресация через стек** кодирует траекторию отскока как предварительно построенные экранные адреса. POP извлекает их по 10 тактов за штуку — самое быстрое произвольное чтение на Z80.
- **4-фазный цвет** циклически переключает 4 кадра атрибутов (2 нормальных + 2 инвертированных) на 50 Гц. Инерция зрительного восприятия усредняет цвета, создавая иллюзию более чем 2 цветов на ячейку.
- **Шаг инверсии** гарантирует, что все четыре цвета вносят вклад в каждую пиксельную позицию.
- Обе техники эксплуатируют **временное разрешение** для создания эффектов, невозможных в любом отдельном кадре.
- Скроллер использует стек для пространственной гибкости; цветовая анимация использует чередование кадров для цветовой гибкости — две главные оси демосценового обмана.

---

## Попробуй сам

1. Построй точечный скроллер. Начни с одного статичного символа, отрисованного через внутренний цикл на основе POP. Проверь ожидаемые тайминги с помощью тестовой обвязки бордюра из главы 1. Затем добавь таблицу отскока и наблюдай, как он волнится.

2. Экспериментируй с параметрами отскока. Измени амплитуду синуса, пространственную частоту и скорость фазы. Небольшие изменения дают разительные визуальные различия.

3. Построй 4-фазную цветовую анимацию. Начни с однородного цвета (все ячейки одинаковые в каждой фазе). Убедись, что видишь ровный цвет, который не является ни ink, ни paper ни одного отдельного кадра. Затем добавь диагональный градиент.

4. Попробуй различные паттерны дизеринга. Шахматный, блоки 2x2, матрица Байера, случайный шум. Какие минимизируют видимое мерцание? Какие дают наиболее плавные воспринимаемые градиенты?

5. Объедини обе техники: 4-фазный цветной фон с монохромным точечным скроллером поверх.

---

> **Источники:** Introspec, «Technical Analysis of Illusion by X-Trade» (Hype, 2017); Introspec, «Making of Eager» (Hype, 2015); Dark, «Programming Algorithms» (Spectrum Expert #01, 1997). Дизассемблирование внутреннего цикла и подсчёт тактов следуют анализу Introspec'а 2017 года. 4-фазная цветовая техника описана в making-of Eager и file_id.diz пати-версии.
