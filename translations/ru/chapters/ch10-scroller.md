# Глава 10: Точечный скроллер и 4-фазная цветовая анимация

> *«Два обычных кадра и два инвертированных кадра. Глаз видит среднее.»*
> -- Introspec, Making of Eager (2015)

---

ZX Spectrum отображает два цвета на ячейку 8x8. Текст прокручивается по экрану с той скоростью, которую может обеспечить процессор. Это фиксированные ограничения — аппаратура делает то, что делает, и никакая изобретательность не изменит кремний.

Но изобретательность может изменить то, что *воспринимает* зритель.

Эта глава объединяет две техники из двух разных демо, разделённых почти двадцатью годами, но связанных общим принципом. Точечный скроллер из *Illusion* от X-Trade (ENLiGHT'96) отрисовывает текст как подпрыгивающее облако отдельных точек, каждая из которых размещается ценой всего 36 тактов (T-states). 4-фазная цветовая анимация из *Eager* от Introspec (3BM Open Air 2015) чередует четыре тщательно подготовленных кадра на частоте 50 Гц, чтобы обмануть глаз и заставить его видеть цвета, которые оборудование не в состоянии воспроизвести. Одна техника эксплуатирует пространственное разрешение — размещая точки где угодно, без привязки к знакоместам. Другая эксплуатирует временное разрешение — циклически меняя кадры быстрее, чем глаз может уследить. Вместе они демонстрируют две главные оси обмана на ограниченном оборудовании: пространство и время.

---

## Часть 1: Точечный скроллер

### Что видит зритель

Представь сообщение — «ILLUSION BY X-TRADE» — отрисованное не сплошными блочными символами, а как поле отдельных точек, каждая точка — один пиксель. Текст плавно дрейфует по экрану горизонтально. Но точки не лежат на плоских строках развёртки. Они подпрыгивают. Всё точечное поле волнообразно колеблется по синусоиде, каждый столбец смещён по вертикали относительно соседних, создавая впечатление текста, рябящего на поверхности воды.

### Шрифт как текстура

Шрифт хранится в памяти как битовая текстура — один бит на точку. Если бит равен 1, точка появляется на экране. Если бит равен 0, ничего не происходит. Ключевое слово здесь — *прозрачность*. В обычном рендерере ты записываешь каждую пиксельную позицию. В точечном скроллере прозрачные пиксели практически бесплатны. Ты проверяешь бит, и если он нулевой — пропускаешь. Только установленные пиксели требуют записи в видеопамять.

Это означает, что стоимость отрисовки пропорциональна числу видимых точек, а не общей площади. Типичный символ 8x8 может иметь 20 установленных пикселей из 64. Для большого прокручиваемого сообщения эта экономия крайне важна. BC указывает на данные шрифта; RLA сдвигает каждый бит во флаг переноса для определения — рисовать или нет.

![Прототип скроллера с точечным полем — каждый символ отрисован как отдельные пиксели, прыгающие на синусоиде, что создаёт классический демосценовый текстовый эффект](../../build/screenshots/proto_ch10_dotfield.png)

### Адресные таблицы на основе стека

В обычном скроллере экранная позиция каждого пикселя вычисляется из координат (x, y) по формуле чересстрочной адресации Spectrum. Это вычисление включает сдвиги, маски и обращения к таблицам. Делать это для тысяч пикселей за кадр поглотило бы весь бюджет кадра.

Решение Dark'а: предварительно вычислить каждый экранный адрес и сохранить их как таблицу, по которой проходит указатель стека. POP читает 2 байта и автоматически инкрементирует SP, всё за 10 тактов (T-states). Направь SP на таблицу вместо реального стека, и POP становится самым быстрым способом извлечения адресов — ни индексных регистров, ни адресной арифметики, ни накладных расходов.

Сравни POP с альтернативами. `LD A,(HL) : INC HL` считывает один байт за 11 тактов — для считывания адреса понадобятся две такие пары (22 T), плюс `LD L,A / LD H,A` для сборки. Индексированная загрузка вроде `LD L,(IX+0) : LD H,(IX+1)` стоит 38 тактов за пару. POP считывает оба байта, инкрементирует указатель и загружает регистровую пару — 10 тактов, без вариантов. Цена в том, что ты отдаёшь указатель стека рендереру. Ничто другое не может использовать SP, пока работает внутренний цикл.

Это значит, что прерывания фатальны. Если прерывание сработает, когда SP указывает в таблицу адресов, Z80 помещает адрес возврата в «стек» — а это на самом деле твоя таблица данных. Два байта тщательно вычисленных экранных адресов будут перезаписаны адресом возврата, и обработчик прерываний начнёт выполнять мусор, оказавшийся по испорченному адресу. Результат — от искажённого кадра до полного зависания. Решение простое и безоговорочное: `DI` перед захватом SP, `EI` после его восстановления. Каждая подпрограмма с POP-трюком в каждом спектрумовском демо следует этому паттерну:

```z80 id:ch10_stack_based_address_tables
    di
    ld   (.smc_sp+1), sp  ; save SP via self-modifying code
    ld   sp, table_addr    ; point SP at pre-computed data
    ; ... inner loop using POP ...
.smc_sp:
    ld   sp, $0000          ; self-modified: restores original SP
    ei
```

Сохранение/восстановление использует самомодифицирующийся код (SMC), потому что это самый быстрый способ одновременно сохранить и восстановить SP. `EX (SP),HL` требует валидного стека. `LD (addr),SP` существует (опкод ED 73, 20 тактов), но она сохраняет SP по фиксированному адресу — потом понадобится отдельная `LD SP,(addr)` для восстановления (тоже 20 тактов), и восстановление не быстрее SMC-подхода. Техника SMC записывает значение SP прямо в поле операнда последующей инструкции `LD SP,nnnn`: `LD (.smc+1),SP` стоит 20 тактов на сохранение, а восстановление (`LD SP,nnnn` с подменённым операндом) — всего 10 тактов. Суммарные затраты на сохранение+восстановление составляют 30 тактов против 40 тактов для пары LD (addr),SP / LD SP,(addr) — небольшая экономия, которая к тому же не требует отдельной ячейки памяти.

Одно тонкое последствие: окно DI/EI блокирует кадровое прерывание. Если внутренний цикл работает долго, HALT в начале главного цикла всё равно поймает следующее прерывание — но если рендеринг выходит за пределы целого кадра, ты теряешь синхронизацию. Вот почему арифметика бюджета кадра так важна. Ты должен знать время наихудшего случая, прежде чем применять POP-трюк.

Подпрыгивающее движение целиком закодировано в адресной таблице. Каждая запись — экранный адрес, уже включающий вертикальное синусоидальное смещение. «Прыжок» не происходит во время отрисовки. Он произошёл, когда таблица была построена. Все три измерения анимации — позиция прокрутки, волна отскока, форма символа — сворачиваются в единую линейную последовательность 16-битных адресов, потребляемую на полной скорости через POP.

### Внутренний цикл

Анализ Introspec'а 2017 года раскрывает внутренний цикл Illusion. Один байт шрифтовых данных содержит 8 бит — 8 пикселей. `LD A,(BC)` читает байт один раз, затем RLA сдвигает по одному биту через 8 развёрнутых итераций:

```z80 id:ch10_the_inner_loop
; Dotfield scroller inner loop (unrolled for one font byte)
; BC = pointer to font/texture data, SP = pre-built address table

    ld   a,(bc)      ;  7 T  read font byte (once per 8 pixels)
    inc  bc          ;  6 T  advance to next font byte

    ; Pixel 7 (MSB)
    pop  hl          ; 10 T  get screen address from stack
    rla              ;  4 T  shift texture bit into carry
    jr   nc,.skip7   ; 12/7 T  skip if transparent
    set  7,(hl)      ; 15 T  plot the dot
.skip7:
    ; Pixel 6
    pop  hl          ; 10 T
    rla              ;  4 T
    jr   nc,.skip6   ; 12/7 T
    set  6,(hl)      ; 15 T
.skip6:
    ; ... pixels 5 through 0 follow the same pattern,
    ; with SET 5 through SET 0 ...
```

Стоимость на пиксель, без учёта амортизированного чтения байта:

| Путь | Инструкции | Такты (T-states) |
|------|-----------|------------------|
| Непрозрачный пиксель | `pop hl` + `rla` + `jr nc` (не взят) + `set ?,(hl)` | **36** |
| Прозрачный пиксель | `pop hl` + `rla` + `jr nc` (взят) | **26** |

![Прыгающий точечный скроллер в действии — текст отрисован как отдельные пиксели, волнообразно движущиеся по синусоиде](../../build/screenshots/ch10_dotscroll.png)

`LD A,(BC)` и `INC BC` стоят 13 тактов (T-states), амортизированных на 8 пикселей — около 1,6 такта на пиксель. «36 тактов на пиксель» из анализа Introspec'а — это стоимость наихудшего случая в пределах развёрнутого байта, без учёта этих накладных расходов.

Позиция бита в SET меняется для каждого пикселя (7, 6, 5 ... 0), поэтому цикл развёрнут 8 раз, а не повторяется. Нельзя параметризовать позицию бита в SET без индексации через IX/IY (слишком медленно) или самомодифицирующегося кода (SMC) (лишние накладные расходы). Развёрнутый цикл — чистое решение.

### Арифметика бюджета кадра

Давай посчитаем как следует. Стандартный кадр Spectrum 48K — 69 888 тактов (клон Pentagon работает чуть дольше — 71 680). Из них ULA крадёт такты во время активной области отображения из-за конкуренции за память, а скроллер пишет в экранную память в течение всего кадра, не только во время бордюра, поэтому конкуренция — реальный фактор. На практике считай, что доступно около 60 000 тактов на 48K и 65 000 на Pentagon. Вычти воспроизведение музыки (типичный AY-проигрыватель стоит 3000–5000 T за кадр), очистку экрана и построение таблицы. Остаётся примерно 40 000–50 000 тактов на собственно отрисовку точек.

Рассмотрим отображение 8 символов шрифта 8x8 = 512 битов шрифта за кадр (8 символов × 8 байт × 8 бит). При типичном заполнении шрифта около 30% примерно 154 бита установлены (непрозрачные) и 358 — сброшены (прозрачные). Стоимость внутреннего цикла:

- 154 непрозрачных пикселя по 36 T = 5 544 T
- 358 прозрачных пикселей по 26 T = 9 308 T
- 64 считывания байтов (`LD A,(BC) : INC BC`) по 13 T = 832 T
- Итого: примерно 15 684 такта

Это с запасом укладывается в один кадр. Ты мог бы отрисовать 20+ символов, прежде чем упрёшься в потолок бюджета. Узкое место — не внутренний цикл, а построение таблицы. Создание 512 записей адресов с синусными подстановками и вычислением экранного адреса стоит примерно 100–150 тактов на запись (в зависимости от реализации), добавляя 50 000–75 000 T к кадру. Illusion решает это предвычислением всего набора таблиц в памяти с циклическим перебором смещений, либо инкрементальным построением: когда скролл сдвигается на один пиксель, большинство записей таблицы сдвигаются на одну позицию, и только новый столбец требует полного пересчёта.

Цифры работают, потому что две оптимизации дают кумулятивный эффект. Адресация через стек устраняет все вычисления координат из внутреннего цикла. Текстурная прозрачность устраняет все записи для пустых пикселей. Построение таблицы затратно, но оно выполняется вне критичного по времени окна DI и может быть распределено по кадру.

### Как закодирован отскок

Адресная таблица — это то место, где живёт искусство. Чтобы создать подпрыгивающее движение, таблица синусов смещает вертикальную позицию каждого столбца:

```text
y_offset = sin_table[(column * phase_freq + scroll_pos * speed_freq) & 255]
```

Два параметра частоты управляют визуальным характером волны. `phase_freq` определяет пространственную частоту — сколько волновых циклов укладывается в видимые столбцы точек. Значение 4 означает, что каждый столбец точек продвигается на 4 позиции в таблице синусов, так что 256/4 = 64 столбца охватывают один полный цикл волны. Значение 8 удваивает частоту, создавая более плотную рябь. `speed_freq` управляет скоростью распространения волны во времени: большие значения заставляют колебание прокручиваться быстрее, независимо от прокрутки текста.

Сама таблица синусов — это 256-байтный массив знаковых смещений, выровненный по странице для быстрого доступа. Выравнивание по странице означает, что старший байт адреса таблицы фиксирован; меняется только младший, поэтому подстановка сводится к:

```z80 id:ch10_how_the_bounce_is_encoded_2
    ld   hl, sin_table    ; H = page, L = don't care
    ld   l, a             ; A = (column * freq + phase) & $FF
    ld   a, (hl)          ; 7 T — one memory read, no arithmetic
```

Значения в таблице знаковые: положительные смещения сдвигают точку вниз, отрицательные — вверх. Амплитуда заложена в таблицу при генерации. Таблица с диапазоном от -24 до +24 даёт колебание в 48 строк развёртки от пика до пика. Генерация таблицы — одноразовая затрата, обычно выполняемая офлайн или при инициализации с помощью таблицы подстановки или простой аппроксимации. На Z80 вычисление истинных значений синуса в реальном времени дорого, поэтому демосценовые кодеры либо предвычисляют таблицы внешним инструментом, либо используют квадрантную симметрию: вычисляют четверть волны (64 записи), затем зеркально отражают и инвертируют знак, чтобы заполнить оставшиеся три четверти.

По координатам каждой точки (x, y + y_offset) вычисляется экранный адрес Spectrum и сохраняется в таблице. Код построения таблицы выполняется один раз за кадр, вне внутреннего цикла. Внутренний цикл видит лишь поток предварительно вычисленных адресов.

### За пределами простого синуса: Лиссажу, спираль и многоволновые паттерны

Красота подхода с предвычисленной таблицей в том, что внутреннему циклу безразлично, какую форму описывает движение. Он потребляет адреса с фиксированной стоимостью независимо от траектории, которая их породила. Это делает тривиальным эксперименты с различными паттернами движения — вся сложность сосредоточена в коде построения таблицы.

**Фигура Лиссажу** добавляет горизонтальное синусное смещение в дополнение к вертикальному. Вместо того чтобы каждый столбец отображался на фиксированную x-позицию байта на экране, x-координата тоже осциллирует:

```text
x_offset = sin_table[(column * x_freq + phase_x) & 255]
y_offset = sin_table[(column * y_freq + phase_y) & 255]
```

Когда `x_freq` и `y_freq` взаимно просты (скажем, 3 и 2), точечное поле вычерчивает фигуру Лиссажу — классический осциллографический паттерн. Текст превращается в ленту, вьющуюся в пространстве. Различные соотношения частот дают кардинально разные формы: 1:1 даёт круг или эллипс, 1:2 — восьмёрку, 2:3 — трилистник, знакомый по старому аналоговому измерительному оборудованию.

Эффект **спирали** или **геликоида** использует единственную фазу, нарастающую от столбца к столбцу, но с переменной амплитудой:

```text
amplitude = base_amp + sin_table[(column * 2 + time) & 255] * depth_scale
y_offset = sin_table[(column * freq + phase) & 255] * amplitude / max_amp
```

Это создаёт иллюзию точек, уходящих вглубь — волна сглаживается в «дальней» точке спирали и расширяется в «ближней».

**Многоволновая суперпозиция** — простейшая техника с самым зрелищным результатом. Сложи два синусных слагаемых с разными частотами:

```text
y_offset = sin_table[(col * 4 + phase1) & 255] + sin_table[(col * 7 + phase2) & 255]
```

Результат — сложная, органично выглядящая волна, которая практически не повторяется. Продвижение `phase1` и `phase2` с разными скоростями порождает непрерывно эволюционирующее движение всего из двух обращений к таблице на столбец. Три и более гармоники создают волны, которые выглядят почти как гидродинамика. Это самый дешёвый способ генерировать сложное движение — каждая дополнительная гармоника стоит одно обращение к таблице и одно сложение на столбец в построителе таблицы, а стоимость внутреннего цикла остаётся неизменной.

---

## Часть 2: 4-фазная цветовая анимация

### Проблема цвета

Каждая ячейка 8x8 имеет один цвет чернил (0-7) и один цвет бумаги (0-7). В пределах одного кадра ты получаешь ровно два цвета на ячейку. Но Spectrum работает на частоте 50 кадров в секунду, и человеческий глаз не различает отдельные кадры на такой частоте. Он видит среднее.

### Трюк

4-фазная техника Introspec'а циклически переключается между четырьмя кадрами:

1. **Нормальный A:** ink = C1, paper = C2. Пиксельные данные = паттерн A.
2. **Нормальный B:** ink = C3, paper = C4. Пиксельные данные = паттерн B.
3. **Инвертированный A:** ink = C2, paper = C1. Пиксельные данные = паттерн A (те же пиксели, цвета поменяны местами).
4. **Инвертированный B:** ink = C4, paper = C3. Пиксельные данные = паттерн B (те же пиксели, цвета поменяны местами).

На частоте 50 Гц каждый кадр отображается в течение 20 миллисекунд. Четырёхкадровый цикл завершается за 80 мс — 12,5 циклов в секунду, выше порога слияния мерцания на CRT-дисплеях.

### Математика восприятия

Проследим один пиксель, который «включён» в паттерне A и «выключен» в паттерне B:

| Кадр | Состояние пикселя | Отображаемый цвет |
|------|------------------|--------------------|
| Нормальный A | вкл (ink) | C1 |
| Нормальный B | выкл (paper) | C4 |
| Инвертированный A | вкл (ink) | C2 |
| Инвертированный B | выкл (paper) | C3 |

Глаз воспринимает среднее: (C1 + C2 + C3 + C4) / 4.

Теперь проверим: пиксель, «включённый» в обоих паттернах, видит C1, C3, C2, C4. Пиксель, «выключенный» в обоих, видит C2, C4, C1, C3. Во всех случаях получается одно и то же среднее. Пиксельный паттерн не влияет на воспринимаемый оттенок — на него влияет только выбор C1 до C4.

Тогда зачем два паттерна? Потому что *промежуточные* переходы имеют значение. Пиксель, чередующийся между ярко-красным и ярко-зелёным, заметно мерцает на 12,5 Гц. Пиксель, чередующийся между близкими оттенками, едва мерцает. Паттерны дизеринга — шахматные, полутоновые, упорядоченные матрицы — управляют *текстурой* мерцания. Introspec подобрал паттерны так, чтобы переходы между кадрами давали минимальное видимое колебание. Это антиконфликтный подбор пикселей: тщательная расстановка «включённых» и «выключенных» битов, чтобы ни один пиксель не переключался между кардинально различающимися цветами в последовательных кадрах.

### Почему инверсия необходима

Без шага инверсии «включённые» пиксели всегда показывали бы ink, а «выключенные» — всегда paper. Ты получил бы ровно два видимых цвета на ячейку, мерцающих между двумя разными парами. Инверсия гарантирует, что и ink, и paper вносят вклад в оба состояния пикселей на протяжении цикла, смешивая все четыре цвета в воспринимаемый результат.

На Spectrum инверсия обходится дёшево. Байт атрибутов имеет формат `FBPPPIII` — Flash, Bright, 3 бита фона (paper), 3 бита чернил (ink). Обмен ink и paper означает ротацию младших 6 бит: paper перемещается на позицию ink, ink — на позицию paper, а Flash и Bright остаются на месте. В коде:

```z80 id:ch10_why_inversion_is_essential
; Swap ink and paper in attribute byte (A)
; Input:  A = F B P2 P1 P0 I2 I1 I0
; Output: A = F B I2 I1 I0 P2 P1 P0
    ld   b, a
    and  $C0           ; isolate Flash + Bright bits
    ld   c, a          ; save FB------
    ld   a, b
    and  $38           ; isolate paper (--PPP---)
    rrca
    rrca
    rrca               ; paper now in ink position (-----PPP)
    ld   d, a          ; save ink-from-paper
    ld   a, b
    and  $07           ; isolate ink (-----III)
    rlca
    rlca
    rlca               ; ink now in paper position (--III---)
    or   d             ; combine: --IIIPPP
    or   c             ; combine: FBIIIPPP = swapped attribute
```

Альтернатива — предвычислить оба буфера атрибутов (нормальный и инвертированный) при инициализации и просто переключать указатели буферов во время выполнения. Это обменивает 3072 байта памяти на нулевые вычисления за кадр — стоящий обмен на 128K-машинах, где памяти хватает.

### Практическая стоимость

Четыре предварительно построенных буфера атрибутов, циклически сменяемых каждый кадр. Покадровая стоимость — блочное копирование 768 байт в область атрибутов ($5800-$5AFF). Через LDIR это стоит 21 такт на байт: 768 × 21 = 16 128 тактов. С использованием стекового трюка (POP из исходного буфера, переключение SP, PUSH в атрибутную память, пакетирование через регистровые пары и теневые регистры) реалистичная стоимость — около 11 000–13 000 тактов, в зависимости от размера пакета и накладных расходов цикла — скромное ускорение в 1,2–1,5 раза по сравнению с LDIR. Выигрыш меньше, чем можно было бы ожидать, потому что каждый пакет требует двух переключений SP (сохранить позицию источника, загрузить адрес назначения, затем переключить обратно), и эти накладные расходы в значительной мере нивелируют преимущество POP+PUSH в чистой скорости перед LDIR. Для *заливки* (запись одного и того же значения в каждый байт) PUSH-трюк намного эффективнее — загрузи регистровые пары один раз и затем выполняй PUSH многократно — но копирование из различающихся исходных данных не может избежать затрат на чтение.

Логика циклической смены тривиальна. Единственная переменная хранит фазу (0–3). Каждый кадр: инкремент и AND с 3 для закольцовки. Индексация в 4-элементную таблицу базовых адресов буферов:

```z80 id:ch10_practical_cost
    ld   a, (phase)
    inc  a
    and  3
    ld   (phase), a
    add  a, a           ; phase * 2 (pointer table is 16-bit entries)
    ld   hl, buf_ptrs
    ld   e, a
    ld   d, 0
    add  hl, de
    ld   a, (hl)
    inc  hl
    ld   h, (hl)
    ld   l, a           ; HL = source buffer address
    ld   de, $5800      ; DE = attribute RAM
    ld   bc, 768
    ldir                ; copy attributes for this phase
```

Память: 4 × 768 = 3072 байта на буферы. На 48K-машине это значительная часть; на 128K можно разместить буферы в подключаемых банках памяти. Пиксельные паттерны (A и B) записываются один раз при инициализации и больше не затрагиваются — каждый кадр меняется только атрибутная память.

### Текстовый оверлей

В Eager поверх цветовой анимации прокручивается текст. Существует несколько подходов, каждый со своими компромиссами.

Простейший — **исключение ячеек**: зарезервировать определённые символьные ячейки под текст, исключить их из цветового цикла и записать фиксированные атрибуты «белый на чёрном» с реальными глифами шрифта. Реализуется легко — достаточно замаскировать эти ячейки при копировании LDIR — но создаёт жёсткую визуальную границу между анимированным фоном и статичной текстовой областью. Текст выглядит наклеенным.

Более изощрённый подход — **интеграция в паттерны**: формы глифов переопределяют конкретные биты в обоих пиксельных паттернах A и B. Там, где у шрифта бит установлен, оба паттерна получают этот бит установленным (или сброшенным, в зависимости от желаемого цвета текста). Это гарантирует, что текстовый пиксель показывает один и тот же цвет во всех четырёх фазах — он не мерцает, потому что никогда не переключается между разными цветовыми состояниями. Окружающие пиксели продолжают циклическую смену в обычном режиме. Результат — текст, который как будто парит над анимированным фоном, с цветовым подтеканием к краям каждой буквы. Стоимость в том, что приходится регенерировать (или патчить) пиксельные паттерны при каждом сдвиге текста, что добавляет несколько тысяч тактов за кадр в зависимости от количества ячеек с текстом.

Третий вариант для 128K-машин — **послойное композитирование**: хранить 4-фазный фон в одном наборе страниц памяти, а текстовый скроллер — в другом, и комбинировать их при копировании атрибутов. Это делает две системы независимыми — скроллеру не нужно знать о цветовой анимации, и наоборот — ценой чуть более сложного цикла копирования, маскирующего текстовые ячейки.

---

## Родословная на демосцене

Точечный скроллер не появился из ниоткуда. Техника стоит в линии эффектов ZX Spectrum, которая тянется с середины 1980-х до наших дней.

Самые ранние спектрумовские скроллеры были простыми посимвольными: горизонтальный скроллинг на LDIR, сдвигающий целую строку символьных ячеек по одному байту за раз. Плавный пиксельный скроллинг был сложнее — у Spectrum нет аппаратного регистра скроллинга, поэтому каждый сдвиг на пиксель требует перезаписи растровых данных. К началу 1990-х демосценовые кодеры разработали несколько подходов: пиксельный скроллинг на RL/RR (сдвиг каждого байта экранной строки), скроллеры на таблицах подстановки (предсдвинутые копии каждого символа) и технику двойной буферизации (рисуем в задний буфер, копируем на экран). Все они были ограничены фундаментальной стоимостью перемещения байтов в видеопамять и из неё.

Точечный подход полностью разрывает с этой традицией. Вместо скроллинга сплошного блока пикселей он разбивает текст на отдельные точки и размещает каждую независимо. В этом состояла идея Dark в середине 1990-х: если отказаться от идеи сплошного шрифта и принять пуантилистский рендеринг, можно использовать POP-трюк для размещения каждой точки с минимальными накладными расходами. Визуальный результат — текст, распадающийся в облако частиц, прыгающих на синусоиде — стал одним из фирменных эффектов русской демосцены.

*Illusion* от X-Trade (ENLiGHT'96) было демо, которое прославило эту технику в мире Spectrum. Точечный скроллер был его центральным эффектом, плавно работающим наряду с музыкой и другими визуальными элементами. Dark опубликовал алгоритмические принципы в *Spectrum Expert* выпуски #01 и #02 (1997–98), где описал общий подход к POP-рендерингу и анимации на таблице синусов. Двадцать лет спустя детальный реверс-инжиниринг бинарника Illusion, выполненный Introspec (опубликован в журнале *Hype*, 2017), подтвердил заявления Dark и предоставил точные подсчёты тактов, о которых сообщество долго гадало.

Техника 4-фазного цвета имеет другую родословную. Цветовая циклическая смена на Spectrum исследовалась с 1980-х — простое двухкадровое чередование (эффекты типа flash) было обычным в играх и демо. Но систематический четырёхфазный подход, с его тщательным шагом инверсии, обеспечивающим равный вклад всех четырёх цветов, был доведён до совершенства Introspec для *Eager* (3BM Open Air 2015). В file_id.diz пати-версии техника упомянута явно, а статья Introspec «Making of Eager» в *Hype* (2015) описывает процесс проектирования: выбор цветов так, чтобы соседние фазы минимизировали видимое мерцание, и использование паттернов дизеринга, равномерно распределяющих переходы по ячейке.

Более широкий принцип — временное мультиплексирование цвета — встречается и на других платформах. Atari 2600 знаменита чередованием кадров для создания мерцающих псевдо-спрайтов. Game Boy использует похожий трюк для псевдо-прозрачности. На Spectrum техника особенно эффективна, потому что послесвечение люминофора ЭЛТ сглаживает переходы лучше, чем это сделал бы ЖК-дисплей. Стоит отметить для современных зрителей: 4-фазный цвет выглядит существенно лучше на настоящем ЭЛТ или в хорошем ЭЛТ-эмуляторе (с симуляцией люминофора), чем на чистом попиксельном дисплее.

---

## Общий принцип: временной обман

Точечный скроллер использует 50 кадров в секунду для *пространственной* гибкости. Каждый кадр — это снимок позиций точек в один момент; мозг зрителя интерполирует между снимками, воспринимая плавное движение. Задача процессора — *расставить* точки как можно быстрее, читая предварительно вычисленные адреса из стека.

4-фазная цветовая анимация использует 50 кадров в секунду для *цветовой* гибкости. Каждый кадр показывает одно из четырёх цветовых состояний; сетчатка зрителя усредняет их. Ни один отдельный кадр не содержит воспринимаемого результата — он существует только в инерции зрительного восприятия.

Обе техники эксплуатируют одну и ту же физическую реальность: ЭЛТ обновляется на частоте 50 Гц, и зрительная система человека не в состоянии различить отдельные кадры на этой частоте. *Временное* разрешение Spectrum значительно богаче его пространственного или цветового разрешения. Демосценовые кодеры обнаружили, что временное разрешение — самая дешёвая ось для эксплуатации.

Обе техники сводят свои внутренние циклы к абсолютному минимуму. Скроллер — до 36 тактов на точку. Цветовая анимация — до одного копирования буфера за кадр. Обе выносят сложность из внутреннего цикла в предварительные вычисления. И обе дают результаты, которые, на взгляд обычного зрителя, кажутся невозможными для этого оборудования.

Вот что делает демосцену искусством времени. Скриншот точечного скроллера — россыпь пикселей. Скриншот 4-фазной цветовой анимации — два цвета на ячейку, ровно как предписывает аппаратура. Надо видеть их *в движении*, чтобы увидеть, как они работают. Красота — в последовательности, а не в отдельном кадре.

---

## Практика 1: Текстовый скроллер с подпрыгивающей точечной матрицей

Построй упрощённый точечный скроллер: короткое текстовое сообщение, отрисованное как подпрыгивающее точечное поле с адресацией на основе POP.

**Структуры данных.** Выровненный по странице растровый шрифт 8x8 (подойдёт ROM-шрифт по адресу `$3D00`). 256-байтная таблица синусов для смещения отскока. RAM-буфер для адресной таблицы (до 4096 x 2 байт).

**Построение таблицы.** Перед каждым кадром итерируй по видимым символам. Для каждого бита в каждом байте шрифта вычисли экранный адрес с учётом синусоидального смещения и сохрани его в адресной таблице. Это выполняется один раз за кадр, вне внутреннего цикла.

**Отрисовка.** Запрети прерывания. Сохрани SP через самомодифицирующийся код (SMC). Направь SP на адресную таблицу. Выполни развёрнутый внутренний цикл: `ld a,(bc) : inc bc`, затем 8 повторений `pop hl : rla : jr nc,skip : set N,(hl)` с N от 7 до 0. Восстанови SP. Разреши прерывания.

**Основной цикл.** `halt` (синхронизация с 50 Гц), очистка экрана (PUSH-очистка из главы 3), построение адресной таблицы, отрисовка точечного поля, продвижение позиции прокрутки и фазы отскока.

**Расширения.** Частичная очистка экрана (отслеживание ограничивающего прямоугольника). Двойная буферизация через теневой экран на 128K. Множественные гармоники отскока. Переменная плотность точек для более разреженного, эфемерного вида.

---

## Практика 2: 4-фазная анимация цветового цикла

Построй 4-фазную цветовую анимацию, создающую плавные градиенты.

**Пиксельные паттерны.** Заполни область растра двумя комплементарными паттернами дизеринга. Простейший вариант: чётные пиксельные строки заполняются `$55` (01010101), нечётные — `$AA` (10101010). Для продакшен-качества используй упорядоченную матрицу Байера 4x4.

**Буферы атрибутов.** Предварительно рассчитай четыре 768-байтных буфера. Буферы 0 и 1 содержат нормальные атрибуты с двумя различными цветовыми схемами (изменяющиеся ink/paper по экрану для диагонального градиента). Буферы 2 и 3 — инвертированные версии: биты ink и paper поменяны местами. Перестановка выполняется битовой ротацией: три RRCA для перемещения битов ink на позицию paper, три RLCA в обратном направлении, маска и объединение.

**Основной цикл.** Каждый кадр: `halt`, индекс в 4-элементную таблицу указателей на буферы с помощью счётчика фаз (AND 3), LDIR 768 байт в `$5800`, инкремент счётчика фаз. Это весь движок времени выполнения — около 16 000 тактов (T-states) за кадр.

**Анимация.** Для движущегося градиента перегенерируй один буфер за кадр (тот, который скоро станет самым старым в 4-кадровом цикле) с продвигающимся цветовым смещением. Это поддерживает конвейер: отображай кадр N, генерируя кадр N+4. Альтернативно — предварительно рассчитай все буферы по банкам 128K для нулевой стоимости в рантайме.

---

## Итого

- **Точечный скроллер** отрисовывает текст как отдельные точки. Внутренний цикл — `pop hl : rla : jr nc,skip : set ?,(hl)` — стоит 36 тактов (T-states) на непрозрачный пиксель, 26 — на прозрачный.
- **Адресация через стек** кодирует траекторию отскока как предварительно построенные экранные адреса. POP извлекает их по 10 тактов за штуку — самое быстрое произвольное чтение на Z80.
- **4-фазный цвет** циклически переключает 4 кадра атрибутов (2 нормальных + 2 инвертированных) на 50 Гц. Инерция зрительного восприятия усредняет цвета, создавая иллюзию более чем 2 цветов на ячейку.
- **Шаг инверсии** гарантирует, что все четыре цвета вносят вклад в каждую пиксельную позицию.
- Обе техники эксплуатируют **временное разрешение** для создания эффектов, невозможных в любом отдельном кадре.
- Скроллер использует стек для пространственной гибкости; цветовая анимация использует чередование кадров для цветовой гибкости — две главные оси демосценового обмана.

---

## Попробуй сам

1. Построй точечный скроллер. Начни с одного статичного символа, отрисованного через внутренний цикл на основе POP. Проверь ожидаемые тайминги с помощью тестовой обвязки бордюра из главы 1. Затем добавь таблицу отскока и наблюдай, как он волнится.

2. Экспериментируй с параметрами отскока. Измени амплитуду синуса, пространственную частоту и скорость фазы. Небольшие изменения дают разительные визуальные различия.

3. Построй 4-фазную цветовую анимацию. Начни с однородного цвета (все ячейки одинаковые в каждой фазе). Убедись, что видишь ровный цвет, который не является ни ink, ни paper ни одного отдельного кадра. Затем добавь диагональный градиент.

4. Попробуй различные паттерны дизеринга. Шахматный, блоки 2x2, матрица Байера, случайный шум. Какие минимизируют видимое мерцание? Какие дают наиболее плавные воспринимаемые градиенты?

5. Объедини обе техники: 4-фазный цветной фон с монохромным точечным скроллером поверх.

---

> **Источники:** Introspec, «Technical Analysis of Illusion by X-Trade» (Hype, 2017); Introspec, «Making of Eager» (Hype, 2015); Dark, «Programming Algorithms» (Spectrum Expert #01, 1997). Дизассемблирование внутреннего цикла и подсчёт тактов следуют анализу Introspec'а 2017 года. 4-фазная цветовая техника описана в making-of Eager и file_id.diz пати-версии.
