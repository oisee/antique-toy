# Глава 15: Анатомия двух машин

> "Design characterizes realizational, stylistic, ideological integrity."
> -- Introspec (spke), "For Design" (Hype 2015)

Добро пожаловать в Часть V. Мы создаём игру.

Части I--IV дали тебе инструментарий демосценера: подсчёт тактов, экранные трюки, оптимизацию внутренних циклов, звуковую архитектуру, сжатие. Игра предъявляет другие требования. Тебе нужна полная карта памяти, а не только область экрана. Тебе нужно понимать переключение банков, потому что твои уровни, музыка и данные спрайтов не поместятся в один непрерывный блок. Тебе нужно знать, как два процессора Agon Light 2 общаются друг с другом, потому что твой игровой цикл пересекает эту границу.

Эта глава -- аппаратный справочник для всего, что последует. Где Глава 1 дала тебе бюджет кадра, а Глава 2 -- раскладку экрана, эта глава даёт всё остальное. Держи её под рукой.

---

## 15.1 ZX Spectrum 128K: карта памяти

Оригинальный 48K Spectrum имел простую модель памяти: 16 КБ ПЗУ по адресам `$0000`-`$3FFF`, 48 КБ ОЗУ по `$4000`-`$FFFF`. Модель 128K сохраняет эту раскладку, видимую процессору, но прячет систему банков под ней.

128K имеет восемь 16-килобайтных страниц ОЗУ (страницы 0-7, в сумме 128 КБ) и два 16-килобайтных ПЗУ (ROM 0: редактор 128K, ROM 1: 48K BASIC). В каждый момент Z80 видит 64 КБ адресного пространства, разделённого на четыре 16-килобайтных слота:

| Диапазон адресов | Содержимое | Примечания |
|------------------|-----------|------------|
| `$0000`-`$3FFF` | ROM (0 или 1) | Выбирается битом 4 `$7FFD` |
| `$4000`-`$7FFF` | Страница ОЗУ 5 | **Всегда** страница 5. Здесь живёт экранная память. |
| `$8000`-`$BFFF` | Страница ОЗУ 2 | **Всегда** страница 2. |
| `$C000`-`$FFFF` | Страница ОЗУ N | Переключаемая: любая страница 0-7 через `$7FFD` |

Страницы 5 и 2 жёстко привязаны к своим слотам. Ты не можешь их заменить. Это означает, что экран (`$4000`-`$57FF`) всегда доступен, а твой основной код (обычно ORG на `$8000`) находится в странице 2, где он не исчезнет при переключении банков.

Верхний 16-килобайтный слот по адресу `$C000`-`$FFFF` -- это гибкий слот. Запиши в порт `$7FFD`, и отображённая туда страница изменится.

### Порт $7FFD: переключение банков

Порт `$7FFD` управляет конфигурацией памяти на 128K. Он доступен только для записи -- ты не можешь его прочитать обратно. Это означает, что ты должен хранить его теневую копию в переменной ОЗУ, если тебе нужно знать текущее состояние.

```text id:ch15_the_7ffd_port_bank_switching
Port $7FFD bit layout:
  Bit 0-2:  RAM page mapped at $C000 (0-7)
  Bit 3:    Screen select (0 = normal screen at page 5,
                           1 = shadow screen at page 7)
  Bit 4:    ROM select (0 = 128K ROM, 1 = 48K BASIC ROM)
  Bit 5:    Disable paging (set this and banking is locked
            until next reset -- used by 48K BASIC)
  Bits 6-7: Unused
```

Типичная подпрограмма переключения банков:

```z80 id:ch15_the_7ffd_port_bank_switching_2
; Switch RAM page at $C000 to page number in A (0-7)
; Preserves other $7FFD bits from shadow variable
bank_switch:
    ld   b, a                 ; 4T   save desired page
    ld   a, (bank_shadow)     ; 13T  load current $7FFD state
    and  %11111000            ; 7T   clear page bits (0-2)
    or   b                    ; 4T   insert new page number
    ld   (bank_shadow), a     ; 13T  update shadow
    ld   bc, $7FFD            ; 10T
    out  (c), a               ; 12T  do the switch
    ret                       ; 10T
                              ; --- 73T total
```

Эти 73 такта (T-state) не бесплатны, но пренебрежимо малы по сравнению с бюджетом кадра 70 000+. Реальная стоимость банкинга -- архитектурная, не временная: ты должен проектировать раскладку данных так, чтобы тебе никогда не нужен доступ к двум разным переключаемым страницам одновременно. Музыкальные данные в странице 4, данные уровня в странице 3, спрайтовая графика в странице 6 -- но твой музыкальный проигрыватель и рендерер не могут оба работать из `$C000` одновременно.

**Теневой экран.** Бит 3 `$7FFD` выбирает, какую страницу ОЗУ ULA читает для отображения: страницу 5 (обычная) или страницу 7 (теневая). Это даёт тебе аппаратную двойную буферизацию -- рисуй на теневом экране, пока ULA показывает обычный, затем переключи, изменив бит 3. Мы будем активно использовать это в Главе 17 (Скроллинг) и Главе 21 (Полная игра).

### Практическая карта памяти для игры на 128K

Вот как реальная игра может распределить свои 128 КБ по восьми страницам:

| Страница | Слот | Использование |
|----------|------|---------------|
| 0 | `$C000` (переключаемая) | Данные уровней (карты, определения тайлов) |
| 1 | `$C000` (переключаемая) | Набор спрайтовой графики 1 |
| 2 | `$8000`-`$BFFF` (фиксированная) | Основной код игры, система сущностей, обработчик прерываний |
| 3 | `$C000` (переключаемая) | Набор спрайтовой графики 2, таблицы подстановки |
| 4 | `$C000` (переключаемая) | Музыкальные данные (.pt3 паттерны, инструменты) |
| 5 | `$4000`-`$7FFF` (фиксированная) | Основной экран, память атрибутов, системные переменные |
| 6 | `$C000` (переключаемая) | Звуковые эффекты, дополнительные данные уровней |
| 7 | `$C000` (переключаемая) | Теневой экран (цель двойной буферизации) |

Заметь: страница 7 служит двойному назначению. ULA может отображать её как теневой экран, но ты можешь также подключить её к `$C000` и использовать как 16-килобайтную страницу данных, когда не используешь двойную буферизацию. Многие демо это эксплуатируют.

Критическое ограничение: **твой обработчик прерываний и основной цикл должны жить в страницах 2 или 5**, потому что только эти страницы гарантированно отображены в любое время. Если прерывание сработает, пока страница 4 подключена к `$C000`, а твой обработчик прерываний живёт по адресу `$C000`, ЦП прыгнет в твои музыкальные данные вместо кода. Результат -- крэш, обычно зрелищный.

**Правило:** никогда не помещай критичный по времени код в переключаемую страницу, если ты абсолютно не уверен, какая страница активна, когда этот код выполняется.

<!-- figure: ch15_memory_map -->
![ZX Spectrum 128K memory map](illustrations/output/ch15_memory_map.png)

---

## 15.2 Спорная память: практическая правда

В Главе 1 мы установили, что клоны Pentagon не имеют спорной памяти и что подсчёт тактов надёжен повсюду. Это правда, и Pentagon остаётся стандартом для потактово точной демосценической работы. Но если ты пишешь игру для релиза, среди твоих игроков будут люди на оригинальном оборудовании Sinclair, моделях Amstrad +2A/+3 и современных FPGA-клонах, эмулирующих оригинальный тайминг. Тебе нужно знать, что делает спорная память и как избежать её худших эффектов.

Introspec исчерпывающе осветил это в своих статьях "GO WEST" на Hype (2015). Вот практическое резюме.

### Что подвержено спорности

На оригинальных машинах Sinclair ULA и ЦП разделяют шину памяти. Когда ULA читает данные экрана для отрисовки дисплея (во время 192 активных строк развёртки), любой доступ ЦП к определённым страницам ОЗУ задерживается. ЦП буквально останавливается на дополнительные такты (T-state), пока ULA не завершит своё чтение.

Спорные страницы различаются между моделями:

| Модель | Спорные страницы | Всегда быстрые |
|--------|------------------|----------------|
| 48K | Только страница 5 (`$4000`-`$7FFF`) | `$8000`-`$FFFF` (не спорная) |
| 128K / +2 | Страницы 1, 3, 5, 7 | Страницы 0, 2, 4, 6 |
| +2A / +2B / +3 | Страницы 4, 5, 6, 7 | Страницы 0, 1, 2, 3 |

На 48K спорной является только нижняя область ОЗУ в 16 КБ (`$4000`-`$7FFF`, страница 5) — верхние 32 КБ (`$8000`-`$FFFF`) не спорные. На 128K паттерн — каждая нечётная страница. На +2A/+3 всё наоборот: верхние страницы спорные.

Это имеет непосредственные практические последствия. На 128K твой основной код по адресу `$8000` (страница 2) находится в неспорной памяти -- быстрый. Экран по адресу `$4000` (страница 5) -- спорный -- записи в экранную память медленнее во время активного отображения. И страница 7 (теневой экран) тоже спорная, что значит, что заполнение двойного буфера на теневом экране медленнее, чем можно ожидать, на оригинальном оборудовании.

### Насколько медленнее?

Introspec измерил реальные штрафы:

- **Случайный побайтовый доступ к спорной памяти:** приблизительно **0,92 дополнительных такта (T-state) на байт** в среднем во время активного отображения
- **Стековые операции (PUSH/POP) к спорной памяти:** приблизительно **1,3 дополнительных такта (T-state) на байт** в среднем
- **Во время бордюра:** **нулевой штраф** -- спорность возникает только пока ULA активно рисует строки развёртки

Эта цифра 0,92 означает, что `LD A,(HL)`, которая должна стоить 7 тактов (T-state), будет стоить в среднем около 7,92 тактов, когда HL указывает в спорную память во время активного отображения. PUSH, записывающий два байта в спорную память при 11 тактах, будет стоить около 13,6 тактов вместо этого.

Эти средние скрывают хаотичную реальность: фактический штраф зависит от того, куда в 8-тактовом цикле чтения ULA попадает твой доступ ЦП. Паттерн повторяется каждые 8 тактов: штрафы 6, 5, 4, 3, 2, 1, 0, 0 дополнительных тактов. Ты можешь попасть в любую точку этого цикла, и штраф накапливается с каждым обращением к памяти внутри инструкции. Это делает точный подсчёт тактов на спорных машинах действительно трудным.

### Практический ответ

Для разработки игр, а не демо-эффектов, подход прост:

1. **Помести код в неспорную память.** На 128K делай ORG по адресу `$8000` (страница 2) -- всегда быстрый.
2. **Пиши на экран во время бордюра, когда возможно.** Верхний и нижний бордюры дают доступ к экранной памяти без спорности. То же касается левого/правого бордюра каждой строки развёртки.
3. **Не беспокойся о точном моделировании спорности.** Заложи 15-20% замедление для кода, обращающегося к экранной памяти во время активного отображения, и проектируй бюджет кадра с этим запасом. Это не потактово точная работа для демо; это разработка игр.
4. **Тестируй на реальном оборудовании или точных эмуляторах.** Fuse правильно эмулирует спорность. Unreal Speccy (режим Pentagon) -- нет, по замыслу. ZEsarUX может эмулировать несколько моделей.

Совет Introspec'а из GO WEST сводится к следующему: **спорная память -- это проблема переносимости, а не драма.** Если твой код работает на Pentagon, он почти наверняка будет работать и на оригинальном оборудовании -- просто чуть медленнее при записи на экран. Места, где спорность реально ломает вещи -- это потактово точные растровые эффекты (мультиколор, синхронизация по плавающей шине), а это демо-техники, не игровые.

---

## 15.3 Тайминг ULA

ULA генерирует видеосигнал и прерывание ЦП. Понимание её тайминга необходимо для бордюрных эффектов, музыки на прерываниях и синхронизации экрана.

### Структура кадра

Полный кадр состоит из строк развёртки. Ширина строки и общее количество строк различаются между моделями:

| Машина | Тактов/строка | Строк | Тактов/кадр |
|--------|--------------|-------|-------------|
| ZX Spectrum 48K | 224 | 312 | 69 888 |
| ZX Spectrum 128K | 228 | 311 | 70 908 |
| Pentagon 128 | 224 | 320 | 71 680 |

Заметь более широкую строку 128K (228 против 224 тактов (T-state)). Дополнительные 4 такта на строку -- в бордюрной/синхронизационной части, не в активном дисплее.

### Такт-карты: области кадра

Кадр делится на три области. Прерывание срабатывает в начале кадрового гасящего импульса, перед верхним бордюром. Вот временная карта для каждой модели:

**Pentagon 128 (71 680 тактов (T-state))**

```text
Interrupt ──┐
            │
Top border  │  80 lines × 224T = 17,920T   No screen reads. No contention.
            │
Active      │ 192 lines × 224T = 43,008T   ULA reads screen memory.
display     │                                No contention on Pentagon.
            │
Bottom      │  48 lines × 224T = 10,752T   No screen reads. No contention.
border      │
────────────┘  Total: 71,680T
```

**ZX Spectrum 128K (70 908 тактов (T-state))**

```text
Interrupt ──┐
            │
Top border  │  63 lines × 228T = 14,364T   No screen reads. No contention.
            │
Active      │ 192 lines × 228T = 43,776T   ULA reads screen memory.
display     │                                Contention on pages 1,3,5,7.
            │
Bottom      │  56 lines × 228T = 12,768T   No screen reads. No contention.
border      │
────────────┘  Total: 70,908T
```

**ZX Spectrum 48K (69 888 тактов (T-state))**

```text
Interrupt ──┐
            │
Top border  │  64 lines × 224T = 14,336T   No screen reads. No contention.
            │
Active      │ 192 lines × 224T = 43,008T   ULA reads screen memory.
display     │                                Contention on all RAM.
            │
Bottom      │  56 lines × 224T = 12,544T   No screen reads. No contention.
border      │
────────────┘  Total: 69,888T
```

После `HALT` у тебя есть весь период верхнего бордюра -- 17 920 тактов (T-state) на Pentagon, 14 364 на 128K -- для работы до того, как луч войдёт в активную область дисплея и начнётся спорность. Вот почему хорошо структурированный код для Spectrum делает записи на экран в начале кадра: ты получаешь доступ к экранной памяти без спорности во время бордюра.

### Тайминг строки развёртки

Каждая строка развёртки разбивается на активную часть (где ULA читает данные экрана) и бордюрную/синхронизационную части:

**48K и Pentagon (224 такта (T-state) на строку):**

```text
128T  active pixel area (ULA reads screen data)
 24T  right border
 48T  horizontal sync + retrace
 24T  left border
```

**128K (228 тактов (T-state) на строку):**

```text
128T  active pixel area (ULA reads screen data)
 24T  right border
 52T  horizontal sync + retrace
 24T  left border
```

Во время 128 активных тактов (T-state) доступ к спорным страницам задерживается (на не-Pentagon машинах). В оставшиеся 96 тактов (или 100 на 128K) -- без спорности. Даже во время активного отображения примерно половина каждой строки развёртки свободна от спорности.

### Общий и практический бюджет

Общие значения кадра выше -- это время между прерываниями. *Практический* бюджет -- такты (T-state), доступные для твоего кода -- меньше:

| Накладные расходы | Стоимость |
|-------------------|-----------|
| HALT + подтверждение прерывания (IM1) | ~30 тактов (T-state) |
| Минимальный обработчик (EI + RET) | ~14 тактов (T-state) |
| Типичный проигрыватель PT3 (в обработчике) | ~3 000--5 000 тактов (T-state) |
| Обслуживание основного цикла (счётчик кадров, переход HALT) | ~20--50 тактов (T-state) |

Практические бюджеты с работающим музыкальным проигрывателем:

| Машина | Общий | После PT3 проигрывателя | После проигрывателя + запас на спорность |
|--------|-------|--------------------------|------------------------------------------|
| Pentagon | 71 680 | ~66 000--68 000 | ~66 000--68 000 (без спорности) |
| 128K | 70 908 | ~65 000--67 000 | ~55 000--60 000 (записи на экран во время акт. отображения) |
| 48K | 69 888 | ~64 000--66 000 | ~50 000--55 000 (вся ОЗУ спорная) |

Когда эта книга говорит "бюджет кадра ~70 000 тактов (T-state)" -- это означает общее значение. При планировании внутренних циклов рассчитывай на практическую цифру -- обычно 65 000--68 000 на Pentagon с музыкой.

---

## 15.4 Плавающая шина, ULA-снег и баг $7FFD

Это три аппаратные причуды, проявляющиеся на оригинальном оборудовании Sinclair, но не на большинстве клонов. Ты можешь никогда не столкнуться с ними при разработке игр, но они могут вызвать загадочные баги, если ты не знаешь об их существовании.

### Плавающая шина

На оригинальном оборудовании Spectrum чтение из неподключённого порта возвращает данные, которые ULA в данный момент выставляет на шину данных. Во время активного отображения ULA читает экранную память, поэтому чтение из порта `$FF` возвращает байт, который ULA сейчас читает.

Демо-кодеры используют это для синхронизации с лучом: читай плавающую шину в тесном цикле, пока не увидишь известное значение из экранной памяти, и ты точно знаешь, где находится луч. Это самый дешёвый метод синхронизации -- без расчёта тайминга прерываний.

Игры редко нуждаются в этом, но имей в виду: если твой код читает из порта, который не существует на данном оборудовании, возвращаемое значение непредсказуемо и варьируется между моделями. Плавающая шина *не* эмулируется на Pentagon, Scorpion или ZX Next.

### Баг чтения $7FFD

Порт `$7FFD` доступен только для записи. Но на некоторых моделях Spectrum чтение из порта `$7FFD` (даже непреднамеренное, через инструкцию, которая случайно выставляет `$7FFD` на адресную шину) приводит к тому, что значение плавающей шины записывается в порт. Это вызывает ложное переключение страниц.

Практическая опасность: инструкция Z80 `LD A,(nn)` выставляет адрес `nn` на шину во время выполнения. Если `nn` случайно оказывается `$7FFD` и ты читаешь данные, хранящиеся по адресу `$7FFD`, чтение памяти может запустить запись в порт на оригинальном оборудовании. Это редкий баг, но реальный. Избегай хранения данных по адресу `$7FFD`.

### ULA-снег

Если регистр I Z80 (используемый для базы таблицы векторов прерываний IM2) установлен в значение в диапазоне `$40`-`$7F`, цикл регенерации DRAM во время каждой выборки опкода M1 выставляет адрес в диапазоне `$4000`-`$7FFF` на адресную шину. Это конфликтует с чтениями экрана ULA и производит визуальный "снег" -- случайный шум на дисплее.

Исправление простое: **никогда не устанавливай I в значение между `$40` и `$7F`.** Типичная настройка IM2 использует `I = $FE` с 257-байтной таблицей идентичных векторов по адресам `$FE00`-`$FF00`. Это держит I далеко за пределами опасной зоны.

---

## 15.5 Различия клонов

Экосистема ZX Spectrum включает десятки клонов, но для современной разработки наиболее важны три: Pentagon 128, Scorpion ZS-256 и ZX Spectrum Next.

### Pentagon 128

Pentagon -- стандартная платформа для русской демосцены и основная цель демосценических глав этой книги.

| Параметр | Pentagon 128 | Оригинал 128K |
|----------|-------------|---------------|
| Тактовая частота ЦП | 3,5 МГц | 3,5 МГц |
| Тактов (T-state) на кадр | **71 680** | 70 908 |
| Строк развёртки на кадр | **320** | 311 |
| Спорная память | **Нет** | Страницы 1, 3, 5, 7 |
| Строк бордюра (верх) | **80** | 63 |
| Строк бордюра (низ) | **48** | 56 |

Дополнительные 772 такта (T-state) на кадр (71 680 против 70 908) приходят от дополнительных строк развёртки. Бордюр распределён по-другому: более высокий верхний бордюр и более короткий нижний. Это влияет на бордюрные эффекты -- демо-код, создающий симметричный бордюрный паттерн на 128K, будет слегка асимметричным на Pentagon.

Отсутствие спорной памяти -- определяющая черта Pentagon для программистов. Каждая инструкция стоит ровно столько, сколько указано в даташите. Вот почему мы используем тайминг Pentagon на протяжении всей этой книги.

**7 МГц турбо-режим.** Многие Pentagon-совместимые машины (Pentagon 512, Pentagon 1024, ATM Turbo 2+) предлагают 7 МГц турбо-режим. ЦП работает на двойной скорости, но тайминг ULA остаётся прежним. Это означает, что бюджет кадра удваивается до приблизительно 143 360 тактов (T-state) в турбо-режиме. Подвох: турбо-режим не стандартизирован на всех машинах, и код, опирающийся на него, не будет работать на стоковом Pentagon 128 или любом оборудовании Sinclair.

Для игр турбо-режим -- это роскошь, позволяющая запускать более сложную логику или больше спрайтов за кадр. Для демо, нацеленных на правила компо, он обычно запрещён -- соревнования указывают "Pentagon 128K, 3,5 МГц".

### Scorpion ZS-256

Scorpion -- украинский клон с 256 КБ ОЗУ (16 страниц по 16 КБ) и несколькими аппаратными расширениями.

| Параметр | Scorpion ZS-256 |
|----------|----------------|
| ОЗУ | 256 КБ (16 страниц) |
| Банкинг | Расширенный порт `$1FFD` для страниц 8-15 |
| Графика | Режим GMX: 320x200, 16 цветов из 256 |
| Спорная память | Нет |
| Тайминг кадра | Pentagon-совместимый (71 680 тактов (T-state)) |

Удвоенная ОЗУ полезна для игр: ты получаешь 16 страниц данных вместо 8. Дополнительные страницы доступны через порт `$1FFD`, использующий схему, аналогичную `$7FFD`, но управляющую дополнительной ОЗУ.

GMX (Graphics Mode Extended) -- козырь Scorpion: дисплей 320x200 с 16 цветами из 256-цветной палитры. Это полностью ломает атрибутный дисплей Spectrum, предлагая линейный фреймбуфер, ближе к тому, что можно увидеть на Amiga или PC VGA. Фреймбуфер GMX большой (32 000 байт для 4-битного цвета) и живёт в расширенных страницах ОЗУ.

Немногие игры нацелены на GMX, потому что это ограничивает аудиторию владельцами Scorpion. Но это демонстрирует, на что способно Z80-оборудование, освобождённое от атрибутной сетки ULA.

### ZX Spectrum Next

ZX Spectrum Next -- современный флагман платформы: машина на FPGA, обратно совместимая с оригинальным Spectrum, но с существенно новым оборудованием.

| Параметр | ZX Spectrum Next |
|----------|-----------------|
| ЦП | Z80N (Z80 + новые инструкции) на 3,5 / 7 / 14 / 28 МГц |
| ОЗУ | 1 МБ (расширяемый до 2 МБ), 8 КБ MMU-страницы |
| MMU | 8 слотов x 8 КБ = тонкое управление маппингом памяти |
| Layer 2 | 256x192 или 320x256, 8-битный цвет (256 цветов) |
| Тайлмэп | Аппаратный слой тайловой карты, 40x32 или 80x32 тайла |
| Спрайты | 128 аппаратных спрайтов, 16x16, до 12 на строку развёртки |
| Copper | Сопроцессор для построчных изменений регистров |
| DMA | zxnDMA для быстрых блочных пересылок |
| Звук AY | 3 x AY-3-8910 (9 каналов) со стерео-панорамированием каждого канала |

**MMU** Next принципиально отличается от банкинга 128K. Вместо одного переключаемого 16-килобайтного слота Next разделяет всё 64-килобайтное адресное пространство на восемь 8-килобайтных слотов. Каждый слот может быть независимо отображён на любую 8-килобайтную страницу из пула ОЗУ 1-2 МБ. Это означает тонкий контроль:

```z80 id:ch15_zx_spectrum_next
; Map 8KB page $0A into slot 3 ($6000-$7FFF)
    ld   a, $0A
    ld   bc, $243B          ; Next register select port
    ld   a, $53             ; Register $53 = MMU slot 3
    out  (c), a
    ld   bc, $253B          ; Next register data port
    ld   a, $0A             ; Page $0A
    out  (c), a
```

Это намного гибче единственного переключаемого слота 128K. Ты можешь отобразить данные спрайтов в одно 8-килобайтное окно, данные уровня в другое и музыкальные данные в третье -- всё одновременно видимое.

**Layer 2** даёт 256-цветный битмап-дисплей без конфликта атрибутов. Это единственное самое значительное улучшение качества жизни для разработчиков игр: больше не нужно тщательное планирование атрибутов, не нужны обходные пути для конфликтов цветов. Просто фреймбуфер, где каждый байт -- один пиксель. Цена -- память: экран Layer 2 256x192 -- это 49 152 байт.

**Аппаратные спрайты** на Next предоставляют 128 слотов спрайтов, каждый 16x16 пикселей с 8-битным цветом, до 12 на строку развёртки. Атрибуты спрайтов (позиция, паттерн, вращение) устанавливаются через регистры Next и порт `$57`. Программный рендеринг не нужен.

**Copper** -- сопроцессор, выполняющий простую программу, синхронизированную с позицией луча. Он может записать в любой регистр Next на любой строке развёртки, обеспечивая построчные смены палитры, смещения скролла и растровые эффекты без потребления тактов (T-state) Z80 -- намеренная дань Amiga Copper.

**zxnDMA** обеспечивает аппаратно-ускоренные блочные пересылки при приблизительно 2 тактах (T-state) на байт -- примерно в 10 раз быстрее `LDIR`. Для заполнения фреймбуфера Layer 2 или пересылки данных спрайтов DMA трансформативен.

Next по сути -- другая машина, которая оказывается обратно совместимой. Интересные ограничения смещаются от "уложусь ли я в бюджет кадра" к "как лучше использовать множественные аппаратные слои".

---

## 15.6 Agon Light 2: другой зверь

Agon Light 2 -- вторая платформа для наших глав по разработке игр. Он работает на Zilog eZ80 -- прямом потомке Z80 -- при 18,432 МГц, с 512 КБ плоской ОЗУ и отдельным сопроцессором ESP32, обрабатывающим видео и аудио. Архитектура принципиально отличается от Spectrum: вместо ЦП, разделяющего шину с фиксированным чипом видеовыхода, Agon использует два независимых процессора, общающихся по последовательной связи.

### Двухпроцессорная архитектура

Определяющая характеристика Agon -- разделение между **eZ80** (твой ЦП) и **ESP32** (VDP, Video Display Processor):

```text
                        +-----------+
                        |   eZ80    |  18.432 MHz
                        |  512 KB   |  Your code runs here
                        |  MOS API  |  24-bit addressing
                        +-----+-----+
                              |
                          UART serial
                          (384 Kbaud)
                              |
                        +-----+-----+
                        |   ESP32   |  240 MHz dual-core
                        |  FabGL    |  Video: up to 640x480
                        |  VDP      |  Audio: waveforms, samples
                        +-----------+
```

Это разделение имеет важные последствия:

1. **Нет общей видеопамяти.** Ты не можешь писать напрямую во фреймбуфер. Каждый пиксель, каждый спрайт, каждая тайловая операция -- это *команда*, отправленная по последовательной связи от eZ80 к ESP32.
2. **Задержка.** Последовательная связь работает на 384 000 бод. Передача одного байта команды занимает около 26 микросекунд. Сложные операции рисования (заливка прямоугольника, отрисовка битмапа) требуют нескольких байт, и VDP нужно время на их выполнение.
3. **Асинхронный рендеринг.** VDP обрабатывает команды из буфера. Твой код на eZ80 отправляет команды и продолжает работать. VDP догоняет независимо. Это значит, что у тебя нет плотной связи Spectrum между работой ЦП и выводом на экран -- но ты также не можешь точно контролировать, когда пиксели появятся.
4. **Независимая частота кадров.** VDP рендерит со своей частотой (обычно 60 Гц). Твой игровой цикл eZ80 может работать с любой частотой; VDP покажет то, что он отрисовал последним.

Для программистов Spectrum это совершенно другой подход. Ты переходишь от «я пишу байты в видеопамять и они появляются на следующей строке развёртки» к «я отправляю команды рисования и доверяю VDP отрендерить их когда-нибудь». Плюс — огромное снижение нагрузки ЦП на графику. Минус — меньше контроля.

### Модель памяти eZ80: 24-битная плоская

eZ80 имеет 24-битную адресную шину, дающую теоретическое адресное пространство 16 МБ. Agon Light 2 отображает 512 КБ ОЗУ в нижнюю часть этого пространства:

| Диапазон адресов | Размер | Содержимое |
|------------------|--------|-----------|
| `$000000`-`$07FFFF` | 512 КБ | ОЗУ |
| `$080000`-`$0FFFFF` | 512 КБ | ОЗУ (зеркало, на некоторых платах) |
| `$A00000`-`$FFFFFF` | varies | Ввод-вывод, встроенная периферия |

Нет банкинга. Нет переключения страниц. Нет спорной памяти. Твой код, данные, буферы, таблицы подстановки — всё живёт в одном плоском, линейно-адресуемом пространстве. После жонглирования 8 страницами Spectrum упрощение ощущается мгновенно.

eZ80 поддерживает два режима работы, определяющих, как он использует адресное пространство.

### ADL-режим и Z80-режим

Это самое важное архитектурное различие на Agon, и оно постоянно сбивает с толку новичков.

**Z80-режим** (также называемый Z80-совместимым режимом) заставляет eZ80 вести себя как классический Z80: 16-битные регистры, 16-битные адреса, 64 КБ адресного пространства. Весь стандартный Z80-код работает без изменений. Верхние 8 бит адреса берутся из регистра MBASE, создавая 64-килобайтное "окно" в 24-битное адресное пространство. Это то, что ты используешь при портировании существующего Z80-кода.

**ADL-режим** (Address Data Long) -- родной режим eZ80: 24-битные регистры, 24-битные адреса, полное 16-мегабайтное адресное пространство. HL, BC, DE, SP, IX/IY -- все 24 бита шириной. `LD HL,$123456` загружает 3-байтное значение. `PUSH HL` помещает 3 байта в стек (не 2). Каждый указатель -- 3 байта.

```z80 id:ch15_adl_mode_vs_z80_mode
; ADL mode: 24-bit addressing, full 512KB accessible
    ld   hl, $040000       ; point to a buffer 256KB into RAM
    ld   (hl), $FF         ; write directly -- no banking needed
    ld   bc, 1024
    ld   de, $040001
    ldir                   ; fill 1KB in one shot
```

MOS (операционная система Agon) загружает eZ80 в ADL-режиме, и большая часть ПО для Agon остаётся в ADL-режиме. Ключевые отличия от Z80-режима:

| Параметр | Z80-режим | ADL-режим |
|----------|-----------|-----------|
| Ширина регистров | 16 бит | 24 бита |
| Адресное пространство | 64 КБ (через MBASE) | 16 МБ (24-битное) |
| Размер PUSH/POP | 2 байта | 3 байта |
| Адреса JP/CALL | 16-битные | 24-битные |
| Размер фрейма стека | 2 байта на запись | 3 байта на запись |
| Кодирование инструкций | Z80-совместимое | Расширенное (3-байтные адреса) |

**Ловушка:** если ты пишешь код, предполагая 16-битные значения, и запускаешь его в ADL-режиме, вещи ломаются неочевидным образом. `PUSH HL` помещает 3 байта, не 2, поэтому твои структуры данных на стеке имеют другой размер. `JP (HL)` прыгает по 24-битному адресу, поэтому таблицы подстановки из 16-битных адресов работать не будут. eZ80 предоставляет инструкции с суффиксами `LD.S` и `LD.L` для явного контроля ширины данных, и ты можешь переключаться между режимами с помощью префиксов `JP.LIL` / `JP.SIS`, но это быстро становится сложным.

**Практическое правило для игр:** оставайся в ADL-режиме. Используй 24-битные адреса повсюду. Не пытайся делить код между сборкой для Spectrum и для Agon на уровне исходников -- адресация слишком различна. Вместо этого дели *алгоритмы* и *форматы данных*, с платформо-специфичными реализациями для доступа к памяти, ввода-вывода и графики.

### MOS API: операционная система

MOS (Machine Operating System) предоставляет системные сервисы на Agon: файловый ввод-вывод, ввод с клавиатуры, доступ к таймерам и связь с VDP. Вызовы MOS делаются через `RST $08` с номером функции в регистре A:

```z80 id:ch15_mos_api_the_operating_system
; MOS API: open a file
    ld   hl, filename       ; pointer to null-terminated filename
    ld   c, $01             ; mode: read
    rst  $08                ; MOS call
    db   $0A                ; function $0A: ffs_fopen
    ; Returns file handle in A
filename:
    db   "level1.dat", 0
```

Ключевые функции MOS для разработки игр:

| Функция | Код | Описание |
|---------|-----|----------|
| `mos_getkey` | `$00` | Чтение клавиатуры (неблокирующее) |
| `mos_load` | `$01` | Загрузка файла с SD-карты |
| `mos_save` | `$02` | Сохранение файла на SD-карту |
| `mos_sysvars` | `$08` | Получение указателя на системные переменные (счётчик vsync и т.д.) |
| `ffs_fopen` | `$0A` | Открытие файла |
| `ffs_fclose` | `$0B` | Закрытие файла |
| `ffs_fread` | `$0C` | Чтение из файла |
| `mos_getrtc` | `$12` | Получение часов реального времени |

Файловый ввод-вывод на Agon тривиально прост по сравнению со Spectrum. Никакой загрузки с ленты, никаких обёрток esxDOS, никакого TR-DOS: просто открой файл с SD-карты и прочитай его в память. Данные уровней, спрайтовые листы, музыка -- загружай их по требованию, без гимнастики с банками.

### VDP-команды: разговор с экраном

Вся графика идёт через VDU-команды, отправляемые ESP32 VDP. eZ80 отправляет байты в поток вывода VDU; VDP интерпретирует их как инструкции рисования:

```z80 id:ch15_vdp_commands_talking_to_the
; VDP: draw a filled rectangle at (10, 10)
    rst  $10 : db 25        ; PLOT command
    rst  $10 : db 85        ; mode: filled rectangle
    rst  $10 : db 10        ; x low
    rst  $10 : db 0         ; x high
    rst  $10 : db 10        ; y low
    rst  $10 : db 0         ; y high
```

Многословно по сравнению с `LD (HL),A`, но VDP делает рендеринг на ESP32. VDP поддерживает битмап-режимы (до 640x480), до 256 аппаратных спрайтов (каждый до 64x64), аппаратные тайловые карты со скроллингом и аудио (волновые формы, ADSR, сэмплы).

Узкое место -- последовательная связь, не ЦП. Сложная сцена с множеством обновлений спрайтов может насытить UART, вызывая визуальный лаг. Минимизируй VDP-команды на кадр: пакетные обновления, используй аппаратный скроллинг вместо перерисовки тайлов и позволь спрайтовому движку делать тяжёлую работу.

---

## 15.7 Сравнение платформ

Давай разложим две машины бок о бок, сфокусировавшись на том, что важно для игрового движка, который мы будем строить в Главах 16-19.

| Параметр | ZX Spectrum 128K | Agon Light 2 |
|----------|-----------------|---------------|
| ЦП | Z80A @ 3,5 МГц | eZ80 @ 18,432 МГц |
| Тактов (T-state) на кадр | ~70 908 (128K, 50 Гц) / 71 680 (Pentagon, 50 Гц) | ~307 200 (60 Гц) |
| ОЗУ | 128 КБ (8 x 16 КБ страниц) | 512 КБ (плоская) |
| Адресное пространство | 64 КБ (банкованное) | 16 МБ (24-битное) |
| Экранная память | Общая шина, прямая запись | Отдельный VDP, командный |
| Цвета | 15 (8 базовых x яркость, минус перекрытие) | До 64 в стандартных режимах |
| Разрешение | 256x192 (атрибутный цвет на 8x8) | Настраиваемое, до 640x480 |
| Спрайты | Только программные | До 256 аппаратных спрайтов |
| Скроллинг | Только программный (ручной сдвиг/копирование) | Аппаратные смещения скролла |
| Звук | AY-3-8910 (3 канала) | ESP32 аудио (многоканальное, волновые формы) |
| Хранилище | Лента / DivMMC (esxDOS) | SD-карта (FAT32) |
| Двойная буферизация | Теневой экран (страница 7) | Управляется VDP |

Соотношение бюджетов кадров приблизительно 4:1 в пользу Agon. Но графика Agon проходит через узкое место последовательной связи, поэтому сырая скорость ЦП не переводится напрямую в скорость рендеринга. На Spectrum `PUSH HL` записывает два байта на экран за 11 тактов (T-state). На Agon обновление позиции спрайта требует 6+ байт по каналу 384 Кбод, занимая сотни микросекунд независимо от скорости ЦП.

Spectrum вознаграждает побайтовую оптимизацию. Agon вознаграждает архитектурные решения. Обе платформы вознаграждают внимательное отношение к бюджетам кадров.

---

## 15.8 Практика: утилита-инспектор памяти

Давай построим простой инспектор памяти для обеих платформ. Эта утилита показывает область ОЗУ как hex-байты на экране и позволяет навигировать по памяти клавиатурой. Это инструмент, который ты будешь постоянно использовать при разработке.

### Версия для Spectrum

Версия для Spectrum пишет прямо в экранную память. Мы показываем 16 строк по 16 байт (256 байт на страницу) с начальным адресом слева.

```z80 id:ch15_spectrum_version
; Memory Inspector - ZX Spectrum 128K
; Displays 256 bytes of memory as hex, navigable with keys
; ORG $8000 (page 2, uncontended)

    ORG  $8000

SCREEN_ATTR EQU $5800
START_ADDR  EQU inspect_addr      ; address to inspect (self-mod)

start:
    call clear_screen

main_loop:
    halt                          ; sync to frame

    ; Read keyboard
    call read_keys                ; returns: A = action
    cp   1
    jr   z, .page_up             ; Q = previous page
    cp   2
    jr   z, .page_down           ; A = next page
    cp   3
    jr   z, .bank_up             ; P = next bank
    cp   4
    jr   z, .bank_down           ; O = previous bank
    jr   .draw

.page_up:
    ld   hl, (inspect_addr)
    ld   de, -256
    add  hl, de
    ld   (inspect_addr), hl
    jr   .draw
.page_down:
    ld   hl, (inspect_addr)
    ld   de, 256
    add  hl, de
    ld   (inspect_addr), hl
    jr   .draw
.bank_up:
    ld   a, (current_bank)
    inc  a
    and  7                        ; wrap 0-7
    ld   (current_bank), a
    call bank_switch
    jr   .draw
.bank_down:
    ld   a, (current_bank)
    dec  a
    and  7
    ld   (current_bank), a
    call bank_switch

.draw:
    ; Display current bank and address
    call draw_header

    ; Display 16 rows x 16 bytes
    ld   hl, (inspect_addr)
    ld   b, 16                    ; 16 rows
    ld   de, $4060                ; screen position (row 3, col 0)
.row_loop:
    push bc
    push hl

    ; Print address
    ld   a, h
    call print_hex                ; print high byte of address
    ld   a, l
    call print_hex                ; print low byte
    ld   a, ':'
    call print_char

    ; Print 16 hex bytes
    pop  hl
    push hl
    ld   b, 16
.byte_loop:
    ld   a, (hl)
    call print_hex                ; 17T call + print routine
    inc  hl
    ld   a, ' '
    call print_char
    djnz .byte_loop

    pop  hl
    ld   de, 16
    add  hl, de                   ; advance to next row
    pop  bc

    ; Move screen pointer down one character row
    call next_char_row

    djnz .row_loop

    jr   main_loop

; --- Data ---
inspect_addr:  dw $C000          ; start address to inspect
current_bank:  db 0              ; current bank at $C000
bank_shadow:   db 0              ; shadow of port $7FFD

; read_keys, print_hex, print_char, clear_screen,
; draw_header, next_char_row, bank_switch: implementations
; omitted for brevity -- see examples/mem_inspect.a80
; for the complete compilable source.
```

Ключевой архитектурный момент: мы инспектируем `$C000`, потому что это переключаемый слот. Меняя `current_bank`, мы можем пролистать все 8 страниц ОЗУ, используя подпрограмму `bank_switch` из раздела 15.1. Сам инспектор живёт по адресу `$8000` (страница 2), защищённый от изменений банкинга.

### Версия для Agon

Версия для Agon использует системные вызовы MOS для ввода с клавиатуры и текстовый вывод VDP. Никаких вычислений адреса экрана, никакой обработки атрибутов -- просто отправляй текст в VDP.

```z80 id:ch15_agon_version
; Memory Inspector - Agon Light 2 (ADL mode)
    .ASSUME ADL=1
    ORG  $040000

main_loop:
    ; Wait for vsync via MOS sysvar
    rst  $08
    db   $08                      ; mos_sysvars
    ld   a, (ix+$00)              ; sysvar_time (low byte)
.wait_vsync:
    cp   (ix+$00)
    jr   z, .wait_vsync           ; spin until counter changes

    ; Check keyboard (Q = up, A = down)
    rst  $08
    db   $00                      ; mos_getkey
    ; ... navigation same as Spectrum version ...

.draw:
    rst  $10
    db   30                       ; VDU 30 = cursor home

    ld   hl, (inspect_addr)       ; 24-bit load!
    ld   b, 16
.row_loop:
    push bc
    push hl
    call print_hex24              ; print full 24-bit address
    ld   a, ':'
    rst  $10
    pop  hl
    push hl
    ld   b, 16
.byte_loop:
    ld   a, (hl)                  ; direct 24-bit access, no banking
    call print_hex8
    inc  hl
    djnz .byte_loop
    pop  hl
    ld   de, 16
    add  hl, de
    pop  bc
    djnz .row_loop
    jr   main_loop

inspect_addr: dl $000000          ; 24-bit address (dl, not dw)
; Full source: examples/mem_inspect_agon.a80
```

Заметь контраст:

- **Нет переключения банков.** Инспектор Agon может смотреть на любой адрес в 512 КБ напрямую. `LD HL,$070000` -- и ты инспектируешь 448 КБ в глубину ОЗУ. Никаких портов, никаких теневых переменных, никакого риска подключить не ту страницу.
- **Нет расчёта адресов экрана.** Текстовый вывод идёт через `RST $10`, и VDP обрабатывает позиционирование курсора, рендеринг символов и скроллинг.
- **24-битные директивы данных.** Мы используем `dl` (define long) для 3-байтных указателей вместо `dw` (define word).
- **VSync через системные переменные.** MOS предоставляет счётчик `sysvar_time`, увеличивающийся каждый кадр. Мы крутимся в ожидании его изменения для синхронизации кадров -- грубее, чем `HALT` у Spectrum, но функционально.

Оба инспектора делают одну работу. Версия для Spectrum -- больше кода (ты должен обрабатывать всё сам), но даёт полный контроль. Версия для Agon -- меньше кода (ОС и VDP обрабатывают отображение), но даёт меньше контроля над тем, как именно выглядит вывод.

Это отражает более широкий опыт разработки на обеих платформах. Spectrum требует больше усилий за меньшее визуальное богатство. Agon требует меньше усилий за большее визуальное богатство. Обе вознаграждают понимание оборудования.

---

## Итого

- **ZX Spectrum 128K** имеет 128 КБ ОЗУ в 8 страницах по 16 КБ. Страницы 2 и 5 фиксированы в адресном пространстве; верхний 16-килобайтный слот по `$C000` переключается через порт `$7FFD`. Держи основной код в странице 2 и обработчик прерываний вне переключаемой памяти.

- **Спорная память** замедляет доступ ЦП к определённым страницам ОЗУ во время активного отображения на оригинальном оборудовании Sinclair. Средний штраф: ~0,92 дополнительных такта (T-state) на байт. Клоны Pentagon не имеют спорности. Для разработки игр заложи 15-20% накладных расходов на записи экрана и держи критичный по времени код в неспорных страницах.

- **Тайминг ULA:** прерывание срабатывает в верхней части кадра. Ты получаешь ~14 000 тактов (T-state) свободного от спорности времени до того, как луч войдёт в активную область дисплея. Используй это окно для записей на экран.

- **Порт $7FFD** доступен только для записи. Храни его теневую копию в ОЗУ. Бит 3 выбирает теневой экран (страница 7) для двойной буферизации. Бит 5 отключает пагинацию навсегда до сброса.

- **Плавающая шина**, **ULA-снег** и **баг чтения $7FFD** -- причуды оригинального оборудования Sinclair. Избегай значений регистра I `$40`-`$7F`. Не храни данные по адресу `$7FFD`. Плавающая шина отсутствует на клонах.

- **Pentagon 128**: нет спорной памяти, 71 680 тактов (T-state) на кадр, 320 строк развёртки. Стандарт демосцены. 7 МГц турбо-режим удваивает бюджет кадра на некоторых вариантах.

- **Scorpion ZS-256**: 256 КБ ОЗУ (16 страниц), режим GMX 320x200x16 цветов.

- **ZX Spectrum Next**: 1-2 МБ ОЗУ с 8-килобайтными MMU-страницами, Layer 2 (256-цветный битмап), 128 аппаратных спрайтов, сопроцессор Copper, zxnDMA, тройной AY-звук.

- **Agon Light 2** использует двухпроцессорную архитектуру: eZ80 @ 18,432 МГц для логики, ESP32 для видео/аудио. 512 КБ плоской ОЗУ, 24-битная адресация (ADL-режим), MOS API для системных сервисов, VDP-команды для всей графики.

- **ADL-режим и Z80-режим**: ADL-режим использует 24-битные регистры и адреса. Z80-режим эмулирует классический Z80 с 16-битными адресами через MBASE. Оставайся в ADL-режиме для нового кода Agon.

- **Последовательная связь** между eZ80 и ESP32 -- узкое место Agon. Минимизируй трафик VDP-команд на кадр. Используй аппаратные спрайты и тайловые карты для уменьшения количества команд рисования.

- Обе платформы вознаграждают тщательное управление бюджетом кадра. Spectrum даёт тебе ~70 000 тактов (T-state) и требует побайтовой оптимизации. Agon даёт ~307 000 тактов (T-state) (при 60 Гц), но ограничивает графику последовательной связью. Разные ограничения, одна дисциплина.

---

> **Источники:** Introspec "GO WEST Parts 1--2" (Hype 2015); ZX Spectrum 128K Service Manual; Zilog eZ80 CPU User Manual; Agon Light 2 Documentation (Bernardo Kastrup); ZX Spectrum Next User Manual (2nd Edition)
