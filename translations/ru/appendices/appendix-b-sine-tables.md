# Приложение B: Генерация таблиц синусов и тригонометрические таблицы

> *«Косинус -- это просто синус со сдвигом на четверть периода.»*
> -- Заповеди Raider'а

---

Каждый эффект демо, который изгибается -- вращение, плазма, скроллинг, туннели -- нуждается в таблице синусов. На Z80 ты заранее вычисляешь значения в таблицу подстановки и индексируешь по углу. Вопрос в том, как хранить и обращаться к этой таблице максимально эффективно.

Это приложение сравнивает восемь подходов к хранению таблицы синусов, от очевидного (256-байтная таблица) до экзотического (2-битное кодирование вторыми разностями). Данные получены из `verify/sine_compare.py`, который ты можешь запустить, чтобы воспроизвести все числа.

## Стандартный формат

Таблица синусов для демосцены содержит **256 записей**, индексированных по углу:

| Индекс | Угол |
|-------|-------|
| 0 | 0° |
| 64 | 90° |
| 128 | 180° |
| 192 | 270° |
| 256 (оборачивается в 0) | 360° |

Каждая запись -- **знаковый байт** (-128 до +127), представляющий значения от -1.0 до приблизительно +1.0. Степень двойки в качестве периода означает, что индекс угла оборачивается естественным образом при 8-битном переполнении, а косинус становится синусом при прибавлении 64:

```z80
; sin(angle) -- direct table lookup
    ld   h, high(sin_table)  ; 7T   table must be 256-byte aligned
    ld   l, a                ; 4T   A = angle (0-255)
    ld   a, (hl)             ; 7T   A = sin(angle)
                             ; --- 18 T-states total

; cos(angle) -- offset by quarter period
    add  a, 64               ; 7T   cos = sin + 90°
    ld   l, a                ; 4T
    ld   a, (hl)             ; 7T
```

Это ключевое правило Raider'а: загрузи H один раз старшим байтом таблицы, затем L -- это угол, и он свободно оборачивается.

---

## Сравнение подходов

| # | Подход | Данные | Код | Итого | ОЗУ | Макс. ошибка | СКО |
|---|----------|------|------|-------|-----|-----------|-----|
| 1 | Полная таблица (256 байт) | 256 | 0 | **256** | 0 | 0 | 0,00 |
| 2 | Четвертьволновая таблица | 65 | 21 | **86** | 0 | 0 | 0,00 |
| 3 | Параболическая аппроксимация | 0 | 38 | **38** | 0 | 8 | 4,51 |
| 4 | Четвертьволна + вторые разности | 18 | 45 | **63** | 64 | 0 | 0,00 |
| 5 | Аппроксимация Бхаскары I | 0 | ~60 | **~60** | 0 | 1 | 0,49 |
| 5b | Бхаскара I + битовая карта коррекции | 1 | ~80 | **~81** | 0 | 0 | 0,00 |
| 6 | Четвертьволна + упакованные 4-битные разности | 33 | 43 | **76** | 64 | 0 | 0,00 |
| 7 | Полные вторые разности, 2-битная упаковка | 66 | 30 | **96** | 256 | 0 | 0,00 |

Подходы делятся на три категории:

- **На основе таблиц** (ОЗУ не требуется): полная таблица, четвертьволновая таблица
- **На основе генерации** (нужен буфер ОЗУ при старте): подходы с разностями и вторыми разностями
- **Приближённые** (вообще без таблицы): параболический, Бхаскара I
- **Приближённые + точная коррекция**: Бхаскара I с битовой картой коррекции

---

## Подход 1: Полная 256-байтная таблица

Самый простой и самый быстрый. Предвычисляешь все 256 значений и встраиваешь как данные.

```z80
; Lookup: 18 T-states, zero error
    ld   h, high(sin_table)
    ld   l, a
    ld   a, (hl)
```

**Стоимость:** 256 байт ПЗУ.
**Скорость:** 18 тактов (T-state) на поиск.
**Когда использовать:** Всегда, если ты не занимаешься sizecoding. На 48K Spectrum с ~40K свободными 256 байт -- ничто. Это выбор по умолчанию.

---

## Подход 2: Четвертьволновая таблица

Синусоида обладает четырёхкратной симметрией. Первый квадрант (0° до 90°, индексы 0 до 64) содержит всю информацию:

- **Второй квадрант** (65-128): зеркало первого квадранта. `sin(128 - i) = sin(i)`.
- **Третий квадрант** (129-192): отрицание первого квадранта. `sin(128 + i) = -sin(i)`.
- **Четвёртый квадрант** (193-255): отрицательное зеркало. `sin(256 - i) = -sin(i)`.

Храни только 65 байт (индексы от 0 до 64 включительно), затем восстанавливай:

```z80
; Quarter-wave sine lookup
; Input:  A = angle (0-255)
; Output: A = sin(angle), signed byte
; Uses:   HL, BC
; Table:  sin_quarter (65 bytes, 256-byte aligned)
;
qsin:
    ld   c, a               ; 4T   save original angle
    and  $7F                 ; 7T   fold to 0-127 (first half)
    cp   65                  ; 7T   past the peak?
    jr   c, .no_mirror       ; 12/7T
    ; Mirror: index = 128 - index
    neg                      ; 8T
    add  a, 128              ; 7T
.no_mirror:
    ld   h, high(sin_quarter) ; 7T
    ld   l, a                ; 4T
    ld   a, (hl)             ; 7T   A = |sin(angle)|
    bit  7, c                ; 8T   was original angle >= 128?
    ret  z                   ; 11/5T  no: positive half, done
    neg                      ; 8T   yes: negate for third/fourth quadrant
    ret                      ; 10T
```

**Стоимость:** 65 байт данных + ~21 байт кода = **86 байт всего**.
**Скорость:** ~50-70 тактов (T-state) на поиск (зависит от квадранта).
**Ошибка:** Ноль.
**Когда использовать:** Демо с ограничением по размеру (256-байтные, 512-байтные интро), где нужны точные значения, но нельзя позволить себе 256 байт.

---

## Подход 3: Параболическая аппроксимация (метод Dark'а)

Из Dark / X-Trade, *Spectrum Expert* #01 (1997). Идея: половина периода косинуса похожа на параболу. Приближение `y ~ 1 - 2(x/pi)^2` близко совпадает. В целочисленных терминах каждая половина периода генерируется как кусочно-квадратичная функция.

**Чистый код, ноль данных.** Цикл генерации требует умножения 8x8 и некоторой аккумуляторной логики -- приблизительно 38 байт.

Ошибка ограничена: **максимальная абсолютная ошибка = 8** (из диапазона в 256 шагов), или примерно **6,3%** от полной шкалы. СКО = 4,51.

Вот где парабола расходится с истинным синусом (первый квадрант):

```
Index  True  Para  Diff
    0     0     0    +0
    4    12    15    -3
    8    25    30    -5
   12    37    43    -6
   16    49    56    -7
   20    60    67    -7
   24    71    77    -6
   28    81    87    -6
   32    88    93    -5
```

Парабола стабильно «опережает» -- она растёт быстрее вблизи нуля и более плоская вблизи пика. Максимальное расхождение: **8 единиц при индексе 17** (примерно 24°).

**Когда использовать:** Экстремальный sizecoding (64-байтные интро, компактные загрузчики). Плазмы, простые скроллеры и эффекты колебания, где глаз не различает точную кривизну от приблизительной. Не подходит для гладкого вращения или точного проволочного 3D.

---

## Подход 4: Кодирование вторыми разностями (глубокий трюк)

Это математически самый интересный подход и, безусловно, самое компактное точное представление.

### Ключевое наблюдение

Вторая производная sin(x) равна -sin(x). При 8-битной целочисленной точности, квантованной в знаковые байты, вторая конечная разность таблицы синусов обладает замечательным свойством: **каждое значение равно ровно -1, 0 или +1**.

```
True sine:      [0,  3,  6,  9, 12, 16, 19, 22, 25, ...]
First diff:     [3,  3,  3,  3,  4,  3,  3,  3,  3, ...]
Second diff:    [0,  0,  0,  1, -1,  0,  0,  0,  0, ...]
```

Три значения. Два бита на запись. Это не приближение -- это точно. Математическая причина: `d^2(sin)/dx^2` -- гладкая функция малой амплитуды, и при 256 записях на период с 8-битной амплитудой дискретная вторая производная никогда не превышает +/-1.

### Полная таблица через 2-битные вторые разности

Хранишь: начальное значение (1 байт), начальную разность (1 байт), затем 254 вторые разности, упакованные по 2 бита (64 байта). **Итого: 66 байт данных + ~30 байт декодирования = 96 байт.** Нужно 256 байт ОЗУ для декодирования.

### Четвертьволна через 2-битные вторые разности

Комбинируй с четвертьволновой симметрией: храни только первые 64 вторые разности. **Итого: 18 байт данных + ~45 байт декодирования = 63 байта.** Нужно 64 байта ОЗУ.

Это **наименьшее точное представление**: 63 байта всего для идеальной 256-записной таблицы синусов.

```z80
; Decode quarter-wave from 2-bit second-order deltas
; sin_d2_data: 16 bytes of packed 2-bit deltas (64 entries)
; sin_buffer:  64 bytes RAM for decoded quarter-wave
;
decode_quarter_d2:
    ld   hl, sin_buffer      ; destination
    ld   de, sin_d2_data     ; source (packed d2 values)
    xor  a
    ld   (hl), a             ; sin[0] = 0
    inc  hl
    ld   b, a                ; b = current delta (starts at 0)
    ld   c, 63               ; 63 more entries to decode

.loop:
    ; Unpack 2-bit d2 value
    ; 00 = 0, 01 = +1, 11 = -1 (10 unused)
    rr   (de)                ; shift out 2 bits
    rr   (de)
    ; ... (bit extraction logic)

    ; Apply: delta += d2, value += delta
    add  a, b               ; new delta
    ld   b, a
    ld   a, (hl-1)          ; previous value (pseudocode)
    add  a, b
    ld   (hl), a
    inc  hl
    dec  c
    jr   nz, .loop

    ; Now use qsin() lookup on sin_buffer
```

Декодирование выполняется один раз при запуске. После этого используй подпрограмму четвертьволнового поиска из подхода 2 на декодированном буфере.

**Когда использовать:** Демо с ограничением по размеру (128-байтные, 256-байтные интро), где нужны точные значения, есть 64 байта ОЗУ и краткая фаза инициализации. Цикл декодирования выполняется менее чем за 2 000 тактов (T-state) -- незаметно.

> **Врезка: Почему не 1 бит на разность?**
>
> Интуитивное возражение: четвертьволна синуса (0° до 90°) монотонно возрастает. Первые разности d1 всегда неотрицательны. В непрерывной математике вторая производная синуса в первом квадранте всегда отрицательна (кривая вогнута). Значит, d2 должно быть <= 0, то есть нам нужно только {-1, 0} -- один бит на запись.
>
> Интуиция верна для непрерывного синуса, но неверна для квантованного целочисленного. При 8-битной точности округление создаёт случайные скачки вверх в d1:
>
> ```
> d1:  3, 3, 3, 3, 4, 3, 3, ...  (that 4 is a rounding correction)
> d2:  0, 0, 0, +1, -1, 0, ...   (the +1 is load-bearing)
> ```
>
> Таких записей +1 -- 12 из 63. Если их подавить (ограничить d1 монотонным невозрастанием), ошибки *накапливаются*: к индексу 64 пик достигает лишь 108 вместо 127 -- максимальная ошибка 19, хуже параболической аппроксимации. Эти коррекции +1 несут именно ту информацию, которая нужна для попадания в правильные целочисленные значения. Их нельзя отбросить.
>
> Код переменной длины с префиксом (0 -> 1 бит, +/-1 -> 2 бита) экономит 4 байта данных по сравнению с фиксированным 2-битным кодированием, но стоит ~15 дополнительных байт логики декодирования на Z80. Чистый проигрыш. Фиксированное 2-битное кодирование -- практический оптимум.

> **Врезка: Почему парабола + коррекция не помогает**
>
> Ещё одна интуитивная идея: сгенерировать параболическую аппроксимацию (38 байт кода, макс. ошибка 8), затем сохранить небольшую таблицу коррекции для доведения до точных значений. Коррекции лежат в диапазоне от -8 до +8, так что они должны хорошо сжиматься.
>
> Коррекции *действительно* хорошо сжимаются -- их первые разности ровно {-1, 0, +1}, упаковывающиеся в 2 бита на запись. Но это не совпадение. Парабола -- это квадратичная функция с постоянной второй производной. Значит:
>
> - `d2(sin)` из {-1, 0, +1} -- вторая производная синуса при целочисленной точности
> - `d2(para)` из {-1, 0, +1} -- вторая производная параболы (почти постоянна)
> - `d1(correction)` = `d1(sin) - d1(para)` из {-1, 0, +1} -- **та же энтропия**
>
> Разности коррекции имеют *точно ту же структуру*, что и прямые вторые разности синуса. Но параболический путь добавляет 38 байт кода генерации плюс ~20 байт для применения коррекций. Итого: ~96 байт против 63 байт для прямого кодирования вторыми разностями.
>
> Парабола убирает гладкую (низкочастотную) компоненту синуса -- но 2-битное кодирование вторыми разностями уже идеально справляется с гладкими данными. Параболе нечего добавить, что вторые разности уже не охватывают. Код генерации -- чистые накладные расходы.

---

## Подход 5: Аппроксимация Бхаскары I (VII век)

Самая удивительная позиция в нашем сравнении пришла от индийского математика VII века Бхаскары I. Его рациональная аппроксимация синуса, опубликованная около 629 г. н.э., достигает **максимальной ошибки всего в 1 единицу** при 8-битной точности -- радикально лучше, чем параболическая аппроксимация (макс. ошибка 8) и почти точно.

### Формула

Для угла x в радианах (от 0 до pi):

```
sin(x) ~ 16x(pi - x) / (5pi^2 - 4x(pi - x))
```

В нашей целочисленной области (угол 0-64 для первого квадранта, амплитуда 0-127):

```
sin(i) ~ 127 * 16i(64 - i) / (5 * 64^2 - 4 * i(64 - i))
       = 127 * 16i(64 - i) / (20480 - 4i(64 - i))
```

Формула -- это отношение двух квадратичных функций. На Z80 это требует умножения 8x8 и 16-битного деления -- подпрограммы, которые во многих демо уже есть для 3D-проекции или текстурного маппинга.

### Точность

По 65 записям первого квадранта аппроксимация Бхаскары I совпадает с точным целочисленным синусом везде, кроме **8 позиций** (из 65), где отклонение ровно +/-1:

```
Index  True  Bhaskara  Diff
    4    12        13    -1
   17    51        52    -1
   28    81        80    +1
   31    88        87    +1
   40   106       105    +1
   43   111       110    +1
   50   120       119    +1
   52   122       121    +1
```

Только 8 позиций различаются, все ровно на +/-1. Ошибки распределены: 2 записи, где Бхаскара завышает (вблизи начала), 6, где занижает (вблизи пика). Всего восемь коррекций, которые кодируются одним байтом -- битовой картой.

### Реализация на Z80

Для реализации нужно:
- Подпрограмма умножения 8x8->16 (~20 байт, вероятно, уже есть)
- Подпрограмма деления 16/16->16 (~30 байт, вероятно, уже есть)
- Обёртка Бхаскары (~25 байт)
- Логика четвертьволнового свёртывания (~15 байт, общая с подходом 2)

Если в твоём демо уже есть подпрограммы умножения и деления, маргинальная стоимость -- примерно **25 байт** для функции синуса с максимальной ошибкой 1.

Если подпрограммы нужно писать с нуля, суммарно получается примерно **60 байт** кода при нуле байт данных. Это конкурентно с подходом вторых разностей (63 байта), но не требует ни буфера ОЗУ, ни фазы декодирования при старте. Компромисс: 1 единица ошибки против идеальной точности.

### Бхаскара I + битовая карта коррекции (точно)

Чтобы устранить последнюю единицу ошибки, сохрани 8 позиций коррекции в виде битовой карты. Поскольку коррекции симметричны (первые 4 нуждаются в +1, последние 4 -- в -1), хватит одного байта:

```z80
; After computing Bhaskara approximation in A, index in C:
    push af
    ld   a, c
    ; Look up correction from bitmap (8 specific indices)
    ; ... (~20 bytes of correction logic)
    pop  af
    add  a, correction      ; ±1 or 0
```

Итого: ~80 байт кода + 1 байт данных = **~81 байт**, ноль ОЗУ, ноль инициализации, точные значения. Дороже вторых разностей (63B), но позволяет обойтись без буфера ОЗУ и инициализации при старте.

### Когда использовать Бхаскару I

- **У тебя уже есть подпрограммы умножения/деления:** ~25 байт сверху, макс. ошибка 1. Трудно побить.
- **Нет ОЗУ для буфера декодирования:** В отличие от вторых разностей, Бхаскара вычисляет на лету.
- **Нужна генерация в реальном времени:** Каждое значение вычисляется независимо -- нет последовательной зависимости, так что можно вычислить sin(любой угол) без предварительного декодирования таблицы.
- **Ошибка +/-1 допустима:** Для скроллеров, плазм и большинства визуальных эффектов разница между максимальной ошибкой 1 и максимальной ошибкой 0 буквально невидима.

> **Историческая справка:** Формула Бхаскары I предшествует европейским тригонометрическим таблицам почти на тысячелетие. То, что рациональная аппроксимация VII века достигает максимальной ошибки 1 на 8-битном процессоре 1980-х -- красивое совпадение математической элегантности и инженерных ограничений. Формула была опубликована в *Махабхаскарии* (629 г. н.э.), комментарии к астрономическим методам Арьябхаты.

---

## Практические рекомендации

Каждый подход на основе генерации создаёт таблицу подстановки при старте. После этого стоимость в рантайме одинакова: `LD H, high(table) / LD L, A / LD A, (HL)` = **18 тактов (T-state)** для 256-байтной таблицы, или подпрограмма четвертьволнового свёртывания при **50-70 тактах (T-state)** для 64-байтного буфера. Столбец «стоимость ПЗУ» ниже -- это то, что важно для sizecoding -- общее число байт, которое твой подход занимает в бинарнике.

| Сценарий | Подход | Стоимость ПЗУ | ОЗУ | Инициализация | Поиск | Ошибка |
|----------|----------|----------|-----|------|--------|-------|
| **Обычное демо / игра** | Полная 256-байтная таблица | 256B | 0 | нет | 18 T | точно |
| **512-байтное интро** | Четвертьволновая таблица | 86B | 0 | нет | 50-70 T | точно |
| **256-байтное интро** | Четвертьволна + вторые разности | 63B | 64B | ~2K T | 50-70 T | точно |
| **Есть умножение/деление** | Бхаскара I (генерация в LUT) | ~25B доп. | 256B | ~80K T | 18 T | макс. +/-1 |
| **128-байтное интро** | Параболическая (генерация в LUT) | 38B | 256B | ~10K T | 18 T | макс. +/-8 |

### Дерево решений

1. **Есть 256 байт в запасе?** Используй полную таблицу. Не усложняй. `LD L,A / LD A,(HL)` при 18 тактах (T-state) не побить.

2. **Ограничение по размеру, но нужна точность?** Четвертьволновая таблица при 86 байтах. ОЗУ не нужно, фазы инициализации нет. Поиск 50-70 тактов (T-state) (логика свёртывания).

3. **Экстремальное ограничение по размеру, нужны точные значения?** Четвертьволна + декодирование вторых разностей при 63 байтах. Декодируй один раз при старте в 64-байтный четвертьволновый буфер, затем используй ту же подпрограмму свёртывания.

4. **Уже есть умножение/деление?** Бхаскара I при ~25 байтах сверху. Сгенерируй полную 256-байтную LUT при старте, затем наслаждайся поиском за 18 тактов (T-state) с макс. ошибкой 1.

5. **Экстремальное ограничение по размеру, приближённость допустима?** Параболическая при 38 байтах, ноль данных. Генерируй в 256-байтную LUT при старте. Макс. ошибка 8, годится для плазм и колебаний.

### Что не работает

- **Парабола + таблица коррекции** (123 байта, точно): хуже, чем просто использовать четвертьволновую таблицу (86 байт). Накладные расходы на вычисление параболы *и* поиск коррекции перечёркивают цель.

- **Разности + RLE** (100-219 байт): разности синуса меняются плавно, а не повторяются сериями. RLE рассчитан на данные с длинными постоянными сериями -- синус не той формы.

- **Полная таблица с дельта-кодированием** (152-271 байт): использует *больше* суммарных байт, чем сырая 256-байтная таблица. Дельта-кодирование помогает только когда разности значительно меньше исходных значений; разности синуса ограничены +/-4, но их всё равно 256.

---

## Заповеди Raider'а

В комментариях Hype к анализу *Illusion* от Introspec'а опытный кодер Raider сконденсировал десятилетия коллективной мудрости в неформальные «заповеди» проектирования таблиц синусов:

1. **256 записей на полный период.** Индекс угла оборачивается при 8-битном переполнении. Модульная арифметика не нужна.
2. **Знаковые байты: -128 до +127.** Соответствует знаковой арифметике Z80.
3. **Выровняй таблицу по странице.** Размести её на 256-байтной границе, чтобы H был константой. `LD H,high(table)` один раз, затем `LD L,angle / LD A,(HL)` навсегда.
4. **Косинус = синус + 64.** Одна инструкция `ADD A,64`.
5. **Синус от (angle + 128) = -синус(angle).** `NEG` инвертирует знак. Используй для фазовых сдвигов.
6. **Не вычисляй синус в рантайме**, если не занимаешься sizecoding. Поиск по таблице всегда быстрее.
7. **Амплитуду держи степенью двойки** (64, 127, 128), чтобы умножение было сдвигом.
8. **Четвертьволновая симметрия** экономит 75% хранилища, когда каждый байт на счету.
9. **Проверяй на границах.** Индекс 0 должен быть ровно 0. Индекс 64 -- максимальное положительное значение (+127). Индекс 128 -- ровно 0. Индекс 192 -- максимальное отрицательное значение (-128 или -127, в зависимости от соглашения).

Эти правила отражают десятилетия опыта. Следуй им, и твои таблицы синусов будут быстрыми, компактными и корректными.

---

## Справочник: Полная 256-байтная таблица

Для удобства приведена стандартная таблица синусов (256 записей, знаковая, период = 256, амплитуда +/-127):

```z80
; 256-byte sine table, page-aligned
; sin(0) = 0, sin(64) = +127, sin(128) = 0, sin(192) = -128
;
    ALIGN 256
sin_table:
    DB    0,   3,   6,   9,  12,  16,  19,  22
    DB   25,  28,  31,  34,  37,  40,  43,  46
    DB   49,  51,  54,  57,  60,  63,  65,  68
    DB   71,  73,  76,  78,  81,  83,  85,  88
    DB   90,  92,  94,  96,  98, 100, 102, 104
    DB  106, 108, 109, 111, 112, 114, 115, 117
    DB  118, 119, 120, 121, 122, 123, 124, 124
    DB  125, 126, 126, 127, 127, 127, 127, 127
    DB  127, 127, 127, 127, 127, 127, 126, 126
    DB  125, 124, 124, 123, 122, 121, 120, 119
    DB  118, 117, 115, 114, 112, 111, 109, 108
    DB  106, 104, 102, 100,  98,  96,  94,  92
    DB   90,  88,  85,  83,  81,  78,  76,  73
    DB   71,  68,  65,  63,  60,  57,  54,  51
    DB   49,  46,  43,  40,  37,  34,  31,  28
    DB   25,  22,  19,  16,  12,   9,   6,   3
    DB    0,  -3,  -6,  -9, -12, -16, -19, -22
    DB  -25, -28, -31, -34, -37, -40, -43, -46
    DB  -49, -51, -54, -57, -60, -63, -65, -68
    DB  -71, -73, -76, -78, -81, -83, -85, -88
    DB  -90, -92, -94, -96, -98,-100,-102,-104
    DB -106,-108,-109,-111,-112,-114,-115,-117
    DB -118,-119,-120,-121,-122,-123,-124,-124
    DB -125,-126,-126,-127,-127,-127,-127,-127
    DB -128,-127,-127,-127,-127,-127,-126,-126
    DB -125,-124,-124,-123,-122,-121,-120,-119
    DB -118,-117,-115,-114,-112,-111,-109,-108
    DB -106,-104,-102,-100, -98, -96, -94, -92
    DB  -90, -88, -85, -83, -81, -78, -76, -73
    DB  -71, -68, -65, -63, -60, -57, -54, -51
    DB  -49, -46, -43, -40, -37, -34, -31, -28
    DB  -25, -22, -19, -16, -12,  -9,  -6,  -3
```

Скопируй, вставь, собери, используй.

---

> **Источники:** Dark / X-Trade "Programming Algorithms" (Spectrum Expert #01, 1997) -- параболическая аппроксимация; Бхаскара I, *Махабхаскария* (629 г. н.э.) -- рациональная аппроксимация; Raider (комментарии Hype, 2017) -- принципы проектирования таблиц синусов; `verify/sine_compare.py` -- сравнительный анализ
