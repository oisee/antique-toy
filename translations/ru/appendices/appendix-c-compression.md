# Приложение C: Краткий справочник по сжатию

> *«Вопрос не в том, сжимать ли -- а в том, какой упаковщик использовать и когда.»*
> -- Глава 14

Это приложение -- отрывная справочная карточка по сжатию данных на ZX Spectrum. Глава 14 покрывает теорию, бенчмарк-данные и обоснование каждой рекомендации. Это приложение сводит всё к таблицам подстановки и правилам принятия решений, которые можно закрепить над монитором.

Все числа взяты из бенчмарка Introspec'а 2017 года ("Data Compression for Modern Z80 Coding," Hype), если не указано иное. Тестовый корпус составлял 1 233 995 байт смешанных данных: академические бенчмарки Calgary/Canterbury, 30 графических экранов ZX Spectrum, 24 музыкальных файла и разнообразные данные демо.

---

## Сравнительная таблица упаковщиков

| Упаковщик | Автор | Сжато (байт) | Степень сжатия | Размер распаковщика | Скорость (T/байт) | Обратная | Примечания |
|------------|--------|--------------------|-------|--------------------|-----------------|-----------|-------|
| **Exomizer 2** | Magnus Lind | 596 161 | 48,3% | ~170 байт | ~250 | Да | Лучшая степень сжатия. Медленная распаковка. |
| **ApLib** | Joergen Ibsen | 606 833 | 49,2% | ~199 байт | ~105 | Нет | Хороший универсал. |
| **Hrust 1** | Alone Coder | 613 602 | 49,7% | ~150 байт | ~120 | Да | Стековый распаковщик с перемещением. Популярен в российской сцене. |
| **PuCrunch** | Pasi Ojala | 616 855 | 50,0% | ~200 байт | ~140 | Нет | Изначально для C64. |
| **Pletter 5** | XL2S | 635 797 | 51,5% | ~120 байт | ~69 | Нет | Быстрый + приличная степень сжатия. |
| **MegaLZ** | LVD / Introspec | 636 910 | 51,6% | 92 байта (компактный) | ~98 (компактный) | Нет | Оптимальный парсер. Возрождён в 2019 с новыми распаковщиками. |
| **MegaLZ fast** | LVD / Introspec | 636 910 | 51,6% | 234 байта | ~63 | Нет | Самый быстрый вариант MegaLZ. Быстрее 3x LDIR. |
| **ZX0** | Einar Saukas | ~642 000* | ~52% | ~70 байт | ~100 | Да | Наследник ZX7. Оптимальный парсер. Современный стандарт. |
| **ZX7** | Einar Saukas | 653 879 | 53,0% | **69 байт** | ~107 | Да | Крошечный распаковщик. Классический инструмент для sizecoding. |
| **Bitbuster** | Team Bomba | ~660 000* | ~53,5% | ~90 байт | ~80 | Нет | Простой. Хорош для первых проектов. |
| **LZ4** | Yann Collet (порт на Z80) | 722 522 | 58,6% | ~100 байт | **~34** | Нет | Самая быстрая распаковка. Байт-выровненные токены. |
| **Hrum** | Hrumer | ~642 000* | ~52% | ~130 байт | ~110 | Нет | Популярен в российской сцене. Объявлен устаревшим Introspec'ом. |
| **ZX1** | Einar Saukas | --- | ~51% | ~80 байт | ~90 | Да | Вариант ZX0. Чуть лучше степень сжатия, чуть больше распаковщик. |
| **ZX2** | Einar Saukas | --- | ~50% | ~100 байт | ~85 | Да | Использован в RED REDUX 256b intro (2025). Лучшая степень сжатия для ZXn. |

\* Приблизительно. ZX0, Bitbuster и Hrum не входили в оригинальный бенчмарк 2017 года; значения оценены по независимым тестам на аналогичных корпусах.

**Как читать таблицу:**

- **Степень сжатия** = сжатый размер / исходный размер. Меньше -- лучше.
- **Скорость** = такты (T-state) на выходной байт при распаковке. Меньше -- быстрее.
- **Размер распаковщика** = байты кода Z80, необходимые для подпрограммы распаковки. Меньше -- лучше для размерных интро.
- **Обратная** = поддерживает распаковку с конца к началу, что позволяет распаковывать на месте, когда источник и приёмник перекрываются.

---

## Дерево решений: какой упаковщик?

Следуй сверху вниз. Выбери первую ветку, подходящую к твоей ситуации.

```
СТАРТ
  |
  +-- Это 256-байтное или 512-байтное интро?
  |     ДА --> ZX0 (70-байтный распаковщик) или собственный RLE (<30 байт)
  |
  +-- Это 1K или 4K интро?
  |     ДА --> ZX0 (лучшее соотношение степень сжатия / размер распаковщика)
  |
  +-- Нужна потоковая распаковка в реальном времени (во время воспроизведения)?
  |     ДА --> LZ4 (~34 T/байт = 2+ КБ за кадр на 50fps)
  |
  +-- Нужна быстрая распаковка между сценами?
  |     ДА --> MegaLZ fast (~63 T/байт) или Pletter 5 (~69 T/байт)
  |
  +-- Скорость распаковки неважна (одноразовая загрузка при старте)?
  |     ДА --> Exomizer (48,3% -- ничего лучше нет)
  |
  +-- Нужен хороший баланс степени сжатия и скорости?
  |     ДА --> ApLib (~105 T/байт, 49,2%)
  |
  +-- Данные в основном серии одинаковых байт?
  |     ДА --> Собственный RLE (распаковщик < 30 байт, тривиально)
  |
  +-- Данные -- последовательные кадры анимации?
  |     ДА --> Сначала дельта-кодирование, затем сжатие ZX0 или LZ4
  |
  +-- Первый проект, хочешь что-то простое?
        ДА --> Bitbuster или ZX0 (оба хорошо документированы, легко интегрируются)
```

---

## Степень сжатия типичных данных ZX Spectrum

Как хорошо сжимаются различные типы данных и трюки для улучшения степени сжатия.

| Тип данных | Исходный размер | Типичная степень ZX0 | Типичная степень Exomizer | Примечания |
|-----------|----------|-------------------|------------------------|-------|
| **Пиксели экрана** ($4000-$57FF) | 6 144 байта | 40--60% | 35--55% | Зависит от сложности изображения. Чёрный фон сжимается хорошо. |
| **Атрибуты** ($5800-$5AFF) | 768 байт | 30--50% | 25--45% | Часто очень повторяющиеся. Однотонные области сжимаются почти в ничто. |
| **Полный экран** (пиксели + атрибуты) | 6 912 байт | 40--58% | 35--52% | Сжимай пиксели и атрибуты раздельно для улучшения степени на 5--10%. |
| **Таблицы синусов/косинусов** | 256 байт | 60--75% | 55--70% | Плавные кривые сжимаются хорошо. Рассмотри генерацию вместо сжатия (Приложение B). |
| **Тайловые данные** (тайлы 8x8) | разное | 35--55% | 30--50% | Упорядочи тайлы по подобию для лучшей степени. |
| **Спрайтовые данные** | разное | 45--65% | 40--60% | Байты масок ухудшают степень. Храни маски отдельно. |
| **Музыка PT3** | разное | 40--55% | 35--50% | Паттерны повторяются. Пустые строки сжимаются хорошо. |
| **Дампы регистров AY** | разное | 30--50% | 25--45% | Сильно повторяются между кадрами. Сначала дельта-кодируй. |
| **Таблицы подстановки** (произвольные) | разное | 50--80% | 45--75% | Случайно выглядящие данные сжимаются плохо. Отсортируй, если можно. |
| **Данные шрифтов** (96 символов x 8 байт) | 768 байт | 55--70% | 50--65% | Много нулевых байт (выносные элементы, тонкие штрихи). |

### Трюки перед сжатием

Эти техники улучшают степень сжатия, реструктурируя данные перед подачей в упаковщик.

**Раздели пиксели и атрибуты.** Полный 6 912-байтный экран, хранимый одним блоком, заставляет упаковщик обрабатывать переход от пиксельных данных к атрибутам на байте 6 144. Сжимай 6 144-байтный блок пикселей и 768-байтный блок атрибутов раздельно. Блок атрибутов, будучи сильно повторяющимся, часто сжимается до менее 200 байт.

**Дельта-кодируй кадры анимации.** Храни первый кадр полностью. Для каждого последующего кадра храни только байты, отличающиеся от предыдущего, как пары (смещение, значение). Применяй LZ-сжатие к дельта-потоку. psndcj сжал 122 кадра (843 264 байта исходных) до 10 512 байт, используя эту технику в Break Space.

**Переупорядочь данные для локальности.** Тайловые карты в порядке «строка за строкой» могут сжиматься лучше, если переупорядочить так, чтобы похожие тайлы шли рядом. Сортируй кадры спрайтов по визуальному подобию. Группируй повторяющиеся подпаттерны вместе.

**Храни константы отдельно.** Если блок данных содержит повторяющийся заголовок или завершитель (например, метаданные тайлов), вынеси его и храни один раз. Сжимай только переменную часть.

**Чередуй плоскости.** Для мультиколорных или маскированных спрайтов хранение всех байтов масок вместе и всех байтов пикселей вместе часто сжимается лучше, чем чередование маска-пиксель-маска-пиксель построчно.

---

## Минимальный RLE-распаковщик

Простейший полезный упаковщик. Менее 30 байт. Подходит для 256-байтных интро или данных с длинными сериями одинаковых байт. Подробное обсуждение в главе 14.

```z80
; Minimal RLE decompressor
; Format: [count][value] pairs, terminated by count = 0
; HL = source (compressed data)
; DE = destination (output buffer)
; Destroys: AF, BC
rle_decompress:
        ld      a, (hl)         ; read count             7T
        inc     hl              ;                         6T
        or      a               ; count = 0?              4T
        ret     z               ; yes: done               5T/11T
        ld      b, a            ; B = count               4T
        ld      a, (hl)         ; read value              7T
        inc     hl              ;                         6T
.fill:  ld      (de), a         ; write value             7T
        inc     de              ;                         6T
        djnz    .fill           ; loop B times            13T/8T
        jr      rle_decompress  ; next pair               12T
; Total: 23 bytes of code
; Speed: ~26 T-states per output byte (within runs)
```

**Инструмент кодирования** (однострочник на Python для простого RLE):

```python
def rle_encode(data):
    out = bytearray()
    i = 0
    while i < len(data):
        val = data[i]
        count = 1
        while i + count < len(data) and data[i + count] == val and count < 255:
            count += 1
        out.extend([count, val])
        i += count
    out.extend([0])  # terminator
    return out
```

Этот наивный RLE раздувает данные без серий (худший случай: 2 байта на 1 байт входных данных). Для смешанных данных используй RLE с байтом-маркером: специальный байт сигнализирует о серии, а все остальные -- литералы. Или просто используй ZX0.

---

## Стандартный распаковщик ZX0 (Z80)

Полный стандартный прямой распаковщик от Einar Saukas. Приблизительно 70 байт. Это версия, которую ты будешь использовать в большинстве проектов.

```z80
; ZX0 decompressor - standard forward version
; (c) Einar Saukas, based on Wikipedia description of LZ format
; HL = source (compressed data)
; DE = destination (output buffer)
; Destroys: AF, BC, DE, HL
dzx0_standard:
        ld      bc, $ffff       ; initial offset = -1
        push    bc              ; store offset on stack
        inc     bc              ; BC = 0 (literal length will be read)
        ld      a, $80          ; init bit buffer with end marker
dzx0s_literals:
        call    dzx0s_elias     ; read number of literals
        ldir                    ; copy literals from source to dest
        add     a, a            ; read next bit: 0 = last offset, 1 = new offset
        jr      c, dzx0s_new_offset
        ; reuse last offset
        call    dzx0s_elias     ; read match length
dzx0s_copy:
        ex      (sp), hl        ; swap: HL = offset, stack = source
        push    hl              ; put offset back on stack
        add     hl, de          ; HL = dest + offset = match source address
        ldir                    ; copy match
        add     a, a            ; read next bit: 0 = literal, 1 = match/offset
        jr      nc, dzx0s_literals
        ; new offset
dzx0s_new_offset:
        call    dzx0s_elias     ; read offset MSB (high bits)
        ex      af, af'         ; save bit buffer
        dec     b               ; B = $FF (offset is negative)
        rl      c               ; C = offset MSB * 2 + carry
        inc     c               ; adjust
        jr      z, dzx0s_done   ; offset = 256 means end of stream
        ld      a, (hl)         ; read offset LSB
        inc     hl
        rra                     ; LSB bit 0 -> carry = length bit
        push    bc              ; save offset MSB
        ld      b, 0
        ld      c, a            ; C = offset LSB >> 1
        pop     af              ; A = offset MSB (from push bc)
        ld      b, a            ; BC = full offset (negative)
        ex      (sp), hl        ; store offset, retrieve source
        push    bc              ; store offset again
        ld      bc, 1           ; minimum match length = 1
        jr      nc, dzx0s_copy  ; if carry clear: length = 1
        call    dzx0s_elias     ; otherwise read match length
        inc     bc              ; +1
        jr      dzx0s_copy
dzx0s_done:
        pop     hl              ; clean stack
        ex      af, af'         ; restore flags
        ret
; Elias interlaced code reader
dzx0s_elias:
        inc     c               ; C starts at 1
dzx0s_elias_loop:
        add     a, a            ; read bit
        jr      nz, dzx0s_elias_nz
        ld      a, (hl)         ; refill bit buffer
        inc     hl
        rla                     ; shift in carry
dzx0s_elias_nz:
        ret     nc              ; stop bit (0) = done
        add     a, a            ; read data bit
        jr      nz, dzx0s_elias_nz2
        ld      a, (hl)         ; refill
        inc     hl
        rla
dzx0s_elias_nz2:
        rl      c               ; shift bit into C
        rl      b               ; and into B
        jr      dzx0s_elias_loop
```

**Использование:**

```z80
        ld      hl, compressed_data     ; source address
        ld      de, $4000               ; destination (e.g., screen)
        call    dzx0_standard           ; decompress
```

**Обратный вариант.** ZX0 также предоставляет обратный распаковщик (`dzx0_standard_back`), который читает сжатые данные с конца к началу и записывает выходные данные с конца к началу. Это позволяет распаковку на месте: размести сжатые данные в конце буфера-приёмника и распаковывай назад, чтобы выходные данные перезаписывали сжатые только после того, как те были прочитаны. Незаменимо, когда ОЗУ мало.

---

## Паттерны интеграции

### Паттерн 1: Распаковка на экран при старте

Самый распространённый сценарий. Загрузить сжатый загрузочный экран и показать его.

```z80
        org     $8000
start:
        ld      hl, compressed_screen
        ld      de, $4000               ; screen memory
        call    dzx0_standard
        ; screen is now visible
        ; ... continue with demo/game ...

        include "dzx0_standard.asm"

compressed_screen:
        incbin  "screen.zx0"
```

### Паттерн 2: Распаковка в буфер между эффектами

Распаковать данные следующего эффекта во временный буфер, пока текущий эффект ещё работает, или во время затемнения.

```z80
; During scene transition:
        ld      hl, scene2_data_zx0
        ld      de, scratch_buffer      ; e.g., $C000 in bank 1
        call    dzx0_standard
        ; scratch_buffer now holds the uncompressed data
        ; switch to scene 2, which reads from scratch_buffer
```

### Паттерн 3: Потоковая распаковка во время воспроизведения

Для эффектов реального времени, которым нужен непрерывный поток данных. LZ4 -- единственный практичный выбор.

```z80
; Each frame: decompress next chunk
frame_loop:
        ld      hl, (lz4_read_ptr)     ; current position in compressed stream
        ld      de, frame_buffer
        ld      bc, 2048                ; bytes to decompress this frame
        call    lz4_decompress_partial
        ld      (lz4_read_ptr), hl     ; save position for next frame
        ; render from frame_buffer
        ; ...
        jr      frame_loop
```

При ~34 T/байт LZ4 распаковывает 2 048 байт за 69 632 такта (T-state) -- укладываясь в один кадр (69 888 тактов на 48K). Это впритык. Используй распаковку во время бордюра или двойную буферизацию для надёжности.

### Паттерн 4: Сжатые данные с переключением банков (128K)

Храни сжатые данные в нескольких 16КБ банках. Распаковывай из текущего подключённого банка, затем переключай банк, когда данные кончаются.

```z80
; Page in bank containing compressed data
        ld      a, (current_bank)
        or      $10                     ; bit 4 = ROM select
        ld      bc, $7ffd
        out     (c), a                  ; page bank into $C000-$FFFF

        ld      hl, $C000              ; compressed data starts at bank base
        ld      de, dest_buffer
        call    dzx0_standard

        ; Page next bank for next asset
        ld      a, (current_bank)
        inc     a
        ld      (current_bank), a
```

Для больших демо с множеством сжатых ресурсов поддерживай таблицу кортежей (банк, смещение, приёмник) и проходи по ним при загрузке.

---

## Конвейер сборки: от ресурса к бинарнику

Шаг сжатия должен быть в твоём Makefile, а не в голове.

```
Source asset       Converter        Compressor        Assembler
  (PNG)       -->   (png2scr)   -->   (zx0)      -->  (sjasmplus)  --> .tap
  (WAV)       -->   (pt3tools)  -->   (zx0)      -->  (incbin)
  (TMX)       -->   (tmx2bin)   -->   (exomizer)
```

**Правила Makefile:**

```makefile
# Compress .scr screens with ZX0
%.zx0: %.scr
	zx0 $< $@

# Compress large assets with Exomizer (one-time load)
%.exo: %.bin
	exomizer raw -c $< -o $@

# Build final binary
demo.bin: main.asm assets/title.zx0 assets/font.zx0
	sjasmplus main.asm --raw=$@
```

**Установка инструментов:**

| Инструмент | Исходный код | Установка |
|------|--------|---------|
| ZX0 | github.com/einar-saukas/ZX0 | `gcc -O2 -o zx0 src/zx0.c src/compress.c src/optimize.c src/memory.c` |
| Exomizer | github.com/bitmanipulators/exomizer | `make` в каталоге `src/` |
| LZ4 | github.com/lz4/lz4 | `make` или `brew install lz4` |
| MegaLZ | github.com/AntonioCerra/megalzR | Старый; ссылки смотри в статье Introspec'а на Hype |

---

## Быстрые формулы

**Байт за кадр при 50fps с распаковщиком X:**

```
bytes_per_frame = 69,888 / speed_t_per_byte
```

| Упаковщик | T/байт | Байт/кадр (48K) | Байт/кадр (128K Pentagon) |
|------------|--------|-------------------|-----------------------------|
| LZ4 | 34 | 2 055 | 2 108 |
| MegaLZ fast | 63 | 1 109 | 1 138 |
| Pletter 5 | 69 | 1 012 | 1 038 |
| ZX0 | 100 | 698 | 716 |
| ApLib | 105 | 665 | 682 |
| Hrust 1 | 120 | 582 | 597 |
| Exomizer | 250 | 279 | 286 |

(Кадр 128K Pentagon = 71 680 тактов)

**Память, сэкономленная сжатием N экранов:**

```
saved = N * 6912 * (1 - ratio)
```

Пример: 8 загрузочных экранов с Exomizer при степени сжатия 48,3% экономят 8 * 6912 * 0,517 = 28 575 байт -- почти два полных 16КБ банка.

---

## См. также

- **Глава 14:** Полное обсуждение теории сжатия, бенчмарка Introspec'а, внутренностей ZX0 и конвейера дельта + LZ.
- **Приложение B:** Генерация таблиц синусов -- когда таблицы достаточно малы, рассмотри генерацию вместо сжатия.
- **Приложение A:** Справочник инструкций Z80 -- LDIR, PUSH/POP и другие инструкции, используемые в распаковщиках.

> **Источники:** Introspec "Data Compression for Modern Z80 Coding" (Hype, 2017); Introspec "Compression on the Spectrum: MegaLZ" (Hype, 2019); Einar Saukas, ZX0/ZX7/ZX1/ZX2 (github.com/einar-saukas); Break Space NFO (Thesuper, 2016)
