# Приложение I: Bytebeat и AY-Beat — генеративный звук на Z80

> *«При 256 байтах bytebeat — твой единственный реалистичный вариант: для паттернового проигрывателя просто нет места.»*
> -- Глава 13

---

Это приложение охватывает формульную генерацию звука на ZX Spectrum — от оригинальной концепции PCM-bytebeat до AY-адаптированной техники, которая порождает структурированную, эволюционирующую музыку из горстки инструкций Z80. Глава 13 знакомит с AY-beat как инструментом sizecoding. Данное приложение — полный справочник: теория, формулы, маппинг регистров и полностью рабочий движок, который можно встроить в 256-байтное интро.

Тебе понадобится справочник по регистрам AY из Приложения G, открытый параллельно с этим приложением. Каждый номер регистра, упомянутый здесь (R0, R7, R8, R11, R13 и т.д.), документирован там с полными побитовыми раскладками и адресами портов.

---

## 1. Классический Bytebeat: традиция PCM

В 2011 году Ville-Matias Heikkila (Viznut) опубликовал открытие, которое уже ходило в подпольных программистских кругах: одно выражение на Си, вычисляемое по разу на сэмпл с инкрементирующимся счётчиком `t`, способно порождать сложную ритмическую музыку, если интерпретировать выход как 8-битный беззнаковый PCM на 8 кГц.

Основная идея:

```c
for (t = 0; ; t++)
    putchar( f(t) );    // pipe to /dev/dsp at 8000 Hz
```

Функция `f(t)` — это обычно однострочное выражение, построенное из побитовых операций, умножения и битовых сдвигов. Никаких осцилляторов, никаких огибающих, никаких таблиц нот — только целочисленная арифметика над счётчиком.

### Знаменитые формулы

**`t*((t>>12|t>>8)&63&t>>4)`** — оригинал Viznut. Каскадные ритмические тона, циклически проходящие через соотношения высот, создавая эффект чего-то среднего между музыкальной шкатулкой и сломанным телефоном. `t>>12` и `t>>8` создают две частотно-делённые версии счётчика; `&63` ограничивает диапазон; `&t>>4` ритмически стробирует выход. Умножение на `t` создаёт фундаментальную развёртку высоты.

**`t*(t>>5|t>>8)>>(t>>16)`** — эволюционирующие ритмические паттерны. Сдвиг вправо на `t>>16` означает, что весь характер звука меняется каждые ~8 секунд (65536 сэмплов при 8 кГц). Каждая 8-секундная секция обладает различным динамическим диапазоном и характером.

**`(t*5&t>>7)|(t*3&t>>10)`** — две переплетённые мелодические линии. `t*5` и `t*3` создают два потока высоты на разных интервалах; AND со сдвинутыми счётчиками независимо стробирует их; OR объединяет. Результат звучит как две переплетающиеся мелодии, играющие одновременно.

### Почему это работает

Побитовые операции над инкрементирующимся счётчиком создают периодические структуры одновременно на множестве временных масштабов. Рассмотри битовый паттерн `t` при счёте:

- Бит 0 переключается каждый сэмпл (4000 Гц — как высота неслышим, но формирует волновую форму)
- Бит 7 переключается каждые 128 сэмплов (~62,5 Гц — басовая территория)
- Бит 12 переключается каждые 4096 сэмплов (~1,95 Гц — ритмический пульс)
- Бит 15 переключается каждые 32768 сэмплов (~0,24 Гц — структурное изменение)

Сдвиг вправо `t>>n` выбирает, какой временной масштаб доминирует. Операции AND создают паттерны совпадений — моменты, когда два временных масштаба выравниваются. Операции OR объединяют независимые паттерны. Умножение на малые константы создаёт гармонические соотношения (соотношения частот). 8-битное усечение выхода действует как естественный формирователь волновой формы, заворачивая значения обратно в диапазон и создавая дополнительные гармоники.

Результат самоподобен: звук обладает ритмической структурой на каждом масштабе, от отдельных циклов колебания до многосекундных фразовых структур. Именно это самоподобие делает bytebeat похожим на музыку, а не на шум — хотя никакие музыкальные знания в формулу не закладывались.

### На Spectrum: тупик бипера

Биперный выход ZX Spectrum — это однобитный динамик, управляемый битом 4 порта $FE. В принципе, можно запустить формулу bytebeat и вывести результат:

```z80
; Beeper bytebeat -- uses all CPU, no visuals possible
; DE = t (16-bit counter)
    ld   de, 0
.loop:
    ; Compute f(t) -- simplified: A = t AND (t >> 8)
    ld   a, e          ; 4T   A = low byte of t
    and  d             ; 4T   A = t_lo AND t_hi
    ; Output bit 4 to speaker
    and  $10           ; 7T   isolate bit 4
    out  ($FE), a      ; 11T  toggle speaker
    inc  de            ; 6T   t++
    jr   .loop         ; 12T
                       ; --- 44T per sample = ~79.5 kHz
```

Это работает и производит звук. Но потребляет 100% процессора — Z80 не делает ничего, кроме вычисления сэмплов и переключения динамика. Никаких обновлений экрана, никаких визуальных эффектов, никакой обработки ввода. Частота дискретизации тоже неправильная (слишком высокая), а точное её управление требует тщательного подсчёта тактов (T-state) с подбивкой NOP-ами.

Для демо это тупик. Бипер — это однобитный выход, требующий постоянного внимания процессора. Настоящая адаптация bytebeat к Spectrum требует совершенно иного подхода.

---

## 2. AY-Beat: bytebeat, переосмысленный для тонового генератора

AY-3-8910 — это не ЦАП. Он не принимает амплитудные сэмплы. Это программируемый тоновый генератор: ты задаёшь ему частоту (как значение периода), громкость (0-15) и необязательные параметры шума и огибающей, а его внутренние осцилляторы автономно генерируют звук. Процессор свободен для другой работы.

Ключевая идея AY-beat: **заменить счётчик сэмплов счётчиком кадров, а PCM-выход — значениями регистров AY.**

Классический bytebeat вычисляет один амплитудный сэмпл на ~8000 Гц. AY-beat вычисляет периоды тона, громкости и параметры шума на 50 Гц — раз за видеокадр, по инструкции HALT. Осцилляторы AY берут на себя саму генерацию звука между кадрами.

Счётчик кадров `t` заменяет счётчик сэмплов. Формулы оперируют `t`, но производят значения регистров, а не сэмплы волновой формы. Там, где PCM-bytebeat имеет одну степень свободы (амплитуда), AY-beat располагает множеством: три независимых периода тона (по 12 бит каждый), три громкости (по 4 бита каждая), один период шума (5 бит) и 16-битный период огибающей с выбором формы.

### Базовая архитектура AY-Beat

```z80
; AY-beat frame update -- called once per HALT
; Assumes frame_counter is a byte in memory
ay_beat_update:
    ld   a, (frame_counter)
    ld   e, a             ; E = t (keep a copy)

    ; === Channel A: tone period from formula ===
    ; tone_lo = (t * 3) AND $3F -- pentatonic-ish cycling
    add  a, a             ; 4T   A = t * 2
    add  a, e             ; 4T   A = t * 3
    and  $3F              ; 7T   mask to 6 bits (periods 0-63)
    ld   d, a             ; 4T   save tone period
    ; Write R0 (tone A low) = D
    xor  a                ; 4T   A = 0 (register number)
    call ay_write_d       ; writes D to AY register A

    ; Write R1 (tone A high) = 0
    ld   a, 1             ; 7T
    ld   d, 0             ; 7T
    call ay_write_d

    ; === Channel A: volume from formula ===
    ; volume = bits 6-3 of t, giving 0-15 cycling
    ld   a, e             ; 4T   reload t
    rrca                  ; 4T
    rrca                  ; 4T
    rrca                  ; 4T
    and  $0F              ; 7T   volume 0-15
    ld   d, a             ; 4T
    ld   a, 8             ; 7T   R8 = Volume A
    call ay_write_d

    ; Advance frame counter
    ld   hl, frame_counter
    inc  (hl)             ; 11T
    ret
```

Это простейший AY-beat: один канал, одна формула тона, одна формула громкости, ~30 байт. Он производит циклическую развёртку, которая поднимается по высоте и затухает и нарастает — не музыка, но узнаваемо структурированный звук.

### Что меняется по сравнению с PCM-bytebeat

| Аспект | Классический (PCM) | AY-Beat |
|--------|---------------------|---------|
| Частота обновления | ~8000 Гц | 50 Гц (частота кадров) |
| Выход | 8-битная амплитуда | Период тона (12 бит), громкость (4 бита), шум (5 бит) |
| Каналы | 1 (моно-динамик) | 3 тона + 1 шум + огибающая |
| Нагрузка на процессор | 100% (все такты) | ~200-500 T за кадр (~0,3%) |
| Масштабирование формул | Мелкозернистое, быстрая эволюция | Крупнозернистое, нужны более широкие сдвиги |
| Генерация звука | Процессор вычисляет каждый сэмпл | Аппаратные осцилляторы AY работают автономно |

Частота кадров 50 Гц означает, что формулы эволюционируют в 160 раз медленнее, чем при 8 кГц. Чтобы получить эквивалентную ритмическую плотность, используй более крупные множители и меньше сдвигов вправо. Формула, которая даёт приятный ритм при 8 кГц с `t>>12` (период ~0,5 сек при 8 кГц), потребует примерно `t>>4` при 50 Гц для аналогичного тайминга (~0,3 сек между повторениями). Общее правило: раздели величины сдвигов из PC-bytebeat на ~7 (log2 от соотношения 160x) и подстрой на слух.

---

## 3. Дрон: огибающая + тон (режим E+T)

Здесь AY-beat становится по-настоящему интересным. Генератор огибающей AY автоматически циклически меняет громкость канала без какого-либо участия процессора. Установи регистр громкости канала в режим огибающей (бит 4 = 1, т.е. запиши $10 в R8/R9/R10), и аппаратная часть берёт на себя модуляцию громкости на частоте огибающей, заданной R11-R12.

Результат — дрон: непрерывно эволюционирующий тембр, создаваемый взаимодействием тонового осциллятора и осциллятора огибающей. Процессорная стоимость поддержания этого дрона почти нулевая — нужно лишь обновлять период тона и период огибающей раз в кадр, а аппаратура делает всё остальное.

### Рецепт дрона

1. Задай период тона по формуле — он определяет базовую высоту.
2. Задай период огибающей по другой формуле — он определяет скорость модуляции.
3. Установи форму огибающей в повторяющуюся волновую форму (формы $08, $0A, $0C или $0E).
4. Установи громкость канала в режим огибающей ($10).
5. Аппаратура производит непрерывно эволюционирующий дрон с нулевой посэмпловой нагрузкой на процессор.

```z80
; Drone setup -- E+T mode
; Tone period evolves per frame, envelope period evolves slower
drone_update:
    ld   a, (frame_counter)
    ld   e, a             ; E = t

    ; --- Tone period: slowly sweeping ---
    and  $7F              ; 128-frame cycle (2.56 seconds)
    ld   d, a
    xor  a                ; R0 = Tone A low
    call ay_write_d
    ld   a, 1             ; R1 = Tone A high
    ld   d, 0
    call ay_write_d

    ; --- Envelope period: evolves on different time scale ---
    ld   a, e             ; reload t
    rrca
    rrca                  ; divide by 4 -- envelope evolves 4x slower
    and  $3F
    add  a, $10           ; offset to avoid very fast envelopes
    ld   d, a
    ld   a, 11            ; R11 = Envelope period low
    call ay_write_d
    ld   a, 12            ; R12 = Envelope period high
    ld   d, 0
    call ay_write_d

    ; --- Envelope shape: repeating triangle ---
    ; CAUTION: writing R13 restarts the envelope cycle.
    ; Only write on the first frame, or when you want a restart.
    ld   a, e
    or   a
    jr   nz, .skip_shape
    ld   a, 13            ; R13 = Envelope shape
    ld   d, $0A           ; shape $0A = repeating triangle \/\/
    call ay_write_d
.skip_shape:

    ; --- Volume A: envelope mode ---
    ld   a, 8             ; R8 = Volume A
    ld   d, $10           ; bit 4 set = use envelope
    call ay_write_d

    ret
```

Красота режима E+T — в интерференции двух частот. Когда период огибающей близок к периоду тона, возникают эффекты амплитудной модуляции — громкость биений на разностной частоте, создающая колеблющийся, органоподобный тембр. Когда частота огибающей значительно ниже частоты тона, она действует как медленное тремоло. Когда значительно выше — попадаешь на территорию buzz-bass (см. Приложение G и Главу 11).

Развёртка периода огибающей при одновременном движении периода тона создаёт непрерывно эволюционирующие текстуры. Две формулы создают двумерное пространство параметров, которое звук исследует во времени. С правильной парой формул дрон никогда не повторяется в точности — он блуждает по тембральным вариациям, создавая амбиентный звуковой ландшафт из менее чем 30 байт кода.

### Стоимость в байтах

Настройка режима E+T с формулой занимает приблизительно 15-25 байт. Для 256-байтного интро это даёт богатый, эволюционирующий дроновый звук фактически бесплатно — без покадрового вычисления громкости, без паттерновых данных, только два значения регистров, выведенных из простых формул. Аппаратура AY выполняет всю работу по осцилляции.

---

## 4. Шумовая перкуссия

Генератор шума AY (R6) производит псевдослучайный шум на программируемой частоте (0-31). Регистр микшера (R7) управляет тем, какие каналы получают шум. Включение и выключение шума ритмически, управляемое счётчиком кадров, создаёт перкуссионные паттерны.

### Базовый паттерн бочки

```z80
; Noise percussion on channel C
; Frame counter in A (already loaded)
    ld   e, a             ; E = t
    and  $07              ; every 8th frame = 6.25 Hz pulse
    jr   nz, .decay

    ; --- Hit: enable noise on C, max volume ---
    ld   a, 7             ; R7 = Mixer
    ld   d, %00100100     ; tone C off, noise C on, others unchanged
    call ay_write_d
    ld   a, 6             ; R6 = Noise period
    ld   d, 2             ; low period = harsh, punchy
    call ay_write_d
    ld   a, 10            ; R10 = Volume C
    ld   d, $0F           ; maximum volume
    call ay_write_d
    jr   .done

.decay:
    ; --- Decay: reduce volume each frame ---
    ; Simple approach: volume = 15 - (t AND 7)
    ld   a, e
    and  $07              ; frames since last hit
    ld   d, a
    ld   a, $0F
    sub  d                ; volume = 15 - elapsed
    jr   nc, .vol_ok
    xor  a                ; clamp to 0
.vol_ok:
    ld   d, a
    ld   a, 10            ; R10 = Volume C
    call ay_write_d

.done:
```

### Характер перкуссии в зависимости от периода шума

| Значение R6 | Характер | Применение |
|-------------|----------|------------|
| 0-3 | Резкий щелчок, пробивной | Бочка, римшот |
| 4-8 | Чёткое шипение | Тело малого барабана |
| 10-15 | Широкий шум | Открытый хай-хэт |
| 20-31 | Низкий гул | Далёкий гром, эмбиент |

### Ритмическое разнообразие через битовые маски

Различные маски AND на счётчике кадров дают различную ритмическую плотность:

| Маска | Период | Частота | Характер |
|-------|--------|---------|----------|
| `AND $03` | Каждые 4 кадра | 12,5 Гц | Скоростная очередь, хай-хэт |
| `AND $07` | Каждые 8 кадров | 6,25 Гц | Стандартная бочка |
| `AND $0F` | Каждые 16 кадров | 3,125 Гц | Половинный темп, разреженный |
| `AND $1F` | Каждые 32 кадра | 1,5625 Гц | Медленный пульс, вступление |

Комбинируй две маски для полиритмии: проверяй `t AND $07` для бочки, `t AND $03` для хай-хэта. Это стоит около 10 дополнительных байт, но добавляет существенную ритмическую сложность.

### Использование огибающей для затухания барабана

Вместо ручного затухания громкости каждый кадр используй генератор огибающей AY в однократном режиме. Установи R13 в форму $00 (затухание до нуля, удержание), и аппаратура обработает спад громкости автоматически:

```z80
; Envelope-based drum hit -- zero CPU cost for decay
    ld   a, e
    and  $07              ; every 8th frame
    jr   nz, .no_hit
    ; Set envelope period (controls decay speed)
    ld   a, 11
    ld   d, $80           ; period = $0080 -- medium decay
    call ay_write_d
    ld   a, 12
    ld   d, 0
    call ay_write_d
    ; Trigger: write shape $00 (single decay)
    ld   a, 13
    ld   d, $00
    call ay_write_d
    ; Volume C = envelope mode
    ld   a, 10
    ld   d, $10
    call ay_write_d
.no_hit:
```

Это экономит несколько байт, устраняя код ручного затухания. Компромисс: генератор огибающей общий для всех каналов в режиме огибающей. Если канал A использует E+T-дрон, канал C не может независимо использовать огибающую для затухания барабана. Планируй распределение каналов соответственно.

---

## 5. Многоканальная гармония

AY имеет три независимых тоновых канала. AY-beat может вывести все три из одной формулы, используя битовую ротацию, создавая впечатление контрапункта практически из ничего.

### Три голоса из одной формулы

```z80
; Three related voices from one frame counter
    ld   a, (frame_counter)
    ld   e, a

    ; === Channel A: base formula ===
    and  $3F              ; period 0-63
    ld   d, a
    xor  a                ; R0
    call ay_write_d

    ; === Channel B: same formula, rotated 2 bits ===
    ld   a, e
    rrca
    rrca                  ; rotate right by 2
    and  $3F
    ld   d, a
    ld   a, 2             ; R2
    call ay_write_d

    ; === Channel C: same formula, rotated 4 bits ===
    ld   a, e
    rrca
    rrca
    rrca
    rrca                  ; rotate right by 4
    and  $3F
    ld   d, a
    ld   a, 4             ; R4
    call ay_write_d
```

Битовые ротации создают версии одного и того же паттерна со сдвигом по фазе. Каналы играют связанные, но смещённые мелодии — они следуют одному контуру, но приходят к каждой высоте в разные моменты. Это создаёт впечатление контрапункта: множество независимых голосов, разделяющих общую логику.

### Почему ротация создаёт гармонию

RRCA — это *ротация*, а не сдвиг: биты, выпадающие снизу, заворачиваются наверх. Это означает, что три канала проходят один и тот же набор значений периода в том же порядке, но со сдвигом во времени. Сдвиг зависит от величины ротации:

- **RRCA x 2:** Канал «впереди» примерно на четверть цикла паттерна. Это часто создаёт интервалы, которые звучат как кварты или квинты — не точно настроенные, но гармонически связанные достаточно, чтобы быть приятными.
- **RRCA x 4:** Половина байта сдвига. Это стремится создавать октавоподобные отношения, поскольку бит 4, ротированный в бит 0, фактически вдвое уменьшает период при определённых фазовых выравниваниях.

Это не настоящие музыкальные интервалы. Это псевдогармонические отношения, созданные структурой двоичных чисел. Но слух снисходителен — если два тона разделяют большую часть своего битового паттерна, они звучат «родственно», и для 256-байтного интро этого достаточно.

### Формулы громкости для многоканальности

Задай каждому каналу свою формулу громкости, чтобы не все три голоса оказывались на одном уровне одновременно:

```z80
    ; Volume A: bits 6-3 of t
    ld   a, e
    rrca
    rrca
    rrca
    and  $0F
    ld   d, a
    ld   a, 8
    call ay_write_d

    ; Volume B: bits 4-1 of t (different phase)
    ld   a, e
    rrca
    and  $0F
    ld   d, a
    ld   a, 9
    call ay_write_d

    ; Volume C: inverted bits 5-2 of t
    ld   a, e
    rrca
    rrca
    and  $0F
    xor  $0F              ; invert -- when A is loud, C is quiet
    ld   d, a
    ld   a, 10
    call ay_write_d
```

Инвертированная громкость на канале C создаёт динамику «вопрос-ответ»: по мере нарастания одного голоса другой затухает. Это стоит 2 дополнительных байта (`XOR $0F`), но существенно улучшает музыкальную текстуру.

---

## 6. Кулинарная книга формул

Следующие формулы были протестированы на AY при частоте кадров 50 Гц. «Байты» — это стоимость реализации на Z80 для вычисления формулы из значения, уже находящегося в регистре A (счётчик кадров). Маска периода определяет диапазон высоты.

### Формулы периода тона

| # | Формула | Реализация на Z80 | Байты | Звук | Лучшее применение |
|---|---------|---------------------|-------|------|-------------------|
| 1 | `t AND $3F` | `and $3F` | 2 | Восходящая пила, цикл 1,28 сек | Простая развёртка |
| 2 | `t*3 AND $3F` | `ld e,a : add a,a : add a,e : and $3F` | 5 | Быстрая развёртка, широкие интервалы | Энергичный бас |
| 3 | `t XOR (t>>3)` | `ld e,a : rrca : rrca : rrca : xor e` | 5 | Хаотичный с периодической структурой | Шумовая текстура |
| 4 | `(t AND $0F) XOR $0F` | `and $0F : xor $0F` | 4 | Треугольная волна, развёртка туда-сюда | Мелодический лид |
| 5 | `t*5 AND t>>2` | `ld e,a : add a,a : add a,a : add a,e : ld d,a : ld a,e : rrca : rrca : and d` | 10 | Ритмическое стробирование | Перкуссионный |
| 6 | `(t+t>>4) AND $1F` | `ld e,a : rrca : rrca : rrca : rrca : add a,e : and $1F` | 6 | Медленно модулированная развёртка | Эволюционирующий дрон |
| 7 | `t AND (t>>3) AND $1F` | `ld e,a : rrca : rrca : rrca : and e : and $1F` | 6 | Самоподобный, фрактальный ритм | Сложные паттерны |
| 8 | `(t>>1) XOR (t>>3)` | `ld e,a : rrca : ld d,a : rrca : rrca : xor d` | 6 | Двухскоростная интерференция | Металлическая текстура |
| 9 | `t*7 AND $7F` | `ld e,a : add a,a : add a,a : add a,a : sub e : and $7F` | 6 | Широкая развёртка, 7x скорость | Ощущение быстрого арпеджио |
| 10 | `(t XOR t>>1) AND $3F` | `ld e,a : rrca : xor e : and $3F` | 5 | Последовательность кода Грея | Ступенчатая мелодия |
| 11 | `t AND $07 OR t>>4` | `ld e,a : and $07 : ld d,a : ld a,e : rrca : rrca : rrca : rrca : or d` | 8 | Вложенные циклы, два ритмических слоя | Многослойный ритм |
| 12 | `(t+t+t>>2) AND $3F` | `ld e,a : add a,a : ld d,a : ld a,e : rrca : rrca : add a,d : and $3F` | 8 | Ускоряющаяся развёртка с подпаттерном | Текстурированный лид |

### Формулы громкости

| # | Формула | Z80 | Байты | Эффект |
|---|---------|-----|-------|--------|
| V1 | `t>>3 AND $0F` | `rrca : rrca : rrca : and $0F` | 5 | Медленный цикл затухания, 5,12 сек |
| V2 | `(t AND $0F) XOR $0F` | `and $0F : xor $0F` | 4 | Треугольная громкость, туда-сюда |
| V3 | `t*3>>4 AND $0F` | `ld e,a : add a,a : add a,e : rrca : rrca : rrca : rrca : and $0F` | 8 | Нерегулярный паттерн затухания |
| V4 | `$0F` (константа) | `ld d,$0F` | 2 | Максимальная громкость, для режима огибающей |

### Как читать таблицу

Выбери формулу тона и формулу громкости. Скомбинируй их. Общая стоимость в байтах — это сумма обеих реализаций плюс накладные расходы на запись регистров AY (~8 байт на канал для двух вызовов ay_write: выбор регистра + данные для младшего байта тона и громкости). Один канал с формулой #1 и громкостью V1 стоит приблизительно 2 + 5 + 16 = 23 байта, включая запись регистров.

Формула #10 (код Грея) заслуживает особого упоминания. Последовательность кода Грея меняет только один бит за шаг, поэтому период тона меняется ровно на одну единицу за кадр — плавная, ступенчатая мелодия. В сочетании с маской AND она циклически проходит ограниченный диапазон высот с приятной регулярностью. Это одна из наиболее музыкально звучащих одиночных формул.

---

## 7. Собираем вместе: полный движок AY-Beat

Вот полный, минимальный движок AY-beat, производящий 3-канальный генеративный звук с дроном на огибающей. Это движок, который ты вставляешь в 256-байтное интро рядом с визуальным эффектом.

```z80
; ============================================================
; Complete AY-beat engine -- 47 bytes
; Produces 3-channel generative music with envelope drone
; Call once per frame (after HALT)
; Clobbers: AF, BC, DE, HL
; ============================================================

ay_beat:
    ld   hl, .frame
    ld   a, (hl)          ; A = frame counter
    inc  (hl)             ; advance for next frame
    ld   e, a             ; E = t (preserved copy)

    ; --- Mixer: all three tones on, no noise ---
    ; Only needed on first frame, but costs 5 bytes either way
    push af
    ld   a, 7             ; R7
    ld   d, $38           ; tones A+B+C on, noise off
    call .wr
    pop  af

    ; --- Channel A: tone = t AND $3F ---
    and  $3F
    ld   d, a
    xor  a                ; R0
    call .wr

    ; --- Channel B: tone = t*3 AND $3F ---
    ld   a, e
    add  a, a
    add  a, e             ; A = t * 3
    and  $3F
    ld   d, a
    ld   a, 2             ; R2
    call .wr

    ; --- Channel C: tone = (t XOR t>>1) AND $3F ---
    ld   a, e
    rrca
    xor  e
    and  $3F
    ld   d, a
    ld   a, 4             ; R4
    call .wr

    ; --- Volumes: A and B fixed at 12, C = envelope mode ---
    ld   a, 8             ; R8 = Volume A
    ld   d, 12
    call .wr
    ld   a, 9             ; R9 = Volume B
    ld   d, 10
    call .wr
    ld   a, 10            ; R10 = Volume C
    ld   d, $10           ; envelope mode
    call .wr

    ; --- Envelope: period sweeps with t, triangle shape ---
    ld   a, e
    rrca
    rrca
    and  $3F
    add  a, $20           ; keep envelope period above $20
    ld   d, a
    ld   a, 11            ; R11
    call .wr
    ; R12 = 0 (envelope period high)
    inc  a                ; A = 12
    ld   d, 0
    call .wr

    ; Shape: only write on frame 0 to avoid constant restarts
    ld   a, e
    or   a
    ret  nz               ; skip shape write on all frames except 0
    ld   a, 13            ; R13
    ld   d, $0E           ; shape $0E = repeating triangle /\/\
    ; fall through to .wr, then ret

.wr:
    ; Write D to AY register A
    ld   bc, $FFFD
    out  (c), a           ; select register
    ld   b, $BF
    out  (c), d           ; write value
    ret

.frame:
    DB   0                ; frame counter (self-modifying data)

; ============================================================
; Total: 47 bytes (code) + AY write routine shared
; The .wr routine is 9 bytes. If your intro already has an
; AY write routine, the engine body alone is 38 bytes.
; ============================================================
```

### Что это производит

- **Канал A:** Простая восходящая развёртка, циклически проходящая периоды 0-63 каждые 64 кадра (1,28 секунды). Фундаментальный паттерн.
- **Канал B:** Та же развёртка с 3-кратной скоростью, создающая быстро меняющиеся интервалы. Когда она совпадает с каналом A, ты слышишь консонанс; когда расходится — диссонанс. Чередование создаёт ритмический интерес.
- **Канал C:** Развёртка по коду Грея в режиме огибающей. Треугольная огибающая создаёт автоматическую модуляцию громкости, порождая дрон, который фазируется относительно периода тона. Это гармоническая подложка под двумя другими голосами.
- **В целом:** Эволюционирующая, самоподобная текстура, циклически проходящая тональные соотношения. Звучит чуждо и механистично — именно то, что нужно для 256-байтного интро.

### Точки настройки

**Измени формулы тона.** Замени любую из последовательностей AND/RRCA на другую формулу из кулинарной книги (раздел 6). Каждая замена полностью меняет характер.

**Добавь шумовую перкуссию.** Вставь блок `ld a,e : and $07 : jr nz,.no_hit` (раздел 4), чтобы добавить ритмические удары. Стоимость: ~12 байт. Займи канал (обычно B) или наложи шум на канал C.

**Используй пентатоническую маскировку.** Вместо `AND $3F` как финальной маски, индексируй в 5-байтную пентатоническую таблицу подстановки. Это ограничивает периоды тона гармонически связанными значениями, делая выход более преднамеренно музыкальным. Стоимость: ~8 байт (5 на таблицу, 3 на поиск). Глава 13 обсуждает эту технику.

**Варьируй фиксированные громкости.** Замени константные записи громкости на формулы громкости из раздела 6. Даже `ld a,e : rrca : rrca : rrca : and $0F` (5 байт на канал) добавляет значительный динамический интерес.

---

## 8. Продвинутое: комбинирование техник

Предыдущие разделы покрывают отдельные строительные блоки. Хорошо сделанный движок AY-beat комбинирует несколько:

### Архитектура для 256-байтного интро

```
Frame 0:   Set mixer, envelope shape (one-time setup)
Frame N:   Update tone A (melody formula)
           Update tone B (harmony formula, rotated)
           Update volume A (fade formula)
           Update volume B (inverted fade)
           Channel C in E+T drone mode (auto-evolving)
           Every 8th frame: noise hit on C (toggle mixer)
```

Суммарная нагрузка на процессор за кадр составляет приблизительно 300-500 тактов (T-state) — значительно менее 1% от ~70000 тактов (T-state), доступных за кадр. Оставшиеся 99% доступны для визуального эффекта.

### Бюджет регистров

AY имеет 14 записываемых регистров. В минимальном движке AY-beat ты обычно записываешь 8-10 за кадр:

| Регистр | Запись | Источник |
|---------|--------|----------|
| R0 (Tone A low) | Каждый кадр | Формула |
| R2 (Tone B low) | Каждый кадр | Формула |
| R4 (Tone C low) | Каждый кадр или однократно | Формула или фиксированный |
| R1, R3, R5 (Tone high) | Однократно (установить в 0) | Константа |
| R7 (Mixer) | Каждый кадр или однократно | Константа или переключается для шума |
| R8, R9 (Volume A, B) | Каждый кадр | Формула или константа |
| R10 (Volume C) | Однократно | $10 (режим огибающей) |
| R11 (Envelope low) | Каждый кадр | Формула |
| R13 (Envelope shape) | Однократно (кадр 0) | Константа |

Регистры, которые можно полностью пропустить: R6 (период шума — нужен только при использовании шума), R12 (старший байт огибающей — устанавливается однократно в 0 для коротких периодов), R14-R15 (порты ввода-вывода — не относятся к звуку).

### Расклад по размеру

Для 256-байтного интро каждый байт на счету. Вот как выглядит типичный бюджет AY-beat:

| Компонент | Байты |
|-----------|-------|
| Подпрограмма записи AY | 9 |
| Управление счётчиком кадров | 5 |
| 3 формулы тона (простые) | 12-18 |
| 3 настройки громкости | 6-15 |
| Настройка микшера | 5 |
| Настройка огибающей | 8-12 |
| Итого | **45-64** |

Это оставляет 192-211 байт на визуальный эффект, основной цикл и любую другую инфраструктуру. При 45 байтах движок из раздела 7 близок к оптимуму по соотношению объёма производимого звука к размеру.

---

## 9. AY-как-ЦАП: классический bytebeat через регистр громкости

Есть промежуточный путь между тупиком бипера и переосмыслением AY-beat. Регистры громкости AY-3-8910 (регистры 8, 9, 10) принимают 4-битные значения (0-15). Если обновлять регистр громкости с высокой частотой — скажем, в тесном цикле — выход AY становится 4-битным ЦАП. Именно так работают оцифрованная речь и проигрывание сэмплов в демо для Spectrum.

В применении к bytebeat: вычисляем `f(t)`, сдвигаем вправо до 4 бит, записываем в регистр громкости:

```z80
; AY-as-DAC bytebeat -- 4-bit PCM through volume register
; Still costly (~80% CPU), but sounds better than beeper
    ld   a, 7               ; mixer: all channels off (tone+noise)
    ld   d, %00111111
    call ay_write
    ld   de, 0               ; t = 0
.loop:
    ; Compute f(t): t AND (t >> 5) -- classic bytebeat formula
    ld   a, e
    ld   b, d
    srl  b
    rr   a
    srl  b
    rr   a
    srl  b
    rr   a
    srl  b
    rr   a
    srl  b
    rr   a                   ; A = t >> 5 (using DE as 16-bit t)
    and  e                   ; A = t AND (t >> 5)
    rrca
    rrca
    rrca
    rrca
    and  $0F                 ; scale to 4-bit (0-15)
    ld   bc, AY_REG
    ld   b, $FF              ; select register
    push af
    ld   a, 8                ; register 8: volume A
    out  (c), a
    ld   b, $BF
    pop  af
    out  (c), a              ; write volume
    inc  de                  ; t++
    jr   .loop
```

Это даёт узнаваемый bytebeat — настоящие формулы волновой формы из раздела 1, слышимые через AY. Качество звука лучше, чем у бипера (4-битное разрешение против 1-битного), а выходной каскад AY обеспечивает правильные уровни аудиосигнала.

Стоимость по-прежнему жёсткая: ~80% процессора. Остаётся тонкая полоска времени для визуалов — достаточно для медленно обновляемого атрибутного эффекта, недостаточно для чего-то амбициозного. Эта техника полезна, когда тебе нужен *конкретный звук* классических формул bytebeat и ты готов заплатить процессорную цену.

### Три пути вывода в сравнении

| Путь | Разрешение | Нагрузка на процессор | Характер звука | Практично для демо? |
|------|------------|----------------------|----------------|---------------------|
| Бипер (порт $FE) | 1 бит | ~100% | Резкий, жужжащий | Нет |
| AY volume DAC | 4 бита | ~80% | Классический bytebeat | Едва (только атрибутные эффекты) |
| AY-beat (регистры) | Тон/шум | ~0,5% | Чиптюн, генеративный | Да — правильный выбор |

Для size-coded интро и демо AY-beat — почти всегда верный выбор. AY-как-ЦАП оставь для арт-проектов, где конкретная звуковая эстетика bytebeat — это суть.

---

## 10. Теория музыки для алгоритмов

Формулы AY-beat, игнорирующие теорию музыки, производят интересный шум. Формулы, которые *кодируют* теорию музыки, производят настоящую музыку. Следующие техники добавляют музыкальность за минимальное число байт.

### Таблицы гамм: ограничение выхода приятными нотами

Сырая формула вроде `tone = t AND $3F` производит все 64 возможных значения периода — большинство из которых не имеют музыкальной ценности. **Таблица гаммы** отображает выход формулы в реальные периоды нот, гарантируя, что каждое значение звучит хорошо.

| Гамма | Ноты | Размер таблицы | Характер |
|-------|------|----------------|----------|
| Пентатоника | 5 (C D E G A) | 10 байт (5 x 2-байтных периодов) | Всегда консонантная, фолк/этно |
| Мажорная диатоника | 7 (C D E F G A B) | 14 байт | Яркая, западная, знакомая |
| Минорная диатоника | 7 (C D Eb F G Ab Bb) | 14 байт | Тёмная, меланхоличная |
| Блюзовая | 6 (C Eb F F# G Bb) | 12 байт | Грубая, экспрессивная |
| Хроматическая | 12 | 24 байта | Атональная, диссонантная — обычно неверный выбор для sizecoding |

Пентатоника — лучший друг сайзкодера: 5 нот, 10 байт, и *любая* комбинация нот звучит приемлемо. На пентатонической гамме невозможно сыграть неправильную ноту. Вот почему так много 256-байтных интро звучат смутно «по-азиатски» или «по-фолковому» — пентатоническое ограничение делает случайные последовательности музыкальными.

```z80
; Scale-constrained note lookup
; Input: A = formula output (any value)
; Output: DE = AY tone period
    ; Map to scale index: A mod scale_length
    and  $07               ; keep low 3 bits
    cp   5                 ; pentatonic has 5 notes
    jr   c, .in_range
    sub  5                 ; wrap: 5→0, 6→1, 7→2
.in_range:
    add  a, a              ; ×2 for word entries
    ld   hl, pentatonic
    add  a, l
    ld   l, a
    ld   e, (hl)
    inc  hl
    ld   d, (hl)           ; DE = tone period
```

### Октавная деривация: бесплатный диапазон высоты

Сохрани одну октаву периодов. Выводи все остальные битовым сдвигом:

- `SRL D : RR E` = одна октава вверх (период вдвое, высота удвоена)
- `SLA E : RL D` = одна октава вниз (период удвоен, высота вдвое)

Пять пентатонических нот x одна сохранённая октава x битовые сдвиги = 5 нот x 5+ октав = 25+ различных высот из 10 байт данных. Формула выбирает ноту, отдельная битовая маска выбирает октаву:

```z80
    ; note_index = formula AND $0F
    ; octave = note_index / 5 (0-2)
    ; note = note_index % 5
    ; Look up base period, then SRL 'octave' times
```

### Арпеджио: тоны аккорда последовательно

Арпеджио циклически проходит тоны аккорда. В терминах ступеней гаммы:

| Аккорд | Смещения ступеней | Звучание |
|--------|-------------------|----------|
| Мажорное трезвучие | 0, 2, 4 (основной тон, терция, квинта) | Яркое, разрешённое |
| Минорное трезвучие | 0, 2, 3 (основной тон, м. терция, квинта) | Тёмное, напряжённое |
| Пауэр-аккорд | 0, 4 (основной тон, квинта) | Открытый, мощный |
| Суспендированный | 0, 3, 4 (основной тон, кварта, квинта) | Неопределённый, парящий |

Реализация: `arp_step = (t / speed) % chord_size`, затем прибавить смещение к текущему основному тону:

```z80
; Arpeggio: cycle through major triad
    ld   a, (frame)
    rrca
    rrca                   ; A = frame / 4 (arp speed)
    ; mod 3 for three chord tones
    ld   b, a
.mod3:
    sub  3
    jr   nc, .mod3
    add  a, 3              ; A = 0, 1, or 2
    ld   hl, arp_major
    add  a, l
    ld   l, a
    ld   a, (hl)           ; A = scale offset
    ; add to chord root, look up in scale table
    ; ...

arp_major:  DB  0, 2, 4    ; root, third, fifth (3 bytes)
arp_minor:  DB  0, 2, 3    ; root, min.third, fifth (3 bytes)
```

Три байта на форму аккорда. Скорость арпеджио выводится из счётчика кадров — отдельный таймер не нужен.

### Пошаговые орнаменты: трели, морденты и глиссандо

Орнамент — это крошечный циклический паттерн относительных смещений высоты, накладываемый на ноту. В трекерной музыке орнаменты оживляют плоские тона:

| Орнамент | Паттерн | Эффект | Байты |
|----------|---------|--------|-------|
| Трель | 0, +1, 0, -1 | Быстрое чередование с соседом | 4 |
| Мордент | 0, +1, 0, 0 | Краткий верхний сосед, затем устаканивание | 4 |
| Глиссандо вверх | 0, 0, +1, +1 | Постепенный подъём | 4 |
| Вибрато | 0, +1, +1, 0, -1, -1 | Плавное колебание | 6 |

Применяй, прибавляя значение орнамента к индексу ноты перед обращением к таблице гаммы:

```z80
    ; ornament_pos = (frame) AND (ornament_length - 1)
    ld   a, (frame)
    and  $03               ; mod 4 for 4-step ornament
    ld   hl, trill
    add  a, l
    ld   l, a
    ld   a, (hl)           ; A = pitch offset (-1, 0, or +1)
    add  a, c              ; C = current note index
    ; ... look up modified note in scale table

trill:    DB  0, 1, 0, -1   ; 4 bytes
mordent:  DB  0, 1, 0, 0    ; 4 bytes
```

Четыре байта превращают статичный тон в живой голос. Накладывай разные орнаменты на разные каналы для богатой текстуры.

### Аккордовые последовательности: гармоническое движение

Основной тон аккорда может меняться со временем, следуя прогрессии. Классическая гармония в 4 байтах:

```z80
; I - IV - V - I progression (the backbone of Western music)
progression:  DB  0, 3, 4, 0     ; scale degrees

; Select chord: (frame / 64) AND 3
    ld   a, (frame)
    rrca
    rrca
    rrca
    rrca
    rrca
    rrca                   ; A = frame / 64
    and  $03               ; mod 4
    ld   hl, progression
    add  a, l
    ld   l, a
    ld   a, (hl)           ; A = chord root (scale degree)
```

Четыре байта данных прогрессии, циклически управляемые счётчиком кадров, дают твоей AY-beat-пьесе гармоническое движение — ощущение, что она «куда-то идёт», а не зацикливается на одном аккорде. Другие прогрессии:

| Прогрессия | Ступени | Байты | Ощущение |
|------------|---------|-------|----------|
| I-IV-V-I | 0, 3, 4, 0 | 4 | Классическое разрешение |
| I-V-vi-IV | 0, 4, 5, 3 | 4 | Поп/рок стандарт |
| i-VI-III-VII | 0, 5, 2, 6 | 4 | Эпический минор |
| I-I-I-I | 0, 0, 0, 0 | 1 (или пропустить) | Дрон/медитативный |

### Суммарный бюджет данных для богатой музыки

Комбинируя все техники:

| Компонент | Байты |
|-----------|-------|
| Пентатоническая таблица (5 нот) | 10 |
| Паттерн арпеджио (1 аккорд) | 3 |
| Орнамент (трель) | 4 |
| Прогрессия (4 аккорда) | 4 |
| **Итого** | **21** |

21 байт музыкальных данных — плюс ~45 байт кода движка — производит трёхканальную музыку с мелодией, гармонией, сменой аккордов и орнаментикой. Пример `aybeat.a80` в сопроводительном коде этой книги демонстрирует этот подход в 320 байтах, с запасом для визуалов.

---

## 11. L-системные грамматики: фрактальные мелодии

Системы Линденмайера (L-системы) — это переписывающие грамматики, изначально изобретённые для моделирования роста растений. В применении к музыке они генерируют самоподобные последовательности с дальнодействующей структурой из крошечных наборов правил.

### Концепция

L-система имеет **аксиому** (начальную строку) и **правила порождения** (правила раскрытия). Каждая итерация заменяет каждый символ согласно его правилу:

```
Axiom: A
Rules: A → A B,  B → A
```

```
Step 0: A
Step 1: A B
Step 2: A B A
Step 3: A B A A B
Step 4: A B A A B A B A
```

Это **L-система Фибоначчи**. Последовательность растёт в соотношении Фибоначчи (~1,618x за шаг). Отобрази символы в музыкальные события:

| Символ | Музыкальное значение |
|--------|---------------------|
| A | Играть основной тон (ступень гаммы 0) |
| B | Играть квинту (ступень гаммы 4) |

Результирующая мелодия: основной тон, квинта, основной тон, основной тон, квинта, основной тон, квинта, основной тон... — последовательность, которая не периодична и не случайна, а *квазипериодична*. Она обладает структурой на каждом масштабе, как фрактал. Звучит преднамеренно, но без повторений.

### Почему L-системы работают для музыки

1. **Самоподобие.** Мелодия на больших масштабах повторяет мелодию на малых масштабах. Именно это делает сочинённую музыку связной — темы повторяются на разных уровнях.
2. **Неповторимость.** В отличие от зацикленного паттерна, последовательность L-системы никогда точно не повторяется (для иррациональных коэффициентов роста). Она остаётся интересной.
3. **Крошечная кодировка.** Правила — это несколько байт. Генерируемая ими последовательность произвольно длинна.

### Полезные правила L-систем

| Название | Аксиома | Правила | Рост | Характер |
|----------|---------|---------|------|----------|
| Фибоначчи | A | A→AB, B→A | ~1,618x | Квазипериодический, органичный |
| Туэ-Морс | A | A→AB, B→BA | 2x | Сбалансированный, честный — без длинных серий |
| Удвоение периода | A | A→AB, B→AA | 2x | Всё более синкопированный |
| Кантор | A | A→ABA, B→BBB | 3x | Разреженный, с паузами (B=пауза) |

### Реализация на Z80

Трюк для Z80 — **не раскрывать строку в памяти** (это потребовало бы неограниченного буфера). Вместо этого вычисляй символ на позиции `n` рекурсивно: отслеживай назад по применениям правил, чтобы определить, от какого исходного символа произошла позиция `n`.

Для L-системы Фибоначчи существует элегантный короткий путь. Символ на позиции `n` зависит от представления Цекендорфа (кодирования Фибоначчи) числа `n`. Но для практического sizecoding работает более простой подход:

```z80
; L-system melody generator (Fibonacci: A→AB, B→A)
; Returns next note in sequence
; Uses position counter in memory
;
; The sequence of symbols can be generated iteratively:
; keep two "previous" bytes and generate the next

lsys_next:
    ld   hl, lsys_state
    ld   a, (hl)           ; prev1
    inc  hl
    ld   b, (hl)           ; prev2
    inc  hl
    ld   c, (hl)           ; position in current generation

    ; Fibonacci rule: output prev1, then swap
    ; When position reaches length, expand to next generation
    ld   d, a              ; D = current symbol to output

    ; Advance: shift the pair
    inc  c
    ld   (hl), c
    dec  hl
    ld   (hl), a           ; prev2 = prev1
    dec  hl
    ; New prev1 from rule: A→A (first output), then A→B (second)
    ; Simplified: alternate symbols based on parity
    ld   a, c
    and  $01
    jr   z, .sym_a
    ld   a, 1              ; B
    jr   .store
.sym_a:
    xor  a                 ; A (=0)
.store:
    ld   (hl), a

    ; Map symbol to scale degree
    ld   a, d
    or   a
    jr   z, .root
    ; B = fifth
    ld   a, 4              ; scale degree 4 = fifth in pentatonic
    ret
.root:
    xor  a                 ; scale degree 0 = root
    ret

lsys_state:
    DB   0                 ; prev1 (A=0, B=1)
    DB   0                 ; prev2
    DB   0                 ; position
```

Более практичный подход для sizecoding: предвычисли несколько итераций L-системы в короткий буфер при инициализации (одна итерация Фибоначчи из 5-символьной аксиомы даёт 8 символов, две итерации — 13, три — 21, всё вмещается в маленький буфер), затем циклически проходи буфер как мелодическую последовательность:

```z80
; Precompute L-system into buffer (Fibonacci, 3 iterations)
; Axiom: "AABAB" (5 symbols) → 8 → 13 → 21 symbols
; 21 notes of fractal melody from 5 bytes of axiom + expansion code

lsys_expand:
    ld   hl, lsys_axiom
    ld   de, lsys_buf
    ld   b, 5              ; axiom length
.expand_iter:
    ; One iteration: for each symbol, apply rule
    push bc
    push hl
    ld   hl, lsys_buf
    ld   de, lsys_work     ; expand into work buffer
    ; ...expand according to rules...
    pop  hl
    pop  bc
    ; Copy work back to buf for next iteration
    ; Repeat for desired number of iterations
    ret

lsys_axiom:
    DB   0, 0, 1, 0, 1     ; A A B A B

; During playback:
; melody_index = frame / note_duration
; note = lsys_buf[melody_index % buf_length]
; look up in scale table → AY period
```

### Мелодия как движение, а не абсолютные ноты

Наиболее музыкальное применение L-систем — отображение символов не в фиксированные ноты, а в **направления шага по гамме**. Мелодия фундаментально — это *движение*: вверх, вниз, повтор, скачок — по гамме. Начальная нота произвольна; контур — вот что важно.

Определи символы как движения:

| Символ | Значение | Шаг по гамме |
|--------|----------|-------------|
| U | Шаг вверх | +1 |
| D | Шаг вниз | -1 |
| R | Повтор | 0 |
| S | Скачок вверх (прыжок) | +2 |

Теперь L-система генерирует мелодический *контур*, а не фиксированные последовательности высот:

```
Axiom: U
Rules: U → U R D,  D → U,  R → U D
```

```
Step 0: U                          (+1)
Step 1: U R D                      (+1, 0, -1)
Step 2: U R D  U D  U              (+1, 0, -1, +1, -1, +1)
Step 3: U R D  U D  U  U R D  U  U R D  U D   ...
```

Мелодия ходит вверх и вниз по текущей гамме, всегда оставаясь в пределах таблицы гаммы. Она естественно тяготеет к стартовой высоте (возвраты балансируют уходы), создавая дугу напряжения и разрешения, которая делает музыку осмысленной.

```z80
; Motion-based L-system playback
; current_note = scale index, modified by each symbol
    ld   a, (current_note)
    ld   hl, lsys_buf
    ld   b, (melody_pos)
    add  a, l
    ; ... get motion symbol at current position ...
    ; D = motion offset from symbol table
    add  a, d              ; current_note += motion
    and  $0F               ; wrap to scale range
    ld   (current_note), a
    ; look up in pentatonic table → AY period
```

Это более музыкально, чем отображение A=основной тон, B=квинта. Одни и те же правила L-системы порождают разные мелодии в зависимости от стартовой ноты и лежащей в основе гаммы — смени гамму с пентатоники на блюзовую, и тот же контур создаёт совершенно другое настроение.

### Трибоначчи: три символа для более богатых паттернов

L-система Фибоначчи использует два символа. **Трибоначчи** использует три: A→ABC, B→A, C→B. Коэффициент роста ~1,839x (постоянная трибоначчи). Три символа означают более разнообразное мелодическое содержание:

| Символ | Как движение | Как нота |
|--------|-------------|----------|
| A | Шаг вверх (+1) | Основной тон |
| B | Повтор (0) | Терция |
| C | Шаг вниз (-1) | Квинта |

```
Axiom: A
Step 1: A B C
Step 2: A B C  A  B
Step 3: A B C  A  B  A B C  A B C
```

Последовательность трибоначчи имеет более длинные неповторяющиеся серии, чем Фибоначчи, и более сложную внутреннюю структуру. Музыкально трёхсимвольный словарь даёт мелодиям больше разнообразия — они не просто прыгают туда-сюда между двумя состояниями.

### Мелодии PRNG с отобранными сидами

Линейный регистр сдвига с обратной связью (LFSR) или аналогичный ГПСЧ генерирует детерминистическую псевдослучайную последовательность из начального значения (сида). Последовательность *звучит* случайно, но точно повторяется при сбросе сида. Это даёт воспроизводимые мелодические фрагменты.

Техника: **протестируй много сидов, оставь те, что звучат хорошо.** Сохрани 2-4 значения сидов (по 2 байта каждый) для разных секций произведения. Во время выполнения загрузи сид и позволь ГПСЧ генерировать мелодию. Сам ГПСЧ — это ~6-8 байт; каждый сид — 2 байта.

```z80
; LFSR-based melody generator
; HL = seed (determines the melody)
prng_note:
    ld   a, h
    xor  l              ; mix bits
    rrca
    rrca
    xor  h
    ld   h, a
    ld   a, l
    add  a, h
    ld   l, a           ; advance LFSR state (~6 bytes)
    and  $07            ; constrain to scale range
    ret                 ; A = note index for scale table

; Different seeds → different melodies
seed_verse:   DW  $A73B    ; tested: produces ascending contour
seed_chorus:  DW  $1F4D    ; tested: produces energetic pattern
seed_bridge:  DW  $8E21    ; tested: produces descending, calm
```

Рабочий процесс: напиши тестовый стенд, который проигрывает мелодию ГПСЧ для каждого значения сида 0-65535, слушай (или анализируй), отмечай удачные. На практике несколько часов тестирования дают десятки пригодных сидов. Сохрани 3-4 из них и переключайся между секциями произведения.

**Комбинирование с таблицами гамм:** выход ГПСЧ проходит через пентатоническую таблицу, поэтому даже «плохие» сиды производят консонантные ноты. Ты отбираешь по *мелодическому контуру*, а не избегаешь неправильных нот — таблица гаммы уже позаботилась об этом.

**Комбинирование с L-системами:** используй ГПСЧ для *выбора того, какое правило L-системы применить* на каждом шаге, создавая стохастические L-системы. Сид управляет «характером» произведения; грамматические правила управляют структурой. Этот гибрид производит наиболее богатый результат из наименьшего числа байт.

### Комбинирование L-систем с другими техниками

L-системы генерируют *последовательности* нот. Комбинируй с другими техниками из этого приложения:

- **Таблица гаммы** отображает символы L-системы в реальные периоды AY
- **Орнаменты** добавляют выразительность каждой ноте
- **Арпеджио** превращает каждую ноту L-системы в аккорд
- **Дрон на огибающей** обеспечивает устойчивую гармоническую подложку под фрактальной мелодией
- **Аккордовая прогрессия** меняет основной тон — мелодия L-системы транспонируется к каждому аккорду

Результат: крошечная программа (~60-80 байт музыкального кода + 20 байт данных), генерирующая минуты структурно связной, неповторяющейся, гармонически обоснованной музыки. Это алгоритмическая композиция, а не случайный шум — и она вмещается в size-coded интро.

### Другие грамматики для музыки

Помимо L-систем, другие формальные грамматики порождают интересные музыкальные последовательности:

**Клеточные автоматы.** Правило 30 или Правило 110, применённые к строке бит, порождают сложные паттерны. Отобрази позиции бит в события включения/выключения нот. Стоимость: ~15 байт на правило клеточного автомата, ~20 байт на пошаговый вычислитель.

**Евклидовы ритмы.** Распредели `k` ударов равномерно по `n` шагам. Этот алгоритм (связанный с евклидовым НОД) генерирует ритмические паттерны, встречающиеся в музыке по всему миру: 3-из-8 — это тресильо, 5-из-8 — синкильо, 7-из-12 — распространённый западноафриканский паттерн колокола. Реализация — ~20 байт, и она создаёт идеальные ритмические основы для любого движка AY-beat.

---

## См. также

- **Глава 11** — архитектура AY-3-8910, теория тона/шума/огибающей, техника buzz-bass
- **Глава 12** — интеграция музыкального движка, синхронизация с эффектами, гибридные цифровые барабаны
- **Глава 13** — техники sizecoding, место AY-beat в размерных категориях 256b/512b/1K/4K
- **Приложение G** — полный справочник регистров AY с побитовыми раскладками, адресами портов и таблицами нот

---

> **Источники:** Viznut (Ville-Matias Heikkila), "Algorithmic symphonies from one line of code -- how and why?" (2011); countercomplex.blogspot.com; Глава 13 этой книги; различные 256-байтные интро для ZX Spectrum с Pouet.net
