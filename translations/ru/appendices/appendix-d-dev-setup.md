# Приложение D: Настройка среды разработки

> *«Тебе нужно пять вещей: редактор, ассемблер, эмулятор, отладчик и Makefile. Всё остальное — опционально.»*
> -- Глава 1

Это приложение проведёт тебя через настройку полноценной среды разработки для Z80 с нуля. К концу ты сможешь компилировать все примеры на ассемблере из этой книги, запускать их в эмуляторе и отлаживать с помощью точек останова и просмотра регистров. Инструкции охватывают macOS, Linux и Windows.

Если ты уже выполнил настройку из Главы 1, большая часть у тебя уже на месте. Это приложение добавляет подробности, описывает альтернативные конфигурации и служит единым справочником, к которому можно вернуться при настройке новой машины.

---

## 1. Ассемблер: sjasmplus

Каждый пример кода в этой книге написан для **sjasmplus** — открытого макроассемблера Z80/Z80N от z00m128. Он поддерживает полный набор инструкций Z80, включая все индексные режимы IX/IY, макросы, Lua-скриптинг, множество выходных форматов и выражения, которые делают написание демосценового кода практичным.

### Установка из исходников

Самый надёжный способ получить sjasmplus — собрать его из исходников. Это гарантирует известную версию и избавляет от платформенных проблем с пакетными менеджерами.

```bash
git clone https://github.com/z00m128/sjasmplus.git
cd sjasmplus
make
```

На macOS тебе понадобятся инструменты командной строки Xcode (`xcode-select --install`). На Linux — `g++` и `make` (устанавливаются через пакетный менеджер). На Windows используй MinGW или WSL.

После сборки скопируй бинарный файл `sjasmplus` куда-нибудь в PATH:

```bash
# macOS / Linux
sudo cp sjasmplus /usr/local/bin/

# Verify
sjasmplus --version
```

Ты должен увидеть версию 1.20.x или новее. Эта книга разрабатывалась и тестировалась с v1.21.1.

### Привязка версии

Репозиторий книги закрепляет sjasmplus как git-подмодуль в `tools/sjasmplus/`. Если ты клонируешь репозиторий с `--recursive`, то получишь именно ту версию, которая использовалась для компиляции каждого примера:

```bash
git clone --recursive https://github.com/[repo]/antique-toy.git
cd antique-toy/tools/sjasmplus
make
```

Это самый безопасный подход. Поведение ассемблера может меняться между версиями — выражение, работающее в 1.21, может интерпретироваться иначе в 1.22.

### Ключевые флаги

| Флаг | Назначение | Пример |
|------|------------|--------|
| `--nologo` | Подавить стартовый баннер | `sjasmplus --nologo main.a80` |
| `--raw=FILE` | Вывести сырой бинарник (без заголовка) | `sjasmplus --raw=output.bin main.a80` |
| `--sym=FILE` | Записать файл символов (для отладчиков) | `sjasmplus --sym=output.sym main.a80` |
| `--fullpath` | Показывать полные пути файлов в сообщениях об ошибках | Полезно с problem matcher в VS Code |
| `--msg=war` | Подавить информационные сообщения, показывать только предупреждения и ошибки | Более чистый вывод сборки |
| `--syntax=abf` | Включить все синтаксические возможности (A как псевдоним аккумулятора, скобки для косвенной адресации, полный набор «фейковых» инструкций) | Рекомендуется для начинающих; позволяет писать `add a, b` наряду с `add b` |

Типичная команда сборки для примера из главы:

```bash
sjasmplus --nologo --raw=build/example.bin chapters/ch01-thinking-in-cycles/examples/timing.a80
```

### Расширение файла

Все файлы с исходным кодом Z80 в этой книге используют расширение `.a80`. Это соглашение, а не требование — sjasmplus не обращает внимания на расширения. Мы используем `.a80`, потому что это расширение распознаётся расширением Z80 Macro Assembler для VS Code и отличает наш исходный код от других диалектов ассемблера.

### Шестнадцатеричная запись

В книге для шестнадцатеричных значений используется запись `$FF`. sjasmplus также принимает `#FF` и `0FFh`, но `$FF` — стандарт для всей книги. Отдельный символ `$` обозначает текущий адрес счётчика команд и используется в конструкциях вроде `jr $` (бесконечный цикл) или `dw $ + 4`.

---

## 2. Редактор: VS Code

Подойдёт любой текстовый редактор. Мы рекомендуем **Visual Studio Code** благодаря расширениям для Z80 и встроенному терминалу. Весь рабочий процесс — редактирование, сборка, отладка — происходит в одном окне.

### Необходимые расширения

Установи их из магазина расширений VS Code (Ctrl+Shift+X):

| Расширение | Автор | Что делает |
|------------|-------|------------|
| **Z80 Macro Assembler** | mborik (`mborik.z80-macroasm`) | Подсветка синтаксиса, автодополнение, разрешение символов для Z80. Понимает синтаксис sjasmplus, включая макросы и локальные метки. |
| **Z80 Assembly Meter** | Nestor Sancho | Показывает количество байтов и стоимость в тактах выделенных инструкций в статусной строке. Выдели блок — мгновенно увидишь его общую стоимость. Незаменимо для подсчёта тактов. |
| **DeZog** | Maziac | Отладчик Z80. Подключается к эмуляторам или к собственному встроенному симулятору. Точки останова, наблюдение за регистрами, просмотр памяти. См. раздел 4. |

### Задача сборки

Настрой задачу сборки, чтобы Ctrl+Shift+B компилировал текущий файл. Создай `.vscode/tasks.json` в корне проекта:

```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Assemble Z80",
      "type": "shell",
      "command": "sjasmplus",
      "args": [
        "--fullpath",
        "--nologo",
        "--msg=war",
        "${file}"
      ],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "problemMatcher": {
        "owner": "z80",
        "fileLocation": "absolute",
        "pattern": {
          "regexp": "^(.*)\\((\\d+)\\):\\s+(error|warning)[^:]*:\\s+(.*)$",
          "file": 1,
          "line": 2,
          "severity": 3,
          "message": 4
        }
      }
    }
  ]
}
```

`problemMatcher` парсит вывод ошибок sjasmplus, так что при клике на ошибку в терминале курсор перейдёт на проблемную строку. Флаг `--fullpath` обеспечивает абсолютные пути файлов, которые нужны VS Code для корректного разрешения.

### Рекомендуемые настройки

Добавь эти настройки в `.vscode/settings.json` рабочего пространства для комфортного редактирования Z80:

```json
{
  "editor.tabSize": 8,
  "editor.insertSpaces": false,
  "editor.rulers": [80],
  "files.associations": {
    "*.a80": "z80-macroasm"
  }
}
```

Размер табуляции 8 с настоящими табами соответствует традиционному ассемблерному соглашению, при котором мнемоники и операнды выравниваются по фиксированным колонкам.

---

## 3. Эмуляторы

Тебе нужен эмулятор для запуска скомпилированного кода. Разные эмуляторы служат разным целям.

### ZEsarUX — полнофункциональная отладка

**ZEsarUX** от cerebellio — самый функциональный открытый эмулятор ZX Spectrum. Он поддерживает полный спектр моделей Spectrum (48K, 128K, +2, +3, Pentagon, Scorpion, ZX-Uno, ZX Spectrum Next), имеет встроенный отладчик и интегрируется с DeZog для отладки в VS Code.

**Установка:**

- macOS: `brew install zesarux`
- Linux: собери из исходников или используй AppImage с https://github.com/chernandezba/zesarux
- Windows: скачай установщик с сайта ZEsarUX

**Почему ZEsarUX для этой книги:** Большинство примеров в главах рассчитаны на ZX Spectrum 128K. ZEsarUX эмулирует переключение банков памяти 128K, звук AY, TurboSound (два чипа AY) и паттерны спорной памяти различных моделей. Его встроенный отладчик показывает регистры, память и дизассемблер без необходимости использовать VS Code. А интеграция с DeZog обеспечивает полноценную отладку в VS Code, когда это нужно.

**Быстрый запуск:**

```bash
# Run a .sna snapshot
zesarux --machine 128k --nosplash output.sna

# Run a .tap file
zesarux --machine 128k --nosplash output.tap
```

### Fuse — лёгкий и точный

**Fuse** (the Free Unix Spectrum Emulator) от Philip Kendall — лёгкий, потактово точный и доступный на всех платформах. Лучший выбор для быстрого тестирования, когда полноценный отладчик не нужен.

**Установка:**

- macOS: `brew install fuse-emulator`
- Linux: `apt install fuse-emulator-sdl` (Debian/Ubuntu) или `dnf install fuse-emulator` (Fedora)
- Windows: скачай с сайта Fuse

**Быстрый запуск:**

```bash
# Run with Pentagon timing (matches the book's T-state counts)
fuse --machine pentagon output.sna

# Run as 128K Spectrum
fuse --machine 128 output.tap
```

Fuse особенно хорош для тестирования кода, чувствительного ко времени, потому что его потактовая точность хорошо проверена. Если твоя тестовая обвязка для полос бордюра (Глава 1) показывает разные результаты в Fuse и другом эмуляторе — доверяй Fuse.

### Unreal Speccy — Windows, ориентация на Pentagon

Если ты разрабатываешь преимущественно под Windows и ориентируешься на тайминги Pentagon, **Unreal Speccy** — отличный выбор. У него встроенный отладчик с картой памяти, точками останова и мониторингом регистров AY. Он точно эмулирует аппаратуру Pentagon и Scorpion.

Скачай с http://dlcorp.nedopc.com/viewforum.php?f=27 или поищи «Unreal Speccy Portable».

### Для Agon Light 2

Agon Light 2 использует процессор eZ80 и другую аппаратную архитектуру. Глава 22 подробно описывает разработку для Agon. Для эмуляции **Fab Agon Emulator** обеспечивает программную симуляцию аппаратуры Agon (eZ80 + ESP32 VDP). Он доступен по адресу https://github.com/tomm/fab-agon-emulator и работает на macOS, Linux и Windows.

### Какой эмулятор выбрать?

| Ситуация | Рекомендуемый эмулятор |
|----------|----------------------|
| Повседневная разработка, запуск примеров | Fuse (быстрый запуск, точный) |
| Отладка с точками останова и наблюдением за регистрами | ZEsarUX + DeZog |
| Разработка музыки AY/TurboSound | ZEsarUX (лучшая эмуляция AY) |
| Проверка таймингов Pentagon | Fuse или Unreal Speccy |
| Разработка для Agon Light 2 | Fab Agon Emulator |
| Быстрая проверка на Windows | Unreal Speccy |

---

## 4. Отладчик: DeZog

**DeZog** от Maziac — расширение для VS Code, которое превращает редактор в отладчик Z80. Он подключается к ZEsarUX, CSpect или собственному встроенному симулятору Z80 и обеспечивает отладку, к которой привыкли современные разработчики: точки останова, пошаговое выполнение, наблюдение за регистрами, просмотр памяти, окно дизассемблера и стек вызовов.

Глава 23 рассматривает DeZog в контексте разработки с помощью ИИ. Этот раздел описывает практическую настройку.

### Установка

1. Открой VS Code.
2. Перейди в расширения (Ctrl+Shift+X).
3. Найди «DeZog» от Maziac.
4. Нажми «Install».

### Подключение к ZEsarUX

DeZog общается с ZEsarUX через сокетное соединение. Сначала запусти ZEsarUX с включённым сервером ZRCP (ZEsarUX Remote Control Protocol):

```bash
zesarux --machine 128k --enable-remoteprotocol --remoteprotocol-port 10000
```

Затем создай `.vscode/launch.json` в своём проекте:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "dezog",
      "request": "launch",
      "name": "DeZog + ZEsarUX",
      "remoteType": "zesarux",
      "zesarux": {
        "port": 10000
      },
      "sjasmplus": [
        {
          "path": "build/output.sld"
        }
      ],
      "topOfStack": "$FF00",
      "commandsAfterLaunch": [
        "-sprites disable",
        "-patterns disable"
      ]
    }
  ]
}
```

Секция `sjasmplus` указывает на файл `.sld` (Source Level Debug), который sjasmplus генерирует с флагом `--sld=FILE`. Это даёт DeZog отладку на уровне исходного кода — точки останова на строках исходника, а не только на адресах.

Чтобы сгенерировать файл `.sld`, добавь флаг в команду сборки:

```bash
sjasmplus --nologo --raw=build/output.bin --sld=build/output.sld --sym=build/output.sym main.a80
```

### Использование встроенного симулятора

Для быстрой отладки без запуска внешнего эмулятора DeZog включает встроенный симулятор Z80. Измени `launch.json` на:

```json
{
  "type": "dezog",
  "request": "launch",
  "name": "DeZog Internal Simulator",
  "remoteType": "zsim",
  "zsim": {
    "machine": "spectrum",
    "memoryModel": "ZX128K"
  },
  "sjasmplus": [
    {
      "path": "build/output.sld"
    }
  ],
  "topOfStack": "$FF00"
}
```

Встроенный симулятор запускается быстрее и не требует установки ZEsarUX. У него нет точной эмуляции спорной памяти, поэтому не используй его для отладки, критичной ко времени — но для логической отладки (правильно ли моя подпрограмма умножения выдаёт результат?) он идеален.

### Ключевые возможности DeZog

**Точки останова.** Кликни в поле рядом со строкой исходного кода, чтобы установить точку останова. Выполнение приостанавливается, когда счётчик команд Z80 достигает этого адреса. Также можно установить условные точки останова (например, остановка при `A == $FF`).

**Наблюдение за регистрами.** Панель переменных показывает все регистры Z80: AF, BC, DE, HL, IX, IY, SP, PC и альтернативный набор (AF', BC', DE', HL'). Отдельные флаги (C, Z, S, P/V, H, N) выведены отдельно для удобства чтения.

**Просмотр памяти.** Панель памяти показывает шестнадцатеричный дамп любого диапазона адресов. Можно ввести адрес и увидеть, что там находится. Незаменимо для проверки таблиц подстановки, содержимого экранной памяти и состояния стека.

**Окно дизассемблера.** Даже без отладки на уровне исходного кода DeZog дизассемблирует код вокруг текущего PC. Полезно для понимания того, как самомодифицирующийся код выглядит во время выполнения.

**Стек вызовов.** DeZog отслеживает пары CALL/RET и показывает стек вызовов. Это работает для обычного кода. Самомодифицирующийся код и RET-цепочки (Глава 3) собьют трекер стека — это ожидаемо.

---

## 5. Сборка примеров из книги

### Клонирование репозитория

```bash
git clone --recursive https://github.com/[repo]/antique-toy.git
cd antique-toy
```

Флаг `--recursive` подтягивает подмодуль sjasmplus из `tools/sjasmplus/`. Если ты уже клонировал без него:

```bash
git submodule update --init --recursive
```

### Предварительные требования

Тебе нужны `make` и компилятор C++ (для сборки sjasmplus из подмодуля). На большинстве систем они уже установлены:

- macOS: `xcode-select --install`
- Debian/Ubuntu: `sudo apt install build-essential`
- Fedora: `sudo dnf install make gcc-c++`
- Windows: используй WSL или установи MinGW и GNU Make

### Команды сборки

Makefile проекта делает всё. Весь скомпилированный вывод помещается в `build/`, который указан в gitignore.

| Команда | Что делает |
|---------|------------|
| `make` | Скомпилировать все примеры из глав с помощью sjasmplus |
| `make test` | Собрать все примеры, вывести результат (pass/fail) для каждого |
| `make ch01` | Скомпилировать только примеры Главы 1 |
| `make ch04` | Скомпилировать только примеры Главы 4 |
| `make demo` | Собрать сопутствующее демо «Antique Toy» |
| `make clean` | Удалить все артефакты сборки |

Успешный запуск `make test` выглядит так:

```
  OK  chapters/ch01-thinking-in-cycles/examples/timing.a80
  OK  chapters/ch04-maths/examples/multiply.a80
  OK  chapters/ch05-wireframe-3d/examples/cube.a80
  ...
---
12 passed, 0 failed
```

Если какой-либо пример не собирается, вывод покажет `FAIL` с именем файла. Запусти проблемный файл вручную через sjasmplus, чтобы увидеть подробную ошибку:

```bash
sjasmplus --nologo chapters/ch04-maths/examples/multiply.a80
```

### Запуск примера

После компиляции загрузи выходной бинарник в эмулятор. Конкретный способ зависит от формата вывода:

```bash
# If the example produces a .sna snapshot
fuse --machine pentagon build/ch01-thinking-in-cycles/examples/timing.sna

# If you built a raw binary, you need to create a .tap or .sna first,
# or load it at the correct address in the emulator's debugger
```

Большинство примеров из глав используют ORG `$8000` и производят сырые бинарники. Для их запуска либо:

1. Используй обёртку `.tap` (Makefile генерирует их, если исходный код содержит соответствующие директивы), либо
2. Загрузи бинарник по адресу `$8000` в отладчике эмулятора и установи PC на `$8000`.

---

## 6. Структура проекта для собственного кода

Когда ты начнёшь писать собственный код Z80 помимо примеров из книги, вот рекомендуемая структура каталогов:

```
my-demo/
  src/
    main.a80          -- entry point, includes other files
    effects/
      plasma.a80      -- individual effect routines
      scroller.a80
    data/
      font.a80        -- DB/DW data tables
      sintable.a80
    lib/
      multiply.a80    -- reusable utility routines
      draw_line.a80
  assets/
    title.scr         -- raw screen files
    music.pt3         -- tracker music
  build/              -- compiled output (gitignored)
  Makefile
  .vscode/
    tasks.json        -- build task
    launch.json       -- DeZog configuration
```

### Минимальный Makefile

```makefile
SJASMPLUS ?= sjasmplus
BUILD_DIR := build
SJASM_FLAGS := --nologo

.PHONY: all clean run

all: $(BUILD_DIR)/demo.bin

$(BUILD_DIR)/demo.bin: src/main.a80 src/effects/*.a80 src/data/*.a80 src/lib/*.a80
	@mkdir -p $(BUILD_DIR)
	$(SJASMPLUS) $(SJASM_FLAGS) --raw=$@ --sym=$(BUILD_DIR)/demo.sym --sld=$(BUILD_DIR)/demo.sld $<

run: $(BUILD_DIR)/demo.bin
	fuse --machine 128 $(BUILD_DIR)/demo.sna

clean:
	rm -rf $(BUILD_DIR)
```

Ключевые моменты:

- Главный файл исходного кода использует директивы `INCLUDE` для подключения других файлов. sjasmplus разрешает пути включений относительно каталога исходного файла.
- Флаг `--sym` генерирует файл символов для справки. Флаг `--sld` генерирует данные отладки на уровне исходного кода для DeZog.
- Перечисли все включаемые файлы как зависимости, чтобы `make` перекомпилировал при изменении любого файла.

### Соглашение об включениях

В твоём `main.a80`:

```z80
    ORG $8000

    ; --- Entry point ---
start:
    di
    ; set up stack, interrupts, etc.
    ld   sp, $FF00
    ; ...

    include "lib/multiply.a80"
    include "effects/plasma.a80"
    include "data/sintable.a80"
```

sjasmplus обрабатывает файлы `INCLUDE` встраиванием, как если бы текст был вставлен в этой точке. Организуй включения по порядку: сначала библиотечные подпрограммы, затем эффекты, затем данные (поскольку данные обычно размещаются в конце бинарника).

---

## 7. Альтернативные инструменты

В этой книге используется sjasmplus, потому что это самый функциональный ассемблер Z80 для демосцены и разработки игр. Но в сообществе ты можешь встретить и другие инструменты.

### Другие ассемблеры

| Ассемблер | Примечания |
|-----------|------------|
| **z80asm** | Часть кросс-компиляторного набора z88dk для C. Хорош, если ты смешиваешь C и ассемблер. Другие синтаксические соглашения. |
| **RASM** | От Roudoudou. Быстрый, поддерживает CPC и Spectrum. Популярен в сцене Amstrad CPC. |
| **pasmo** | Простой, переносимый, ограниченная функциональность. Подходит для маленьких автономных программ, но лишён макросов и продвинутых возможностей, необходимых для крупных проектов. |

Примеры из книги используют специфичные для sjasmplus возможности (локальные метки с `.`, отрицательные значения DB, шестнадцатеричный префикс `$`), которые могут не работать без изменений в других ассемблерах. Если ты хочешь портировать пример на другой ассемблер, изменения обычно минимальны: синтаксис меток, шестнадцатеричная нотация и имена директив.

### Другие расширения VS Code

| Расширение | Примечания |
|------------|------------|
| **SjASMPlus Syntax** | Альтернативная подсветка синтаксиса, настроенная специально для sjasmplus. Попробуй, если `z80-macroasm` неправильно подсвечивает какую-либо специфичную для sjasmplus возможность. |
| **Z80 Debugger** (Spectron) | Более старый отладчик Z80 для VS Code. DeZog в основном его заменил. |

### CSpect — эмулятор для Next

Если у тебя есть ZX Spectrum Next или ты ориентируешься на специфичные для Next возможности (copper, layer 2, DMA, турборежим 28 МГц), **CSpect** от Mike Dailly — эталонный эмулятор. DeZog подключается к CSpect так же, как к ZEsarUX. CSpect работает только под Windows, но запускается через Wine на macOS и Linux.

### SpectrumAnalyzer

Браузерный инструмент, визуализирующий раскладку экранной памяти ZX Spectrum, конфликты атрибутов и тайминги. Полезен для понимания обсуждения чересстрочной раскладки экрана в Главе 2. Доступен по адресу https://shiru.untergrund.net/spectrumanalyzer.html (или поищи «ZX Spectrum screen analyzer»).

---

## 8. Устранение неполадок

### «sjasmplus: command not found»

Бинарный файл отсутствует в PATH. Либо скопируй его в `/usr/local/bin/` (macOS/Linux), либо добавь его каталог в PATH, либо задай переменную `SJASMPLUS` при запуске make:

```bash
make SJASMPLUS=/path/to/sjasmplus
```

### Ошибки компиляции в примерах из книги

Во-первых, убедись, что ты используешь версию sjasmplus из подмодуля (`tools/sjasmplus/`). Более новые или старые версии могут вести себя иначе. Во-вторых, проверь, что ты ассемблируешь файл из правильного каталога — sjasmplus разрешает пути `INCLUDE` относительно исходного файла, а не рабочего каталога.

### DeZog не может подключиться к ZEsarUX

1. Убедись, что ZEsarUX запущен с `--enable-remoteprotocol`.
2. Проверь, что номер порта в `launch.json` совпадает с аргументом `--remoteprotocol-port`.
3. На macOS может потребоваться разрешить ZEsarUX через файрвол (Системные настройки > Конфиденциальность и безопасность).
4. Попробуй перезапустить ZEsarUX перед запуском сессии DeZog.

### Эмулятор показывает мусор на экране

Если ты загрузил сырой бинарник и видишь мусор, наиболее вероятная причина — неправильный адрес загрузки. Примеры из книги используют ORG `$8000`. Убедись, что эмулятор загружает бинарник именно по этому адресу, а не по `$0000` или другому адресу по умолчанию. Использование вывода в формате `.sna` или `.tap` (который содержит информацию об адресе) устраняет эту проблему.

### Выходной файл сборки пуст или нулевого размера

Проверь, что в исходном файле есть директива `ORG` и хотя бы одна инструкция. sjasmplus с `--raw=` создаёт бинарник от первого выданного байта до последнего. Если ничего не выдано (например, файл содержит только `ORG $8000` без кода), выходной файл будет пуст.

---

## Справочник инструментов

| Инструмент | Назначение | Официальный URL | Упоминание в книге |
|------------|------------|----------------|-------------------|
| **sjasmplus** | Макроассемблер Z80/Z80N | https://github.com/z00m128/sjasmplus | Глава 1, все примеры |
| **VS Code** | Редактор и IDE | https://code.visualstudio.com | Глава 1 |
| **Z80 Macro Assembler** | Расширение VS Code для синтаксиса | Marketplace: `mborik.z80-macroasm` | Глава 1 |
| **Z80 Assembly Meter** | Отображение подсчёта тактов | Marketplace: Nestor Sancho | Глава 1 |
| **DeZog** | Отладчик Z80 для VS Code | Marketplace: Maziac / https://github.com/maziac/DeZog | Глава 23 |
| **ZEsarUX** | Полнофункциональный эмулятор Spectrum | https://github.com/chernandezba/zesarux | Глава 1, Глава 23 |
| **Fuse** | Лёгкий эмулятор Spectrum | https://fuse-emulator.sourceforge.net | Глава 1 |
| **Unreal Speccy** | Эмулятор с фокусом на Pentagon | http://dlcorp.nedopc.com | Глава 1 |
| **CSpect** | Эмулятор ZX Spectrum Next | https://dailly.blogspot.com | Глава 22 (возможности Next) |
| **Fab Agon Emulator** | Эмулятор Agon Light 2 | https://github.com/tomm/fab-agon-emulator | Глава 22 |
| **ZX0** | Оптимальный LZ-компрессор | https://github.com/einar-saukas/ZX0 | Глава 14, Приложение C |
| **Exomizer** | Компрессор с лучшей степенью сжатия | https://github.com/bitmanipulators/exomizer | Глава 14, Приложение C |
| **Vortex Tracker II** | Трекер музыки для AY | https://github.com/ivanpirog/vortextracker | Глава 11 |

---

## См. также

- **Глава 1:** Первый практикум — настройка VS Code, sjasmplus и тестовой обвязки.
- **Глава 22:** Настройка платформы Agon Light 2, тулчейн eZ80, Fab Agon Emulator.
- **Глава 23:** Интеграция DeZog с рабочими процессами с помощью ИИ.
- **Приложение A:** Справочник инструкций Z80 — инструкции, которые ты будешь отлаживать.
- **Приложение G:** Справочник регистров AY — пригодится при отладке звукового кода в ZEsarUX.
