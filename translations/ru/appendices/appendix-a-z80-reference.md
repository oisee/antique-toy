# Приложение A: Краткий справочник инструкций Z80

> *«Инструкция, которая должна занимать 7 тактов (T-state), может занять 13, если попадёт на худшую фазу цикла конкуренции.»*
> -- Глава 1

Это не полное руководство по Z80. Это справочная карточка для кодеров демосцены и программистов игр на ZX Spectrum и Agon Light 2 -- инструкции, которые ты действительно используешь, тайминги, которые нужно знать наизусть, и паттерны, сберегающие такты (T-state) во внутренних циклах.

Все значения тактов (T-state) указаны для **таймингов Pentagon** (без конкуренции). Размер в байтах -- длина кодировки инструкции. Столбцы флагов: **S** (знак), **Z** (нуль), **H** (полуперенос), **P/V** (чётность/переполнение), **N** (вычитание), **C** (перенос). Прочерк означает без изменений; точка означает не определено.

---

## 8-битные инструкции загрузки

| Инструкция | Байты | Такты (T-state) | Флаги | Примечания |
|-------------|-------|----------|-------|-------|
| `LD r,r'` | 1 | 4 | ------ | Самая быстрая инструкция. r,r' = A,B,C,D,E,H,L |
| `LD r,n` | 2 | 7 | ------ | Непосредственная загрузка |
| `LD r,(HL)` | 1 | 7 | ------ | Чтение памяти через HL |
| `LD (HL),r` | 1 | 7 | ------ | Запись в память через HL |
| `LD (HL),n` | 2 | 10 | ------ | Непосредственное значение в память |
| `LD A,(BC)` | 1 | 7 | ------ | |
| `LD A,(DE)` | 1 | 7 | ------ | |
| `LD (BC),A` | 1 | 7 | ------ | |
| `LD (DE),A` | 1 | 7 | ------ | |
| `LD A,(nn)` | 3 | 13 | ------ | Абсолютный адрес |
| `LD (nn),A` | 3 | 13 | ------ | Абсолютный адрес |
| `LD r,(IX+d)` | 3 | 19 | ------ | Индексная. Дорогая -- избегай во внутренних циклах |
| `LD (IX+d),r` | 3 | 19 | ------ | Индексная |
| `LD (IX+d),n` | 4 | 23 | ------ | Индексная непосредственная |
| `LD A,I` | 2 | 9 | SZ0P0- | P/V = IFF2 |
| `LD A,R` | 2 | 9 | SZ0P0- | P/V = IFF2; R = счётчик регенерации |

---

## 16-битные инструкции загрузки

| Инструкция | Байты | Такты (T-state) | Флаги | Примечания |
|-------------|-------|----------|-------|-------|
| `LD rr,nn` | 3 | 10 | ------ | rr = BC, DE, HL, SP |
| `LD HL,(nn)` | 3 | 16 | ------ | |
| `LD (nn),HL` | 3 | 16 | ------ | |
| `LD rr,(nn)` | 4 | 20 | ------ | rr = BC, DE, SP (префикс ED) |
| `LD (nn),rr` | 4 | 20 | ------ | rr = BC, DE, SP (префикс ED) |
| `LD SP,HL` | 1 | 6 | ------ | Установка указателя стека |
| `LD SP,IX` | 2 | 10 | ------ | |
| `PUSH rr` | 1 | 11 | ------ | rr = AF, BC, DE, HL. **5,5T на байт** |
| `POP rr` | 1 | 10 | ------ | **5T на байт** -- самое быстрое чтение 2 байт |
| `PUSH IX` | 2 | 15 | ------ | |
| `POP IX` | 2 | 14 | ------ | |

---

## 8-битная арифметика и логика

| Инструкция | Байты | Такты (T-state) | Флаги | Примечания |
|-------------|-------|----------|-------|-------|
| `ADD A,r` | 1 | 4 | SZ.V0C | |
| `ADD A,n` | 2 | 7 | SZ.V0C | |
| `ADD A,(HL)` | 1 | 7 | SZ.V0C | |
| `ADC A,r` | 1 | 4 | SZ.V0C | Сложение с переносом |
| `ADC A,n` | 2 | 7 | SZ.V0C | |
| `SUB r` | 1 | 4 | SZ.V1C | |
| `SUB n` | 2 | 7 | SZ.V1C | |
| `SUB (HL)` | 1 | 7 | SZ.V1C | |
| `SBC A,r` | 1 | 4 | SZ.V1C | Вычитание с переносом |
| `CP r` | 1 | 4 | SZ.V1C | Сравнение (SUB без сохранения результата) |
| `CP n` | 2 | 7 | SZ.V1C | |
| `CP (HL)` | 1 | 7 | SZ.V1C | |
| `AND r` | 1 | 4 | SZ1P00 | H всегда установлен, C всегда сброшен |
| `AND n` | 2 | 7 | SZ1P00 | |
| `OR r` | 1 | 4 | SZ0P00 | Сбрасывает H и C |
| `OR n` | 2 | 7 | SZ0P00 | |
| `XOR r` | 1 | 4 | SZ0P00 | `XOR A` = обнуление A за 4T/1B (против `LD A,0` = 7T/2B) |
| `XOR n` | 2 | 7 | SZ0P00 | |
| `INC r` | 1 | 4 | SZ.V0- | **Не** влияет на перенос |
| `DEC r` | 1 | 4 | SZ.V1- | **Не** влияет на перенос |
| `INC (HL)` | 1 | 11 | SZ.V0- | Чтение-модификация-запись |
| `DEC (HL)` | 1 | 11 | SZ.V1- | Чтение-модификация-запись |
| `NEG` | 2 | 8 | SZ.V1C | A = 0 - A (дополнительный код, отрицание) |
| `DAA` | 1 | 4 | SZ.P-C | Коррекция BCD -- редко используется в демо |
| `CPL` | 1 | 4 | --1-1- | A = NOT A (обратный код) |
| `SCF` | 1 | 4 | --0-00 | Установить флаг переноса. N,H сброшены. Новое поведение на CMOS |
| `CCF` | 1 | 4 | --.-0. | Инвертировать перенос. H = старый C |

---

## 16-битная арифметика

| Инструкция | Байты | Такты (T-state) | Флаги | Примечания |
|-------------|-------|----------|-------|-------|
| `ADD HL,rr` | 1 | 11 | --.?0C | rr = BC, DE, HL, SP. Влияет только на H, N, C |
| `ADC HL,rr` | 2 | 15 | SZ.V0C | Полный набор флагов |
| `SBC HL,rr` | 2 | 15 | SZ.V1C | Полный набор флагов |
| `INC rr` | 1 | 6 | ------ | Флаги не затрагиваются |
| `DEC rr` | 1 | 6 | ------ | Флаги не затрагиваются |
| `ADD IX,rr` | 2 | 15 | --.?0C | rr = BC, DE, IX, SP |

**Ключевой момент:** `INC rr` и `DEC rr` **не** устанавливают флаг нуля. Нельзя использовать `DEC BC / JR NZ` как 16-битный счётчик цикла. Используй `DEC B / JR NZ` для 8-битных циклов с `DJNZ`, или проверяй BC явно.

---

## Сдвиги и вращения

| Инструкция | Байты | Такты (T-state) | Флаги | Примечания |
|-------------|-------|----------|-------|-------|
| `RLCA` | 1 | 4 | --0-0C | Вращение A влево, бит 7 в перенос и бит 0 |
| `RRCA` | 1 | 4 | --0-0C | Вращение A вправо, бит 0 в перенос и бит 7 |
| `RLA` | 1 | 4 | --0-0C | Вращение A влево через перенос |
| `RRA` | 1 | 4 | --0-0C | Вращение A вправо через перенос. **Ключевая для циклов умножения** |
| `RLC r` | 2 | 8 | SZ0P0C | CB-префикс. Полный набор флагов |
| `RRC r` | 2 | 8 | SZ0P0C | |
| `RL r` | 2 | 8 | SZ0P0C | Вращение влево через перенос |
| `RR r` | 2 | 8 | SZ0P0C | Вращение вправо через перенос |
| `SLA r` | 2 | 8 | SZ0P0C | Арифметический сдвиг влево. Бит 0 = 0 |
| `SRA r` | 2 | 8 | SZ0P0C | Арифметический сдвиг вправо. Бит 7 сохранён (расширение знака) |
| `SRL r` | 2 | 8 | SZ0P0C | Логический сдвиг вправо. Бит 7 = 0 |
| `RLC (HL)` | 2 | 15 | SZ0P0C | Чтение-модификация-запись |
| `RL (HL)` | 2 | 15 | SZ0P0C | Прокрутка пиксельных данных влево |
| `RR (HL)` | 2 | 15 | SZ0P0C | Прокрутка пиксельных данных вправо |
| `SLA (HL)` | 2 | 15 | SZ0P0C | |
| `SRL (HL)` | 2 | 15 | SZ0P0C | |
| `RLD` | 2 | 18 | SZ0P0- | Вращение полубайтов (HL) влево через A. Полезно для нибблевой графики |
| `RRD` | 2 | 18 | SZ0P0- | Вращение полубайтов (HL) вправо через A |

**Заметка для демосцены:** `RLA`/`RRA` (4T, 1 байт) влияют только на перенос и биты 3,5 регистра F. CB-префиксные версии `RL r`/`RR r` (8T, 2 байта) устанавливают все флаги. В циклах умножения версии с аккумулятором экономят половину стоимости.

---

## Битовые операции

| Инструкция | Байты | Такты (T-state) | Флаги | Примечания |
|-------------|-------|----------|-------|-------|
| `BIT b,r` | 2 | 8 | .Z1.0- | Проверка бита b регистра |
| `BIT b,(HL)` | 2 | 12 | .Z1.0- | Проверка бита b памяти |
| `SET b,r` | 2 | 8 | ------ | Установить бит b регистра |
| `SET b,(HL)` | 2 | 15 | ------ | Установить бит b памяти. **Используется при рисовании линий** |
| `RES b,r` | 2 | 8 | ------ | Сбросить бит b регистра |
| `RES b,(HL)` | 2 | 15 | ------ | Сбросить бит b памяти |

---

## Переходы, вызовы, возврат

| Инструкция | Байты | Такты (T-state) | Флаги | Примечания |
|-------------|-------|----------|-------|-------|
| `JP nn` | 3 | 10 | ------ | Абсолютный переход |
| `JP cc,nn` | 3 | 10 | ------ | Условный: NZ, Z, NC, C, PO, PE, P, M. **Одинаковая скорость при выполнении и невыполнении** |
| `JR e` | 2 | 12 | ------ | Относительный переход (-128 до +127) |
| `JR cc,e` | 2 | 12/7 | ------ | cc = только NZ, Z, NC, C. **7T при невыполнении** |
| `JP (HL)` | 1 | 4 | ------ | Переход по адресу в HL. Самый быстрый косвенный переход |
| `JP (IX)` | 2 | 8 | ------ | Переход по адресу в IX |
| `DJNZ e` | 2 | 13/8 | ------ | Dec B, переход если NZ. **13T при выполнении, 8T при невыполнении** |
| `CALL nn` | 3 | 17 | ------ | Сохранить PC, перейти к nn |
| `CALL cc,nn` | 3 | 17/10 | ------ | 10T при невыполнении |
| `RET` | 1 | 10 | ------ | Извлечь PC. **Используется для RET-цепочки диспетчеризации** |
| `RET cc` | 1 | 11/5 | ------ | 5T при невыполнении |
| `RST p` | 1 | 11 | ------ | Вызов по адресу $00,$08,$10,$18,$20,$28,$30,$38 |

**Ключевые сравнения для диспетчеризации:**

| Метод | Такты (T-state) | Байты |
|--------|----------|-------|
| `CALL nn` | 17 | 3 |
| `RET` (как диспетчер в RET-цепочке) | 10 | 1 |
| `JP (HL)` | 4 | 1 |
| `JP nn` | 10 | 3 |

---

## Инструкции ввода/вывода

| Инструкция | Байты | Такты (T-state) | Флаги | Примечания |
|-------------|-------|----------|-------|-------|
| `OUT (n),A` | 2 | 11 | ------ | Адрес порта = `(A << 8) | n`. Бордюр: `OUT ($FE),A` |
| `IN A,(n)` | 2 | 11 | ------ | Адрес порта = `(A << 8) | n`. Клавиатура: `IN A,($FE)` |
| `OUT (C),r` | 2 | 12 | ------ | Адрес порта = BC. **Запись в регистр AY** |
| `IN r,(C)` | 2 | 12 | SZ0P0- | Адрес порта = BC. Устанавливает флаги |
| `OUTI` | 2 | 16 | .Z..1. | Out (HL) в порт (C), inc HL, dec B |
| `OTIR` | 2 | 21/16 | 01..1. | Повторять OUTI пока B=0. 16T на последнем |
| `OUTD` | 2 | 16 | .Z..1. | Out (HL) в порт (C), inc HL, dec B |

**Адреса портов AY-3-8910 на ZX Spectrum 128K:**

| Порт | Адрес | Назначение |
|------|---------|---------|
| Выбор регистра | `$FFFD` | `LD BC,$FFFD : OUT (C),A` |
| Запись данных | `$BFFD` | `LD B,$BF : OUT (C),r` |
| Чтение данных | `$FFFD` | `IN A,(C)` |

Типичная последовательность записи в регистр AY (24T + накладные расходы):

```z80
    ld   bc, $FFFD      ; 10T  AY register select port
    out  (c), a          ; 12T  select register number (in A)
    ld   b, $BF          ;  7T  switch to data port $BFFD
    out  (c), e          ; 12T  write value (in E)
                         ; --- 41T total
```

---

## Блочные инструкции

| Инструкция | Байты | Такты (T-state) | Флаги | Примечания |
|-------------|-------|----------|-------|-------|
| `LDI` | 2 | 16 | --0.0- | (DE) = (HL), inc HL, inc DE, dec BC. P/V = (BC != 0) |
| `LDIR` | 2 | 21/16 | --000- | Повторять LDI. 21T на байт, 16T последний байт |
| `LDD` | 2 | 16 | --0.0- | (DE) = (HL), dec HL, dec DE, dec BC |
| `LDDR` | 2 | 21/16 | --000- | Повторять LDD. 21T на байт, 16T последний байт |
| `CPI` | 2 | 16 | SZ.?1- | Сравнить A с (HL), inc HL, dec BC |
| `CPIR` | 2 | 21/16 | SZ.?1- | Повторять CPI. Останавливается при совпадении или BC=0 |
| `CPD` | 2 | 16 | SZ.?1- | Сравнить A с (HL), dec HL, dec BC |
| `CPDR` | 2 | 21/16 | SZ.?1- | Повторять CPD |

**Стоимость LDI vs LDIR на байт:**

| Метод | На байт | 256 байт | 32 байта | Экономия |
|--------|----------|-----------|----------|---------|
| LDIR | 21T (16T последний) | 5 371T | 672T | -- |
| LDI-цепочка | 16T | 4 096T | 512T | На 24% быстрее |

Развёрнутая LDI-цепочка стоит 2 байта на каждую LDI (`$ED $A0`), но экономит 5T на байт -- на 24% быстрее, чем LDIR. Подробнее в главе 3 об арифметике точки входа для LDI-цепочек.

---

## Обмен и разное

| Инструкция | Байты | Такты (T-state) | Флаги | Примечания |
|-------------|-------|----------|-------|-------|
| `EX DE,HL` | 1 | 4 | ------ | Обмен DE и HL. **Бесплатный обмен указателей** |
| `EX AF,AF'` | 1 | 4 | ------ | Обмен AF с теневым AF' |
| `EXX` | 1 | 4 | ------ | Обмен BC,DE,HL с BC',DE',HL'. **6 регистров за 4T** |
| `EX (SP),HL` | 1 | 19 | ------ | Обмен HL с вершиной стека. Полезно для передачи параметров |
| `EX (SP),IX` | 2 | 23 | ------ | Обмен IX с вершиной стека |
| `DI` | 1 | 4 | ------ | Запретить прерывания. **Обязательно перед трюками со стеком** |
| `EI` | 1 | 4 | ------ | Разрешить прерывания. Отложено на одну инструкцию |
| `HALT` | 1 | 4+ | ------ | Ожидание прерывания. Инструкция синхронизации кадра |
| `NOP` | 1 | 4 | ------ | Заполнение, выравнивание таймингов |
| `IM 1` | 2 | 8 | ------ | Режим прерываний 1 (RST $38). Стандартный режим Spectrum |
| `IM 2` | 2 | 8 | ------ | Режим прерываний 2. Использует регистр I как старший байт таблицы векторов |

---

## «Быстрые» инструкции демосцены

Это самые дешёвые инструкции в каждой категории -- строительные блоки каждого оптимизированного внутреннего цикла.

### Самый быстрый межрегистровый перенос

`LD r,r'` -- **4T, 1 байт**. Минимальная стоимость любой инструкции Z80. Включает `LD A,A` (фактически NOP, не влияющий на флаги).

### Самый быстрый способ обнулить регистр

`XOR A` -- **4T, 1 байт**. Устанавливает A в ноль, устанавливает флаг Z, сбрасывает перенос. Сравни с `LD A,0` при 7T/2 байта. Всегда используй `XOR A`, если не нужно сохранить флаги.

### Самое быстрое чтение из памяти

`LD A,(HL)` -- **7T, 1 байт**. Минимальная стоимость любого чтения из памяти. Другие источники-указатели (`LD A,(BC)`, `LD A,(DE)`) тоже 7T/1 байт, но HL -- единственный указатель, поддерживающий `LD r,(HL)` для всех регистров.

### Самая быстрая запись в память

`LD (HL),r` -- **7T, 1 байт**. Наравне с чтением. Запись по указателям BC или DE (`LD (BC),A`, `LD (DE),A`) тоже 7T/1B, но работает только с A.

### Самая быстрая запись 2 байт

`PUSH rr` -- **11T, 1 байт** на 2 байта = **5,5T на байт**. Самый быстрый способ записи данных в память, но только туда, куда указывает SP (вниз). Требует DI и перехвата указателя стека. Подробнее в главе 3.

### Самое быстрое чтение 2 байт

`POP rr` -- **10T, 1 байт** на 2 байта = **5T на байт**. Даже быстрее, чем PUSH для чтения. Используй с SP, указывающим на таблицу данных, для сверхбыстрого поиска.

### Самое быстрое блочное копирование

| Метод | На байт | Примечания |
|--------|----------|-------|
| Пара `PUSH/POP` | 5,25T | Запись: 5,5T, Чтение: 5T. Но нужен перехват SP |
| `LDI` (развёрнутая цепочка) | 16T | Без настройки на каждый байт. На 24% быстрее LDIR |
| `LDIR` | 21T | Одна инструкция, но медленная на байт |
| `LD (HL),r` + `INC HL` | 13T | Тело ручного цикла (без счётчика) |
| `LD (HL),r` + `INC L` | 11T | Работает только в пределах 256-байтной страницы |

### Самый быстрый ввод/вывод

`OUT (n),A` -- **11T, 2 байта**. Для фиксированных адресов портов (бордюр и т.д.). Для переменных портов (AY) `OUT (C),r` при 12T/2 байта -- единственный вариант.

### Самый быстрый обмен указателей

`EX DE,HL` -- **4T, 1 байт**. Мгновенный обмен содержимого DE и HL. Никакой другой обмен регистров не стоит так дёшево. `EXX` тоже 4T/1 байт, но меняет все три пары одновременно.

### Самый быстрый условный цикл

`DJNZ e` -- **13T при выполнении, 8T при невыполнении, 2 байта**. Декрементирует B и переходит. Сравни с `DEC B / JR NZ,e` при 4+12 = 16T/3 байта. DJNZ экономит 3T и 1 байт за итерацию.

### Самый быстрый косвенный переход

`JP (HL)` -- **4T, 1 байт**. Переход по адресу в HL. Несмотря на вводящую в заблуждение мнемонику, эта инструкция НЕ читает из памяти по (HL) -- она загружает в PC значение HL. Незаменима для таблиц переходов и вычисляемых goto.

---

## Недокументированные инструкции

Эти инструкции отсутствуют в официальной документации Zilog, но надёжно работают на всех кристаллах Z80 (NMOS и CMOS), всех клонах ZX Spectrum и на eZ80. Они широко используются в коде демосцены и поддерживаются sjasmplus.

### IXH, IXL, IYH, IYL (полурегистры индексных регистров)

Регистры IX и IY можно разделить на 8-битные половины, обращаясь к ним через DD/FD-префикс к обычным инструкциям H/L:

| Инструкция | Байты | Такты (T-state) | Примечания |
|-------------|-------|----------|-------|
| `LD A,IXH` | 2 | 8 | Чтение старшего байта IX |
| `LD A,IXL` | 2 | 8 | Чтение младшего байта IX |
| `LD IXH,A` | 2 | 8 | Запись старшего байта IX |
| `LD IXL,n` | 3 | 11 | Непосредственное значение в младший байт IX |
| `ADD A,IXL` | 2 | 8 | Арифметика с половинами IX |
| `INC IXH` | 2 | 8 | Инкремент старшего байта IX |
| `DEC IXL` | 2 | 8 | Декремент младшего байта IX |

**Применение в демосцене:** Два дополнительных 8-битных регистра для счётчиков, аккумуляторов или малых значений, не затрагивая основной регистровый файл. Особенно полезно, когда BC/DE/HL все заняты как указатели. Стоимость: на 4T больше, чем эквивалентная операция с основным регистром.

Синтаксис sjasmplus: `IXH`, `IXL`, `IYH`, `IYL` (также принимает `HX`, `LX`, `HY`, `LY`).

### SLL r (логический сдвиг влево)

| Инструкция | Байты | Такты (T-state) | Примечания |
|-------------|-------|----------|-------|
| `SLL r` | 2 | 8 | Сдвиг влево, бит 0 устанавливается в 1 (а не в 0) |
| `SLL (HL)` | 2 | 15 | То же для памяти |

`SLL` сдвигает влево и устанавливает бит 0 в 1 (в отличие от `SLA`, которая устанавливает бит 0 в 0). Опкод: CB 30+r. Иногда полезна для построения битовых паттернов.

Синтаксис sjasmplus: `SLL` или `SLI` или `SL1`.

### OUT (C),0

| Инструкция | Байты | Такты (T-state) | Примечания |
|-------------|-------|----------|-------|
| `OUT (C),0` | 2 | 12 | Вывод нуля в порт BC |

Опкод `ED 71`. Выводит ноль в порт, адресуемый BC. На CMOS Z80 (включая eZ80) вместо этого выводит $FF. **Не портируется на Agon Light 2.** На NMOS Z80 (все настоящие Спектрумы) надёжно выводит $00.

Синтаксис sjasmplus: `OUT (C),0`.

### Недокументированные битовые операции с CB-префиксом над (IX+d)

Инструкции вида `SET b,(IX+d),r` одновременно выполняют битовую операцию над памятью по (IX+d) и копируют результат в регистр r. Это 4-байтные инструкции (DD CB dd op), занимающие 23T. Иногда полезны, но редко критически важны.

---

## Шпаргалка по влиянию на флаги

Знание того, какие инструкции устанавливают какие флаги, позволяет избежать избыточных `CP` или `AND A` -- типичного источника потерянных тактов (T-state).

### Инструкции, устанавливающие все арифметические флаги (S, Z, H, P/V, N, C)

- `ADD A,r/n/(HL)` -- P/V = переполнение
- `ADC A,r/n/(HL)` -- P/V = переполнение
- `SUB r/n/(HL)` -- P/V = переполнение
- `SBC A,r/n/(HL)` -- P/V = переполнение
- `CP r/n/(HL)` -- Те же флаги, что у SUB, но A не изменяется
- `NEG` -- P/V = переполнение
- `ADC HL,rr` -- P/V = переполнение
- `SBC HL,rr` -- P/V = переполнение

### Инструкции, устанавливающие Z и S (но НЕ перенос)

- `INC r` / `DEC r` -- C без изменений. **Нельзя проверять перенос после INC/DEC.**
- `INC (HL)` / `DEC (HL)` -- То же
- `AND r/n/(HL)` -- C всегда 0, H всегда 1
- `OR r/n/(HL)` -- C всегда 0, H всегда 0
- `XOR r/n/(HL)` -- C всегда 0, H всегда 0
- `IN r,(C)` -- C без изменений
- `BIT b,r/(HL)` -- Z = инверсия проверяемого бита, C без изменений
- Все сдвиги/вращения с CB-префиксом -- Полный набор флагов, включая C

### Инструкции, устанавливающие ТОЛЬКО флаги, связанные с переносом

- `ADD HL,rr` -- Только H и C (S, Z, P/V без изменений)
- `RLCA` / `RRCA` / `RLA` / `RRA` -- Только C, H=0, N=0 (S, Z, P/V без изменений)
- `SCF` -- C=1, H=0, N=0
- `CCF` -- C инвертирован, H = старый C, N=0

### Инструкции, НЕ устанавливающие флаги

- `LD` (все варианты)
- `INC rr` / `DEC rr` (16-битные inc/dec)
- `PUSH` / `POP` (кроме POP AF, восстанавливающей флаги)
- `EX` / `EXX`
- `DI` / `EI` / `HALT` / `NOP`
- `JP` / `JR` / `DJNZ` / `CALL` / `RET` / `RST`
- `OUT (n),A` / `IN A,(n)` (версии без CB)

### Практические трюки

**Проверка A на ноль без CP 0:**

```z80
    or   a              ; 4T  sets Z if A=0, clears C
    and  a              ; 4T  same effect, but also sets H
```

**Проверка переноса после 16-битного INC/DEC:** Невозможно. `INC rr`/`DEC rr` не устанавливают флаги. Чтобы проверить, достиг ли 16-битный регистр нуля:

```z80
    ld   a, b           ; 4T
    or   c              ; 4T  Z set if BC = 0
```

**Пропуск CP после SUB:** Если ты уже выполнил `SUB r`, флаги установлены -- не добавляй после него `CP` или `OR A`.

**INC/DEC сохраняют перенос:** Используй `INC r`/`DEC r` между операциями многобайтной арифметики, не разрушая цепочку переноса.

---

## Архитектура регистров

### Основной набор регистров

```
  A   F          Accumulator + Flags
  B   C          Counter (B for DJNZ) + general
  D   E          General purpose pair
  H   L          Primary memory pointer (HL is the "accumulator pair")
```

### Специальные регистры

```
  SP             Stack pointer (16-bit)
  PC             Program counter (16-bit)
  IX             Index register (16-bit, DD prefix, +4T penalty)
  IY             Index register (16-bit, FD prefix, +4T penalty)
                 NOTE: IY is used by the Spectrum ROM interrupt handler.
                 Do not use IY unless you have DI or IM2 set up.
  I              Interrupt vector page (used in IM2)
  R              Refresh counter (7-bit, increments every M1 cycle)
```

### Теневые регистры

```
  A'  F'         Swapped with EX AF,AF'
  B'  C'         \
  D'  E'          | Swapped all three with EXX
  H'  L'         /
```

`EXX` меняет BC/DE/HL на BC'/DE'/HL' за **4T**. Это даёт тебе шесть дополнительных 8-битных регистров (или три дополнительные 16-битные пары) практически бесплатно. Типичное использование: хранить указатели в теневом наборе и переключать по мере необходимости.

**Внимание:** Обработчик прерываний ROM Spectrum (IM1) использует IY (он должен указывать на системные переменные по адресу $5C3A или на безопасную область памяти). Теневые регистры BC'/DE'/HL' и AF' сохраняются обработчиком ROM и безопасны для использования при разрешённых прерываниях. Если твой код использует IY для других целей, сначала запрети прерывания (`DI`) или переключись на IM2 с собственным обработчиком.

### Привязка регистровых пар к инструкциям

| Пара | Используется в | Примечания |
|------|---------|-------|
| BC | `DJNZ` (только B), `OUT (C),r`, `IN r,(C)`, блочные инструкции (счётчик) | B = счётчик цикла, C = младший байт порта |
| DE | `EX DE,HL`, `LDI`/`LDIR` (приёмник), `LD (DE),A` | Указатель-приёмник для блочных операций |
| HL | Почти всё: `LD r,(HL)`, `ADD HL,rr`, `JP (HL)`, `PUSH/POP`, `LDI` (источник) | Универсальный указатель |
| AF | `PUSH AF`/`POP AF`, `EX AF,AF'` | A = аккумулятор, F = флаги |
| SP | `PUSH`/`POP`, `LD SP,HL`, `EX (SP),HL` | Перехват для трюков с данными |

---

## Типичные последовательности инструкций

### Вычисление адреса пикселя (экранный адрес из Y,X)

Преобразование экранных координат в адрес видеопамяти ZX Spectrum. Вход: B = Y (0-191), C = X (0-255). Выход: HL = адрес байта в экране, A = битовая маска.

```z80
; pixel_addr: calculate screen address from coordinates
; Input:  B = Y (0-191), C = X (0-255)
; Output: HL = byte address, A = pixel bit position
; Cost:   ~107 T-states
;
pixel_addr:
    ld   a, b           ; 4T   A = Y
    and  $07             ; 7T   scanline within char cell (Y:2-0)
    or   $40             ; 7T   add screen base ($4000 high byte)
    ld   h, a           ; 4T   H = 010 00 SSS (partial)
    ld   a, b           ; 4T   A = Y again
    rra                 ; 4T   \
    rra                 ; 4T    | shift right 3
    rra                 ; 4T   /
    and  $18             ; 7T   mask Y:4-3 (third bits)
    or   h              ; 4T   H = 010 TT SSS
    ld   h, a           ; 4T
    ld   a, b           ; 4T   A = Y again
    and  $38             ; 7T   mask Y:5-3 (character row within third)
    rlca                ; 4T   \  rotate left 2 to get
    rlca                ; 4T   /  Y:5-3 in bits 7-5
    ld   l, a           ; 4T   L = RRR 00000 (partial)
    ld   a, c           ; 4T   A = X
    rra                 ; 4T   \
    rra                 ; 4T    | X / 8
    rra                 ; 4T   /
    and  $1F             ; 7T   mask to 5-bit column
    or   l              ; 4T   combine row and column
    ld   l, a           ; 4T   L = RRR CCCCC
```

### DOWN_HL: сдвиг на одну строку пикселей вниз

Самый используемый графический примитив на Spectrum. Типичный случай (внутри знакоряда) стоит всего 20T.

```z80
; down_hl: advance HL one pixel row down
; Input:  HL = screen address
; Output: HL = address one row below
; Cost:   20T (common), 46T (third boundary), 77T (char boundary)
;
down_hl:
    inc  h              ; 4T   try next scanline
    ld   a, h           ; 4T
    and  7              ; 7T   crossed character boundary?
    ret  nz             ; 5T   no: done (20T total)

    ld   a, l           ; 4T   yes: advance character row
    add  a, 32          ; 7T   L += 32
    ld   l, a           ; 4T
    ret  c              ; 5T   carry = crossed third (46T total)

    ld   a, h           ; 4T   same third: undo extra H increment
    sub  8              ; 7T
    ld   h, a           ; 4T
    ret                 ; 10T  (77T total)
```

### Беззнаковое умножение 8x8 (сдвигом и сложением)

Из Dark / X-Trade, Spectrum Expert #01 (1997). Используется в матрицах вращения и преобразованиях координат.

```z80
; mulu112: 8x8 unsigned multiply
; Input:  B = multiplicand, C = multiplier
; Output: A:C = 16-bit result (A = high, C = low)
; Cost:   196-204 T-states
;
mulu112:
    ld   a, 0           ; 7T   clear accumulator
    ld   d, 8           ; 7T   8 bits

.loop:
    rr   c              ; 8T   shift multiplier bit into carry
    jr   nc, .noadd     ; 7/12T
    add  a, b           ; 4T   add multiplicand
.noadd:
    rra                 ; 4T   shift result right
    dec  d              ; 4T
    jr   nz, .loop      ; 12T
    ret                 ; 10T
```

### Запись в регистр AY

Стандартная последовательность для записи в звуковой чип AY-3-8910 на ZX Spectrum 128K.

```z80
; ay_write: write value to AY register
; Input:  A = register number (0-15), E = value
; Cost:   41 T-states (plus CALL/RET overhead)
;
ay_write:
    ld   bc, $FFFD      ; 10T  register select port
    out  (c), a          ; 12T  select register
    ld   b, $BF          ;  7T  data port ($BFFD)
    out  (c), e          ; 12T  write value
    ret                  ; 10T
```

### 16-битное сравнение (HL с DE)

В Z80 нет прямого 16-битного сравнения. Используй `SBC` и восстановление.

```z80
; Compare HL with DE (sets flags as if HL - DE)
; Destroys: A (if using the OR method for equality)
;
; For equality only:
    or   a              ; 4T   clear carry
    sbc  hl, de         ; 15T  HL = HL - DE, flags set
    add  hl, de         ; 11T  restore HL
                        ; --- 30T total, Z flag valid
```

### Заливка экрана через стек

Самый быстрый способ залить экран паттерном. Подробнее в главе 3.

```z80
; fill_screen: fill 6144 bytes using PUSH
; Input:  HL = 16-bit fill pattern
; Cost:   ~36,000 T-states (vs ~129,000 with LDIR)
;
fill_screen:
    di                          ; 4T
    ld   (restore_sp + 1), sp   ; 20T  save SP (self-modifying)
    ld   sp, $5800              ; 10T  end of pixel area

    ld   b, 192                 ; 7T   192 iterations x 16 pushes x 2 bytes = 6144
.loop:
    REPT 16
        push hl                 ; 11T  x 16 = 176T
    ENDR
    djnz .loop                  ; 13T/8T

restore_sp:
    ld   sp, $0000              ; 10T  self-modified
    ei                          ; 4T
    ret                         ; 10T
```

### Быстрый перебор строк пикселей (раздельные счётчики)

Из анализа DOWN_HL Introspec'а (Hype, 2020). Устраняет все условные переходы из внутреннего цикла. Общая стоимость для 192 строк: 2 343T против 5 922T для наивных вызовов DOWN_HL.

```z80
; iterate all 192 rows with minimal overhead
; HL starts at $4000
;
iterate_screen:
    ld   hl, $4000          ; 10T
    ld   c, 3               ; 7T   three thirds

.third:
    ld   b, 8               ; 7T   eight character rows per third

.char_row:
    push hl                 ; 11T  save char row start

    REPT 7
        ; ... process row using HL ...
        inc  h              ; 4T   next scanline (NO branching)
    ENDR
    ; ... process 8th row ...

    pop  hl                 ; 10T  restore char row start
    ld   a, l              ; 4T
    add  a, 32             ; 7T   next character row
    ld   l, a              ; 4T
    djnz .char_row         ; 13T/8T

    ld   a, h              ; 4T
    add  a, 8              ; 7T   next third
    ld   h, a              ; 4T
    dec  c                 ; 4T
    jr   nz, .third        ; 12T/7T
```

---

## Таблица быстрых сравнений стоимости

Для решений во внутренних циклах эти сравнения важнее всего:

| Операция | Медленный способ | Быстрый способ | Экономия |
|-----------|----------|----------|---------|
| Обнулить A | `LD A,0` (7T, 2B) | `XOR A` (4T, 1B) | 3T, 1B |
| Проверить A=0 | `CP 0` (7T, 2B) | `OR A` (4T, 1B) | 3T, 1B |
| Скопировать 1 байт (HL)→(DE) | `LD A,(HL)`+`LD (DE),A`+`INC HL`+`INC DE` (26T, 4B) | `LDI` (16T, 2B) | 10T, 2B на байт |
| Скопировать N байт | `LDIR` (21T/байт) | N x `LDI` (16T/байт) | На 24% быстрее, стоит 2N байт кода |
| Заполнить 2 байта | `LD (HL),A`+`INC HL` x2 (26T) | `PUSH rr` (11T) | На 58% быстрее, нужен перехват SP |
| 8-битный цикл | `DEC B`+`JR NZ` (16T, 3B) | `DJNZ` (13T, 2B) | 3T, 1B за итерацию |
| Косвенный вызов | `CALL nn` (17T, 3B) | `RET` через список рендеринга (10T, 1B) | 7T, 2B за диспетчеризацию |
| Обмен регистров | `LD A,H`+`LD H,D`+`LD D,A` (12T, 3B) | `EX DE,HL` (4T, 1B) | 8T, 2B |
| Сохранить 6 регистров | 3 x `PUSH` (33T, 3B) | `EXX` (4T, 1B) | 29T, 2B |

---

## Справочник по размеру кодировки инструкций

Для sizecoding и оценки плотности кода:

| Префикс | Инструкции | Доп. байты | Доп. такты (T-state) |
|--------|-------------|-------------|----------------|
| Нет | Большинство 8-битных операций, LD, ADD, INC, PUSH, POP, JP, JR | 0 | 0 |
| CB | Битовые операции, сдвиги, вращения над регистрами | +1 | обычно +4 |
| ED | Блочные операции, 16-битные ADC/SBC, IN/OUT (C), LD rr,(nn) | +1 | различно |
| DD | Операции с индексацией через IX | +1 | +4 до +8 |
| FD | Операции с индексацией через IY | +1 | +4 до +8 |
| DD CB | Битовые/сдвиговые/вращательные над (IX+d) | +2 | +8 до +12 |

**Совет для sizecoding:** Избегай инструкций с индексацией через IX/IY, когда возможно. `LD A,(IX+5)` -- 3 байта/19T. `LD L,5 / LD A,(HL)` -- 3 байта/11T, если H уже содержит страницу. Индексные регистры удобны, но дороги.

---

> **Источники:** Zilog Z80 CPU User Manual (UM0080); Sean Young, "The Undocumented Z80 Documented" (2005); Dark / X-Trade, "Programming Algorithms" (Spectrum Expert #01, 1997); Introspec, "Once more about DOWN_HL" (Hype, 2020); Глава 1 (тестовая обвязка); Глава 3 (паттерны инструментария); Глава 4 (умножение, деление)
