# Приложение J: Современные инструменты для создания ретро-демо

> *«Лучший инструмент --- тот, который переносит данные из твоей головы в память Z80 за минимальное число шагов.»*

---

## J.1 Два мира, одна философия

Демосцена на PC и демосцена на Z80 выглядят как разные планеты. На одной планете кодеры пишут фрагментные шейдеры на GLSL, процедурно генерируют меши через графы нодов и сжимают всё в 64K-исполняемые файлы, рендерящие трёхмерную графику в реальном времени при 60fps на потребительских GPU. На другой планете кодеры вручную пишут подпрограммы на ассемблере Z80, умещая четырнадцать эффектов в 128K банкированной памяти, считая такты, чтобы каждый кадр уложился ровно в 71 680 тактов.

Разрыв в аппаратных возможностях --- огромный. Разрыв в философии --- почти нулевой.

Оба мира поклоняются ограничениям. 64K-интро на PC ограничено размером файла столь же безжалостно, как демо на ZX Spectrum ограничено скоростью процессора. Участник Shader Showdown, пишущий реймарчер за 25 минут, испытывает то же творческое давление, что и автор 256-байтной программы, оптимизирующий переиспользование регистров. Процедурная генерация --- построение контента из алгоритмов вместо хранения его как данных --- является центральной техникой на обеих платформах, потому что обе наказывают за данные и поощряют вычисления (PC наказывает хранимые данные через ограничения размера файла; Spectrum наказывает их через ограничения памяти).

В этом приложении рассматривается современный инструментарий демосцены: редакторы синхронизации, генераторы данных, музыкальные синтезаторы, упаковщики исполняемых файлов и шейдерные инструменты. Большинство этих инструментов рассчитаны на x86/GPU и не могут работать на Z80 напрямую. Но они выполняют три роли в создании демо для ZX Spectrum:

1. **Генераторы данных** --- вычисляют траектории, позиции частиц, процедурные текстуры на PC, затем экспортируют результаты как сжатые бинарные таблицы, которые Z80 воспроизводит.
2. **Планировщики синхронизации** --- проектируют временн*у*ю связь между музыкой и визуалами в интерактивном редакторе, затем экспортируют номера кадров и кривые параметров в таблицы Z80 `dw`.
3. **Среды прототипирования** --- тестируют визуальные алгоритмы на полной скорости на современном GPU, затем переводят работающий алгоритм на ассемблер Z80, точно зная, как должен выглядеть целевой результат.

Философия последовательна: **используй любой инструмент для подготовки, но рантайм Z80 --- это рукописный ассемблер.** Качество демо оценивается по тому, что работает на Spectrum, а не по тому, что работает на PC разработчика. Инструменты --- это леса; здание --- это Z80.

---

## J.2 Инструменты синхронизации

### Проблема синхронизации

Синхронизация --- попадание нужного визуального события в нужный музыкальный момент --- это самая сложная часть создания демо (Глава 20). На уровне Z80 синхронизация --- это всегда таблица данных: номера кадров в паре с действиями. Вопрос в том, как определить эти номера кадров эффективно и быстро итерировать.

Пять инструментов решают эту проблему, каждый со своим рабочим процессом.

### GNU Rocket

**Что это.** GNU Rocket --- это синк-трекер --- редактор в стиле трекера, где столбцы представляют именованные параметры (`camera:x`, `fade:alpha`, `effect:id`), а строки --- временн*ы*е шаги (обычно кадры или музыкальные доли). Ты ставишь ключевые кадры на определённых строках и выбираешь режим интерполяции между ними: **step** (мгновенная смена), **linear** (постоянная скорость), **smooth** (кубическое сглаживание), или **ramp** (экспоненциальная). Демо подключается к редактору Rocket по TCP в процессе разработки. Ты перематываешь таймлайн, редактируешь значения и видишь обновление демо в реальном времени.

**Кто использует.** Rocket --- де-факто стандартный инструмент синхронизации на PC и Amiga демосценах. Logicoma, Noice, Loonies, Adapt и десятки других групп используют его. Он был портирован на C, C++, C#, Python, Rust и JavaScript.

**Рабочий процесс для Z80.** ZX Spectrum не может запустить TCP-клиент, но концепция переносится напрямую:

1. Проектируй синк-треки в Rocket на PC, перематывая под музыку
2. Экспортируй данные ключевых кадров как бинарный файл (нативный экспорт Rocket)
3. Запусти Python-конвертер: квантуй float в 8-битные или 16-битные значения с фиксированной точкой, выдавая таблицы `db`/`dw`
4. Подключи таблицы в демо через `INCBIN`

Код Z80 просто читает таблицу --- никакого TCP, никаких float, никакой сложности. Ты получаешь интерактивный опыт редактирования Rocket при разработке и минимальные накладные расходы рантайма Spectrum в финальном бинарнике.

**Интерполяция.** Четыре режима интерполяции Rocket чисто отображаются на воспроизведение Z80:
- **Step** → просто используй значение напрямую (0 тактов на интерполяцию)
- **Linear** → предвычисли дельту на кадр, прибавляй каждый кадр (~20 T-states)
- **Smooth/Ramp** → запеки интерполированную кривую в экспортированную таблицу (Z80 читает предвычисленные значения, никакой интерполяции в рантайме)

Для большинства демо на ZX Spectrum запекание всех кривых в покадровые значения --- самый простой подход. Демо на 3 000 кадров (одна минута при 50fps) с 4 параметрами синхронизации потребляет 12 КБ несжатых данных --- существенно, но сжимаемо до 2--4 КБ с помощью ZX0.

**Исходники:** `github.com/rocket/rocket` (MIT-подобная лицензия)

<!-- figure: appj_gnu_rocket -->
```text
┌─────────────────────────────────────────────────────────────────────┐
│                    FIGURE: GNU Rocket sync editor                   │
│                                                                     │
│  Tracker-like grid with named columns:                              │
│  [camera:x]  [camera:y]  [fade:alpha]  [effect:id]                 │
│                                                                     │
│  Rows = frames/time steps. Keyframes shown as bright cells.         │
│  Between keyframes: interpolation curves (step/linear/smooth/ramp)  │
│  visualised as lines connecting values.                             │
│                                                                     │
│  Bottom: transport controls (play, pause, scrub).                   │
│  Connected to running demo via TCP — edit live.                     │
│                                                                     │
│  Screenshot needed: build GNU Rocket from source, create example    │
│  project with 4 tracks, capture at a point showing all 4            │
│  interpolation modes.                                               │
└─────────────────────────────────────────────────────────────────────┘
```

### Vortex Tracker II

**Что это.** Vortex Tracker II --- стандартный редактор ProTracker 3 для сцены ZX Spectrum. Ключевая функция для работы с синхронизацией --- **счётчик кадров** в правом нижнем углу окна --- он показывает абсолютный счёт прерываний (номер кадра) на текущей позиции воспроизведения.

**Рабочий процесс синхронизации.** Воспроизведи .pt3-файл. Следи за счётчиком кадров. Когда слышишь удар, акцент или переход фразы, к которому хочешь привязаться, запиши номер кадра. Внеси его в свою таблицу синхронизации. Пересобери демо, проверь, подкорректируй.

Kolnogorov (Vein) описывает это как свой основной метод: «Vortex + видеоредактор. В Vortex кадр показан в правом нижнем углу --- я смотрел, к каким кадрам привязываться, создавал таблицу с записями `dw frame, action` и синхронизировал по ней.»

**Форк VTI.** Сообщество поддерживает VTI, форк Vortex Tracker II с дополнительными возможностями, включая улучшенную точность воспроизведения и расширенную поддержку форматов. Для работы с синхронизацией оригинальный VT2 и VTI эквивалентны --- счётчик кадров работает одинаково.

**Ограничение.** Итерирование медленное. Каждое изменение тайминга требует пересборки демо и просмотра с начала. Для простых демо с дюжиной точек синхронизации этого достаточно. Для сложных демо с сотнями событий более интерактивный инструмент (Rocket, Blender) стоит затрат на настройку.

<!-- figure: appj_vortex_tracker -->
```text
┌─────────────────────────────────────────────────────────────────────┐
│              FIGURE: Vortex Tracker II — frame counter              │
│                                                                     │
│  VT2 main window with pattern editor visible.                       │
│  Bottom-right: position display showing pattern:row and             │
│  absolute frame number.                                             │
│  Highlight/circle the frame counter.                                │
│                                                                     │
│  Caption: "The frame number in VT2's status bar maps directly to    │
│  the PT3 player's interrupt counter on the Spectrum. What you see   │
│  here is what your sync table references."                          │
│                                                                     │
│  Screenshot needed: open any .pt3 in VTI fork, play to a           │
│  mid-song position, capture with frame number visible.              │
└─────────────────────────────────────────────────────────────────────┘
```

### Blender VSE (Video Sequence Editor)

**Что это.** Встроенный нелинейный видеоредактор Blender. Для синхронизации демо он предоставляет таймлайн, на котором можно размещать цветные полосы (по одной на эффект), импортировать музыкальный трек как аудиополосу с видимой волновой формой и расставлять маркеры в точках синхронизации.

**Рабочий процесс синхронизации:**
1. Захвати каждый эффект, работающий в эмуляторе, как короткий видеоклип (или используй цветные полосы-заглушки)
2. Импортируй клипы и музыку (.wav) в VSE
3. Расположи клипы на таймлайне, перематывай, чтобы найти идеальные точки монтажа
4. Расставь маркеры (зелёные ромбики) на каждом событии синхронизации
5. Считай номера кадров с позиций маркеров

Визуальный рабочий процесс мощен: ты *видишь* волновую форму аудио, *видишь*, где попадает удар, и перетаскиваешь маркер в нужное место. Никаких вычислений, никаких конвертаций BPM в кадры.

**Экспорт.** Маркеры можно экспортировать через Python-консоль Blender:

```python
for m in bpy.context.scene.timeline_markers:
    print(f"dw {m.frame}, 0  ; {m.name}")
```

Это выдаёт таблицу синхронизации, готовую для Z80, напрямую. Переименуй маркеры в соответствии с идентификаторами эффектов (`plasma`, `flash`, `scroll`) --- и экспорт станет полноценной таблицей сцен.

**DaVinci Resolve** предоставляет аналогичные возможности (таймлайн + маркеры + экспорт EDL/CSV), и его бесплатной версии достаточно. Выбирай тот, который уже знаешь.

<!-- figure: appj_blender_vse -->
```text
┌─────────────────────────────────────────────────────────────────────┐
│                 FIGURE: Blender VSE — demo storyboard               │
│                                                                     │
│  Timeline with 4-5 colour-coded strips (one per effect):            │
│  [TORUS: blue] [PLASMA: green] [DOTSCROLL: yellow] [ROTOZOOM: red]  │
│                                                                     │
│  Below: audio waveform strip (music.wav)                            │
│  Vertical markers (green diamonds) at sync points.                  │
│  Playhead at a transition point between effects.                    │
│                                                                     │
│  Screenshot needed: create Blender project with dummy strips +      │
│  real AY music exported as WAV. Place ~8 markers at beat hits.      │
└─────────────────────────────────────────────────────────────────────┘
```

### Blender Graph Editor

**Что это.** Редактор кривых Blender для анимированных свойств с ключевыми кадрами. Для работы над демо ты создаёшь пользовательские свойства объекта (например, `scroll_speed`, `fade_alpha`, `camera_z`) и ставишь на них ключевые кадры в соответствии с энергетикой и фразировкой музыки.

**Почему это важно.** Graph Editor даёт визуальный интерактивный контроль над тем, как параметры изменяются во времени --- то же самое, что предоставляет GNU Rocket, но интегрированное в экосистему Blender. Ты видишь несколько кривых одновременно, корректируешь тайминг ключевых кадров перетаскиванием и переключаешь режимы интерполяции (constant, linear, Bezier) для каждого ключевого кадра.

**Экспорт через Python API:**

```python
for fcurve in bpy.data.actions['SyncAction'].fcurves:
    name = fcurve.data_path.split('"')[1]
    print(f"; {name}")
    for kf in fcurve.keyframe_points:
        print(f"    dw {int(kf.co.x)}, {int(kf.co.y)}")
```

Это выдаёт данные синхронизации, готовые для Z80, напрямую. Проект Blender становится одновременно раскадровкой, справкой по синхронизации и конвейером данных --- всё в одном файле.

<!-- figure: appj_blender_graph -->
```text
┌─────────────────────────────────────────────────────────────────────┐
│              FIGURE: Blender Graph Editor — keyframe export         │
│                                                                     │
│  Graph with X = frame number, Y = parameter value.                  │
│  3 curves: scroll_speed (smooth ease-in), fade_alpha (step at       │
│  transitions), camera_z (linear ramp).                              │
│                                                                     │
│  Annotation showing the Python export:                              │
│  for kf in fcurve.keyframe_points:                                  │
│      print(f"dw {int(kf.co.x)}, {int(kf.co.y)}")                   │
│                                                                     │
│  Arrow pointing to resulting Z80 data:                              │
│  dw 0, 0  /  dw 50, 128  /  dw 150, 255  /  ...                    │
│                                                                     │
│  Screenshot needed: same Blender project, switch to Graph Editor    │
│  view with 3 animated custom properties.                            │
└─────────────────────────────────────────────────────────────────────┘
```

### Motion Canvas

Краткое упоминание: **Motion Canvas** --- это новый инструмент на TypeScript с MIT-лицензией для программного создания параметрических анимаций. Он спроектирован для объясняющих видео, но его подход «таймлайн как код» может служить средством планирования синхронизации для кодеров, предпочитающих писать код, а не перетаскивать ключевые кадры. Проект ещё на ранней стадии; следи за ним на `motioncanvas.io`.

### Сравнительная таблица

| Инструмент | Лицензия | Метод синхронизации | Путь экспорта для Z80 | Интерактивный? |
|------|---------|-------------|-----------------|--------------|
| GNU Rocket | MIT-подобная | Треки с ключевыми кадрами + интерполяция | Бинарный → Python → таблицы `dw` | Да (TCP live editing) |
| Vortex Tracker II | Freeware | Считывание счётчика кадров | Вручную (записать номера кадров) | Частично (слушать + записывать) |
| Blender VSE | GPL | Маркеры на таймлайне + волновая форма | Python → таблицы `dw` | Да (визуальная перемотка) |
| Blender Graph Editor | GPL | Кривые с ключевыми кадрами | Python API → таблицы `dw` | Да (визуальное редактирование кривых) |
| DaVinci Resolve | Free/Commercial | Маркеры на таймлайне | EDL/CSV → Python → таблицы `dw` | Да (визуальная перемотка) |
| Motion Canvas | MIT | Таймлайн, определённый кодом | Экспорт из TypeScript (custom) | Программный |

---

## J.3 Предвизуализация и раскадровка

Прежде чем писать хоть одну строку ассемблера Z80, тебе нужно знать, как демо выглядит. Не в деталях --- не каждый выбор палитры или скорость скроллинга --- а общую структуру: какие эффекты, в каком порядке, какой длительности, с какими переходами. Это предвизуализация, и она экономит больше времени, чем любая оптимизация кода.

### Blender как инструмент раскадровки

**Grease Pencil** в Blender (теперь полностью интегрированный как система 2D-рисования) позволяет набрасывать грубые представления каждого эффекта --- цветные прямоугольники, простые формы, нарисованные от руки приближения. Они не обязаны выглядеть как финальные эффекты. Они должны передавать: «здесь, в течение стольких-то секунд, происходит что-то голубое и кручёное».

Практический подход:
1. Создай один объект Grease Pencil на каждый эффект (цветной прямоугольник с названием эффекта)
2. Расположи их на таймлайне VSE вместе с музыкальным треком
3. Воспроизведи и посмотри на структуру

Ты делаешь не анимацию. Ты делаешь *расписание* --- визуальное представление того, какой эффект когда работает и как долго. Цвета помогают заметить структурные проблемы: три медленных голубых эффекта подряд означают, что темп неправильный. 45-секундный отрезок без перехода означает, что зритель заскучает.

### Видеоредакторы для черновой сборки

Когда у тебя есть эффекты, работающие в эмуляторе, захвати их как видеоклипы (OBS Studio, запись экрана или функции записи эмулятора). Импортируй клипы в видеоредактор --- DaVinci Resolve, Blender VSE или даже iMovie --- и расположи на таймлайне с музыкой.

Черновая сборка выявляет проблемы, невидимые в коде:
- Эффект, который впечатляет по отдельности, но тянется слишком долго в контексте
- Переход, который должен попадать в удар, но оказывается между ударами
- Два последовательных эффекта с похожими цветовыми палитрами, которые сливаются
- Фрагмент, где визуальная энергия падает, в то время как музыка нарастает

Черновая сборка стоит часа работы. Она экономит дни корректировок тайминга на уровне ассемблера.

### Рабочий процесс GABBA

Подход diver4d для GABBA (2019) пошёл дальше: он использовал **Luma Fusion**, iOS-видеоредактор, в качестве основного инструмента планирования синхронизации. Рабочий процесс:

1. Закодируй каждый эффект по отдельности, протестируй в эмуляторе
2. Запиши экран с работающим эффектом
3. Импортируй записи + музыку в Luma Fusion на iPad
4. Расположи на таймлайне, перематывай покадрово, чтобы найти точки синхронизации
5. Запиши номера кадров, составь таблицу синхронизации

Ключевое понимание: покадровая синхронизация --- это задача *видеомонтажа*, а не *программирования*. Решая её в инструменте, предназначенном для видеомонтажа, diver4d мог итерировать тайминг за секунды вместо минут. Код Z80 был слоем реализации; творческие решения принимались в видеоредакторе.

### Kolnogorov о планировании синхронизации

Kolnogorov (Vein) формулирует комбинированный подход: «Я экспортировал клипы с эффектами в видео, собирал их в видеоредакторе, прикреплял музыкальный трек и смотрел, в каком порядке эффекты работают лучше всего, отмечая кадры, где должны происходить события.»

Важное слово --- *смотрел*. Это визуальный, интуитивный процесс. Ты *видишь*, где удар попадает на волновую форму. Ты *видишь*, где переход эффекта ощущается правильно. И считываешь номер кадра. Никаких вычислений, никаких конвертаций BPM в кадры.

---

## J.4 Генераторы данных

Демо на ZX Spectrum воспроизводит предвычисленные данные при 50fps. Вопрос: где вычислять эти данные? Для простых таблиц синусов и координат Брезенхэма достаточно Python-скрипта. Для сложных 3D-траекторий, органического движения частиц или жестов, захваченных в VR, нужна более мощная среда.

### Unity как генератор данных

Unity --- это не overkill для демо на ZX Spectrum: это overkill в качестве *движка демо*, но идеально в качестве *генератора данных*. Разница важна.

**Захват движения в VR.** XR Toolkit в Unity захватывает позицию VR-контроллера с частотой 90 Гц. Нарисуй траекторию в воздухе VR-контроллером --- органическое движение руки невозможно воспроизвести математическими формулами. Понизь частоту до 50fps, квантуй до 8-битных знаковых значений, примени дельта-кодирование, сожми. 5-секундная нарисованная вручную траектория превращается в 250 байт упакованных данных, которые *выглядят живыми* на Spectrum.

**Системы GPU-частиц.** VFX Graph в Unity запускает миллионы частиц на GPU. Прототипируй фонтан частиц, вихрь или симуляцию стаи, затем экспортируй позиции частиц по кадрам как CSV. На Spectrum ты рисуешь эти позиции как точки или ячейки атрибутов. Физическая симуляция, которая потребовала бы месяцев реализации на Z80, работает за миллисекунды на GPU.

**Прототипирование шейдеров.** Напиши плазму, тоннель или ротозумер как фрагментный шейдер в ShaderGraph Unity. Итерируй в реальном времени на полном разрешении, пока не будет выглядеть правильно. Затем переведи алгоритм на Z80, точно зная, как должен выглядеть целевой результат.

### Unreal Engine как генератор данных

Unreal предлагает эквивалентные возможности через другие инструменты:
- **OpenXR** для захвата движения в VR
- **Niagara** для систем GPU-частиц
- **Material Editor** для прототипирования шейдеров

Выбор между Unity и Unreal для генерации данных --- вопрос знакомства. Оба экспортируют в одинаковые форматы (CSV, бинарные массивы). Оба предоставляют больше вычислительной мощности, чем тебе когда-либо понадобится для генерации данных Z80-демо.

### Blender как генератор данных

Для большинства задач генерации данных Blender достаточен и полностью свободен:

- **Geometry Nodes** для процедурных траекторий --- определи путь как сплайн, разбросай точки вдоль него, анимируй шумом, экспортируй позиции вершин по кадрам
- **Grease Pencil** для рисованной анимации --- рисуй кадры, экспортируй координаты точек
- **Python API** для прямого экспорта --- доступ к любому анимированному свойству из `bpy.data`
- **Физическая симуляция** для частиц, ткани, жидкости --- симулируй, запеки, экспортируй покадровые данные

Blender не умеет захватывать движение в VR (без сторонних аддонов) и его система частиц работает на CPU (медленнее GPU-систем для миллионов частиц). Во всём остальном он не уступает Unity/Unreal и даже превосходит их для целей генерации данных.

### Конвейер экспорта

Независимо от того, какой инструмент генерирует данные, конвейер до Z80 проходит одни и те же этапы:

```text
Source tool (Unity/Unreal/Blender)
  → Export: float arrays (CSV, JSON, or binary)
    → Python: float → 8-bit fixed-point (or 16-bit where needed)
      → Delta-encode: store differences between frames (smaller values)
        → Transpose: column-major layout (all X values, then all Y values)
          → packbench analyze: verify entropy, check suggested transforms
            → zx0/pletter: compress
              → sjasmplus: INCBIN into demo
```

Каждый этап уменьшает размер данных:

| Этап | Пример размера (250 кадров x 4 параметра) |
|-------|--------------------------------------|
| Float CSV | ~10 КБ |
| 8-битная фиксированная точка | 1 000 байт |
| Дельта-кодирование | 1 000 байт (значения уменьшаются, лучше степень сжатия) |
| Транспонирование + сжатие | 300--500 байт |

Этапы дельта-кодирования и транспонирования не уменьшают сырой размер --- они переформатируют данные для лучшего сжатия. Столбцовая раскладка группирует похожие значения вместе (все дельты X, затем все дельты Y), что сжимается радикально лучше, чем построчная раскладка, где дельты X и Y чередуются.

### Когда использовать что

| Задача | Инструмент | Почему |
|------|------|-----|
| Таблицы синусов, таблицы подстановки | Python-скрипт | Проще всего, без зависимостей |
| Процедурные 3D-траектории | Blender (Geometry Nodes) | Бесплатный, визуальный, Python-экспорт |
| Нарисованные вручную траектории анимации | Blender (Grease Pencil) | Рисуй прямо, покадрово |
| Захват жестов в VR | Unity (XR Toolkit) или Unreal (OpenXR) | Нужно VR-оборудование + рантайм |
| Позиции GPU-частиц | Unity (VFX Graph) или Unreal (Niagara) | Миллионы частиц, быстро |
| Прототип шейдерного алгоритма | Любой (ShaderToy, Unity, Unreal, Blender) | Какой знаешь |

Предвычисленные векторные анимации Kolnogorov --- подходящий пример: 3D-геометрия была вычислена офлайн (минуты вычислений допустимы для 4K-интро), полученные траектории вершин были сохранены как сжатые таблицы, и Spectrum воспроизводил их при 50fps. Инструмент, сгенерировавший траектории, не имеет значения для зрителя. Важно, что данные существуют и Z80 их воспроизводит.

---

## J.5 Инструментарий PC-демосцены: краткая история

PC-демосцена потратила двадцать пять лет на создание инструментов для процедурной генерации контента и экстремального сжатия. Эти инструменты не могут работать на Z80, но их философия проектирования --- процедурность во всём, маленькое --- это красивое, ограничение как творчество --- в точности отражает то, что кодеры ZX Spectrum делают вручную. Понимание инструментария PC-сцены поможет тебе увидеть, какие проблемы уже решены (в других контекстах) и какие идеи можно адаптировать.

### Farbrausch (1999--2012)

**Farbrausch** --- немецкая демогруппа, переопределившая границы возможного в 64K- и 4K-исполняемых файлах. Их подход: строить инструменты, генерирующие всё процедурно, а затем упаковывать генераторы в крохотные исполняемые файлы.

**Werkkzeug** (версии с 1 по 4) был их флагманским инструментом --- нодовой процедурной системой, где текстуры, меши, анимации и композиции определялись как графы операторов. Никакие растровые изображения не хранились; каждый пиксель вычислялся в рантайме из рецепта математических операций. Инструмент использовался внутри Farbrausch; зрители видели лишь результирующие исполняемые файлы.

Заметные работы, созданные с помощью Werkkzeug:
- **fr-08: .the .product** (2000) --- музыкальное 3D-видео в реальном времени в 64 КБ, переопределившее категорию 64K-интро. Победило в компо демо на The Party 2000.
- **.kkrieger** (2004) --- шутер от первого лица в 97 280 байт. Текстуры, меши, анимации, AI и звук --- всё сгенерировано процедурно. Исполняемый файл меньше исходника этого приложения.
- **fr-041: debris.** (2007) --- кинематографическое демо в 177 КБ, продвинувшее качество рендеринга в реальном времени за пределы того, чего достигали многие полноразмерные демо. Победило на Breakpoint 2007.

**kkrunchy** --- их упаковщик исполняемых файлов для 64K-интро --- контекстно-смесевый компрессор, достигавший степени сжатия далеко за пределами стандартных упаковщиков вроде UPX. kkrunchy до сих пор активно используется кодерами 64K-интро, более чем десятилетие после роспуска Farbrausch.

**V2 Synthesizer** --- программный синтезатор, спроектированный для интро --- VSTi-плагин для сочинения музыки с крохотным рантайм-проигрывателем, помещавшимся внутри упакованного исполняемого файла. Музыка хранилась как данные нот и параметры синтеза, а не как аудио.

В 2012 году Farbrausch выложили весь свой инструментарий в открытый доступ под BSD-подобной лицензией: `github.com/farbrausch/fr_public`. Репозиторий включает Werkkzeug (все версии), kkrunchy, V2 и ряд других инструментов. Код --- капсула времени инженерии демосцены начала 2000-х: плотный C++, Win32 API, Direct3D 9 и креативные решения задач, которые современные GPU решают грубой силой.

**Актуальность для Z80.** Эквивалент процедурных текстур Werkkzeug на ZX Spectrum --- твой Python-скрипт сборки, генерирующий таблицы подстановки из математических функций. Эквивалент kkrunchy --- ZX0 или Pletter. Эквивалент V2 --- AY-beat или проигрыватель Shiru для AY. Разный масштаб, тот же принцип: генерируй контент из компактных описаний, сжимай результат, распаковывай в рантайме.

### TiXL (2024--наши дни)

**TiXL** (ранее Tooll3) --- духовный наследник Werkkzeug, разрабатываемый **Still** (pixtur/Thomas Mann) --- демосценером, работавшим с участниками Farbrausch и продвинувшим нодовый процедурный подход дальше.

TiXL --- среда для создания моушн-графики в реальном времени, построенная на современных GPU API. Как и Werkkzeug, она использует граф нодов для определения процедурного контента, но с двадцатью годами эволюции GPU за спиной: вычислительные шейдеры, физически корректный рендеринг, GPU-частицы и реймарчинг в реальном времени.

Распространяется под лицензией MIT (`github.com/tixl3d/tixl`); TiXL показывает, куда эволюционировала философия Werkkzeug. Концепция графа нодов --- определение контента как рецепта операций, а не хранение его как данных --- напрямую применима к разработке демо для Z80, даже при том что конкретные операции совершенно другие.

<!-- figure: appj_tixl_nodes -->
```text
┌─────────────────────────────────────────────────────────────────────┐
│                    FIGURE: TiXL node graph                          │
│                                                                     │
│  Visual programming canvas with connected nodes:                    │
│  [Time] → [Sine] → [Multiply] → [SetFloat]                        │
│                                                                     │
│  A procedural texture pipeline:                                     │
│  [Noise3D] → [Remap] → [ColorGrade] → [RenderTarget]              │
│                                                                     │
│  3D scene graph:                                                    │
│  [Mesh:Torus] → [Transform] → [Material] → [DrawMesh]             │
│  [Camera] → [Render] → [PostFX:Bloom] → [Output]                  │
│                                                                     │
│  Right panel: live preview of the rendered output.                  │
│  Bottom: timeline with playback controls.                           │
│                                                                     │
│  Caption: "TiXL (MIT, 2024) carries forward the Werkkzeug           │
│  philosophy of node-based procedural content generation. The         │
│  Z80 equivalent is a Python build script that generates lookup       │
│  tables and compressed data from mathematical functions."            │
│                                                                     │
│  Screenshot needed: install TiXL, open an example project,          │
│  capture the node graph + preview in a split view.                  │
└─────────────────────────────────────────────────────────────────────┘
```

### Bonzomatic

**Bonzomatic** (автор Gargaj / Conspiracy) --- стандартный инструмент для соревнований **Shader Showdown** --- живых шейдерных баттлов на демопати. Два кодера делят сцену, каждый пишет фрагментный шейдер с нуля за 25 минут, код и результат проецируются бок о бок для зрителей.

Bonzomatic предоставляет минималистичный редактор с окном предпросмотра в реальном времени. Каждое нажатие клавиши перекомпилирует шейдер; результат обновляется мгновенно. Нет сохранения, нет истории отмен за пределами буфера редактора, нет библиотек. Это чистое творчество в условиях ограничений --- тот же дух, что и 256-байтное кодирование на Spectrum.

**Исходники:** `github.com/Gargaj/Bonzomatic`

### Crinkler

**Crinkler** (авторы Rune Stubbe и Aske Simon Christensen / Loonies) --- **сжимающий линкер** для Windows-исполняемых файлов. Там, где обычный линкер создаёт .exe, а ты сжимаешь его отдельно, Crinkler объединяет линковку и сжатие в один шаг, достигая степени сжатия, недоступной ни одному отдельному упаковщику.

Crinkler --- стандарт для 1K, 4K и 8K PC-интро. Его сжатие настолько эффективно, что кодеры регулярно измеряют свою работу в «Crinkler-байтах» --- финальный упакованный размер, который может составлять 60--70% от несжатого кода + данных.

Параллель с Z80: ZX0 и Pletter выполняют ту же роль для демо на Spectrum, хотя степень сжатия скромнее (код Z80 содержит меньше избыточности, чем x86).

**Исходники:** `github.com/runestubbe/Crinkler` (лицензия zlib)

### Squishy

**Squishy** (авторы Logicoma) --- упаковщик 64K-исполняемых файлов --- эквивалент kkrunchy для современных 64K-интро. В отличие от Crinkler (который работает с крохотными интро), Squishy нацелен на размерный класс 64 КБ, где исполняемый файл содержит значительный объём шейдерного кода, процедур генерации текстур и музыки.

Распространяется только в бинарном виде; исходники недоступны. Упоминается здесь, потому что 64K-интро Logicoma (Happy Coding, Elysian, H - Immersion) представляют современное состояние искусства в категории 64K, и Squishy --- часть этого конвейера.

### Shader Minifier

**Shader Minifier** (автор Ctrl-Alt-Test) --- минификатор GLSL/HLSL, который переименовывает переменные, удаляет пробелы и оптимизирует шейдерный код для минимального размера. Используется в sizecoding-интро, где важен каждый байт шейдерного исходника (шейдеры часто хранятся как строки в исполняемом файле и компилируются в рантайме).

**Исходники:** `github.com/laurentlb/shader-minifier`

### z80-optimizer

**z80-optimizer** (автор oisee, 2025) --- брутфорс-супероптимизатор Z80, написанный на Go. Он перебирает все пары инструкций Z80 (406 x 406 опкодов), тестирует каждую пару на всех возможных состояниях регистров и флагов и сообщает, когда более короткая или быстрая замена даёт идентичный результат. Никаких эвристик, никакого машинного обучения --- чистый исчерпывающий перебор с полной верификацией эквивалентности состояний.

Один запуск на Apple M2 (3 ч 16 мин, 34,7 миллиарда сравнений) выдаёт **602 008 доказуемо корректных правил оптимизации** по **83 уникальным паттернам трансформаций**. Примеры: `SLA A : RR A` → `OR A` (экономия 3 байта, 12T); `LD A, 0 : NEG` → `SUB A` (экономия 2 байта); `SCF : RR A` → `SCF : RRA` (экономия 1 байт, 4T). Важно: он корректно *отвергает* `LD A, 0` → `XOR A`, потому что поведение флагов различается --- та самая тонкая разница, которую вручную поддерживаемые таблицы подглядывания иногда упускают.

Полезен как пост-обработка для сгенерированного компилятором кода Z80 или как справочник для ручной оптимизации. Результат --- машиночитаемая база правил, которую можно интегрировать в инструменты ассемблера. См. Главу 23 об обсуждении брутфорс-подходов vs нейросетевых подходов к оптимизации Z80.

**Исходники:** `github.com/oisee/z80-optimizer` (лицензия MIT, v0.1.0)

### Общая философия

Все эти инструменты разделяют принцип, напрямую переносимый на работу с Z80: **процедурная генерация побеждает хранимые данные.** На PC это означает генерацию текстур из функций шума вместо хранения растровых изображений. На Spectrum это означает вычисление таблицы синусов из параболической аппроксимации вместо хранения 256 байт предвычисленных значений. Аппаратура различается в миллион раз; подход тот же.

---

## J.6 Музыкальные и звуковые инструменты

PC-демосцена нуждается в крошечных синтезаторах --- программных инструментах, помещающихся в 4K- или 64K-исполняемый файл и при этом производящих музыку профессионального качества. Z80-сцена нуждается в трекерах для AY-3-8910. Есть некоторое пересечение.

### Sointu

**Sointu** --- синтезатор для 4K-интро --- форк 4klang, переписанный на Go для кроссплатформенности. Он предоставляет VST-подобный интерфейс для проектирования патчей (осцилляторы, фильтры, огибающие, эффекты) и компилятор, генерирующий минимальный нативный проигрыватель.

Код проигрывателя спроектирован для экстремально малого размера: весь рантайм синтезатора, включая все определения инструментов и данные нот, помещается менее чем в 4 КБ кода + данных x86. Это делает его PC-эквивалентом того, чего AY-beat (Глава 13) достигает на Spectrum: максимум звука из минимума байтов.

**Исходники:** `github.com/vsariola/sointu` (лицензия MIT)

### 4klang

**4klang** (автор Alcatraz) --- оригинальный синтезатор для 4K-интро, от которого был форкнут Sointu. Он предоставляет VSTi-плагин для сочинения и режим вывода ассемблера, генерирующий NASM-исходник для проигрывателя --- синтезатор буквально написан на ассемблере x86, оптимизированном по размеру.

4klang определил стандарт музыки для 4K-интро и по-прежнему активно используется наряду со своим наследником Sointu.

**Исходники:** `github.com/gopher-atz/4klang`

### WaveSabre

**WaveSabre** (автор Logicoma) нацелен на 64K-интро --- более крупный размерный класс, где синтезатор может быть сложнее. Он предоставляет VST-совместимые инструменты с реверберацией, задержкой, хорусом, дисторшном и другими эффектами, которые 4K-синтезаторы вынуждены опускать. Рантайм-проигрыватель достаточно компактен для 64K, но слишком велик для 4K.

WaveSabre стоит за музыкой в отмеченных наградами 64K-интро Logicoma (Happy Coding, Elysian).

**Исходники:** `github.com/logicomacorp/WaveSabre` (лицензия MIT)

### Oidos

**Oidos** (автор Blueberry / Loonies) использует принципиально иной подход: аддитивный синтез. Там, где большинство синтезаторов строят звук из осцилляторов и фильтров, Oidos строит его из сумм синусоидальных волн с индивидуально управляемыми частотами и амплитудами. Результат --- характерный, богатый звук, занимающий уникальное звуковое пространство в 4K-интро.

**Исходники:** `github.com/askeksa/Oidos`

### Furnace

**Furnace** --- мультисистемный чиптюн-трекер, поддерживающий более 80 звуковых чипов --- включая **AY-3-8910**. Это делает его непосредственно актуальным для создания демо на ZX Spectrum: ты можешь сочинять музыку для AY в Furnace с современным интерфейсом, имеющим возможности, которых нет в Vortex Tracker II (отмена, несколько вкладок, визуальный редактор огибающей, осциллограф по каналам).

Среди других поддерживаемых чипов: SN76489 (Sega Master System, BBC Micro), YM2612 (Mega Drive), SID (C64), Pokey (Atari) и многие другие. Если ты работаешь над мультиплатформенными ретро-проектами, Furnace --- единственный трекер, покрывающий все цели.

**Форматы экспорта.** Furnace может экспортировать в формат VGM (Video Game Music), который захватывает сырые записи в регистры по кадрам. Для AY-3-8910 это означает поток 14-байтных дампов регистров при 50/60 Гц --- напрямую используемый на Spectrum с минимальным проигрывателем, записывающим регистры на каждом прерывании. Пользовательские скрипты экспорта могут конвертировать VGM в PT3 или в сырые таблицы регистров для INCBIN.

**Ограничение.** Эмуляция AY в Furnace хороша, но не идентична воспроизведению PT3 в Vortex Tracker. Если твоё демо использует PT3-проигрыватель, сочиняй в Vortex Tracker для гарантированного воспроизведения 1:1. Используй Furnace, когда хочешь современный опыт редактирования и готов заниматься конвертацией форматов, или когда работаешь с AY напрямую через сырые записи в регистры.

**Исходники:** `github.com/tildearrow/furnace` (GPL-2.0)

### Сравнительная таблица

| Инструмент | Размерный класс | Лицензия | Актуальность для Z80 |
|------|-----------|---------|---------------|
| Sointu | 4K-интро | MIT | Концептуальная (те же ограничения, что и AY-beat) |
| 4klang | 4K-интро | OSS | Концептуальная |
| WaveSabre | 64K-интро | MIT | Концептуальная |
| Oidos | 4K-интро | OSS | Концептуальная |
| Furnace | Любой | GPL-2.0 | **Прямая** --- поддержка AY-3-8910, экспорт VGM |
| Vortex Tracker II | Любой | Freeware | **Прямая** --- нативный PT3, стандарт ZX |

---

## J.7 Практические рецепты

Пять пошаговых рабочих процессов, связывающих современные инструменты с ассемблером Z80. Каждый рецепт начинается с пустого проекта и заканчивается данными, которые можно подключить в демо через `INCBIN`.

### Рецепт 1: GNU Rocket → таблица синхронизации Z80

**Цель:** Спроектировать интерполированные кривые синхронизации в Rocket, экспортировать как таблицы Z80 `dw`.

**Шаги:**

1. **Установи Rocket.** Клонируй `github.com/rocket/rocket`, собери из исходников (CMake). Запусти редактор.

2. **Создай треки.** Добавь четыре трека: `effect:id`, `fade:alpha`, `scroll:speed`, `flash:border`. Установи BPM в соответствии с музыкой (например, 125 BPM при 50fps = 24 кадра на долю).

3. **Расставь ключевые кадры.** В строке 0: `effect:id` = 0 (logo), `fade:alpha` = 255. В строке 150: `effect:id` = 1 (plasma), `fade:alpha` плавно меняется от 255 к 0 (smooth-интерполяция). Продолжи для всей длительности демо.

4. **Экспортируй.** Используй экспортер синхронизации Rocket (или утилиту `sync_export`) для записи бинарных файлов по каждому треку.

5. **Конвертируй с помощью Python:**

```python
import struct

def rocket_to_z80(track_file, output_file):
    with open(track_file, 'rb') as f:
        data = f.read()
    # Rocket binary: array of (row: u32, value: float32) pairs
    pairs = []
    for i in range(0, len(data), 8):
        row, val = struct.unpack('<If', data[i:i+8])
        pairs.append((row, max(0, min(255, int(val)))))

    with open(output_file, 'w') as f:
        for row, val in pairs:
            f.write(f"    dw {row}, {val}\n")
        f.write("    dw 0  ; end marker\n")

rocket_to_z80('effect_id.track', 'sync_effect.inc')
```

6. **Подключи в демо:**

```z80
sync_effect:
    INCLUDE "sync_effect.inc"
```

**Вариант с запеканием.** Для гладкой интерполяции без затрат в рантайме разверни ключевые кадры в покадровые значения:

```python
# Interpolate between keyframes, output one value per frame
for frame in range(total_frames):
    value = interpolate(keyframes, frame)  # linear, smooth, or ramp
    print(f"    db {max(0, min(255, int(value)))}")
```

Трек на 3 000 кадров, запечённый в покадровые значения `db` = 3 000 байт без сжатия, ~800 байт после ZX0.

### Рецепт 2: Blender VSE → таблица номеров кадров

**Цель:** Визуально спланировать структуру демо с музыкой, экспортировать точки синхронизации.

**Шаги:**

1. **Создай проект Blender.** Установи частоту кадров 50fps (Properties → Output → Frame Rate → 50). Установи длину таймлайна под свою музыку.

2. **Импортируй музыку.** Add → Sound в VSE. Импортируй свой .pt3, экспортированный в .wav (используй «File → Export to WAV» в Vortex Tracker). Волновая форма появится на таймлайне.

3. **Добавь полосы эффектов.** Add → Color strips для каждого эффекта. Назови их (plasma, scroll, torus). Задай цвета. Расположи на таймлайне так, чтобы они покрывали всю длительность демо.

4. **Расставь маркеры.** Перематывай таймлайн. Когда слышишь удар или точку перехода, нажми M, чтобы добавить маркер. Переименуй каждый маркер: `plasma_start`, `flash_1`, `scroll_begin` и т.д.

5. **Экспортируй через Python-консоль:**

```python
import bpy

# Print sync table
print("; Auto-generated sync table from Blender VSE")
print("sync_table:")
for m in sorted(bpy.context.scene.timeline_markers,
                key=lambda x: x.frame):
    print(f"    dw {m.frame}  ; {m.name}")
print("    dw 0  ; end marker")
```

6. **Скопируй вывод в .inc-файл проекта.** Пересобери демо с помощью `make`.

7. **Итерируй.** Посмотри демо, отметь, где тайминг ощущается неправильно, вернись в Blender, скорректируй маркеры, переэкспортируй. Каждая итерация занимает секунды.

### Рецепт 3: Unity VR → данные траектории

**Цель:** Захватить нарисованную вручную 3D-траекторию с помощью VR-контроллера, экспортировать как сжатые данные для Z80.

**Шаги:**

1. **Настрой проект Unity.** Создай новый 3D-проект, установи XR Toolkit через Package Manager. Настрой под свой шлем (Quest, Index и т.д.).

2. **Запиши траекторию контроллера.** Создай скрипт, захватывающий `transform.position` правого контроллера каждый кадр:

```csharp
void Update() {
    positions.Add(new Vector3(
        controller.transform.position.x,
        controller.transform.position.y,
        controller.transform.position.z
    ));
}
```

3. **Экспортируй CSV.** По окончании записи запиши позиции в CSV:

```csharp
File.WriteAllLines("trajectory.csv",
    positions.Select(p => $"{p.x},{p.y},{p.z}"));
```

4. **Конвертируй с помощью Python:**

```python
import csv

with open('trajectory.csv') as f:
    rows = list(csv.reader(f))

# Downsample from 90Hz to 50Hz
factor = 90 / 50
resampled = [rows[int(i * factor)] for i in range(int(len(rows) / factor))]

# Quantise to signed 8-bit (-128..127)
def q8(val, scale=64.0):
    return max(-128, min(127, int(float(val) * scale)))

# Delta-encode
prev = [0, 0, 0]
deltas = []
for row in resampled:
    cur = [q8(row[0]), q8(row[1]), q8(row[2])]
    deltas.append([c - p for c, p in zip(cur, prev)])
    prev = cur

# Transpose (column-major) and output
print("; X deltas")
print("traj_dx:")
print("    db " + ", ".join(str(d[0] & 0xFF) for d in deltas))
print("; Y deltas")
print("traj_dy:")
print("    db " + ", ".join(str(d[1] & 0xFF) for d in deltas))
print("; Z deltas")
print("traj_dz:")
print("    db " + ", ".join(str(d[2] & 0xFF) for d in deltas))
```

5. **Сожми.** Пропусти каждый столбец через ZX0 отдельно (столбцовая раскладка сжимается намного лучше чередующейся). Подключи сжатые блобы через `INCBIN`.

6. **Воспроизведение на Z80.** Распакуй каждый столбец в буфер. Каждый кадр читай следующую дельту и прибавляй к текущей позиции. Рисуй полученную точку (X, Y) на экране (проецируй Z для глубины при необходимости).

### Рецепт 4: Furnace → музыка для AY

**Цель:** Сочинить музыку для AY-3-8910 в Furnace и экспортировать для воспроизведения на ZX Spectrum.

**Шаги:**

1. **Настрой Furnace.** Создай новый проект. Добавь систему AY-3-8910 (Settings → выбери «AY-3-8910» из списка чипов). Установи тактовую частоту 1,7734 МГц (стандарт ZX Spectrum). Установи частоту обновления 50 Гц (PAL).

2. **Сочиняй.** Используй паттерн-редактор Furnace --- похож на Vortex Tracker, но с отменой, осциллограммой по каналам и визуальным редактором огибающей. Furnace поддерживает аппаратные огибающие AY, микширование шума и все стандартные возможности AY.

3. **Экспортируй в VGM.** File → Export → VGM. Это создаёт .vgm-файл, содержащий сырые записи в регистры AY по кадрам --- поток пар `(регистр, значение)` при 50 Гц.

4. **Конвертируй VGM в дамп регистров:**

```python
import struct

def vgm_to_ay_regs(vgm_file):
    with open(vgm_file, 'rb') as f:
        data = f.read()

    # Skip VGM header (find data offset at 0x34)
    data_offset = struct.unpack_from('<I', data, 0x34)[0] + 0x34

    frames = []
    current_regs = [0] * 14
    pos = data_offset

    while pos < len(data):
        cmd = data[pos]
        if cmd == 0xA0:  # AY-3-8910 register write
            reg = data[pos + 1]
            val = data[pos + 2]
            if reg < 14:
                current_regs[reg] = val
            pos += 3
        elif cmd == 0x62:  # Wait 1/50s
            frames.append(list(current_regs))
            pos += 1
        elif cmd == 0x66:  # End of data
            break
        else:
            pos += 1

    return frames

frames = vgm_to_ay_regs('music.vgm')

# Output as Z80 include
print(f"music_frames: equ {len(frames)}")
print("music_data:")
for regs in frames:
    print("    db " + ", ".join(f"${r:02X}" for r in regs))
```

5. **Проигрыватель для Z80.** Простейший возможный проигрыватель --- 14 инструкций OUT на прерывание:

```z80
play_frame:
    ld hl, (music_ptr)
    ld b, 14
    xor a
.loop:
    out ($FD), a        ; select register
    ld c, (hl)
    inc hl
    push af
    ld a, c
    out ($BF), a        ; write value
    pop af
    inc a
    djnz .loop
    ld (music_ptr), hl
    ret
```

6. **Альтернатива: конвертация в PT3.** Если предпочитаешь стандартный PT3-проигрыватель (меньше, лучше сжатие), используй утилиту `vgm2pt3` или сочиняй напрямую в Vortex Tracker. Преимущество Furnace --- современный интерфейс; преимущество Vortex Tracker --- гарантированная совместимость с PT3.

### Рецепт 5: packbench → предварительный анализ перед сжатием

**Цель:** Проанализировать сырые данные демо перед сжатием, чтобы определить оптимальные преобразования.

**Шаги:**

1. **Собери без сжатия.** Собери демо с сырыми (несжатыми) данными INCBIN.

2. **Запусти packbench analyse** для каждого файла данных:

```bash
packbench analyze sprites.bin
```

3. **Прочитай отчёт.** packbench сообщает:
   - **Энтропия** (бит на байт) --- теоретический минимальный сжатый размер
   - **Распределение байтов** --- показывает, группируются ли значения (хорошо) или распределены равномерно (плохо для сжатия)
   - **Длины серий** --- показывает паттерны повторений
   - **Рекомендованные преобразования** --- дельта-кодирование, разделение на битовые плоскости, транспонирование и т.д.

4. **Примени рекомендованные преобразования.** Если packbench предлагает дельта-кодирование:

```python
data = open('sprites.bin', 'rb').read()
deltas = bytes([((data[i] - data[i-1]) & 0xFF) for i in range(1, len(data))])
open('sprites_delta.bin', 'wb').write(bytes([data[0]]) + deltas)
```

5. **Повтори анализ.** Запусти packbench для преобразованных данных. Энтропия должна быть ниже.

6. **Сожми.** Пропусти преобразованные данные через ZX0 или Pletter. Сравни сжатый размер с оригиналом --- преобразование должно дать меньший результат.

7. **Обнови демо.** Распаковщик Z80 запускается первым (декодирование ZX0), затем обратное преобразование (обратное дельта-кодирование) восстанавливает исходные данные. Обратное преобразование дёшево: ~10 T-states на байт для дельта-декодирования.

---

## Дополнительное чтение

- **GNU Rocket:** `github.com/rocket/rocket` --- редактор синхронизации + клиентские библиотеки
- **TiXL:** `github.com/tixl3d/tixl` --- нодовая моушн-графика (MIT)
- **Архив Farbrausch:** `github.com/farbrausch/fr_public` --- Werkkzeug, kkrunchy, V2 (BSD)
- **Furnace:** `github.com/tildearrow/furnace` --- мультисистемный чиптюн-трекер (GPL-2.0)
- **Sointu:** `github.com/vsariola/sointu` --- синтезатор для 4K-интро (MIT)
- **WaveSabre:** `github.com/logicomacorp/WaveSabre` --- синтезатор для 64K-интро (MIT)
- **Crinkler:** `github.com/runestubbe/Crinkler` --- сжимающий линкер (zlib)
- **Bonzomatic:** `github.com/Gargaj/Bonzomatic` --- живое шейдерное кодирование
- **Shader Minifier:** `github.com/laurentlb/shader-minifier` --- оптимизатор GLSL/HLSL
- **z80-optimizer:** `github.com/oisee/z80-optimizer` --- брутфорс-супероптимизатор Z80 (MIT)
- **Motion Canvas:** `motioncanvas.io` --- параметрическая анимация (MIT)
- **Blender:** `blender.org` --- 3D, VSE, Graph Editor, Geometry Nodes, Grease Pencil (GPL)
