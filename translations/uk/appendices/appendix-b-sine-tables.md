# Додаток B: Генерація таблиць синусів та тригонометричні таблиці

> *"Косинус -- це просто синус зі зсувом на чверть періоду."*
> -- Заповіді Raider

---

Кожен ефект демо, що вигинається -- обертання, плазма, скролінг, тунелі -- потребує таблиці синусів. На Z80 ти попередньо обчислюєш значення в таблицю підстановки та індексуєш за кутом. Питання в тому, як зберігати та отримувати доступ до цієї таблиці якомога ефективніше.

Цей додаток порівнює вісім підходів до зберігання таблиці синусів, від очевидного (256-байтна таблиця) до екзотичного (2-бітне кодування дельт другого порядку). Дані взяті з `verify/sine_compare.py`, який ти можеш запустити для відтворення кожного числа тут.

## Стандартний формат

Таблиця синусів демосцени має **256 записів**, індексованих за кутом:

| Індекс | Кут |
|--------|-----|
| 0 | 0° |
| 64 | 90° |
| 128 | 180° |
| 192 | 270° |
| 256 (обертається на 0) | 360° |

Кожен запис -- **знаковий байт** (-128 до +127), що представляє -1.0 до приблизно +1.0. Степінь двійки як період означає, що індекс кута обертається природно при 8-бітному переповненні, а косинус стає синусом при додаванні 64:

```z80
; sin(angle) -- direct table lookup
    ld   h, high(sin_table)  ; 7T   table must be 256-byte aligned
    ld   l, a                ; 4T   A = angle (0-255)
    ld   a, (hl)             ; 7T   A = sin(angle)
                             ; --- 18 T-states total

; cos(angle) -- offset by quarter period
    add  a, 64               ; 7T   cos = sin + 90°
    ld   l, a                ; 4T
    ld   a, (hl)             ; 7T
```

Це ключове правило Raider: зберігай H один раз зі старшим байтом таблиці, тоді L -- це кут, і він обертається вільно.

---

## Порівняння підходів

| # | Підхід | Дані | Код | Разом | RAM | Макс. похибка | RMS |
|---|--------|------|-----|-------|-----|---------------|-----|
| 1 | Повна таблиця (256 байтів) | 256 | 0 | **256** | 0 | 0 | 0.00 |
| 2 | Чвертьхвильова таблиця | 65 | 21 | **86** | 0 | 0 | 0.00 |
| 3 | Параболічна апроксимація | 0 | 38 | **38** | 0 | 8 | 4.51 |
| 4 | Чвертьхвильова + дельти 2-го порядку | 18 | 45 | **63** | 64 | 0 | 0.00 |
| 5 | Апроксимація Бхаскари I | 0 | ~60 | **~60** | 0 | 1 | 0.49 |
| 5b | Бхаскара I + бітова карта корекції | 1 | ~80 | **~81** | 0 | 0 | 0.00 |
| 6 | Чвертьхвильова + упаковані 4-бітні дельти | 33 | 43 | **76** | 64 | 0 | 0.00 |
| 7 | Повні дельти 2-го порядку, 2-бітна упаковка | 66 | 30 | **96** | 256 | 0 | 0.00 |

Підходи поділяються на три категорії:

- **На основі таблиці підстановки** (RAM не потрібна): повна таблиця, чвертьхвильова таблиця
- **На основі генерації** (потребує RAM-буфер при запуску): підходи з дельтами та дельтами другого порядку
- **Наближені** (взагалі без таблиці): параболічний, Бхаскара I
- **Наближені + точна корекція**: Бхаскара I з бітовою картою корекції

---

## Підхід 1: Повна 256-байтна таблиця

Найпростіший та найшвидший. Попередньо обчисли всі 256 значень та вбудуй їх як дані.

```z80
; Lookup: 18 T-states, zero error
    ld   h, high(sin_table)
    ld   l, a
    ld   a, (hl)
```

**Вартість:** 256 байтів ROM.
**Швидкість:** 18 тактів (T-state) на пошук.
**Коли використовувати:** Завжди, якщо ти не займаєшся sizecoding. На 48K Spectrum з ~40K вільних 256 байтів -- ніщо. Це вибір за замовчуванням.

---

## Підхід 2: Чвертьхвильова таблиця

Синусоїда має чотириразову симетрію. Перший квадрант (0° до 90°, індекси 0 до 64) містить усю інформацію:

- **Другий квадрант** (65-128): дзеркало першого квадранту. `sin(128 - i) = sin(i)`.
- **Третій квадрант** (129-192): від'ємне першого квадранту. `sin(128 + i) = -sin(i)`.
- **Четвертий квадрант** (193-255): від'ємне дзеркало. `sin(256 - i) = -sin(i)`.

Зберігай лише 65 байтів (індекси від 0 до 64 включно), потім реконструюй:

```z80
; Quarter-wave sine lookup
; Input:  A = angle (0-255)
; Output: A = sin(angle), signed byte
; Uses:   HL, BC
; Table:  sin_quarter (65 bytes, 256-byte aligned)
;
qsin:
    ld   c, a               ; 4T   save original angle
    and  $7F                 ; 7T   fold to 0-127 (first half)
    cp   65                  ; 7T   past the peak?
    jr   c, .no_mirror       ; 12/7T
    ; Mirror: index = 128 - index
    neg                      ; 8T
    add  a, 128              ; 7T
.no_mirror:
    ld   h, high(sin_quarter) ; 7T
    ld   l, a                ; 4T
    ld   a, (hl)             ; 7T   A = |sin(angle)|
    bit  7, c                ; 8T   was original angle >= 128?
    ret  z                   ; 11/5T  no: positive half, done
    neg                      ; 8T   yes: negate for third/fourth quadrant
    ret                      ; 10T
```

**Вартість:** 65 байтів даних + ~21 байт коду = **86 байтів загалом**.
**Швидкість:** ~50-70 тактів (T-state) на пошук (залежить від квадранту).
**Похибка:** Нуль.
**Коли використовувати:** Демо з обмеженням розміру (256-байтні, 512-байтні інтро), де потрібні точні значення, але не можна витратити 256 байтів.

---

## Підхід 3: Параболічна апроксимація (метод Dark)

Від Dark / X-Trade, *Spectrum Expert* #01 (1997). Ідея: половина періоду косинуса виглядає як парабола. Наближення `y ~ 1 - 2(x/pi)^2` збігається добре. У цілочисельних термінах кожен напівперіод генерується як кусково-квадратична функція.

**Чистий код, нуль даних.** Цикл генерації потребує множення 8x8 та трохи логіки акумулятора -- приблизно 38 байтів.

Похибка обмежена: **максимальна абсолютна похибка = 8** (з діапазону 256 кроків), або приблизно **6,3%** повної шкали. RMS похибка 4.51.

Ось де парабола розходиться з істинним синусом (перший квадрант):

```
Index  True  Para  Diff
    0     0     0    +0
    4    12    15    -3
    8    25    30    -5
   12    37    43    -6
   16    49    56    -7
   20    60    67    -7
   24    71    77    -6
   28    81    87    -6
   32    88    93    -5
```

Парабола стабільно "попереду" -- вона зростає швидше біля нуля та більш плоска біля вершини. Максимальне розходження: **8 одиниць при індексі 17** (приблизно 24°).

**Коли використовувати:** Екстремальний sizecoding (64-байтні інтро, компактні завантажувачі). Плазми, прості скролери та ефекти хвилювання, де око не розрізняє точну кривизну від наближеної. Не підходить для плавного обертання або точного каркасного 3D.

---

## Підхід 4: Кодування дельтами другого порядку (глибокий трюк)

Це найцікавіший з математичної точки зору підхід і найкомпактніше точне представлення.

### Ключова ідея

Друга похідна sin(x) дорівнює -sin(x). При 8-бітній цілочисельній точності, квантуючи до знакових байтів, друга скінченна різниця таблиці синусів має чудову властивість: **кожне значення є рівно -1, 0 або +1**.

```
True sine:      [0,  3,  6,  9, 12, 16, 19, 22, 25, ...]
First diff:     [3,  3,  3,  3,  4,  3,  3,  3,  3, ...]
Second diff:    [0,  0,  0,  1, -1,  0,  0,  0,  0, ...]
```

Три значення. Два біти на запис. Це не наближення -- це точно. Математична причина: `d^2(sin)/dx^2` -- це гладка функція з малою амплітудою, і при 256 записах на період з 8-бітною амплітудою дискретна друга похідна ніколи не перевищує +/-1.

### Повна таблиця через 2-бітні дельти другого порядку

Зберігаємо: початкове значення (1 байт), початкову дельту (1 байт), потім 254 дельти другого порядку, упаковані по 2 біти кожна (64 байти). **Загалом: 66 байтів даних + ~30 байтів коду декодування = 96 байтів.** Потрібно 256 байтів RAM для декодування.

### Чвертьхвильова через 2-бітні дельти другого порядку

Комбінуй з чвертьхвильовою симетрією: зберігай лише перші 64 дельти другого порядку. **Загалом: 18 байтів даних + ~45 байтів коду декодування = 63 байти.** Потрібно 64 байти RAM.

Це **найменше точне представлення**: 63 байти загалом для ідеальної 256-записної таблиці синусів.

```z80
; Decode quarter-wave from 2-bit second-order deltas
; sin_d2_data: 16 bytes of packed 2-bit deltas (64 entries)
; sin_buffer:  64 bytes RAM for decoded quarter-wave
;
decode_quarter_d2:
    ld   hl, sin_buffer      ; destination
    ld   de, sin_d2_data     ; source (packed d2 values)
    xor  a
    ld   (hl), a             ; sin[0] = 0
    inc  hl
    ld   b, a                ; b = current delta (starts at 0)
    ld   c, 63               ; 63 more entries to decode

.loop:
    ; Unpack 2-bit d2 value
    ; 00 = 0, 01 = +1, 11 = -1 (10 unused)
    rr   (de)                ; shift out 2 bits
    rr   (de)
    ; ... (bit extraction logic)

    ; Apply: delta += d2, value += delta
    add  a, b               ; new delta
    ld   b, a
    ld   a, (hl-1)          ; previous value (pseudocode)
    add  a, b
    ld   (hl), a
    inc  hl
    dec  c
    jr   nz, .loop

    ; Now use qsin() lookup on sin_buffer
```

Декодування виконується один раз при запуску. Після цього використовуй підпрограму чвертьхвильового пошуку з Підходу 2 на декодованому буфері.

**Коли використовувати:** Демо з обмеженням розміру (128-байтні, 256-байтні інтро), де потрібні точні значення, можна дозволити 64 байти RAM та є коротка фаза запуску. Цикл декодування виконується менш ніж за 2 000 тактів (T-state) -- непомітно.

> **Врізка: Чому не 1 біт на дельту?**
>
> Інтуїтивне заперечення: чвертьхвильовий синус (0° до 90°) монотонно зростає. Перші різниці d1 завжди невід'ємні. У неперервній математиці друга похідна синуса в першому квадранті завжди від'ємна (крива опукла вниз). Тому d2 має бути <= 0, тобто потрібні лише {-1, 0} -- один біт на запис.
>
> Інтуїція правильна для неперервного синуса, але хибна для квантованого цілочисельного синуса. При 8-бітній точності округлення створює випадкові підйоми в d1:
>
> ```
> d1:  3, 3, 3, 3, 4, 3, 3, ...  (that 4 is a rounding correction)
> d2:  0, 0, 0, +1, -1, 0, ...   (the +1 is load-bearing)
> ```
>
> Існує 12 таких записів +1 з 63. Якщо їх подавити (обмежити d1 до монотонно неспадної), похибки *накопичуються*: до індексу 64 пік досягає лише 108 замість 127 -- максимальна похибка 19, гірша за параболічну апроксимацію. Ці корекції +1 несуть саме ту інформацію, яка потрібна для потрапляння в правильні цілочисельні значення. Їх не можна відкинути.
>
> Змінний префіксний код (0 -> 1 біт, +/-1 -> 2 біти) заощаджує 4 байти даних порівняно з фіксованим 2-бітним кодуванням, але коштує ~15 додаткових байтів логіки декодування Z80. Чистий програш. Фіксоване 2-бітне кодування -- практичний оптимум.

> **Врізка: Чому парабола + корекція не допомагає**
>
> Ще одна інтуїтивна ідея: згенерувати параболічну апроксимацію (38 байтів коду, максимальна похибка 8), потім зберігати невелику таблицю корекції для виправлення до точних значень. Корекції в діапазоні від -8 до +8, тому мали б добре стискатися.
>
> Корекції *дійсно* добре стискаються -- їхні перші різниці рівно {-1, 0, +1}, упаковуючись по 2 біти на запис. Але це не збіг. Парабола -- квадратична функція з постійною другою похідною. Тому:
>
> - `d2(sin)` in {-1, 0, +1} -- друга похідна синуса при цілочисельній точності
> - `d2(para)` in {-1, 0, +1} -- друга похідна параболи (майже постійна)
> - `d1(correction)` = `d1(sin) - d1(para)` in {-1, 0, +1} -- **та сама ентропія**
>
> Дельти корекції мають *точно таку ж структуру*, як прямі d2 синуса. Але параболічний шлях додає 38 байтів коду генерації, плюс ~20 байтів для застосування корекцій. Загалом: ~96 байтів проти 63 байтів для прямого d2-кодування.
>
> Парабола видаляє гладку (низькочастотну) компоненту синуса -- але 2-бітне d2-кодування вже ідеально обробляє гладкі дані. Параболі нічого не залишається додати, чого d2 вже не охоплює. Код генерації -- чисті накладні витрати.

---

## Підхід 5: Апроксимація Бхаскари I (VII століття)

Найнесподіваніший учасник нашого порівняння походить від індійського математика VII століття Бхаскари I. Його раціональне наближення до синуса, опубліковане близько 629 р. н.е., досягає **максимальної похибки лише 1 одиниця** при 8-бітній точності -- значно кращої за параболічну апроксимацію (максимальна похибка 8) та майже точної.

### Формула

Для кута x в радіанах (0 до pi):

```
sin(x) ~ 16x(pi - x) / (5pi^2 - 4x(pi - x))
```

У нашій цілочисельній області (кут 0-64 для першого квадранту, амплітуда 0-127):

```
sin(i) ~ 127 * 16i(64 - i) / (5 * 64^2 - 4 * i(64 - i))
       = 127 * 16i(64 - i) / (20480 - 4i(64 - i))
```

Формула -- це відношення двох квадратичних функцій. На Z80 для цього потрібно множення 8x8 та 16-бітне ділення -- підпрограми, які багато демо вже включають для 3D-проєкції або текстурного маппінгу.

### Точність

Серед 65 записів першого квадранту Бхаскара I збігається з точним цілочисельним синусом скрізь, крім **8 позицій** (з 65), де він відрізняється рівно на +/-1:

```
Index  True  Bhaskara  Diff
    4    12        13    -1
   17    51        52    -1
   28    81        80    +1
   31    88        87    +1
   40   106       105    +1
   43   111       110    +1
   50   120       119    +1
   52   122       121    +1
```

Лише 8 позицій відрізняються, всі рівно на +/-1. Похибки розділені: 2 записи, де Бхаскара перевищує (біля початку), 6 де занижує (біля вершини). Вісім корекцій загалом, які кодуються як однобайтна бітова карта.

### Реалізація на Z80

Реалізація потребує:
- Підпрограму множення 8x8->16 (~20 байтів, ймовірно вже доступна)
- Підпрограму ділення 16/16->16 (~30 байтів, ймовірно вже доступна)
- Обгортку Бхаскари (~25 байтів)
- Логіку чвертьхвильового згортання (~15 байтів, спільну з Підходом 2)

Якщо в твоєму демо вже є підпрограми множення та ділення, маргінальна вартість -- приблизно **25 байтів** для функції синуса з максимальною похибкою 1.

Якщо потрібні підпрограми з нуля, загалом приблизно **60 байтів** коду з нулем байтів даних. Це конкурує з підходом d2-дельт (63 байти), але не потребує RAM-буфера та фази декодування при запуску. Компроміс: 1 одиниця похибки проти ідеальної точності.

### Бхаскара I + бітова карта корекції (точна)

Щоб усунути цю останню одиницю похибки, зберігай 8 позицій корекції як бітову карту. Оскільки корекції симетричні (перші 4 потребують +1, останні 4 потребують -1), достатньо одного байту:

```z80
; After computing Bhaskara approximation in A, index in C:
    push af
    ld   a, c
    ; Look up correction from bitmap (8 specific indices)
    ; ... (~20 bytes of correction logic)
    pop  af
    add  a, correction      ; ±1 or 0
```

Загалом: ~80 байтів коду + 1 байт даних = **~81 байт**, нуль RAM, нуль при запуску, точні значення. Дорожче за d2-дельти (63B), але уникає RAM-буфера та декодування при запуску.

### Коли використовувати Бхаскару I

- **У тебе вже є підпрограми множення/ділення:** ~25 байтів додатково, максимальна похибка 1. Складно побити.
- **Немає RAM для буфера декодування:** На відміну від d2-дельт, Бхаскара обчислює на льоту.
- **Потрібна генерація в реальному часі:** Кожне значення обчислюється незалежно -- немає послідовної залежності, тому можна обчислити sin(будь-який кут) без попереднього декодування таблиці.
- **Похибка +/-1 прийнятна:** Для скролерів, плазм та більшості візуальних ефектів різниця між максимальною похибкою 1 та максимальною похибкою 0 буквально непомітна.

> **Історична примітка:** Формула Бхаскари I випередила європейські тригонометричні таблиці майже на тисячоліття. Те, що раціональне наближення VII століття досягає максимальної похибки 1 на 8-бітному процесорі 1980-х -- це прекрасне зіткнення математичної елегантності та інженерних обмежень. Формула була опублікована в *Mahabhaskariya* (629 р. н.е.), коментарі до астрономічних методів Аріабхати.

---

## Практичні рекомендації

Кожен підхід на основі генерації створює таблицю підстановки при запуску. Після цього вартість виконання ідентична: `LD H, high(table) / LD L, A / LD A, (HL)` = **18 тактів (T-state)** для 256-байтної таблиці, або підпрограма чвертьхвильового згортання за **50-70 тактів (T-state)** для 64-байтного буфера. Стовпець "Вартість ROM" нижче -- це те, що важливо для sizecoding -- загальна кількість байтів, яку твій підхід займає в бінарному файлі.

| Використання | Підхід | Вартість ROM | RAM | Ініц. | Пошук | Похибка |
|--------------|--------|-------------|-----|-------|-------|---------|
| **Звичайне демо / гра** | Повна 256-байтна таблиця | 256B | 0 | немає | 18 T | точно |
| **512-байтне інтро** | Чвертьхвильова таблиця | 86B | 0 | немає | 50-70 T | точно |
| **256-байтне інтро** | Чвертьхвильова + d2-дельти | 63B | 64B | ~2K T | 50-70 T | точно |
| **Є множення/ділення** | Бхаскара I (генерація в LUT) | ~25B додатково | 256B | ~80K T | 18 T | +/-1 макс |
| **128-байтне інтро** | Параболічна (генерація в LUT) | 38B | 256B | ~10K T | 18 T | +/-8 макс |

### Дерево прийняття рішень

1. **Маєш 256 байтів вільних?** Використовуй повну таблицю. Не ускладнюй. `LD L,A / LD A,(HL)` за 18 тактів (T-state) не можна побити.

2. **Обмежений розмір, але потрібна точність?** Чвертьхвильова таблиця за 86 байтів. RAM не потрібна, фаза запуску відсутня. Пошук 50-70 тактів (T-state) (логіка згортання).

3. **Екстремальне обмеження розміру, потрібні точні значення?** Чвертьхвильова + декодування дельтами другого порядку за 63 байти. Декодуй один раз при запуску в 64-байтний чвертьбуфер, потім використовуй ту саму підпрограму згортання.

4. **Вже є множення/ділення?** Бхаскара I за ~25 байтів додатково. Згенеруй повну 256-байтну LUT при запуску, потім насолоджуйся пошуками за 18 тактів (T-state) з максимальною похибкою 1.

5. **Екстремальне обмеження розміру, наближення прийнятне?** Параболічна за 38 байтів, нуль даних. Згенеруй в 256-байтну LUT при запуску. Максимальна похибка 8, добре для плазм та хвилювань.

### Що не працює

- **Парабола + таблиця корекції** (123 байти, точна): гірше, ніж просто чвертьхвильова таблиця (86 байтів). Накладні витрати на обчислення параболи *та* пошук корекції нівелюють мету.

- **Дельта + RLE** (100-219 байтів): дельти синуса змінюються плавно, а не повторюються серіями. RLE розроблена для даних з довгими постійними серіями -- синус має неправильну форму для неї.

- **Повна таблиця з дельта-кодуванням** (152-271 байт): використовує *більше* загальних байтів, ніж сира 256-байтна таблиця. Дельта-кодування допомагає лише коли дельти значно менші за оригінальні значення; дельти синуса вже обмежені до +/-4, але їх все одно потрібно 256.

---

## Заповіді Raider

У коментарях на Hype до аналізу *Illusion* від Introspec ветеран-кодер Raider виклав десятиліття колективної мудрості в неформальні "заповіді" для проєктування таблиць синусів:

1. **256 записів на повний період.** Індекс кута обертається при 8-бітному переповненні. Модульна арифметика не потрібна.
2. **Знакові байти: -128 до +127.** Відповідає знаковій арифметиці Z80.
3. **Вирівняй таблицю по сторінці.** Розмісти її на 256-байтній межі, щоб H був постійним. `LD H,high(table)` один раз, потім `LD L,angle / LD A,(HL)` назавжди.
4. **Косинус -- це синус + 64.** Одна інструкція `ADD A,64`.
5. **Синус від (angle + 128) = -синус(angle).** `NEG` перевертає знак. Використовуй це для фазових зсувів.
6. **Не обчислюй синус під час виконання**, якщо ти не займаєшся sizecoding. Пошук у таблиці завжди швидший.
7. **Тримай амплітуду як степінь двійки** (64, 127, 128), щоб множення було зсувом.
8. **Чвертьхвильова симетрія** заощаджує 75% зберігання, коли кожен байт має значення.
9. **Перевіряй на межах.** Індекс 0 має бути рівно 0. Індекс 64 має бути максимальним додатним значенням (+127). Індекс 128 має бути рівно 0. Індекс 192 має бути максимальним від'ємним значенням (-128 або -127, залежно від твоєї конвенції).

Ці правила відображають десятиліття досвіду. Дотримуйся їх, і твої таблиці синусів будуть швидкими, компактними та правильними.

---

## Довідник: Повна 256-байтна таблиця

Для зручності, ось стандартна таблиця синусів (256 записів, знакова, період = 256, амплітуда +/-127):

```z80
; 256-byte sine table, page-aligned
; sin(0) = 0, sin(64) = +127, sin(128) = 0, sin(192) = -128
;
    ALIGN 256
sin_table:
    DB    0,   3,   6,   9,  12,  16,  19,  22
    DB   25,  28,  31,  34,  37,  40,  43,  46
    DB   49,  51,  54,  57,  60,  63,  65,  68
    DB   71,  73,  76,  78,  81,  83,  85,  88
    DB   90,  92,  94,  96,  98, 100, 102, 104
    DB  106, 108, 109, 111, 112, 114, 115, 117
    DB  118, 119, 120, 121, 122, 123, 124, 124
    DB  125, 126, 126, 127, 127, 127, 127, 127
    DB  127, 127, 127, 127, 127, 127, 126, 126
    DB  125, 124, 124, 123, 122, 121, 120, 119
    DB  118, 117, 115, 114, 112, 111, 109, 108
    DB  106, 104, 102, 100,  98,  96,  94,  92
    DB   90,  88,  85,  83,  81,  78,  76,  73
    DB   71,  68,  65,  63,  60,  57,  54,  51
    DB   49,  46,  43,  40,  37,  34,  31,  28
    DB   25,  22,  19,  16,  12,   9,   6,   3
    DB    0,  -3,  -6,  -9, -12, -16, -19, -22
    DB  -25, -28, -31, -34, -37, -40, -43, -46
    DB  -49, -51, -54, -57, -60, -63, -65, -68
    DB  -71, -73, -76, -78, -81, -83, -85, -88
    DB  -90, -92, -94, -96, -98,-100,-102,-104
    DB -106,-108,-109,-111,-112,-114,-115,-117
    DB -118,-119,-120,-121,-122,-123,-124,-124
    DB -125,-126,-126,-127,-127,-127,-127,-127
    DB -128,-127,-127,-127,-127,-127,-126,-126
    DB -125,-124,-124,-123,-122,-121,-120,-119
    DB -118,-117,-115,-114,-112,-111,-109,-108
    DB -106,-104,-102,-100, -98, -96, -94, -92
    DB  -90, -88, -85, -83, -81, -78, -76, -73
    DB  -71, -68, -65, -63, -60, -57, -54, -51
    DB  -49, -46, -43, -40, -37, -34, -31, -28
    DB  -25, -22, -19, -16, -12,  -9,  -6,  -3
```

Скопіюй, встав, зібрай, використовуй.

---

> **Джерела:** Dark / X-Trade "Programming Algorithms" (Spectrum Expert #01, 1997) для параболічної апроксимації; Бхаскара I, *Mahabhaskariya* (629 р. н.е.) для раціональної апроксимації; Raider (коментарі на Hype, 2017) для принципів проєктування таблиць синусів; `verify/sine_compare.py` для порівняльного аналізу
