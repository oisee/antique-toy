# Додаток A: Короткий довідник інструкцій Z80

> *"Інструкція, яка мала б зайняти 7 тактів (T-state), може зайняти 13, якщо потрапить у найгіршу фазу циклу спірної пам'яті."*
> -- Розділ 1

Це не повний посібник по Z80. Це довідкова картка для програмістів демосцени та ігор на ZX Spectrum і Agon Light 2 -- інструкції, якими ти дійсно користуєшся, таймінги, які потрібно знати напам'ять, і патерни, що заощаджують такти (T-state) у внутрішніх циклах.

Всі значення тактів (T-state) наведені для **таймінгу Pentagon** (без спірної пам'яті). Кількість байтів -- це довжина кодування інструкції. Стовпці прапорців показують: **S** (знак), **Z** (нуль), **H** (напівперенесення), **P/V** (парність/переповнення), **N** (віднімання), **C** (перенесення). Тире означає "не змінюється"; крапка -- "невизначено".

---

## 8-бітні інструкції завантаження

| Інструкція | Байти | Такти (T-state) | Прапорці | Примітки |
|------------|-------|-----------------|----------|----------|
| `LD r,r'` | 1 | 4 | ------ | Найшвидша інструкція. r,r' = A,B,C,D,E,H,L |
| `LD r,n` | 2 | 7 | ------ | Безпосереднє завантаження |
| `LD r,(HL)` | 1 | 7 | ------ | Читання з пам'яті через HL |
| `LD (HL),r` | 1 | 7 | ------ | Запис у пам'ять через HL |
| `LD (HL),n` | 2 | 10 | ------ | Безпосереднє значення в пам'ять |
| `LD A,(BC)` | 1 | 7 | ------ | |
| `LD A,(DE)` | 1 | 7 | ------ | |
| `LD (BC),A` | 1 | 7 | ------ | |
| `LD (DE),A` | 1 | 7 | ------ | |
| `LD A,(nn)` | 3 | 13 | ------ | Абсолютна адреса |
| `LD (nn),A` | 3 | 13 | ------ | Абсолютна адреса |
| `LD r,(IX+d)` | 3 | 19 | ------ | Індексне. Дороге -- уникай у внутрішніх циклах |
| `LD (IX+d),r` | 3 | 19 | ------ | Індексне |
| `LD (IX+d),n` | 4 | 23 | ------ | Індексне безпосереднє |
| `LD A,I` | 2 | 9 | SZ0P0- | P/V = IFF2 |
| `LD A,R` | 2 | 9 | SZ0P0- | P/V = IFF2; R = лічильник оновлення |

---

## 16-бітні інструкції завантаження

| Інструкція | Байти | Такти (T-state) | Прапорці | Примітки |
|------------|-------|-----------------|----------|----------|
| `LD rr,nn` | 3 | 10 | ------ | rr = BC, DE, HL, SP |
| `LD HL,(nn)` | 3 | 16 | ------ | |
| `LD (nn),HL` | 3 | 16 | ------ | |
| `LD rr,(nn)` | 4 | 20 | ------ | rr = BC, DE, SP (префікс ED) |
| `LD (nn),rr` | 4 | 20 | ------ | rr = BC, DE, SP (префікс ED) |
| `LD SP,HL` | 1 | 6 | ------ | Встановлення вказівника стеку |
| `LD SP,IX` | 2 | 10 | ------ | |
| `PUSH rr` | 1 | 11 | ------ | rr = AF, BC, DE, HL. **5,5T на байт** |
| `POP rr` | 1 | 10 | ------ | **5T на байт** -- найшвидше 2-байтне читання |
| `PUSH IX` | 2 | 15 | ------ | |
| `POP IX` | 2 | 14 | ------ | |

---

## 8-бітна арифметика та логіка

| Інструкція | Байти | Такти (T-state) | Прапорці | Примітки |
|------------|-------|-----------------|----------|----------|
| `ADD A,r` | 1 | 4 | SZ.V0C | |
| `ADD A,n` | 2 | 7 | SZ.V0C | |
| `ADD A,(HL)` | 1 | 7 | SZ.V0C | |
| `ADC A,r` | 1 | 4 | SZ.V0C | Додавання з перенесенням |
| `ADC A,n` | 2 | 7 | SZ.V0C | |
| `SUB r` | 1 | 4 | SZ.V1C | |
| `SUB n` | 2 | 7 | SZ.V1C | |
| `SUB (HL)` | 1 | 7 | SZ.V1C | |
| `SBC A,r` | 1 | 4 | SZ.V1C | Віднімання з перенесенням |
| `CP r` | 1 | 4 | SZ.V1C | Порівняння (SUB без збереження результату) |
| `CP n` | 2 | 7 | SZ.V1C | |
| `CP (HL)` | 1 | 7 | SZ.V1C | |
| `AND r` | 1 | 4 | SZ1P00 | H завжди встановлено, C завжди скинуто |
| `AND n` | 2 | 7 | SZ1P00 | |
| `OR r` | 1 | 4 | SZ0P00 | Скидає H та C |
| `OR n` | 2 | 7 | SZ0P00 | |
| `XOR r` | 1 | 4 | SZ0P00 | `XOR A` = обнулити A за 4T/1B (проти `LD A,0` = 7T/2B) |
| `XOR n` | 2 | 7 | SZ0P00 | |
| `INC r` | 1 | 4 | SZ.V0- | **Не** впливає на перенесення |
| `DEC r` | 1 | 4 | SZ.V1- | **Не** впливає на перенесення |
| `INC (HL)` | 1 | 11 | SZ.V0- | Читання-модифікація-запис |
| `DEC (HL)` | 1 | 11 | SZ.V1- | Читання-модифікація-запис |
| `NEG` | 2 | 8 | SZ.V1C | A = 0 - A (доповнення до двох) |
| `DAA` | 1 | 4 | SZ.P-C | BCD-корекція -- рідко використовується в демо |
| `CPL` | 1 | 4 | --1-1- | A = NOT A (доповнення до одиниці) |
| `SCF` | 1 | 4 | --0-00 | Встановити прапорець перенесення. N,H скинуті. Нова поведінка на CMOS |
| `CCF` | 1 | 4 | --.-0. | Інвертувати перенесення. H = старий C |

---

## 16-бітна арифметика

| Інструкція | Байти | Такти (T-state) | Прапорці | Примітки |
|------------|-------|-----------------|----------|----------|
| `ADD HL,rr` | 1 | 11 | --.?0C | rr = BC, DE, HL, SP. Впливає тільки на H, N, C |
| `ADC HL,rr` | 2 | 15 | SZ.V0C | Повний набір прапорців |
| `SBC HL,rr` | 2 | 15 | SZ.V1C | Повний набір прапорців |
| `INC rr` | 1 | 6 | ------ | Прапорці не змінюються |
| `DEC rr` | 1 | 6 | ------ | Прапорці не змінюються |
| `ADD IX,rr` | 2 | 15 | --.?0C | rr = BC, DE, IX, SP |

**Ключовий момент:** `INC rr` та `DEC rr` **не** встановлюють прапорець нуля. Не можна використовувати `DEC BC / JR NZ` як 16-бітний лічильник циклу. Використовуй `DEC B / JR NZ` для 8-бітних циклів з `DJNZ` або перевіряй BC явно.

---

## Зсуви та обертання

| Інструкція | Байти | Такти (T-state) | Прапорці | Примітки |
|------------|-------|-----------------|----------|----------|
| `RLCA` | 1 | 4 | --0-0C | Обертання A вліво, біт 7 у перенесення та біт 0 |
| `RRCA` | 1 | 4 | --0-0C | Обертання A вправо, біт 0 у перенесення та біт 7 |
| `RLA` | 1 | 4 | --0-0C | Обертання A вліво через перенесення |
| `RRA` | 1 | 4 | --0-0C | Обертання A вправо через перенесення. **Ключова для циклів множення** |
| `RLC r` | 2 | 8 | SZ0P0C | CB-префікс. Повний набір прапорців |
| `RRC r` | 2 | 8 | SZ0P0C | |
| `RL r` | 2 | 8 | SZ0P0C | Обертання вліво через перенесення |
| `RR r` | 2 | 8 | SZ0P0C | Обертання вправо через перенесення |
| `SLA r` | 2 | 8 | SZ0P0C | Арифметичний зсув вліво. Біт 0 = 0 |
| `SRA r` | 2 | 8 | SZ0P0C | Арифметичний зсув вправо. Біт 7 зберігається (знакове розширення) |
| `SRL r` | 2 | 8 | SZ0P0C | Логічний зсув вправо. Біт 7 = 0 |
| `RLC (HL)` | 2 | 15 | SZ0P0C | Читання-модифікація-запис |
| `RL (HL)` | 2 | 15 | SZ0P0C | Скролінг піксельних даних вліво |
| `RR (HL)` | 2 | 15 | SZ0P0C | Скролінг піксельних даних вправо |
| `SLA (HL)` | 2 | 15 | SZ0P0C | |
| `SRL (HL)` | 2 | 15 | SZ0P0C | |
| `RLD` | 2 | 18 | SZ0P0- | Обертання ніблів (HL) вліво через A. Корисне для ніблової графіки |
| `RRD` | 2 | 18 | SZ0P0- | Обертання ніблів (HL) вправо через A |

**Примітка для демосцени:** `RLA`/`RRA` (4T, 1 байт) впливають лише на перенесення та біти 3,5 регістра F. CB-префіксні версії `RL r`/`RR r` (8T, 2 байти) встановлюють усі прапорці. У циклах множення акумуляторні версії заощаджують половину вартості.

---

## Бітові маніпуляції

| Інструкція | Байти | Такти (T-state) | Прапорці | Примітки |
|------------|-------|-----------------|----------|----------|
| `BIT b,r` | 2 | 8 | .Z1.0- | Перевірити біт b регістра |
| `BIT b,(HL)` | 2 | 12 | .Z1.0- | Перевірити біт b пам'яті |
| `SET b,r` | 2 | 8 | ------ | Встановити біт b регістра |
| `SET b,(HL)` | 2 | 15 | ------ | Встановити біт b пам'яті. **Використовується при малюванні ліній** |
| `RES b,r` | 2 | 8 | ------ | Скинути біт b регістра |
| `RES b,(HL)` | 2 | 15 | ------ | Скинути біт b пам'яті |

---

## Переходи, виклики, повернення

| Інструкція | Байти | Такти (T-state) | Прапорці | Примітки |
|------------|-------|-----------------|----------|----------|
| `JP nn` | 3 | 10 | ------ | Абсолютний перехід |
| `JP cc,nn` | 3 | 10 | ------ | Умовний: NZ, Z, NC, C, PO, PE, P, M. **Однакова швидкість при виконанні та невиконанні** |
| `JR e` | 2 | 12 | ------ | Відносний перехід (-128 до +127) |
| `JR cc,e` | 2 | 12/7 | ------ | cc = тільки NZ, Z, NC, C. **7T якщо не виконано** |
| `JP (HL)` | 1 | 4 | ------ | Перехід за адресою в HL. Найшвидший непрямий перехід |
| `JP (IX)` | 2 | 8 | ------ | Перехід за адресою в IX |
| `DJNZ e` | 2 | 13/8 | ------ | Dec B, перехід якщо NZ. **13T виконано, 8T не виконано** |
| `CALL nn` | 3 | 17 | ------ | Push PC, перехід до nn |
| `CALL cc,nn` | 3 | 17/10 | ------ | 10T якщо не виконано |
| `RET` | 1 | 10 | ------ | Pop PC. **Використовується для RET-ланцюжок диспетчеризації** |
| `RET cc` | 1 | 11/5 | ------ | 5T якщо не виконано |
| `RST p` | 1 | 11 | ------ | Виклик на $00,$08,$10,$18,$20,$28,$30,$38 |

**Ключові порівняння для диспетчеризації:**

| Метод | Такти (T-state) | Байти |
|-------|-----------------|-------|
| `CALL nn` | 17 | 3 |
| `RET` (як диспетчеризація в RET-ланцюжку) | 10 | 1 |
| `JP (HL)` | 4 | 1 |
| `JP nn` | 10 | 3 |

---

## Інструкції введення/виведення

| Інструкція | Байти | Такти (T-state) | Прапорці | Примітки |
|------------|-------|-----------------|----------|----------|
| `OUT (n),A` | 2 | 11 | ------ | Адреса порту = `(A << 8) | n`. Бордюр: `OUT ($FE),A` |
| `IN A,(n)` | 2 | 11 | ------ | Адреса порту = `(A << 8) | n`. Клавіатура: `IN A,($FE)` |
| `OUT (C),r` | 2 | 12 | ------ | Адреса порту = BC. **Запис регістра AY** |
| `IN r,(C)` | 2 | 12 | SZ0P0- | Адреса порту = BC. Встановлює прапорці |
| `OUTI` | 2 | 16 | .Z..1. | Out (HL) до порту (C), inc HL, dec B |
| `OTIR` | 2 | 21/16 | 01..1. | Повтор OUTI поки B=0. 16T на останньому |
| `OUTD` | 2 | 16 | .Z..1. | Out (HL) до порту (C), inc HL, dec B |

**Адреси портів AY-3-8910 на ZX Spectrum 128K:**

| Порт | Адреса | Призначення |
|------|--------|-------------|
| Вибір регістра | `$FFFD` | `LD BC,$FFFD : OUT (C),A` |
| Запис даних | `$BFFD` | `LD B,$BF : OUT (C),r` |
| Читання даних | `$FFFD` | `IN A,(C)` |

Типова послідовність запису регістра AY (24T + накладні витрати):

```z80
    ld   bc, $FFFD      ; 10T  AY register select port
    out  (c), a          ; 12T  select register number (in A)
    ld   b, $BF          ;  7T  switch to data port $BFFD
    out  (c), e          ; 12T  write value (in E)
                         ; --- 41T total
```

---

## Блочні інструкції

| Інструкція | Байти | Такти (T-state) | Прапорці | Примітки |
|------------|-------|-----------------|----------|----------|
| `LDI` | 2 | 16 | --0.0- | (DE) = (HL), inc HL, inc DE, dec BC. P/V = (BC != 0) |
| `LDIR` | 2 | 21/16 | --000- | Повтор LDI. 21T на байт, 16T останній байт |
| `LDD` | 2 | 16 | --0.0- | (DE) = (HL), dec HL, dec DE, dec BC |
| `LDDR` | 2 | 21/16 | --000- | Повтор LDD. 21T на байт, 16T останній байт |
| `CPI` | 2 | 16 | SZ.?1- | Порівняти A з (HL), inc HL, dec BC |
| `CPIR` | 2 | 21/16 | SZ.?1- | Повтор CPI. Зупиняється при збігу або BC=0 |
| `CPD` | 2 | 16 | SZ.?1- | Порівняти A з (HL), dec HL, dec BC |
| `CPDR` | 2 | 21/16 | SZ.?1- | Повтор CPD |

**Вартість LDI проти LDIR на байт:**

| Метод | На байт | 256 байтів | 32 байти | Виграш |
|-------|---------|------------|----------|--------|
| LDIR | 21T (16T останній) | 5 371T | 672T | -- |
| LDI-ланцюжок | 16T | 4 096T | 512T | На 24% швидше |

Розгорнутий LDI-ланцюжок коштує 2 байти на LDI (`$ED $A0`), але заощаджує 5T на байт -- на 24% швидше за LDIR. Дивись Розділ 3 для арифметики точки входу з LDI-ланцюжками.

---

## Обмін та інше

| Інструкція | Байти | Такти (T-state) | Прапорці | Примітки |
|------------|-------|-----------------|----------|----------|
| `EX DE,HL` | 1 | 4 | ------ | Обміняти DE та HL. **Безкоштовний обмін вказівників** |
| `EX AF,AF'` | 1 | 4 | ------ | Обміняти AF з тіньовим AF' |
| `EXX` | 1 | 4 | ------ | Обміняти BC,DE,HL з BC',DE',HL'. **6 регістрів за 4T** |
| `EX (SP),HL` | 1 | 19 | ------ | Обміняти HL з вершиною стеку. Корисне для передачі параметрів |
| `EX (SP),IX` | 2 | 23 | ------ | Обміняти IX з вершиною стеку |
| `DI` | 1 | 4 | ------ | Заборонити переривання. **Обов'язково перед трюками зі стеком** |
| `EI` | 1 | 4 | ------ | Дозволити переривання. Відкладено на одну інструкцію |
| `HALT` | 1 | 4+ | ------ | Чекати переривання. Інструкція синхронізації з кадром |
| `NOP` | 1 | 4 | ------ | Заповнення, таймінг |
| `IM 1` | 2 | 8 | ------ | Режим переривань 1 (RST $38). Стандартний режим Spectrum |
| `IM 2` | 2 | 8 | ------ | Режим переривань 2. Використовує регістр I як старший байт таблиці векторів |

---

## "Швидкі" інструкції демосцени

Це найдешевші інструкції у кожній категорії -- будівельні блоки кожного оптимізованого внутрішнього циклу.

### Найшвидше переміщення регістр-регістр

`LD r,r'` -- **4T, 1 байт**. Мінімальна вартість будь-якої інструкції Z80. Включає `LD A,A` (фактично NOP, що не впливає на прапорці).

### Найшвидший спосіб обнулити регістр

`XOR A` -- **4T, 1 байт**. Встановлює A в нуль, встановлює прапорець нуля, скидає перенесення. Порівняй з `LD A,0` -- 7T/2 байти. Завжди використовуй `XOR A`, якщо тобі не потрібно зберегти прапорці.

### Найшвидше читання з пам'яті

`LD A,(HL)` -- **7T, 1 байт**. Мінімальна вартість будь-якого читання з пам'яті. Інші джерела (`LD A,(BC)`, `LD A,(DE)`) також 7T/1 байт, але HL -- єдиний вказівник, який підтримує `LD r,(HL)` для всіх регістрів.

### Найшвидший запис у пам'ять

`LD (HL),r` -- **7T, 1 байт**. Нарівні з читанням. Запис через вказівник BC або DE (`LD (BC),A`, `LD (DE),A`) також 7T/1B, але працює тільки з A.

### Найшвидший 2-байтний запис

`PUSH rr` -- **11T, 1 байт** за 2 байти = **5,5T на байт**. Найшвидший спосіб запису даних у пам'ять, але тільки туди, куди вказує SP (вниз). Потребує DI та перехоплення вказівника стеку. Дивись Розділ 3.

### Найшвидше 2-байтне читання

`POP rr` -- **10T, 1 байт** за 2 байти = **5T на байт**. Навіть швидше за PUSH для читання. Використовуй з SP, що вказує на таблицю даних, для надшвидких пошуків.

### Найшвидше блочне копіювання

| Метод | На байт | Примітки |
|-------|---------|----------|
| Пара `PUSH/POP` | 5,25T | Запис: 5,5T, Читання: 5T. Але потребує перехоплення SP |
| `LDI` (розгорнутий ланцюжок) | 16T | Без налаштування на байт. На 24% швидше за LDIR |
| `LDIR` | 21T | Одна інструкція, але повільна на байт |
| `LD (HL),r` + `INC HL` | 13T | Тіло ручного циклу (без лічильника) |
| `LD (HL),r` + `INC L` | 11T | Працює тільки в межах 256-байтної сторінки |

### Найшвидше введення/виведення

`OUT (n),A` -- **11T, 2 байти**. Для фіксованих адрес портів (бордюр тощо). Для змінних портів (AY), `OUT (C),r` за 12T/2 байти -- єдиний варіант.

### Найшвидший обмін вказівників

`EX DE,HL` -- **4T, 1 байт**. Обмін вмісту DE та HL миттєво. Жоден інший обмін регістрів не є таким дешевим. `EXX` також 4T/1 байт, але обмінює всі три пари одночасно.

### Найшвидший умовний цикл

`DJNZ e` -- **13T виконано, 8T не виконано, 2 байти**. Зменшує B та здійснює перехід. Порівняй з `DEC B / JR NZ,e` -- 4+12 = 16T/3 байти. DJNZ заощаджує 3T та 1 байт на ітерацію.

### Найшвидший непрямий перехід

`JP (HL)` -- **4T, 1 байт**. Перехід за адресою в HL. Попри оманливу мнемоніку, це НЕ зчитує з пам'яті за (HL) -- воно завантажує PC значенням HL. Незамінне для таблиць переходів та обчислюваних goto.

---

## Недокументовані інструкції

Ці інструкції відсутні в офіційній документації Zilog, але надійно працюють на всіх кристалах Z80 (NMOS і CMOS), всіх клонах ZX Spectrum та eZ80. Вони широко використовуються в коді демосцени та підтримуються sjasmplus.

### IXH, IXL, IYH, IYL (напіврегістри індексних регістрів)

Регістри IX та IY можна розділити на 8-бітні половини, з доступом через префікс DD/FD до звичайних інструкцій H/L:

| Інструкція | Байти | Такти (T-state) | Примітки |
|------------|-------|-----------------|----------|
| `LD A,IXH` | 2 | 8 | Читання старшого байту IX |
| `LD A,IXL` | 2 | 8 | Читання молодшого байту IX |
| `LD IXH,A` | 2 | 8 | Запис старшого байту IX |
| `LD IXL,n` | 3 | 11 | Безпосереднє в молодший байт IX |
| `ADD A,IXL` | 2 | 8 | Арифметика з половинами IX |
| `INC IXH` | 2 | 8 | Інкремент старшого байту IX |
| `DEC IXL` | 2 | 8 | Декремент молодшого байту IX |

**Застосування в демосцені:** Два додаткових 8-бітних регістри для лічильників, акумуляторів або малих значень без торкання основного файлу регістрів. Особливо корисно, коли BC/DE/HL всі зайняті як вказівники. Вартість: на 4T більше, ніж еквівалентна операція з основним регістром.

Синтаксис sjasmplus: `IXH`, `IXL`, `IYH`, `IYL` (також приймає `HX`, `LX`, `HY`, `LY`).

### SLL r (логічний зсув вліво)

| Інструкція | Байти | Такти (T-state) | Примітки |
|------------|-------|-----------------|----------|
| `SLL r` | 2 | 8 | Зсув вліво, біт 0 встановлюється в 1 (не 0) |
| `SLL (HL)` | 2 | 15 | Те ж саме для пам'яті |

`SLL` зсуває вліво та встановлює біт 0 в 1 (на відміну від `SLA`, яка встановлює біт 0 в 0). Опкод: CB 30+r. Іноді корисна для побудови бітових шаблонів.

Синтаксис sjasmplus: `SLL` або `SLI` або `SL1`.

### OUT (C),0

| Інструкція | Байти | Такти (T-state) | Примітки |
|------------|-------|-----------------|----------|
| `OUT (C),0` | 2 | 12 | Вивести нуль у порт BC |

Опкод `ED 71`. Виводить нуль у порт, адресований BC. На CMOS Z80 (включаючи eZ80) замість цього виводить $FF. **Не переносне на Agon Light 2.** На NMOS Z80 (усі реальні Spectrum) надійно виводить $00.

Синтаксис sjasmplus: `OUT (C),0`.

### Недокументовані CB-префіксні бітові операції над (IX+d)

Інструкції на кшталт `SET b,(IX+d),r` одночасно виконують бітову операцію над пам'яттю за (IX+d) та копіюють результат у регістр r. Це 4-байтні інструкції (DD CB dd op), що займають 23T. Іноді корисні, але рідко критичні.

---

## Шпаргалка по ефектах на прапорці

Знання того, які інструкції встановлюють які прапорці, дозволяє уникнути надлишкових інструкцій `CP` або `AND A` -- поширеного джерела марно витрачених тактів (T-state).

### Інструкції, що встановлюють усі арифметичні прапорці (S, Z, H, P/V, N, C)

- `ADD A,r/n/(HL)` -- P/V = переповнення
- `ADC A,r/n/(HL)` -- P/V = переповнення
- `SUB r/n/(HL)` -- P/V = переповнення
- `SBC A,r/n/(HL)` -- P/V = переповнення
- `CP r/n/(HL)` -- Ті ж прапорці, що й SUB, але A не змінюється
- `NEG` -- P/V = переповнення
- `ADC HL,rr` -- P/V = переповнення
- `SBC HL,rr` -- P/V = переповнення

### Інструкції, що встановлюють Z та S (але НЕ перенесення)

- `INC r` / `DEC r` -- C не змінюється. **Не можна перевіряти перенесення після INC/DEC.**
- `INC (HL)` / `DEC (HL)` -- Те ж саме
- `AND r/n/(HL)` -- C завжди 0, H завжди 1
- `OR r/n/(HL)` -- C завжди 0, H завжди 0
- `XOR r/n/(HL)` -- C завжди 0, H завжди 0
- `IN r,(C)` -- C не змінюється
- `BIT b,r/(HL)` -- Z = доповнення перевіреного біту, C не змінюється
- Всі CB-префіксні обертання/зсуви -- Повний набір прапорців включаючи C

### Інструкції, що встановлюють ТІЛЬКИ прапорці, пов'язані з перенесенням

- `ADD HL,rr` -- Тільки H та C (S, Z, P/V не змінюються)
- `RLCA` / `RRCA` / `RLA` / `RRA` -- Тільки C, H=0, N=0 (S, Z, P/V не змінюються)
- `SCF` -- C=1, H=0, N=0
- `CCF` -- C інвертовано, H = старий C, N=0

### Інструкції, що НЕ встановлюють прапорці

- `LD` (всі варіанти)
- `INC rr` / `DEC rr` (16-бітний інкремент/декремент)
- `PUSH` / `POP` (крім POP AF, яка відновлює прапорці)
- `EX` / `EXX`
- `DI` / `EI` / `HALT` / `NOP`
- `JP` / `JR` / `DJNZ` / `CALL` / `RET` / `RST`
- `OUT (n),A` / `IN A,(n)` (версії без CB)

### Практичні прийоми

**Перевірка A на нуль без CP 0:**
```z80
    or   a              ; 4T  sets Z if A=0, clears C
    and  a              ; 4T  same effect, but also sets H
```

**Перевірка перенесення після 16-бітного INC/DEC:** Неможливо. `INC rr`/`DEC rr` не встановлюють прапорці. Щоб перевірити, чи 16-бітний регістр досяг нуля:
```z80
    ld   a, b           ; 4T
    or   c              ; 4T  Z set if BC = 0
```

**Пропуск CP після SUB:** Якщо ти вже виконав `SUB r`, прапорці встановлені -- не додавай після нього `CP` або `OR A`.

**INC/DEC зберігають перенесення:** Використовуй `INC r`/`DEC r` між операціями багатобайтної арифметики, не руйнуючи ланцюжок перенесення.

---

## Архітектура регістрів

### Основний набір регістрів

```
  A   F          Accumulator + Flags
  B   C          Counter (B for DJNZ) + general
  D   E          General purpose pair
  H   L          Primary memory pointer (HL is the "accumulator pair")
```

### Спеціальні регістри

```
  SP             Stack pointer (16-bit)
  PC             Program counter (16-bit)
  IX             Index register (16-bit, DD prefix, +4T penalty)
  IY             Index register (16-bit, FD prefix, +4T penalty)
                 NOTE: IY is used by the Spectrum ROM interrupt handler.
                 Do not use IY unless you have DI or IM2 set up.
  I              Interrupt vector page (used in IM2)
  R              Refresh counter (7-bit, increments every M1 cycle)
```

### Тіньові регістри

```
  A'  F'         Swapped with EX AF,AF'
  B'  C'         \
  D'  E'          | Swapped all three with EXX
  H'  L'         /
```

`EXX` обмінює BC/DE/HL з BC'/DE'/HL' за **4T**. Це дає тобі шість додаткових 8-бітних регістрів (або три додаткових 16-бітних пари) фактично безкоштовно. Типове використання: зберігати вказівники в тіньовому наборі та обмінювати в/з за потребою.

**Увага:** Обробник переривань ROM Spectrum (IM1) використовує тіньові регістри. Якщо переривання дозволені, дані `EXX`/`EX AF,AF'` будуть зіпсовані при кожному перериванні. Завжди виконуй `DI` перед використанням тіньових регістрів, або перейди на IM2 зі своїм обробником.

### Зв'язки регістрових пар з інструкціями

| Пара | Використовується | Примітки |
|------|------------------|----------|
| BC | `DJNZ` (тільки B), `OUT (C),r`, `IN r,(C)`, блочні інструкції (лічильник) | B = лічильник циклу, C = молодший байт порту |
| DE | `EX DE,HL`, `LDI`/`LDIR` (приймач), `LD (DE),A` | Вказівник приймача для блочних операцій |
| HL | Майже все: `LD r,(HL)`, `ADD HL,rr`, `JP (HL)`, `PUSH/POP`, `LDI` (джерело) | Універсальний вказівник |
| AF | `PUSH AF`/`POP AF`, `EX AF,AF'` | A = акумулятор, F = прапорці |
| SP | `PUSH`/`POP`, `LD SP,HL`, `EX (SP),HL` | Перехоплення для трюків з даними |

---

## Типові послідовності інструкцій

### Обчислення піксельної адреси (адреса екрану за Y,X)

Перетворення координат екрану на адресу відеопам'яті ZX Spectrum. Вхід: B = Y (0-191), C = X (0-255). Вихід: HL = адреса байту екрану, A = бітова маска.

```z80
; pixel_addr: calculate screen address from coordinates
; Input:  B = Y (0-191), C = X (0-255)
; Output: HL = byte address, A = pixel bit position
; Cost:   ~55 T-states
;
pixel_addr:
    ld   a, b           ; 4T   A = Y
    and  $07             ; 7T   scanline within char cell (SSS)
    or   $40             ; 7T   add screen base ($4000 high byte)
    ld   h, a           ; 4T   H = 010 00 SSS (partial)
    ld   a, b           ; 4T   A = Y again
    rra                 ; 4T   \
    rra                 ; 4T    | shift character row (TTRR RRR)
    rra                 ; 4T   /  to bits 4-3
    and  $18             ; 7T   mask TT (third bits)
    or   h              ; 4T   H = 010 TT SSS
    ld   h, a           ; 4T
    ld   a, c           ; 4T   A = X
    rra                 ; 4T   \
    rra                 ; 4T    | X / 8
    rra                 ; 4T   /
    and  $1F             ; 7T   mask to 5-bit column
    ld   l, a           ; 4T   L = 000 CCCCC
```

### DOWN_HL: переміщення на один піксельний рядок вниз

Найуживаніший графічний примітив на Spectrum. Типовий випадок (у межах знакорядка) коштує лише 20T.

```z80
; down_hl: advance HL one pixel row down
; Input:  HL = screen address
; Output: HL = address one row below
; Cost:   20T (common), 46T (third boundary), 77T (char boundary)
;
down_hl:
    inc  h              ; 4T   try next scanline
    ld   a, h           ; 4T
    and  7              ; 7T   crossed character boundary?
    ret  nz             ; 5T   no: done (20T total)

    ld   a, l           ; 4T   yes: advance character row
    add  a, 32          ; 7T   L += 32
    ld   l, a           ; 4T
    ret  c              ; 5T   carry = crossed third (46T total)

    ld   a, h           ; 4T   same third: undo extra H increment
    sub  8              ; 7T
    ld   h, a           ; 4T
    ret                 ; 10T  (77T total)
```

### 8x8 беззнакове множення (зсув і додавання)

Від Dark / X-Trade, Spectrum Expert #01 (1997). Використовується в матрицях обертання та перетвореннях координат.

```z80
; mulu112: 8x8 unsigned multiply
; Input:  B = multiplicand, C = multiplier
; Output: A:C = 16-bit result (A = high, C = low)
; Cost:   196-204 T-states
;
mulu112:
    ld   a, 0           ; 7T   clear accumulator
    ld   d, 8           ; 7T   8 bits

.loop:
    rr   c              ; 8T   shift multiplier bit into carry
    jr   nc, .noadd     ; 7/12T
    add  a, b           ; 4T   add multiplicand
.noadd:
    rra                 ; 4T   shift result right
    dec  d              ; 4T
    jr   nz, .loop      ; 12T
    ret                 ; 10T
```

### Запис регістра AY

Стандартна послідовність для запису в звуковий чіп AY-3-8910 на ZX Spectrum 128K.

```z80
; ay_write: write value to AY register
; Input:  A = register number (0-15), E = value
; Cost:   41 T-states (plus CALL/RET overhead)
;
ay_write:
    ld   bc, $FFFD      ; 10T  register select port
    out  (c), a          ; 12T  select register
    ld   b, $BF          ;  7T  data port ($BFFD)
    out  (c), e          ; 12T  write value
    ret                  ; 10T
```

### 16-бітне порівняння (HL проти DE)

Z80 не має прямого 16-бітного порівняння. Використовуй `SBC` та відновлення.

```z80
; Compare HL with DE (sets flags as if HL - DE)
; Destroys: A (if using the OR method for equality)
;
; For equality only:
    or   a              ; 4T   clear carry
    sbc  hl, de         ; 15T  HL = HL - DE, flags set
    add  hl, de         ; 11T  restore HL
                        ; --- 30T total, Z flag valid
```

### Заповнення екрану через стек

Найшвидший спосіб заповнити екран шаблоном. Дивись Розділ 3.

```z80
; fill_screen: fill 6144 bytes using PUSH
; Input:  HL = 16-bit fill pattern
; Cost:   ~36,000 T-states (vs ~129,000 with LDIR)
;
fill_screen:
    di                          ; 4T
    ld   (restore_sp + 1), sp   ; 20T  save SP (self-modifying)
    ld   sp, $5800              ; 10T  end of pixel area

    ld   b, 192                 ; 7T   192 iterations x 16 pushes x 2 bytes = 6144
.loop:
    REPT 16
        push hl                 ; 11T  x 16 = 176T
    ENDR
    djnz .loop                  ; 13T/8T

restore_sp:
    ld   sp, $0000              ; 10T  self-modified
    ei                          ; 4T
    ret                         ; 10T
```

### Швидкий обхід піксельних рядків (роздільні лічильники)

Від аналізу DOWN_HL Introspec (Hype, 2020). Усуває все умовне розгалуження з внутрішнього циклу. Загальна вартість для 192 рядків: 2 343T проти 5 922T для наївних викликів DOWN_HL.

```z80
; iterate all 192 rows with minimal overhead
; HL starts at $4000
;
iterate_screen:
    ld   hl, $4000          ; 10T
    ld   c, 3               ; 7T   three thirds

.third:
    ld   b, 8               ; 7T   eight character rows per third

.char_row:
    push hl                 ; 11T  save char row start

    REPT 7
        ; ... process row using HL ...
        inc  h              ; 4T   next scanline (NO branching)
    ENDR
    ; ... process 8th row ...

    pop  hl                 ; 10T  restore char row start
    ld   a, l              ; 4T
    add  a, 32             ; 7T   next character row
    ld   l, a              ; 4T
    djnz .char_row         ; 13T/8T

    ld   a, h              ; 4T
    add  a, 8              ; 7T   next third
    ld   h, a              ; 4T
    dec  c                 ; 4T
    jr   nz, .third        ; 12T/7T
```

---

## Швидкі порівняння вартості

Для рішень у внутрішніх циклах ці порівняння найважливіші:

| Операція | Повільний спосіб | Швидкий спосіб | Виграш |
|----------|------------------|----------------|--------|
| Обнулити A | `LD A,0` (7T, 2B) | `XOR A` (4T, 1B) | 3T, 1B |
| Перевірити A=0 | `CP 0` (7T, 2B) | `OR A` (4T, 1B) | 3T, 1B |
| Скопіювати 1 байт у пам'ять | `LD (HL),A`+`INC HL` (13T) | `LDI` (16T) | LDI повільніша, але авто-інкрементує і DE теж |
| Скопіювати N байтів | `LDIR` (21T/байт) | N x `LDI` (16T/байт) | На 24% швидше, коштує 2N байтів коду |
| Заповнити 2 байти | `LD (HL),A`+`INC HL` x2 (26T) | `PUSH rr` (11T) | На 58% швидше, потребує перехоплення SP |
| 8-бітний цикл | `DEC B`+`JR NZ` (16T, 3B) | `DJNZ` (13T, 2B) | 3T, 1B на ітерацію |
| Непрямий виклик | `CALL nn` (17T, 3B) | `RET` через render list (10T, 1B) | 7T, 2B на диспетчеризацію |
| Обмін регістрів | `LD A,H`+`LD H,D`+`LD D,A` (12T, 3B) | `EX DE,HL` (4T, 1B) | 8T, 2B |
| Зберегти 6 регістрів | 3 x `PUSH` (33T, 3B) | `EXX` (4T, 1B) | 29T, 2B |

---

## Довідник розмірів кодування інструкцій

Для sizecoding та оцінки щільності коду:

| Префікс | Інструкції | Додаткові байти | Додаткові такти (T-state) |
|---------|-----------|-----------------|---------------------------|
| Немає | Більшість 8-бітних операцій, LD, ADD, INC, PUSH, POP, JP, JR | 0 | 0 |
| CB | Бітові операції, зсуви, обертання регістрів | +1 | +4 зазвичай |
| ED | Блочні операції, 16-бітні ADC/SBC, IN/OUT (C), LD rr,(nn) | +1 | різне |
| DD | IX-індексні операції | +1 | від +4 до +8 |
| FD | IY-індексні операції | +1 | від +4 до +8 |
| DD CB | Бітові/зсув/обертання над (IX+d) | +2 | від +8 до +12 |

**Порада для sizecoding:** Уникай IX/IY-індексних інструкцій, коли можливо. `LD A,(IX+5)` -- 3 байти/19T. `LD L,5 / LD A,(HL)` -- 3 байти/11T, якщо H вже містить сторінку. Індексні регістри зручні, але дорогі.

---

> **Джерела:** Zilog Z80 CPU User Manual (UM0080); Sean Young, "The Undocumented Z80 Documented" (2005); Dark / X-Trade, "Programming Algorithms" (Spectrum Expert #01, 1997); Introspec, "Once more about DOWN_HL" (Hype, 2020); Розділ 1 (тестова обв'язка); Розділ 3 (шаблони інструментарію); Розділ 4 (множення, ділення)
