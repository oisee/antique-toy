# Розділ 13: Мистецтво sizecoding

> "It was like playing puzzle-like games -- constant reshuffling of code to find shorter encodings."
> -- UriS, про написання NHBF (2025)

Існує категорія змагань на демосцені, де обмеженням є не час, а *простір*. Вся твоя програма -- код, що малює екран, створює звук, обробляє кадровий цикл, зберігає будь-які потрібні дані -- повинна вміститися у 256 байт. Або 512. Або 1K, або 4K, або 8K. Жодного байта більше. Файл вимірюється, і якщо він 257 байт, його дискваліфіковано.

Це змагання з **sizecoding**, і вони створюють одні з найвидатніших робіт на сцені ZX Spectrum. 256-байтне інтро, що заповнює екран анімованими патернами та грає впізнавану мелодію, -- це форма стиснення настільки екстремальна, що вона межує з магією. Розрив між тим, що бачить глядач, і розміром файлу, що це створює -- цей розрив і є мистецтвом.

Цей розділ про мислення, техніки та конкретні трюки, що роблять sizecoding можливим.

---

## 13.1 Що таке sizecoding?

Змагання на демо зазвичай пропонують кілька категорій з обмеженням розміру:

| Категорія | Ліміт | Що вміщується |
|-----------|-------|---------------|
| 256 байт | 256 | Один щільний ефект, можливо простий звук |
| 512 байт | 512 | Ефект з базовою музикою або два простих ефекти |
| 1K інтро | 1 024 | Кілька ефектів, повноцінна музика, переходи |
| 4K інтро | 4 096 | Коротке демо з кількома частинами |
| 8K інтро | 8 192 | Відполіроване міні-демо |

Ліміти абсолютні. Файл вимірюється в байтах, і переговорів немає.

Те, що робить sizecoding захоплюючим -- це інверсія звичної ієрархії оптимізації. У світі підрахованих тактів демосценних ефектів ти оптимізуєш для *швидкості* -- розгортаєш цикли, дублюєш дані, генеруєш код, все заради обміну простору на час. Sizecoding це інвертує. Швидкість не має значення. Читабельність не має значення. Єдине питання: чи можна зробити на один байт коротше?

UriS, який написав 256-байтне інтро NHBF для Chaos Constructions 2025, описав процес як "гру в головоломки." Опис точний. Sizecoding -- це головоломка, де фігури -- це інструкції Z80, дошка -- 256 байт ОЗП, і найкращі рішення включають ходи, що вирішують кілька проблем одночасно.

Зміна мислення:

- **Кожний байт цінний.** 3-байтна інструкція там, де достатньо 2-байтної -- це 0,4% всієї твоєї програми. На 256 байтах один збережений байт -- це як заощадити 250 байт у 64K програмі.

- **Код і дані перетинаються.** Ті самі байти, що виконуються як інструкції, можуть слугувати даними. Z80 не розрізняє їх -- лише шлях лічильника команд через пам'ять відрізняє код від даних.

- **Вибір інструкцій визначається розміром, не швидкістю.** `RST $10` коштує 1 байт. `CALL $0010` робить те саме за 3 байти. У звичайному демо ти б ніколи не помітив. На 256 байтах ці 2 байти -- різниця між наявністю звуку чи ні.

- **Початковий стан -- це безкоштовні дані.** Після завантаження регістри мають відомі значення. Пам'ять за певними адресами містить відомі дані. Кодер розміру використовує кожний біт цього безкоштовного стану.

- **Самомодифікований код (SMC) -- не трюк, а необхідність.** Коли ти не можеш дозволити собі окрему змінну, ти модифікуєш операнд інструкції на місці.

---

## 13.2 Анатомія 256-байтного інтро: NHBF

**NHBF** (No Heart Beats Forever) було створено UriS для Chaos Constructions 2025, натхненне RED REDUX з Multimatograf 2025. Воно створює текст з екранними ефектами та музику -- зациклені прямокутнохвильові пауер-акорди з випадковими мелодійними нотами пентатоніки -- все за 256 байт.

### Музика

На 256 байтах ти не можеш включити трекерний програвач або таблиці нот. NHBF керує чипом AY безпосередньо. Пауер-акорди захардкоджені як безпосередні значення в інструкціях запису регістрів AY -- ті самі байти, що формують операнд `LD A, n`, *є* музичною нотою. Мелодійний канал використовує псевдовипадковий генератор (зазвичай `LD A, R` -- зчитування регістра оновлення -- з наступним AND для маскування діапазону) для вибору з пентатонічної гами. Пентатонічна гама звучить приємно незалежно від того, які ноти опиняються поруч, тому мелодія звучить навмисно, хоча вона випадкова. Два байти на "випадкове" число; п'ять нот, що ніколи не конфліктують.

### Візуальна частина

Друк тексту через ROM -- `RST $10` виводить символ за 1 байт виклику -- це найдешевший спосіб отримати пікселі на екрані. Але навіть 20-символьний рядок коштує 40 байт (коди символів + виклики RST). Кодери розміру шукають способи ще більшого стиснення: перетинання рядкових даних з іншим кодом або обчислення символів за формулою.

### Головоломка: Пошук перетинань

UriS описує ключовий процес як постійне перетасовування. Ти пишеш першу версію на 300 байт, потім вдивляєшся в неї. Помічаєш, що лічильник циклу для візуального ефекту закінчується значенням, яке тобі потрібне як номер регістра AY. Прибери `LD A, 7`, що його встановлювала -- цикл вже залишив 7 в A. Два байти збережено. Процедура очищення екрану використовує LDIR, що зменшує BC до нуля. Розташуй код так, щоб наступна секція потребувала BC = 0, і збережи `LD BC, 0` -- ще 3 байти.

Кожна інструкція створює побічні ефекти -- значення регістрів, стани прапорців, вміст пам'яті -- і мистецтво полягає в розташуванні інструкцій так, щоб побічні ефекти однієї процедури були вхідними даними іншої.

### Відкриття Art-Top

Під час розробки Art-Top помітив щось дивовижне: значення регістрів, що залишилися від процедури очищення екрану, випадково збіглися з точною довжиною, потрібною для текстового рядка. Не заплановано. UriS написав очищення екрану, потім вивід тексту, і ці два випадково поділили стан регістрів, що усунув окремий лічильник довжини.

Такий серендипний збіг -- серце кодування на 256 байтах. Ти не можеш його спланувати. Ти можеш лише створити умови, за яких він може статися, постійно перетасовуючи код і стежачи за випадковими збігами. Коли знаходиш такий -- це відчувається як відкриття, що два елементи пазла з різних наборів ідеально з'єднуються.

### Ключові техніки на 256 байтах

**1. Використовуй початковий стан регістрів і пам'яті.** Після стандартного завантаження з стрічки регістри мають відомі значення: A часто містить останній завантажений байт, BC -- довжину блоку, HL вказує біля кінця завантажених даних. Область системних змінних ($5C00-$5CB5) містить відомі значення. Екранна пам'ять чиста після CLS. Кожне відоме значення, яке ти використовуєш замість явного завантаження, економить 1-3 байти.

**2. Перетинай код і дані.** Байт $3E -- це опкод `LD A, n`, а також значення 62 -- символ ASCII, координата екрана або значення регістра AY. Якщо твоя програма виконує цей байт як інструкцію *і* читає його як дані з іншого шляху коду, ти змусив один байт виконувати дві роботи. Поширений патерн: безпосередній операнд `LD A, n` подвоюється як дані, які інша процедура читає через `LD A, (addr)`, вказуючи на instruction_address + 1.

**3. Обирай інструкції за розміром.**

| Велике кодування | Мале кодування | Економія |
|-----------------|----------------|----------|
| `CALL $0010` (3 байти) | `RST $10` (1 байт) | 2 байти |
| `JP label` (3 байти) | `JR label` (2 байти) | 1 байт |
| `LD A, 0` (2 байти) | `XOR A` (1 байт) | 1 байт |
| `CP 0` (2 байти) | `OR A` (1 байт) | 1 байт |

Інструкції RST критичні. `RST n` -- це 1-байтний CALL на одну з восьми адрес ($00, $08, $10, $18, $20, $28, $30, $38). На Spectrum `RST $10` викликає виведення символу ROM, `RST $28` входить у калькулятор. У звичайному демо ці ROM-процедури занадто повільні. На 256 байтах збереження 2 байт на CALL -- це все.

**Кожний JP у 256-байтному інтро повинен бути JR** -- вся програма вміщується в діапазон -128..+127.

**4. Самомодифікований код (SMC) для повторного використання послідовностей.** Потрібна підпрограма для роботи з двома різними адресами? Захардкодь першу і пропатч операнд для другого виклику. Дешевше, ніж передача параметрів.

**5. Математичні зв'язки між константами.** Якщо твоїй музиці потрібен період тону 200 і твоєму ефекту потрібен лічильник циклу 200, використовуй той самий регістр. Якщо одне значення вдвічі більше за інше, використовуй `ADD A, A` (1 байт) замість завантаження другої константи (2 байти).

---

## 13.3 Трюк LPRINT

У 2015 році diver4d опублікував "Secrets of LPRINT" на Hype, документуючи техніку, старішу за саму демосцену -- таку, що вперше з'явилася у піратських завантажувачах касетного ПЗ у 1980-х.

### Як це працює

Системна змінна за адресою 23681 ($5C81) контролює, куди процедури виведення BASIC направляють дані. Зазвичай вона вказує на буфер принтера. Зміни її так, щоб вона вказувала на екранну пам'ять, і LPRINT записує безпосередньо на екран:

```basic
10 POKE 23681,64: LPRINT "HELLO"
```

Цей єдиний POKE перенаправляє канал принтера на $4000 -- початок екранної пам'яті.

### Ефект транспозиції

Візуальний результат -- це не просто текст на екрані, а *транспонований* текст. Екранна пам'ять Spectrum має черезрядкову розкладку (Розділ 2), але драйвер принтера записує послідовно. Дані потрапляють в екранну пам'ять відповідно до лінійної логіки драйвера, але *відображаються* відповідно до черезрядкової розкладки. Результат циклує через 8 візуальних станів у міру просування через третини екрану -- каскад даних, що будується горизонтальними смугами, зсуваючись і перекомбінуючись.

З різними символьними даними -- графічними символами, UDG або ретельно обраними ASCII-послідовностями -- транспозиція створює вражаючі візуальні патерни. Оператор LPRINT обробляє всю адресацію екрану, рендеринг символів та просування курсору. Твоя програма надає лише дані.

### Від піратських завантажувачів до демо-мистецтва

diver4d простежив цей трюк до піратських завантажувачів касет. Пірати, що додавали власні екрани завантаження, потребували візуальних ефектів у дуже небагатьох байтах BASIC -- LPRINT був ідеальним. Техніка вийшла з ужитку, коли сцена перейшла на машинний код.

Але у 2011 році JtN та 4D випустили **BBB** -- демо, що свідомо повернулося до LPRINT як мистецьке висловлювання. Старий трюк піратських завантажувачів, оформлений з наміром, став демо-мистецтвом. Обмеження -- BASIC, хак з перенаправленням принтера, без машинного коду -- стало медіумом.

### Чому це важливо для sizecoding

LPRINT забезпечує складне виведення на екран при майже нульовій кількості твого власного коду. ROM виконує важку роботу. Твій внесок: POKE для перенаправлення виведення, дані для друку та `RST $10` (або LPRINT) для запуску. Ти використовуєш 16-КБ ROM Spectrum як "безкоштовний" рушій виведення на екран -- код, що не враховується у твоєму ліміті розміру.

---

## 13.4 512-байтні інтро: Простір для дихання

Подвоєння від 256 до 512 байт -- це не вдвічі більше, а якісно інше. На 256 ти борешся за кожну інструкцію і звук мінімальний. На 512 ти можеш мати повноцінний ефект *і* повноцінний звук, або два ефекти з переходом.

### Поширені 512-байтні патерни

**Плазма через суми синусних таблиць.** Синусна таблиця -- це дорога частина. Повна 256-байтна таблиця споживає половину твого бюджету. Рішення: 64-елементна чверть-хвильова таблиця з дзеркальним відображенням під час виконання (економить 192 байти), або генерація таблиці при запуску за допомогою параболічної апроксимації з Розділу 4 (~20 байт коду замість 256 байт даних).

**Тунель через пошук кута/відстані.** На 512 байтах ти обчислюєш кут і відстань на ходу, використовуючи грубі апроксимації. Нижча візуальна якість, ніж у тунелі Eager (Розділ 9), але впізнавано тунель.

**Вогонь через клітинний автомат.** Кожна клітина усереднює своїх сусідів знизу, мінус згасання. Кілька інструкцій на піксель, переконлива анімація, і на 512 байтах ти можеш додати атрибути для кольору *та* біперний звук.

### Трюки із самомодифікацією

Самомодифікація стає структурною на 512 байтах. Вбудуй лічильник кадрів *всередину* інструкції:

```z80
frame_ld:
    ld   a, 0               ; this 0 is the frame counter
    inc  a
    ld   (frame_ld + 1), a  ; update the counter in place
```

Окремої змінної немає. Лічильник живе в потоці інструкцій.

Патч зсувів переходів для перемикання між ефектами:

```z80
effect_jump:
    jr   effect_1               ; this offset gets patched
    ; ...
effect_1:
    ; render effect 1, then:
    ld   a, effect_2 - effect_jump - 2
    ld   (effect_jump + 1), a   ; next frame jumps to effect 2
```

### Трюк з ORG

Обери адресу ORG твоєї програми так, щоб байти адреси самі по собі були корисними даними. Розмісти код за адресою $4000, і кожний JR/DJNZ, що посилається на мітки біля початку, генерує малі байти зсуву -- придатні як лічильники циклів, значення кольорів або номери регістрів AY. Якщо твоєму ефекту потрібен $40 (старший байт екранної пам'яті) як константа, розмісти код за адресою, де $40 природно з'являється в операнді адреси. *Кодування самого коду* надає дані, потрібні деінде.

Це найглибший рівень головоломки sizecoding.

---

## 13.5 Практика: Написання 256-байтного інтро крок за кроком

Почни з працюючої атрибутної плазми (~400 байт) і оптимізуй її до 256.

### Крок 1: Неоптимізована версія

Проста атрибутна плазма: заповни 768 байт пам'яті атрибутів значеннями із сум синусів, зміщеними лічильником кадрів. Звук: циклічна мелодія на каналі A AY. Ця версія чиста, читабельна і приблизно 400 байт -- синусна таблиця (32 байти), таблиця нот (16 байт), інлайнові записи AY та цикл плазми з табличними пошуками.

### Крок 2: Заміни CALL на RST

Будь-який виклик ROM-адреси, що збігається з вектором RST, економить 2 байти за кожне використання. Для виведення AY заміни шість багатослівних інлайнових записів регістрів (~60 байт) невеликою підпрограмою:

```z80
ay_write:                      ; register in A, value in E
    ld   bc, $FFFD
    out  (c), a
    ld   b, $BF
    out  (c), e
    ret                        ; 8 bytes total
```

Шість викликів (5 байт кожний: завантаження A + завантаження E + CALL) = 30 + 8 = 38 байт. Економія: ~22 байти.

### Крок 3: Перетини дані з кодом

32-байтна синусна таблиця на точці входу декодується як здебільшого нешкідливі інструкції Z80 ($00=NOP, $06=LD B,n, $0C=INC C...). Розмісти її на початку програми. При першому виконанні процесор спотикається через ці "інструкції", псуючи деякі регістри. Головний цикл потім перестрибує таблицю і більше ніколи не виконує її -- але дані залишаються для пошуків. Байти таблиці виконують подвійну функцію.

### Крок 4: Використовуй стан регістрів

Після того, як цикл плазми записав 768 атрибутів, HL = $5B00 і BC = 0 (від будь-якого LDIR, використаного при ініціалізації). Якщо наступна операція потребує ці значення, пропусти явні завантаження. Відкриття Art-Top у NHBF було саме цим: значення регістрів від очищення екрану збіглися з довжиною текстового рядка. Не заплановано. Помічено.

Після кожного проходу оптимізації анотуй, що кожний регістр містить у кожній точці. Стан регістрів -- це спільний ресурс, фундаментальна валюта sizecoding.

### Крок 5: Менші кодування скрізь

- `LD A, 0` -> `XOR A` (економія 1 байт)
- `LD HL, nn` + `LD A, (HL)` -> `LD A, (nn)` (економія 1 байт, якщо HL не потрібен)
- `JP` -> `JR` скрізь (економія 1 байт кожний)
- `CALL sub : ... : RET` -> пряме проходження (економія 4 байти)
- `PUSH AF` для тимчасових збережень проти `LD (var), A` (економія 2 байти)

### Фінальний ривок

Останні 10-20 байт -- найскладніші. Структурне перегрупування: зміни порядок коду так, щоб прямі переходи усували інструкції JR. Об'єднай звуковий та візуальний цикли. Вбудуй байти даних у потік інструкцій -- якщо тобі потрібен $07 як дані і також потрібен `RLCA` (опкод $07), розташуй так, щоб один слугував обома.

Ти вдивляєшся в шістнадцятковий дамп. Ти пробуєш перемістити звукову процедуру перед візуальною. Ти пробуєш замінити синусну таблицю генератором часу виконання. Кожна спроба перетасовує байти. Іноді все вишиковується.

Задоволення від вміщення цілісного аудіовізуального досвіду у 256 байт -- від розв'язання головоломки -- реальне, специфічне і несхоже на жодне інше відчуття в програмуванні.

---

## 13.6 Sizecoding як мистецтво

Є момент у sizecoding -- і making-of від UriS передає це ідеально -- коли програма займає 260 байт і тобі потрібно скоротити 4. Ти можеш прибрати візуальну фічу. Ти можеш спростити звук. Або ти можеш знайти кодування, де ті самі байти служать обом цілям. Коли ти знаходиш таке кодування, це не просто технічне рішення. Це *елегантно*. Код красивіший від того, що він менший.

Ось чому змагання з sizecoding зберігаються. Практична корисність 256-байтної програми -- нульова. Майстерність -- це суть. Обмеження -- це полотно. Результати -- крихітні бінарні файли, що створюють музику та рух з простору, меншого за цей абзац -- є справжнім мистецтвом.

Стаття diver4d про LPRINT робить подібне зауваження з протилежного боку. Трюк LPRINT не ефективний. Він створює візуальний шум, який ледве кваліфікується як "ефект." Але коли JtN і 4D використали його в BBB, обрамивши техніку мистецьким наміром, результатом стало демо, яке люди запам'ятали. Обмеження стало медіумом. Обмеження стали стилем.

Sizecoding навчає тебе речам, які покращують усе твоє програмування. Дисципліна ставити під сумнів кожний байт загострює усвідомлення кодування інструкцій. Звичка шукати перетини переноситься на будь-яку оптимізаційну роботу. Практика використання початкового стану та побічних ефектів робить тебе кращим системним програмістом. А досвід розв'язування головоломок -- пошуку розташування, де все вміщується -- застосовний далеко за межами 256 байт.

---

## Підсумок

- Змагання з **sizecoding** вимагають повних програм у 256, 512, 1K, 4K або 8K байт -- суворі ліміти, що вимагають принципово іншого підходу до програмування.
- **NHBF** (UriS, CC 2025) демонструє мислення на 256 байт: кожний байт виконує подвійну функцію, стани регістрів від однієї процедури живлять наступну, вибір інструкцій визначається виключно розміром кодування.
- **Трюк LPRINT** (diver4d, 2015) перенаправляє вивід принтера BASIC на екранну пам'ять через адресу 23681, створюючи складні візуальні патерни в кількох байтах -- від піратських завантажувачів касет до демо-мистецтва.
- **На 512 байтах** самомодифікований код (SMC) стає структурним (патчення цілей переходів, вбудовування лічильників в операнди), і такі ефекти як плазма, тунель та вогонь стають здійсненними поряд зі звуком.
- **Процес оптимізації** рухається від структурних змін (усунення таблиць, злиття циклів) до вибору кодування (RST замість CALL, JR замість JP, XOR A замість LD A,0) до серендипних відкриттів (стани регістрів, що збігаються з потребами в даних).
- **Трюк з ORG** -- вибір адреси завантаження так, щоб байти адреси подвоювалися як корисні дані -- представляє найглибший рівень головоломки.

---

## Спробуй сам

1. **Почни з великого, скороти до малого.** Напиши атрибутну плазму з лічильником кадрів. Доведи її до робочого стану будь-якого розміру. Потім оптимізуй до 512 байт, відстежуючи кожний збережений байт і як.

2. **Дослідж LPRINT.** У BASIC спробуй `POKE 23681,64 : FOR i=1 TO 500 : LPRINT CHR$(RND*96+32); : NEXT i`. Спостерігай, як транспоновані дані заповнюють екран. Поекспериментуй з різними діапазонами символів.

3. **Картуй стан регістрів.** Напиши невелику програму та анотуй, що кожний регістр містить у кожній точці. Шукай місця, де вихід однієї процедури збігається з потрібним входом іншої.

4. **Вивчи вектори RST.** Дизасемблюй ROM Spectrum за адресами $0000, $0008, $0010, $0018, $0020, $0028, $0030, $0038. Це твої "безкоштовні" підпрограми.

5. **Виклик 256 байт.** Стисни практичну вправу з цього розділу до 256 байт. Тобі доведеться приймати складні рішення про те, що залишити, а що прибрати. У цьому вся суть.

---

*Далі: Розділ 14 -- Стиснення: Більше даних у меншому просторі. Ми переходимо від програм, що вміщуються у 256 байт, до проблеми вміщення кілобайт даних у кілобайти сховища, з комплексним бенчмарком 10 пакувальників від Introspec як нашим путівником.*

> **Джерела:** UriS "NHBF Making-of" (Hype, 2025); diver4d "LPRINT Secrets" (Hype, 2015)
