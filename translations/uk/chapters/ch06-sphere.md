# Розділ 6: Сфера --- Текстурне накладання на 3,5 МГц

> *"Кодерські ефекти — це завжди про еволюцію обчислювальної схеми."*
> --- Introspec, 2017

---

Йде 1996 рік, і демо під назвою *Illusion* займає перше місце на ENLiGHT'96 у Санкт-Петербурзі. Публіка спостерігає, як монохромне зображення обгортається навколо сфери, що обертається, плавно крутиться в реальному часі, на ZX Spectrum, що працює на 3,5 МГц без жодного апаратного прискорення. Жодного блітера. Жодного GPU. Жодного співпроцесора. Лише Z80, 48 кілобайт суцільної оперативної пам'яті та все, що двадцятирічний кодер на ім'я Dark зміг із них вичавити.

Двадцять років потому, у березні 2017 року, Introspec сідає з копією бінарника та дизасемблером. Він розбирає цикл рендерингу інструкція за інструкцією, рахує такти, зіставляє адреси пам'яті зі структурами даних і публікує свої знахідки на Hype. Те, що слідує далі, — один із найдетальніших публічних розборів демосценового ефекту, коли-небудь написаних для ZX Spectrum, — і в потоці коментарів, що спалахує під статтею, розгоряється дебат про те, що насправді важливо в рендерингу реального часу на обмеженому залізі.

Цей розділ слідує аналізу Introspec'а. Ми подивимось через його плече, поки він трасує код, зрозуміємо, *чому* сфера працює саме так, як працює, а потім побудуємо спрощену версію самі.

---

## Проблема: Круглий об'єкт на квадратному екрані

Сфера на екрані — це не сфера. Це коло, заповнене спотвореним зображенням. Спотворення підпорядковується правилам сферичної проекції: пікселі біля екватора розташовані рівномірно, пікселі біля полюсів стиснуті горизонтально, а все відображення вигинається, створюючи ілюзію тривимірної поверхні.

Вихідне зображення в Illusion зберігається як монохромна бітова карта — один байт на піксель, де кожен байт дорівнює або 0, або 1. Це марнотратство за стандартами Spectrum, де екранна пам'ять пакує вісім пікселів у байт, але це дає дещо суттєве: код рендерингу може працювати з пікселями як з арифметичними значеннями, а не з бітовими позиціями.

Отже, завдання таке: зчитати пікселі з вихідного зображення, відібрати їх відповідно до сферичної проекції, запакувати вісім із них в один екранний байт та записати цей байт у відеопам'ять. Зробити це для кожного видимого байта сфери. Зробити це досить швидко для анімації. Зробити це на Z80 з частотою 3,5 МГц.

## Ключова ідея: Код, що пише код

Перше питання, яке задає будь-який програміст Z80: як виглядає внутрішній цикл? На машині, де один `NOP` займає 4 такти і ти маєш приблизно 70 000 тактів на кадр, внутрішній цикл *і є* програмою. Все інше — налаштування, генерація таблиць, керування кадрами — це накладні витрати, що відбуваються один раз або нечасто. Внутрішній цикл виконується тисячі разів за кадр.

Розв'язок Dark'а — взагалі не мати фіксованого внутрішнього циклу.

Натомість код рендерингу *генерується під час виконання*. Для кожного горизонтального рядка сфери програма конструює послідовність інструкцій Z80, пристосовану до геометрії цього рядка. Згенерований код зчитує вихідні пікселі по порядку, накопичує їх в екранні байти через зсуви та додавання, і просувається по вихідних даних на відстані, що варіюються залежно від кривизни сфери. Різні рядки сфери породжують різний код.

Це техніка, що з'являється по всій демосцені: самогенерований код, який іноді називають "скомпільованими спрайтами", коли його застосовують до рендерингу спрайтів, або "генерацією розгорнутих циклів" у загальному випадку. Що робить версію зі сферою відмінною — це варіативність. Скомпільований спрайт фіксований — одного разу згенерований, він малює одну й ту ж форму щоразу. Код сфери змінюється з кутом повороту, тому що різні вихідні пікселі стають видимими, коли сфера обертається.

## Усередині дизасемблювання

Introspec відстежив рендеринговий рушій до блоку згенерованого коду та набору таблиць підстановки, що починаються з адреси `$6944`. Таблиці кодують геометрію сфери як серію *відстаней пропуску*: для кожної позиції вздовж рядка розгортки сфери — скільки вихідних пікселів потрібно пропустити перед наступним відібраним.

На екваторі відстані пропуску приблизно рівномірні — вихідне зображення накладається на сферу з мінімальним спотворенням. Біля полюсів горизонтальне стиснення проекції означає більші пропуски між відібраними пікселями. На самій верхівці та внизу лише кілька пікселів видимі на рядок, і пропуски можуть бути значними.

Згенерований внутрішній цикл має повторювану структуру. Для кожного екранного байта (вісім запакованих пікселів) він виконує послідовність на кшталт:

```z80
; --- Accumulating 8 source pixels into one screen byte ---
; HL points into the source image (one byte per pixel)
; A is the accumulator, building the screen byte bit by bit

    add  a,a          ; shift accumulator left (make room for next pixel)
    add  a,(hl)       ; add source pixel (0 or 1) into lowest bit
    inc  l            ; advance to next source pixel
    ; ... possibly more INC L instructions here,
    ; depending on how many pixels to skip

    add  a,a          ; shift again
    add  a,(hl)       ; sample next pixel
    inc  l
    inc  l            ; skip one extra pixel (sphere curvature)

    add  a,a
    add  a,(hl)
    inc  l

    ; ... six more times, for 8 pixels total ...
```

Ключова деталь: між кожним `add a,(hl)` кількість інструкцій `inc l` варіюється. Одна піксельна позиція може потребувати єдиного `inc l` (відбір суміжних пікселів). Інша може потребувати три або чотири (пропуск стиснутих регіонів проекції). Таблиці підстановки за адресою `$6944` кодують саме те, скільки інструкцій `inc l` вставити в кожній позиції.

Подивимось уважніше, що відбувається з одним пікселем:

```z80
    add  a,a          ;  4 T-states  (shift A left by 1)
    add  a,(hl)       ;  7 T-states  (add source pixel into bit 0)
    inc  l            ;  4 T-states  (advance source pointer)
```

Це мінімальна вартість: 15 тактів, щоб зсунути акумулятор і відібрати один піксель, плюс 4 такти за кожен пропущений вихідний байт. Після восьми таких послідовностей акумулятор містить повний екранний байт.

Зверни увагу, що вказівник на вихідні дані просувається за допомогою `inc l`, а не `inc hl`. Це навмисно. `INC HL` займає 6 тактів; `INC L` займає 4. Обмежуючи вихідні дані межами однієї 256-байтної сторінки (так що змінюється лише молодший байт адреси), Dark економить 2 такти на кожному просуванні. Коли ти робиш це тисячі разів за кадр, ці 2 такти накопичуються.

Тут є тонкість, яку легко пропустити. Вихідне зображення зберігається як один байт на піксель, і `INC L` обертається в межах 256-байтної сторінки. Це означає, що кожен рядок розгортки вихідних даних має вміщуватись у 256 байтів, і вихідний буфер має бути вирівняний за сторінкою. Це обмеження формує весь макет пам'яті демо.

## Підрахунок тактів

Introspec підрахував вартість одного вихідного байта:

**101 + 32x тактів**

де *x* — це середня кількість додаткових інструкцій `INC L` на піксель понад обов'язкову одну. Перевіримо це.

Фіксована вартість на піксель:

| Інструкція | Такти |
|-------------|----------|
| `add a,a`   | 4        |
| `add a,(hl)`| 7        |
| `inc l`     | 4        |
| **Підсумок** | **15**  |

Для 8 пікселів фіксована вартість складає 8 x 15 = 120 тактів. Але є додаткові накладні витрати на байт: код повинен записати завершений байт в екранну пам'ять і підготуватися до наступного. Припустимо, що послідовність виводу виглядає приблизно так:

```z80
    ld   (de),a       ;  7 T-states  (write screen byte)
    inc  e            ;  4 T-states  (advance screen pointer)
```

Також може бути підготовка акумулятора (`xor a` або подібне) на початку кожного байта. Беручи виміряну Introspec'ом цифру 101 такт як фіксовану базову вартість на байт, накладні витрати понад сирий відбір пікселів складають приблизно 101 - 120 = ... що означає, що базова цифра вже включає інструкції виводу та частина піксельної роботи переплітається інакше, ніж наївний підрахунок підказує.

Чистіший спосіб прочитати формулу: 101 такт фіксованих накладних витрат (вивід, керування вказівниками, будь-яка побайтова підготовка), плюс 32 такти на кожен додатковий пропуск. "32" виходить з 8 пікселів, помножених на 4 такти за кожний додатковий `INC L`, що дає нам x як середню кількість додаткових пропусків на піксельну позицію в цьому байті. Коли сфера біля екватора, x малий — проекція близька до рівномірної. Біля полюсів x великий, і рендеринг сповільнюється. Але полюси також мають менше байтів для малювання (сфера там вужча), тому загальне навантаження приблизно балансується.

Чи досить це швидко? Кадр Spectrum'а — це приблизно 70 000 тактів (на Pentagon більше: 71 680). Сфера діаметром 56 пікселів займає приблизно 7 байтів у поперечнику в найширшому місці. По всій висоті потрібно відрендерити, можливо, 200--250 байтів. При 101 такті на байт (екваторіальний, x близький до нуля), це приблизно 25 000 тактів — комфортно вкладається в бюджет одного кадру, з запасом на очищення екрану, пошук по таблицях та все інше обслуговування. Навіть біля полюсів, де x може в середньому становити 2--3, вартість на байт зростає до 165--197 тактів, але менше байтів потрібно малювати. Арифметика сходиться. Вкладається.

## Прохід генерації коду

Перед тим як внутрішній цикл запуститься, *прохід генерації коду* його конструює. Цей прохід зчитує таблиці підстановки за адресою `$6944`, які кодують геометрію сфери для поточного кута повороту, та емітує інструкції Z80 в буфер:

1. Для кожного рядка розгортки сфери зчитати відстані пропуску з таблиці.
2. Емітувати `add a,a`, за яким слідує `add a,(hl)` для кожного пікселя.
3. Емітувати відповідну кількість інструкцій `inc l` на основі відстані пропуску.
4. Після кожних 8 пікселів емітувати інструкцію виводу для запису накопиченого байта в екранну пам'ять.
5. Наприкінці кожного рядка розгортки емітувати повернення або перехід до обробника наступного рядка.

Згенерований блок коду потім викликається безпосередньо. Процесор виконує інструкції так, ніби це звичайна підпрограма, але вони були написані мить тому генератором коду. Це самомодифікований код у найбільш буквальному сенсі — програма генерує програму, яка малює екран.

Сам прохід генерації коду не безкоштовний, але він виконується один раз за кадр (або один раз за крок повороту), тоді як згенерований внутрішній цикл виконується сотні разів. Амортизована вартість мізерна.

## Що Dark знав: Spectrum Expert і будівельні блоки

У цій історії є деталь, яка перетворює її з технічної цікавинки на наративну арку. Dark — кодер, що стоїть за сферним ефектом Illusion — це той самий Dark, який написав статті *"Алгоритми програмування"* у Spectrum Expert #01, опублікованому в 1997 році.

Ці статті охоплюють множення (зсув-і-додавання проти пошуку в таблиці квадратів), ділення (з відновленням і логарифмічне), генерацію таблиці синусів через параболічну апроксимацію та малювання ліній за Брезенхемом з оптимізованими 8x8 матричними блоками. Це навчальний матеріал, написаний для спільноти програмістів ZX Spectrum, що пояснює фундаментальні техніки, потрібні будь-якому демо-кодеру.

І це, цілком точно, будівельні блоки, використані в Illusion.

Сфера потребує: таблиць тригонометричних підстановок для обчислення проекції (синус/косинус, параболічна апроксимація зі статті Dark'а). Множення з фіксованою точкою для масштабування. Ретельного макету пам'яті для швидкості (та сама дисципліна підрахунку тактів, якій Dark навчає протягом усіх статей). Підхід на основі таблиць пропуску для кодування геометрії сфери — це пряме застосування типу мислення, орієнтованого на попередні обчислення, який пропагує Dark.

Dark опублікував підручник. Потім написав демо, що демонструє кожну техніку з нього. Двадцять років потому Introspec зворотно розібрав демо і знайшов саме ті патерни, яким Dark навчав. У нас є обидві сторони історії: вчитель, що пояснює свої методи, і аналітик, що підтверджує — ці методи є саме тим, що містить готовий продукт.

## Дебат на Hype: Внутрішні цикли проти математики

Стаття Introspec'а 2017 року на Hype спровокувала довгий потік коментарів. Серед найсуттєвіших обмінів був дебат між kotsoft та Introspec'ом про те, де полягає справжня робота ефекту на кшталт цього.

kotsoft стверджував, що математичний підхід до проекції — як обчислюєш, який вихідний піксель відображається на яку екранну позицію — є критичним проектним рішенням. Зроби проекцію неправильно або використай наївний алгоритм — і жодна оптимізація внутрішнього циклу тебе не врятує. Математична модель визначає, чи ефект взагалі *здійсненний* на цьому залізі.

Introspec заперечив, що внутрішній цикл — це місце, де такти насправді витрачаються. Можна мати прекрасну математичну модель, але якщо код рендерингу коштує 200 тактів на байт замість 100, ти вдвічі знизив частоту кадрів. Математичний підхід визначає, *що* обчислювати; внутрішній цикл визначає, *чи встигнеш ти обчислити вчасно*.

Обидва праві, і напруга між ними висвітлює щось фундаментальне про демосценове кодування. Демо-ефект — це не чиста математика і не чиста інженерія. Це перетин: елегантна обчислювальна схема (проекція сфери, закодована як таблиці пропуску), поєднана з ефективною стратегією виконання (згенеровані розгорнуті цикли з просуванням `INC L`). Жодне з них саме по собі не достатнє.

Підсумок Introspec'а вловлює це: "кодерські ефекти — це завжди про еволюцію обчислювальної схеми." Слово *еволюцію* ключове. Ти не починаєш з підручникового алгоритму і оптимізуєш його, поки він не вміститься. Ти еволюціонуєш алгоритм і реалізацію разом, кожен обмежує та уможливлює інший, доки не знайдеш форму, що працює в межах бюджету заліза.

## Практика: Спрощена сфера 56x56, що обертається

Давай накидаємо, як побудувати спрощену версію цього ефекту. Ми цілимо на сферу 56x56 пікселів — 7 байтів у ширину на екваторі, 56 рядків розгортки у висоту. Мета — не відтворити повний рендеринговий рушій Illusion, а достатньо зрозуміти базову техніку, щоб її реалізувати.

### Крок 1: Попередній розрахунок геометрії сфери

Для кожного рядка розгортки *y* (від -28 до +27, центрованого на сфері), обчисли видиму дугу:

```
radius_at_y = sqrt(R^2 - y^2)    ; where R = 28 (sphere radius in pixels)
```

Це дає половину ширини сфери на цьому рядку розгортки. Для кожної піксельної позиції *x* в межах цієї дуги, обчисли відповідну довготу та широту на поверхні сфери:

```
latitude  = arcsin(y / R)
longitude = arcsin(x / radius_at_y) + rotation_angle
```

Це дає координати (u, v) у вихідній текстурі для кожного екранного пікселя.

### Крок 2: Побудова таблиць пропуску

Замість зберігання повних пар (u, v) для кожного пікселя (занадто дорого з точки зору пам'яті), обчисли *різницю позицій у вихідних даних* між суміжними екранними пікселями. Для кожного рядка розгортки тобі потрібен список значень пропуску: скільки вихідних пікселів просунути між послідовними екранними відборами.

Біля екватора послідовні екранні пікселі відображаються на майже суміжні вихідні пікселі — пропуски по 1. Біля полюсів проекція стискається, і ти пропускаєш більше вихідних пікселів — пропуски по 2, 3 або більше.

Зберігай це як таблицю. Для нашої сфери 56x56 тобі потрібно максимум 56 записів на рядок (найширший рядок), помножених на 56 рядків, помножених на один байт на запис. Це максимум 3 136 байтів для одного кута повороту — але на практиці можна використати вертикальну симетрію (верхня половина дзеркально відображає нижню) та зберігати лише половину таблиці.

Для анімації тобі потрібні таблиці пропуску для кількох кутів повороту. З 32 кроками повороту можна вмістити таблиці приблизно в 32 x 1 568 = близько 49 КБ. Це переповнює доступну пам'ять, тому на практиці використовуєш менше кроків повороту, грубіше кутове розділення або регенеруєш таблиці на льоту з компактного представлення.

### Крок 3: Генерація коду рендерингу

Для кожного кадру зчитай таблицю пропуску для поточного кута повороту та згенеруй код Z80:

```z80
; Code generator pseudocode (in Z80 assembly, this would be
; a loop that writes opcodes into a buffer)

generate_sphere_code:
    ld   iy,skip_table        ; pointer to skip distances
    ld   ix,code_buffer       ; pointer to output code buffer

.line_loop:
    ; For each scan line...
    ld   b,bytes_this_line    ; number of output bytes (e.g. 7 at equator)

.byte_loop:
    ; For each output byte, emit code for 8 pixels:
    ld   c,8                  ; 8 pixels per byte

.pixel_loop:
    ; Emit: ADD A,A
    ld   (ix+0),$87           ; opcode for ADD A,A
    inc  ix

    ; Emit: ADD A,(HL)
    ld   (ix+0),$86           ; opcode for ADD A,(HL)
    inc  ix

    ; Emit INC L instructions based on skip distance
    ld   a,(iy+0)             ; read skip distance
    inc  iy

.emit_inc_l:
    or   a
    jr   z,.pixel_done
    ld   (ix+0),$2C           ; opcode for INC L
    inc  ix
    dec  a
    jr   nz,.emit_inc_l

.pixel_done:
    dec  c
    jr   nz,.pixel_loop

    ; Emit: LD (DE),A  (write byte to screen)
    ld   (ix+0),$12           ; opcode for LD (DE),A
    inc  ix
    ; Emit: INC E
    ld   (ix+0),$1C           ; opcode for INC E
    inc  ix

    dec  b
    jr   nz,.byte_loop

    ; Emit line transition code here (advance DE to next screen line)
    ; ...

    jr   .line_loop
```

Це спрощено — справжній код Illusion більш щільно інтегрований, і Dark, ймовірно, використовував компактніший та ефективніший генератор коду. Але принцип той самий: зчитай відстані пропуску, емітуй опкоди.

### Крок 4: Виконання та відображення

Коли буфер коду заповнений, виклич його як підпрограму:

```z80
    ld   hl,source_image      ; source texture (page-aligned, 1 byte/pixel)
    ld   de,screen_address    ; start of sphere area in video memory
    call code_buffer          ; execute the generated rendering code
```

Згенерований код проходить через усю сферу, зчитуючи вихідні пікселі, пакуючи їх в екранні байти та записуючи у відеопам'ять. Коли він повертається, сфера намальована.

Для анімації збільшуй кут повороту, завантажуй відповідну таблицю пропуску (або регенеруй її), регенеруй код і рендери знову.

### Крок 5: Макет вихідного зображення

Вихідна текстура має бути організована для швидкого послідовного доступу. Оскільки код рендерингу використовує `INC L` для просування по ній, текстура повинна бути вирівняна за сторінкою (починатися з адреси, де молодший байт дорівнює `$00`), і кожен рядок має вміщуватись у 256 байтів. Текстура шириною 256 пікселів, збережена як один байт на піксель, ідеально відповідає цьому обмеженню: кожен рядок займає одну сторінку.

Для монохромного випадку кожен піксель має значення `$00` або `$01`. Це означає, що `ADD A,(HL)` або додає 0 (піксель вимкнений), або 1 (піксель увімкнений) до молодшого біта акумулятора, одразу після того як `ADD A,A` зсунув усе вгору. Результат — бітово запакований екранний байт, де кожен біт відповідає відібраному вихідному пікселю.

---

## Загальний патерн

Сфера в Illusion — це конкретний приклад загального демосценового патерну, що з'являється по всій цій книзі. Патерн має три частини:

**Попередні обчислення.** Затратна математична робота — проекція, тригонометрія, перетворення координат — виконується один раз (або один раз за кадр) і зберігається як компактні таблиці. Таблиці кодують *що* рендерити, не кодуючи *як*.

**Генерація коду.** Сам код рендерингу генерується з таблиць. Це усуває розгалуження, лічильники циклів та умовну логіку з внутрішнього циклу. Кожна інструкція в згенерованому коді виконує корисну роботу. Немає накладних витрат на "з'ясування, що робити далі" — це рішення було прийнято під час генерації.

**Послідовний доступ до пам'яті.** Внутрішній цикл зчитує дані послідовно, просуваючи вказівник однобайтними інкрементами. Це найшвидший можливий патерн доступу на Z80, де непрямі через регістр завантаження (`LD A,(HL)`) дешеві, а індексована адресація (`LD A,(IX+d)`) дорога.

Ротозумер у наступному розділі використовує той самий патерн. Як і скролер з точкового поля в Розділі 10. Як і атрибутні тунелі в Розділі 9. Деталі різняться — різні таблиці, різний згенерований код, різні формати даних — але архітектура та сама. Introspec впізнав це, коли написав, що кодерські ефекти — це "еволюція обчислювальної схеми." Сфера, ротозумер, тунель: усі вони еволюціонували з одного фундаментального підходу. Еволюція — в деталях — яке обчислення, який макет таблиці, який внутрішній цикл — але скелет спільний.

Dark зрозумів це у 1996 році. Він закодував це у своїх статтях для Spectrum Expert у 1997 році. Introspec підтвердив це дизасемблюванням у 2017 році. Патерн залишається таким же актуальним зараз, як і тоді, на будь-якій платформі, де такти дефіцитні і кожна інструкція повинна виправдати своє існування.

---

## Підсумок

- Ефект сфери в Illusion накладає монохромне вихідне зображення на сферу, що обертається, за допомогою динамічно згенерованого коду Z80.
- Таблиці підстановки кодують геометрію сфери як відстані пропуску пікселів. Код рендерингу генерується з цих таблиць під час виконання.
- Внутрішній цикл використовує `ADD A,A` та `ADD A,(HL)` для накопичення пікселів в екранні байти, зі змінною кількістю інструкцій `INC L` для просування по вихідних даних.
- Продуктивність: 101 + 32x тактів на вихідний байт, де x залежить від позиції.
- Підхід ілюструє загальний демосценовий патерн: попередні обчислення геометрії, генерація коду, послідовний доступ до пам'яті.
- Dark написав фундаментальні алгоритми у Spectrum Expert (1997) і застосував їх в Illusion (1996). Introspec зворотно розібрав результат двадцять років потому, підтвердивши техніки.

---

> **Джерела:** Introspec, "Technical Analysis of Illusion by X-Trade" (Hype, 2017); Dark, "Programming Algorithms" (Spectrum Expert #01, 1997). Потік коментарів на Hype включає внески від kotsoft, Raider та інших.
