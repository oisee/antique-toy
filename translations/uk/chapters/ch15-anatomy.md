# Розділ 15: Анатомія двох машин

> "Design characterizes realizational, stylistic, ideological integrity."
> -- Introspec (spke), "For Design" (Hype 2015)

Ласкаво просимо до Частини V. Ми будуємо гру.

Частини I--IV дали тобі інструментарій демосценера: підрахунок тактів, екранні трюки, оптимізацію внутрішніх циклів, звукову архітектуру, стиснення. Гра висуває інші вимоги. Тобі потрібна повна карта пам'яті, а не лише область екрану. Тобі потрібно розуміти перемикання банків, бо дані рівнів, музика та графіка спрайтів не вмістяться в одному неперервному блоці. Тобі потрібно знати, як два процесори Agon Light 2 спілкуються між собою, бо твій ігровий цикл охоплює цю межу.

Цей розділ -- апаратний довідник для всього, що далі. Де Розділ 1 дав тобі бюджет кадру, а Розділ 2 -- розкладку екрану, цей розділ дає тобі все інше. Тримай його в закладках.

---

## 15.1 ZX Spectrum 128K: Карта пам'яті

Оригінальний 48K Spectrum мав просту модель пам'яті: 16 КБ ROM за адресами `$0000`-`$3FFF`, 48 КБ RAM за адресами `$4000`-`$FFFF`. Модель 128K зберігає цю розкладку видимою для процесора, але приховує систему перемикання банків під нею.

128K має вісім 16-КБ сторінок RAM (сторінки 0-7, загалом 128 КБ) та два 16-КБ ROM (ROM 0: редактор 128K, ROM 1: 48K BASIC). У кожний момент Z80 бачить 64-КБ адресний простір, розділений на чотири 16-КБ слоти:

| Діапазон адрес | Вміст | Примітки |
|----------------|-------|----------|
| `$0000`-`$3FFF` | ROM (0 або 1) | Обирається бітом 4 порту `$7FFD` |
| `$4000`-`$7FFF` | Сторінка RAM 5 | **Завжди** сторінка 5. Тут живе екранна пам'ять. |
| `$8000`-`$BFFF` | Сторінка RAM 2 | **Завжди** сторінка 2. |
| `$C000`-`$FFFF` | Сторінка RAM N | Перемикається: будь-яка сторінка 0-7 через `$7FFD` |

Сторінки 5 і 2 жорстко прив'язані до своїх слотів. Ти не можеш їх замінити. Це означає, що екран (`$4000`-`$57FF`) завжди доступний, і твій основний код (зазвичай з ORG `$8000`) сидить у сторінці 2, де він не зникне при перемиканні банків.

Верхній 16-КБ слот за адресою `$C000`-`$FFFF` -- гнучкий. Запиши в порт `$7FFD`, і сторінка, відображена туди, зміниться.

### Порт $7FFD: Перемикання банків

Порт `$7FFD` контролює конфігурацію пам'яті на 128K. Він доступний лише для запису -- ти не можеш його прочитати назад. Це означає, що ти маєш зберігати його значення-тінь у змінній RAM, якщо тобі потрібно знати поточний стан.

```
Port $7FFD bit layout:
  Bit 0-2:  RAM page mapped at $C000 (0-7)
  Bit 3:    Screen select (0 = normal screen at page 5,
                           1 = shadow screen at page 7)
  Bit 4:    ROM select (0 = 128K ROM, 1 = 48K BASIC ROM)
  Bit 5:    Disable paging (set this and banking is locked
            until next reset -- used by 48K BASIC)
  Bits 6-7: Unused
```

Типова процедура перемикання банків:

```z80
; Switch RAM page at $C000 to page number in A (0-7)
; Preserves other $7FFD bits from shadow variable
bank_switch:
    ld   b, a                 ; 4T   save desired page
    ld   a, (bank_shadow)     ; 13T  load current $7FFD state
    and  %11111000            ; 7T   clear page bits (0-2)
    or   b                    ; 4T   insert new page number
    ld   (bank_shadow), a     ; 13T  update shadow
    ld   bc, $7FFD            ; 10T
    out  (c), a               ; 12T  do the switch
    ret                       ; 10T
                              ; --- 73T total
```

Ці 73 такти (T-state) не безкоштовні, але нехтовні порівняно з бюджетом кадру 70 000+. Справжня вартість перемикання банків -- архітектурна, не часова: ти маєш проектувати розкладку даних так, щоб тобі ніколи не потрібен одночасний доступ до двох різних банкованих сторінок. Дані музики в сторінці 4, дані рівня в сторінці 3, графіка спрайтів у сторінці 6 -- але твій програвач музики та твій рендерер не можуть обидва працювати з `$C000` одночасно.

**Тіньовий екран.** Біт 3 порту `$7FFD` обирає, яку сторінку RAM ULA читає для відображення: сторінку 5 (нормальну) або сторінку 7 (тіньову). Це дає тобі апаратну подвійну буферизацію -- малюй у тіньовий екран, поки ULA відображає нормальний, потім перемикай, переключивши біт 3. Ми будемо інтенсивно використовувати це в Розділі 17 (Скролінг) та Розділі 21 (Повна гра).

### Практична карта пам'яті для гри на 128K

Ось як реальна гра може розкласти свої 128 КБ по восьми сторінках:

| Сторінка | Слот | Використання |
|----------|------|-------------|
| 0 | `$C000` (банкований) | Дані рівнів (карти, визначення тайлів) |
| 1 | `$C000` (банкований) | Набір графіки спрайтів 1 |
| 2 | `$8000`-`$BFFF` (фіксований) | Основний код гри, система сутностей, обробник переривань |
| 3 | `$C000` (банкований) | Набір графіки спрайтів 2, таблиці підстановки |
| 4 | `$C000` (банкований) | Дані музики (паттерни .pt3, інструменти) |
| 5 | `$4000`-`$7FFF` (фіксований) | Основний екран, пам'ять атрибутів, системні змінні |
| 6 | `$C000` (банкований) | Звукові ефекти, додаткові дані рівнів |
| 7 | `$C000` (банкований) | Тіньовий екран (ціль подвійної буферизації) |

Зверни увагу: сторінка 7 виконує подвійну функцію. ULA може відображати її як тіньовий екран, але ти також можеш підключити її до `$C000` і використовувати як 16-КБ сторінку даних, коли ти не використовуєш подвійну буферизацію. Багато демо використовують це.

Критичне обмеження: **твій обробник переривань та головний цикл повинні жити в сторінках 2 або 5**, тому що це єдині сторінки, гарантовано підключені в усі моменти. Якщо переривання спрацьовує, коли сторінка 4 підключена до `$C000`, і твій обробник переривань живе за адресою `$C000`, процесор стрибає в твої музичні дані замість коду. Результат -- аварія, зазвичай видовищна.

**Правило:** ніколи не розміщуй критичний за часом код у банкованій сторінці, якщо ти не абсолютно впевнений, яка сторінка активна, коли цей код виконується.

![ZX Spectrum 128K memory map](illustrations/output/ch15_memory_map.png)

---

## 15.2 Спірна пам'ять: Практична правда

У Розділі 1 ми встановили, що клони Pentagon не мають спірної пам'яті і що підрахунок тактів надійний скрізь. Це правда, і Pentagon залишається стандартом для потактово точної роботи з демо. Але якщо ти пишеш гру для випуску, серед твоїх гравців будуть люди на оригінальному залізі Sinclair, моделях Amstrad +2A/+3 та сучасних FPGA-клонах, що емулюють оригінальний таймінг. Тобі потрібно знати, що робить спірна пам'ять і як уникнути її найгірших наслідків.

Introspec детально висвітлив це у своїх статтях "GO WEST" на Hype (2015). Ось практичне резюме.

### Що стає спірним

На оригінальних машинах Sinclair ULA та процесор ділять шину пам'яті. Коли ULA читає екранні дані для малювання дисплея (протягом 192 активних рядків розгортки), будь-який доступ процесора до певних сторінок RAM затримується. Процесор буквально призупиняється на додаткові такти (T-state), поки ULA завершує своє читання.

Спірні сторінки відрізняються між моделями:

| Модель | Спірні сторінки | Завжди швидкі |
|--------|----------------|---------------|
| 48K | Вся RAM (`$4000`-`$FFFF`) | Немає (але `$8000`+ менш спірна на практиці) |
| 128K / +2 | Сторінки 1, 3, 5, 7 | Сторінки 0, 2, 4, 6 |
| +2A / +2B / +3 | Сторінки 4, 5, 6, 7 | Сторінки 0, 1, 2, 3 |

48K -- найгірший випадок -- вся RAM спірна. На 128K патерн -- кожна непарна сторінка. На +2A/+3 він перевертається: старші сторінки спірні.

Це має безпосередні практичні наслідки. На 128K твій основний код за адресою `$8000` (сторінка 2) знаходиться в неспірній пам'яті -- швидкий. Екран за адресою `$4000` (сторінка 5) спірний -- записи в екранну пам'ять повільніші під час активного відображення. І сторінка 7 (тіньовий екран) також спірна, що означає, що заповнення подвійного буфера в тіньовому екрані повільніше, ніж ти міг очікувати, на оригінальному залізі.

### Наскільки повільніше?

Introspec виміряв реальні штрафи:

- **Випадковий байтовий доступ до спірної пам'яті:** приблизно **0,92 додаткових такти (T-state) на байт** в середньому під час активного відображення
- **Стекові операції (PUSH/POP) до спірної пам'яті:** приблизно **1,3 додаткових такти (T-state) на байт** в середньому
- **Під час часу бордюру:** **нульовий штраф** -- спірність виникає лише поки ULA активно малює рядки розгортки

Ця цифра 0,92 означає, що `LD A,(HL)`, яке повинно коштувати 7 тактів (T-state), коштуватиме в середньому близько 7,92, коли HL вказує на спірну пам'ять під час активного відображення. PUSH, що записує два байти в спірну пам'ять за 11 тактів (T-state), коштуватиме близько 13,6 замість цього.

Ці середні значення приховують брудну реальність: фактичний штраф залежить від того, де в 8-тактовому циклі читання ULA потрапляє твій доступ процесора до пам'яті. Патерн повторюється кожні 8 тактів (T-state): штрафи 6, 5, 4, 3, 2, 1, 0, 0 додаткових тактів. Ти можеш потрапити в будь-яку точку цього циклу, і штраф накопичується з кожним зверненням до пам'яті в межах інструкції. Це робить точний підрахунок тактів на спірних машинах дійсно складним.

### Практична відповідь

Для розробки ігор, а не демо-ефектів, підхід простий:

1. **Розміщуй код у неспірній пам'яті.** На 128K -- ORG за адресою `$8000` (сторінка 2) -- завжди швидко.
2. **Пиши на екран під час часу бордюру, коли це можливо.** Верхній і нижній бордюри дають тобі безспірний доступ до екранної пам'яті. Як і лівий/правий бордюр кожного рядка розгортки.
3. **Не турбуйся про точне моделювання спірності.** Закладай 15-20% уповільнення для коду, що торкається екранної пам'яті під час активного відображення, і проектуй бюджет кадру з цим запасом. Це не потактово точна робота з демо; це розробка ігор.
4. **Тестуй на реальному залізі або точних емуляторах.** Fuse емулює спірність правильно. Unreal Speccy (режим Pentagon) -- ні, за задумом. ZEsarUX може емулювати кілька моделей.

Порада Introspec з GO WEST зводиться до цього: **спірна пам'ять -- це питання портативності, а не драма.** Якщо твій код працює на Pentagon, він майже напевно працюватиме на оригінальному залізі теж -- просто трохи повільніше під час записів на екран. Місця, де спірність дійсно ламає речі -- це потактово точні растрові ефекти (мультиколор, синхронізація через плаваючу шину), а це демо-техніки, а не ігрові.

---

## 15.3 Таймінг ULA

ULA генерує відеосигнал та переривання процесора. Розуміння її таймінгу необхідне для ефектів бордюру, музики на перериваннях та синхронізації екрану.

### Структура кадру

Повний кадр складається з рядків розгортки. Ширина рядка розгортки та загальна кількість рядків розгортки відрізняються між моделями:

| Машина | Тактів/рядок | Рядків розгортки | Тактів/кадр |
|--------|-------------|-----------------|-------------|
| ZX Spectrum 48K | 224 | 312 | 69 888 |
| ZX Spectrum 128K | 228 | 311 | 70 908 |
| Pentagon 128 | 224 | 320 | 71 680 |

Зверни увагу на ширший рядок розгортки 128K (228 проти 224 тактів (T-state)). Додаткові 4 такти на рядок знаходяться в частині бордюру/синхронізації, а не в активному відображенні.

### Такт-карти: Регіони кадру

Кадр ділиться на три регіони. Переривання спрацьовує на початку вертикального гасіння, перед верхнім бордюром. Ось карта таймінгу для кожної моделі:

**Pentagon 128 (71 680 тактів (T-state))**

```
Interrupt ──┐
            │
Top border  │  80 lines × 224T = 17,920T   No screen reads. No contention.
            │
Active      │ 192 lines × 224T = 43,008T   ULA reads screen memory.
display     │                                No contention on Pentagon.
            │
Bottom      │  48 lines × 224T = 10,752T   No screen reads. No contention.
border      │
────────────┘  Total: 71,680T
```

**ZX Spectrum 128K (70 908 тактів (T-state))**

```
Interrupt ──┐
            │
Top border  │  63 lines × 228T = 14,364T   No screen reads. No contention.
            │
Active      │ 192 lines × 228T = 43,776T   ULA reads screen memory.
display     │                                Contention on pages 1,3,5,7.
            │
Bottom      │  56 lines × 228T = 12,768T   No screen reads. No contention.
border      │
────────────┘  Total: 70,908T
```

**ZX Spectrum 48K (69 888 тактів (T-state))**

```
Interrupt ──┐
            │
Top border  │  64 lines × 224T = 14,336T   No screen reads. No contention.
            │
Active      │ 192 lines × 224T = 43,008T   ULA reads screen memory.
display     │                                Contention on all RAM.
            │
Bottom      │  56 lines × 224T = 12,544T   No screen reads. No contention.
border      │
────────────┘  Total: 69,888T
```

Після `HALT` ти маєш увесь період верхнього бордюру -- 17 920 тактів (T-state) на Pentagon, 14 364 на 128K -- щоб робити роботу до того, як промінь увійде в область активного відображення і почнеться спірність. Ось чому добре структурований код для Spectrum робить записи на екран на початку кадру: ти отримуєш безспірний доступ до екранної пам'яті під час періоду бордюру.

### Таймінг рядка розгортки

Кожний рядок розгортки поділяється на активну частину (де ULA читає екранні дані) та частини бордюру/синхронізації:

**48K та Pentagon (224 такти (T-state) на рядок):**

```
128T  active pixel area (ULA reads screen data)
 24T  right border
 48T  horizontal sync + retrace
 24T  left border
```

**128K (228 тактів (T-state) на рядок):**

```
128T  active pixel area (ULA reads screen data)
 24T  right border
 52T  horizontal sync + retrace
 24T  left border
```

Протягом 128 активних тактів (T-state) доступ до пам'яті спірних сторінок затримується (на не-Pentagon машинах). Протягом решти 96 тактів (або 100 на 128K) -- без спірності. Навіть під час активного відображення приблизно половина кожного рядка розгортки безспірна.

### Загальний проти практичного бюджету

Загальні значення кадру вище -- це час між перериваннями. *Практичний* бюджет -- такти (T-state), доступні для твого коду -- менший:

| Накладні витрати | Вартість |
|-----------------|----------|
| HALT + підтвердження переривання (IM1) | ~30 тактів (T-state) |
| Мінімальний ISR (EI + RET) | ~14 тактів (T-state) |
| Типовий програвач музики PT3 (в ISR) | ~3 000--5 000 тактів (T-state) |
| Обслуговування головного циклу (лічильник кадрів, перехід HALT) | ~20--50 тактів (T-state) |

Практичні бюджети з працюючим програвачем музики:

| Машина | Загалом | Після програвача PT3 | Після програвача + запас спірності |
|--------|---------|---------------------|-----------------------------------|
| Pentagon | 71 680 | ~66 000--68 000 | ~66 000--68 000 (без спірності) |
| 128K | 70 908 | ~65 000--67 000 | ~55 000--60 000 (записи на екран під час активного відображення) |
| 48K | 69 888 | ~64 000--66 000 | ~50 000--55 000 (вся RAM спірна) |

Коли ця книга каже "бюджет кадру ~70 000 тактів (T-state)", це означає загальне значення. При плануванні внутрішніх циклів закладай практичну цифру -- зазвичай 65 000--68 000 на Pentagon з музикою.

---

## 15.4 Плаваюча шина, ULA Snow та баг $7FFD

Це три апаратні дивацтва, що з'являються на оригінальних машинах Sinclair, але не на більшості клонів. Ти можеш ніколи не зустріти їх при розробці ігор, але вони можуть спричинити загадкові баги, якщо ти не знаєш про їх існування.

### Плаваюча шина

На оригінальному залізі Spectrum читання з непідключеного порту повертає дані, які ULA в цей момент виставляє на шину даних. Під час активного відображення ULA читає екранну пам'ять, тому читання з порту `$FF` повертає байт, який ULA зараз читає.

Демо-кодери використовують це для синхронізації з променем: читай плаваючу шину в щільному циклі, поки не побачиш відоме значення з екранної пам'яті, і ти точно знаєш, де знаходиться промінь. Це найдешевший метод синхронізації -- не потрібен таймінг переривань.

Ігри рідко потребують цього, але знай: якщо твій код читає з порту, який не існує на залізі, повернене значення непередбачуване і варіюється між моделями. Плаваюча шина *не* емулюється на Pentagon, Scorpion або ZX Next.

### Баг читання $7FFD

Порт `$7FFD` доступний лише для запису. Але на деяких моделях Spectrum читання з порту `$7FFD` (навіть ненавмисне, через інструкцію, що випадково виставляє `$7FFD` на адресну шину) спричиняє запис значення плаваючої шини в порт. Це викликає спонтанне перемикання сторінки.

Практична небезпека: інструкція Z80 `LD A,(nn)` виставляє адресу `nn` на шину під час виконання. Якщо `nn` випадково є `$7FFD` і ти читаєш дані, збережені за адресою `$7FFD`, читання пам'яті може спричинити запис у порт на оригінальному залізі. Це неочевидний баг, але реальний. Уникай зберігання даних за адресою `$7FFD`.

### ULA Snow

Якщо регістр I процесора Z80 (використовується для базової адреси таблиці векторів переривань IM2) встановлений на значення в діапазоні `$40`-`$7F`, цикл оновлення DRAM під час кожного вибирання опкоду M1 виставляє адресу в діапазоні `$4000`-`$7FFF` на адресну шину. Це конфліктує з читанням екрану ULA і створює візуальний "сніг" -- випадковий шум на дисплеї.

Виправлення просте: **ніколи не встановлюй I на значення між `$40` та `$7F`.** Типове налаштування IM2 використовує `I = $FE` з 257-байтною таблицею ідентичних векторів за адресами `$FE00`-`$FF00`. Це тримає I значно вище небезпечної зони.

---

## 15.5 Відмінності клонів

Екосистема ZX Spectrum включає десятки клонів, але три найважливіші для сучасної розробки: Pentagon 128, Scorpion ZS-256 та ZX Spectrum Next.

### Pentagon 128

Pentagon -- стандартна платформа для російської демосцени та основна ціль для демосценних розділів цієї книги.

| Параметр | Pentagon 128 | Оригінальний 128K |
|----------|-------------|-------------------|
| Тактова частота | 3,5 МГц | 3,5 МГц |
| Тактів на кадр | **71 680** | 70 908 |
| Рядків розгортки на кадр | **320** | 311 |
| Спірна пам'ять | **Немає** | Сторінки 1, 3, 5, 7 |
| Рядки бордюру (верх) | **80** | 63 |
| Рядки бордюру (низ) | **48** | 56 |

Додаткові 772 такти (T-state) на кадр (71 680 проти 70 908) приходять від додаткових рядків розгортки. Бордюр розподілений інакше: вищий верхній бордюр і коротший нижній. Це впливає на ефекти бордюру -- демо-код, що створює симетричний патерн бордюру на 128K, буде трохи асиметричним на Pentagon.

Відсутність спірної пам'яті -- визначальна риса Pentagon для програмістів. Кожна інструкція коштує рівно стільки, скільки вказано в документації. Ось чому ми використовуємо таймінг Pentagon протягом усієї книги.

**Турбо-режим 7 МГц.** Багато Pentagon-сумісних машин (Pentagon 512, Pentagon 1024, ATM Turbo 2+) пропонують турбо-режим 7 МГц. Процесор працює на подвійній швидкості, але таймінг ULA залишається тим самим. Це означає, що бюджет кадру подвоюється до приблизно 143 360 тактів (T-state) у турбо-режимі. Пастка: турбо-режим не стандартний на всіх машинах, і код, що на нього покладається, не працюватиме на стандартному Pentagon 128 або будь-якому залізі Sinclair.

Для ігор турбо-режим -- це розкіш, що дозволяє запускати складнішу логіку або більше спрайтів на кадр. Для демо, що цілять на правила компо, він зазвичай заборонений -- змагання вказують "Pentagon 128K, 3,5 МГц."

### Scorpion ZS-256

Scorpion -- це український клон з 256 КБ RAM (16 сторінок по 16 КБ) та кількома апаратними розширеннями.

| Особливість | Scorpion ZS-256 |
|-------------|----------------|
| RAM | 256 КБ (16 сторінок) |
| Перемикання банків | Розширений порт `$1FFD` для сторінок 8-15 |
| Графіка | Режим GMX: 320x200, 16 кольорів з 256 |
| Спірна пам'ять | Немає |
| Таймінг кадру | Сумісний з Pentagon (71 680 тактів (T-state)) |

Подвоєна RAM корисна для ігор: ти отримуєш 16 сторінок даних замість 8. Додаткові сторінки доступні через порт `$1FFD`, який використовує схему, подібну до `$7FFD`, але контролює додаткову RAM.

GMX (Graphics Mode Extended) -- це коронний прийом Scorpion: дисплей 320x200 з 16 кольорами, обраними з 256-кольорової палітри. Це повністю порушує атрибутний дисплей Spectrum, пропонуючи лінійний фреймбуфер, ближчий до того, що ти міг би побачити на Amiga або PC VGA. Фреймбуфер GMX великий (32 000 байт для 4-бітного кольору) і живе в розширених сторінках RAM.

Мало ігор цілять на GMX, бо це обмежує аудиторію власниками Scorpion. Але це демонструє, що може робити Z80-обладнання, звільнене від атрибутної сітки ULA.

### ZX Spectrum Next

ZX Spectrum Next -- сучасний флагман платформи: FPGA-машина, зворотно сумісна з оригінальним Spectrum, але з суттєвим новим обладнанням.

| Особливість | ZX Spectrum Next |
|-------------|-----------------|
| Процесор | Z80N (Z80 + нові інструкції) на 3,5 / 7 / 14 / 28 МГц |
| RAM | 1 МБ (розширюється до 2 МБ), 8-КБ сторінки MMU |
| MMU | 8 слотів x 8 КБ = точне управління відображенням пам'яті |
| Layer 2 | 256x192 або 320x256, 8-бітний колір (256 кольорів) |
| Тайлмапа | Апаратний шар тайлмапи, 40x32 або 80x32 тайлів |
| Спрайти | 128 апаратних спрайтів, 16x16, до 12 на рядок розгортки |
| Copper | Співпроцесор для порядкових змін регістрів |
| DMA | zxnDMA для швидких блочних переносів |
| AY-звук | 3 x AY-3-8910 (9 каналів) з поканальним стерео-панорамуванням |

**MMU** Next фундаментально відрізняється від перемикання банків 128K. Замість одного перемикного 16-КБ слоту Next ділить весь 64-КБ адресний простір на вісім 8-КБ слотів. Кожний слот може бути незалежно відображений на будь-яку 8-КБ сторінку з пулу RAM 1-2 МБ. Це означає, що ти можеш мати точне управління:

```z80
; Map 8KB page $0A into slot 3 ($6000-$7FFF)
    ld   a, $0A
    ld   bc, $243B          ; Next register select port
    ld   a, $53             ; Register $53 = MMU slot 3
    out  (c), a
    ld   bc, $253B          ; Next register data port
    ld   a, $0A             ; Page $0A
    out  (c), a
```

Це набагато гнучкіше за єдиний перемикний слот 128K. Ти можеш відобразити дані спрайтів в одне 8-КБ вікно, дані рівня в інше і музичні дані в третє -- все одночасно видиме.

**Layer 2** дає тобі 256-кольоровий бітмап-дисплей без конфлікту атрибутів. Це єдине найбільше покращення якості життя для розробників ігор: більше ніякого ретельного планування атрибутів, ніяких обхідних шляхів для конфлікту кольорів. Просто фреймбуфер, де кожний байт -- один піксель. Ціна -- пам'ять: Layer 2 екран 256x192 займає 49 152 байти.

**Апаратні спрайти** на Next надають 128 спрайтових слотів, кожний 16x16 пікселів з 8-бітним кольором, до 12 на рядок розгортки. Атрибути спрайтів (позиція, патерн, обертання) встановлюються через регістри Next та порт `$57`. Програмний рендеринг не потрібен.

**Copper** -- це співпроцесор, що виконує просту програму, синхронізовану з позицією променя. Він може записувати в будь-який регістр Next на будь-якому рядку розгортки, забезпечуючи порядкові зміни палітри, зсуви прокрутки та растрові ефекти без споживання тактів (T-state) Z80 -- свідомий оммаж Amiga Copper.

**zxnDMA** забезпечує апаратно-прискорений блочний перенос зі швидкістю приблизно 2 такти (T-state) на байт -- приблизно в 10 разів швидше, ніж `LDIR`. Для заповнення фреймбуфера Layer 2 або переносу даних спрайтів DMA є трансформаційним.

Next -- це, по суті, інша машина, яка випадково зворотно сумісна. Цікаві обмеження зсуваються від "чи вміщу я це в бюджет кадру" до "як найкраще використати кілька апаратних шарів."

---

## 15.6 Agon Light 2: Інший звір

Agon Light 2 -- друга платформа для наших розділів з розробки ігор. Вона працює на Zilog eZ80 -- прямому нащадку Z80 -- на частоті 18,432 МГц, з 512 КБ плоскої RAM та окремим співпроцесором ESP32, що обробляє відео та аудіо. Архітектура принципово відрізняється від Spectrum: замість процесора, що ділить шину з фіксованим чипом відеовиходу, Agon використовує два незалежних процесори, що спілкуються через послідовний зв'язок.

### Двопроцесорна архітектура

Визначальна характеристика Agon -- поділ між **eZ80** (твій процесор) та **ESP32** (VDP, відеопроцесор):

```
                        +-----------+
                        |   eZ80    |  18.432 MHz
                        |  512 KB   |  Your code runs here
                        |  MOS API  |  24-bit addressing
                        +-----+-----+
                              |
                          UART serial
                          (384 Kbaud)
                              |
                        +-----+-----+
                        |   ESP32   |  240 MHz dual-core
                        |  FabGL    |  Video: up to 640x480
                        |  VDP      |  Audio: waveforms, samples
                        +-----------+
```

Цей поділ має глибокі наслідки:

1. **Немає спільної відеопам'яті.** Ти не можеш записувати безпосередньо у фреймбуфер. Кожний піксель, кожний спрайт, кожна тайлова операція -- це *команда*, надіслана через послідовний зв'язок від eZ80 до ESP32.
2. **Затримка.** Послідовний зв'язок працює на 384 000 бод. Один командний байт передається приблизно за 26 мікросекунд. Складні операції малювання (заповнення прямокутника, малювання бітмапу) вимагають кількох байт, і VDP потрібен час для їх виконання.
3. **Асинхронний рендеринг.** VDP обробляє команди з буфера. Твій код eZ80 надсилає команди та продовжує працювати. VDP наздоганяє незалежно. Це означає, що ти не маєш щільного зв'язку Spectrum між процесорною роботою та виводом на екран -- але ти також не можеш точно контролювати, коли пікселі з'являються.
4. **Незалежна частота кадрів.** VDP рендерить зі своєю частотою (зазвичай 60 Гц). Твій ігровий цикл eZ80 може працювати з будь-якою частотою; VDP відобразить те, що він найостанніше намалював.

Для програмістів Spectrum це зміна парадигми. Ти переходиш від "я пишу байти у відеопам'ять і вони з'являються на наступному рядку розгортки" до "я надсилаю команди малювання і довіряю VDP відрендерити їх з часом." Плюс -- величезно зменшене навантаження на процесор для графіки. Мінус -- менше контролю.

### Модель пам'яті eZ80: 24-бітна плоска

eZ80 має 24-бітну адресну шину, що дає йому теоретичний 16-МБ адресний простір. Agon Light 2 відображає 512 КБ RAM на початок цього простору:

| Діапазон адрес | Розмір | Вміст |
|----------------|--------|-------|
| `$000000`-`$07FFFF` | 512 КБ | RAM |
| `$080000`-`$0FFFFF` | 512 КБ | RAM (дзеркало, на деяких платах) |
| `$A00000`-`$FFFFFF` | різне | Введення-виведення, периферія на кристалі |

Без перемикання банків. Без перемикання сторінок. Без спірної пам'яті. Твій код, твої дані, твої буфери, твої таблиці підстановки -- все живе в одному плоскому, лінійно адресованому просторі. Після 8-сторінкової жонглерської вправи Spectrum це визволяюче.

eZ80 підтримує два режими роботи, що визначають, як він використовує цей адресний простір.

### Режим ADL проти режиму Z80

Це найважливіша архітектурна відмінність на Agon, і вона постійно збиває з пантелику новачків.

**Режим Z80** (також називається Z80-сумісний режим) змушує eZ80 поводитися як класичний Z80: 16-бітні регістри, 16-бітні адреси, 64-КБ адресний простір. Весь стандартний код Z80 працює без змін. Старші 8 біт адреси приходять з регістра MBASE, створюючи 64-КБ "вікно" в 24-бітний адресний простір. Це те, що ти використовуєш при портуванні існуючого коду Z80.

**Режим ADL** (Address Data Long) -- рідний режим eZ80: 24-бітні регістри, 24-бітні адреси, повний 16-МБ адресний простір. HL, BC, DE, SP та IX/IY всі 24 біти шириною. `LD HL,$123456` завантажує 3-байтне значення. `PUSH HL` штовхає 3 байти на стек (не 2). Кожний вказівник -- 3 байти.

```z80
; ADL mode: 24-bit addressing, full 512KB accessible
    ld   hl, $040000       ; point to a buffer 256KB into RAM
    ld   (hl), $FF         ; write directly -- no banking needed
    ld   bc, 1024
    ld   de, $040001
    ldir                   ; fill 1KB in one shot
```

MOS (операційна система Agon) завантажує eZ80 в режимі ADL, і більшість ПЗ Agon залишається в режимі ADL. Ключові відмінності від режиму Z80:

| Особливість | Режим Z80 | Режим ADL |
|-------------|-----------|-----------|
| Ширина регістрів | 16 біт | 24 біти |
| Адресний простір | 64 КБ (через MBASE) | 16 МБ (24-біт) |
| Розмір PUSH/POP | 2 байти | 3 байти |
| Адреси JP/CALL | 16-біт | 24-біт |
| Розмір стекового кадру | 2 байти на запис | 3 байти на запис |
| Кодування інструкцій | Z80-сумісне | Розширене (3-байтні адреси) |

**Пастка:** якщо ти пишеш код, припускаючи 16-бітні значення, і запускаєш його в режимі ADL, речі ламаються по-тонкому. `PUSH HL` штовхає 3 байти, не 2, тому твої стекові структури даних мають інший розмір. `JP (HL)` стрибає на 24-бітну адресу, тому таблиці підстановки 16-бітних адрес не працюватимуть. eZ80 надає інструкції з суфіксами `LD.S` та `LD.L` для явного контролю ширини даних, і ти можеш перемикатися між режимами з префіксами `JP.LIL` / `JP.SIS`, але це швидко ускладнюється.

**Практичне правило для ігор:** залишайся в режимі ADL. Використовуй 24-бітні адреси скрізь. Не намагайся ділити код між збіркою для Spectrum та збіркою для Agon на рівні вихідного коду -- адресація занадто різна. Натомість діли *алгоритми* та *формати даних*, з платформо-специфічними реалізаціями для доступу до пам'яті, введення-виведення та графіки.

### MOS API: Операційна система

MOS (Machine Operating System) надає системні сервіси на Agon: файлове введення-виведення, клавіатурний ввід, доступ до таймера та комунікацію з VDP. Виклики MOS здійснюються через `RST $08` з номером функції в регістрі A:

```z80
; MOS API: open a file
    ld   hl, filename       ; pointer to null-terminated filename
    ld   c, $01             ; mode: read
    rst  $08                ; MOS call
    db   $0A                ; function $0A: ffs_fopen
    ; Returns file handle in A
filename:
    db   "level1.dat", 0
```

Ключові функції MOS для розробки ігор:

| Функція | Код | Опис |
|---------|-----|------|
| `mos_getkey` | `$00` | Читання клавіатури (неблокуюче) |
| `mos_load` | `$01` | Завантаження файлу з SD-карти |
| `mos_save` | `$02` | Збереження файлу на SD-карту |
| `mos_sysvars` | `$08` | Отримання вказівника на системні змінні (лічильник vsync тощо) |
| `ffs_fopen` | `$0A` | Відкриття файлу |
| `ffs_fclose` | `$0B` | Закриття файлу |
| `ffs_fread` | `$0C` | Читання з файлу |
| `mos_getrtc` | `$12` | Отримання часу реального часу |

Файлове введення-виведення на Agon тривіально просте порівняно зі Spectrum. Без завантаження з стрічки, без обгорток esxDOS, без TR-DOS: просто відкрий файл з SD-карти і прочитай його в пам'ять. Дані рівнів, спрайт-листи, музика -- завантажуй за запитом, без банкової гімнастики.

### VDP-команди: Спілкування з екраном

Вся графіка проходить через VDU-команди, надіслані до ESP32 VDP. eZ80 надсилає байти у VDU-вихідний потік; VDP інтерпретує їх як інструкції малювання:

```z80
; VDP: draw a filled rectangle at (10, 10)
    rst  $10 : db 25        ; PLOT command
    rst  $10 : db 85        ; mode: filled rectangle
    rst  $10 : db 10        ; x low
    rst  $10 : db 0         ; x high
    rst  $10 : db 10        ; y low
    rst  $10 : db 0         ; y high
```

Багатослівно порівняно з `LD (HL),A`, але VDP виконує рендеринг на ESP32. VDP підтримує бітмап-режими (до 640x480), до 256 апаратних спрайтів (кожний до 64x64), апаратні тайлмапи з прокруткою та аудіо (форми хвиль, ADSR, семпли).

Вузьке місце -- послідовний зв'язок, а не процесор. Складна сцена з багатьма оновленнями спрайтів може насичити UART, викликаючи візуальний лаг. Мінімізуй VDP-команди на кадр: групуй оновлення, використовуй апаратну прокрутку замість перемалювання тайлів і дозволяй спрайтовому рушію виконувати важку роботу.

---

## 15.7 Порівняння платформ

Розкладемо дві машини поруч, зосереджуючись на тому, що має значення для ігрового рушія, який ми побудуємо в Розділах 16-19.

| Особливість | ZX Spectrum 128K | Agon Light 2 |
|-------------|-----------------|---------------|
| Процесор | Z80A @ 3,5 МГц | eZ80 @ 18,432 МГц |
| Тактів на кадр (50 Гц) | ~70 908 (128K) / 71 680 (Pentagon) | ~368 640 |
| RAM | 128 КБ (8 x 16 КБ сторінок) | 512 КБ (плоска) |
| Адресний простір | 64 КБ (банкований) | 16 МБ (24-біт) |
| Екранна пам'ять | Спільна шина, прямий запис | Окремий VDP, на основі команд |
| Кольори | 15 (8 базових x яскравість (bright), мінус перетин) | До 64 у стандартних режимах |
| Роздільна здатність | 256x192 (атрибутний колір на 8x8) | Налаштовувана, до 640x480 |
| Спрайти | Лише програмні | До 256 апаратних спрайтів |
| Скролінг | Лише програмний (ручний зсув/копіювання) | Апаратні зсуви прокрутки |
| Звук | AY-3-8910 (3 канали) | Аудіо ESP32 (багатоканальне, форми хвиль) |
| Сховище | Стрічка / DivMMC (esxDOS) | SD-карта (FAT32) |
| Подвійна буферизація | Тіньовий екран (сторінка 7) | Керована VDP |

Відношення бюджетів кадрів приблизно 5:1 на користь Agon. Але графіка Agon проходить через послідовне вузьке місце, тому сира швидкість процесора не перетворюється напряму у швидкість рендерингу. На Spectrum `PUSH HL` записує два байти на екран за 11 тактів (T-state). На Agon оновлення позиції спрайта вимагає 6+ байт через зв'язок на 384 Кбод, що займає сотні мікросекунд незалежно від швидкості процесора.

Spectrum винагороджує побайтову оптимізацію. Agon винагороджує архітектурні рішення. Обидва винагороджують ретельне мислення про бюджети кадрів.

---

## 15.8 Практика: Утиліта інспектора пам'яті

Побудуймо простий інспектор пам'яті для обох платформ. Ця утиліта відображає область RAM як шістнадцяткові байти на екрані та дозволяє навігувати по пам'яті за допомогою клавіатури. Це інструмент, який ти використовуватимеш постійно під час розробки.

### Версія для Spectrum

Версія для Spectrum записує безпосередньо в екранну пам'ять. Ми відображаємо 16 рядків по 16 байт (256 байт на сторінку) з початковою адресою, показаною зліва.

```z80
; Memory Inspector - ZX Spectrum 128K
; Displays 256 bytes of memory as hex, navigable with keys
; ORG $8000 (page 2, uncontended)

    ORG  $8000

SCREEN_ATTR EQU $5800
START_ADDR  EQU inspect_addr      ; address to inspect (self-mod)

start:
    call clear_screen

main_loop:
    halt                          ; sync to frame

    ; Read keyboard
    call read_keys                ; returns: A = action
    cp   1
    jr   z, .page_up             ; Q = previous page
    cp   2
    jr   z, .page_down           ; A = next page
    cp   3
    jr   z, .bank_up             ; P = next bank
    cp   4
    jr   z, .bank_down           ; O = previous bank
    jr   .draw

.page_up:
    ld   hl, (inspect_addr)
    ld   de, -256
    add  hl, de
    ld   (inspect_addr), hl
    jr   .draw
.page_down:
    ld   hl, (inspect_addr)
    ld   de, 256
    add  hl, de
    ld   (inspect_addr), hl
    jr   .draw
.bank_up:
    ld   a, (current_bank)
    inc  a
    and  7                        ; wrap 0-7
    ld   (current_bank), a
    call bank_switch
    jr   .draw
.bank_down:
    ld   a, (current_bank)
    dec  a
    and  7
    ld   (current_bank), a
    call bank_switch

.draw:
    ; Display current bank and address
    call draw_header

    ; Display 16 rows x 16 bytes
    ld   hl, (inspect_addr)
    ld   b, 16                    ; 16 rows
    ld   de, $4060                ; screen position (row 3, col 0)
.row_loop:
    push bc
    push hl

    ; Print address
    ld   a, h
    call print_hex                ; print high byte of address
    ld   a, l
    call print_hex                ; print low byte
    ld   a, ':'
    call print_char

    ; Print 16 hex bytes
    pop  hl
    push hl
    ld   b, 16
.byte_loop:
    ld   a, (hl)
    call print_hex                ; 7T load + print routine
    inc  hl
    ld   a, ' '
    call print_char
    djnz .byte_loop

    pop  hl
    ld   de, 16
    add  hl, de                   ; advance to next row
    pop  bc

    ; Move screen pointer down one character row
    call next_char_row

    djnz .row_loop

    jr   main_loop

; --- Data ---
inspect_addr:  dw $C000          ; start address to inspect
current_bank:  db 0              ; current bank at $C000
bank_shadow:   db 0              ; shadow of port $7FFD

; read_keys, print_hex, print_char, clear_screen,
; draw_header, next_char_row, bank_switch: implementations
; omitted for brevity -- see examples/mem_inspect.a80
; for the complete compilable source.
```

Ключовий архітектурний момент: ми інспектуємо `$C000`, тому що це банкований слот. Змінюючи `current_bank`, ми можемо пройтися по всіх 8 сторінках RAM, використовуючи процедуру `bank_switch` з розділу 15.1. Сам інспектор живе за адресою `$8000` (сторінка 2), безпечний від змін банків.

### Версія для Agon

Версія для Agon використовує системні виклики MOS для клавіатурного вводу та текстовий вивід VDP. Без обчислення адрес екрану, без обробки атрибутів -- просто надсилай текст у VDP.

```z80
; Memory Inspector - Agon Light 2 (ADL mode)
    .ASSUME ADL=1
    ORG  $040000

main_loop:
    ; Wait for vsync via MOS sysvar
    rst  $08
    db   $08                      ; mos_sysvars
    ld   a, (ix+$00)              ; sysvar_time (low byte)
.wait_vsync:
    cp   (ix+$00)
    jr   z, .wait_vsync           ; spin until counter changes

    ; Check keyboard (Q = up, A = down)
    rst  $08
    db   $00                      ; mos_getkey
    ; ... navigation same as Spectrum version ...

.draw:
    rst  $10
    db   30                       ; VDU 30 = cursor home

    ld   hl, (inspect_addr)       ; 24-bit load!
    ld   b, 16
.row_loop:
    push bc
    push hl
    call print_hex24              ; print full 24-bit address
    ld   a, ':'
    rst  $10
    pop  hl
    push hl
    ld   b, 16
.byte_loop:
    ld   a, (hl)                  ; direct 24-bit access, no banking
    call print_hex8
    inc  hl
    djnz .byte_loop
    pop  hl
    ld   de, 16
    add  hl, de
    pop  bc
    djnz .row_loop
    jr   main_loop

inspect_addr: dl $000000          ; 24-bit address (dl, not dw)
; Full source: examples/mem_inspect_agon.a80
```

Зверни увагу на контраст:

- **Без перемикання банків.** Інспектор Agon може дивитися на будь-яку адресу в 512 КБ безпосередньо. `LD HL,$070000` -- і ти інспектуєш 448 КБ в RAM. Без портів, без тіньових змінних, без ризику підключити не ту сторінку.
- **Без обчислення адрес екрану.** Текстовий вивід йде через `RST $10`, і VDP обробляє позиціонування курсора, рендеринг символів та прокрутку.
- **24-бітні директиви даних.** Ми використовуємо `dl` (define long) для 3-байтних вказівників замість `dw` (define word).
- **VSync через системні змінні.** MOS надає лічильник `sysvar_time`, що інкрементується кожний кадр. Ми чекаємо на ньому у циклі для кадрової синхронізації -- грубіше, ніж `HALT` Spectrum, але функціональне.

Обидва інспектори роблять ту саму роботу. Версія для Spectrum -- більше коду (ти маєш обробляти все сам), але дає повний контроль. Версія для Agon -- менше коду (ОС та VDP обробляють відображення), але дає менше контролю над тим, як саме виглядає вивід.

Це відображає ширший досвід розробки на обох платформах. Spectrum вимагає більше зусиль для меншого візуального багатства. Agon вимагає менше зусиль для більшого візуального багатства. Обидва винагороджують розуміння обладнання.

---

## Підсумок

- **ZX Spectrum 128K** має 128 КБ RAM у 8 сторінках по 16 КБ. Сторінки 2 і 5 фіксовані в адресному просторі; верхній 16-КБ слот за адресою `$C000` перемикається через порт `$7FFD`. Тримай основний код у сторінці 2, а обробник переривань -- подалі від банкованої пам'яті.

- **Спірна пам'ять** уповільнює доступ процесора до певних сторінок RAM під час активного відображення на оригінальному залізі Sinclair. Середній штраф: ~0,92 додаткових такти (T-state) на байт. Клони Pentagon не мають спірності. Для розробки ігор закладай 15-20% накладних витрат на записи на екран і тримай критичний за часом код у неспірних сторінках.

- **Таймінг ULA:** переривання спрацьовує на початку кадру. Ти отримуєш ~14 000 тактів (T-state) безспірного часу до того, як промінь увійде в область активного відображення. Використовуй це вікно для записів на екран.

- **Порт `$7FFD`** доступний лише для запису. Зберігай його значення-тінь у RAM. Біт 3 обирає тіньовий екран (сторінка 7) для подвійної буферизації. Біт 5 вимикає перемикання сторінок остаточно до перезавантаження.

- **Плаваюча шина**, **ULA snow** та **баг читання `$7FFD`** -- це дивацтва оригінального заліза Sinclair. Уникай значень регістра I `$40`-`$7F`. Не зберігай дані за адресою `$7FFD`. Плаваюча шина відсутня на клонах.

- **Pentagon 128**: без спірної пам'яті, 71 680 тактів (T-state) на кадр, 320 рядків розгортки. Стандарт демосцени. Турбо-режим 7 МГц подвоює бюджет кадру на деяких варіантах.

- **Scorpion ZS-256**: 256 КБ RAM (16 сторінок), режим GMX 320x200x16 кольорів.

- **ZX Spectrum Next**: 1-2 МБ RAM з 8-КБ сторінками MMU, Layer 2 (256-кольоровий бітмап), 128 апаратних спрайтів, співпроцесор Copper, zxnDMA, потрійний AY-звук.

- **Agon Light 2** використовує двопроцесорну архітектуру: eZ80 @ 18,432 МГц для логіки, ESP32 для відео/аудіо. 512 КБ плоскої RAM, 24-бітна адресація (режим ADL), MOS API для системних сервісів, VDP-команди для всієї графіки.

- **Режим ADL проти режиму Z80**: режим ADL використовує 24-бітні регістри та адреси. Режим Z80 емулює класичний Z80 з 16-бітними адресами через MBASE. Залишайся в режимі ADL для нового коду Agon.

- **Послідовний зв'язок** між eZ80 та ESP32 -- це вузьке місце Agon. Мінімізуй трафік VDP-команд на кадр. Використовуй апаратні спрайти та тайлмапи для зменшення кількості команд малювання.

- Обидві платформи винагороджують ретельне управління бюджетом кадру. Spectrum дає тобі ~70 000 тактів (T-state) і вимагає побайтової оптимізації. Agon дає тобі ~368 000 тактів (T-state), але обмежує графіку через послідовний зв'язок. Різні обмеження, та сама дисципліна.

---

> **Джерела:** Introspec "GO WEST Parts 1--2" (Hype 2015); ZX Spectrum 128K Service Manual; Zilog eZ80 CPU User Manual; Agon Light 2 Documentation (Bernardo Kastrup); ZX Spectrum Next User Manual (2nd Edition)
