# Розділ 5: 3D на 3,5 МГц

> *"Обчислюй лише те, що мусиш. Решту -- виводь."*
> --- Dark & STS, Spectrum Expert #02 (1998)

Попередній розділ дав тобі будівельні блоки: множення, ділення, таблиці синусів, малювання ліній. Тепер ми збираємо їх разом. Мета -- об'ємний тривимірний об'єкт, що обертається, на ZX Spectrum: заповнені полігони, відсікання задніх граней, правильне впорядкування за глибиною -- з прийнятною частотою кадрів.

Ось де ти натикаєшся на стіну.

---

## Проблема: дванадцять множень на вершину

Обертання точки в тривимірному просторі навколо всіх трьох осей вимагає послідовності тригонометричних множень. Якщо обертати послідовно -- спочатку навколо Z, потім Y, потім X -- кожна вісь потребує чотирьох множень і двох додавань для перетворення двох координат. Три осі, чотири множення кожна: дванадцять множень на вершину.

Візьми множення зсувом і додаванням з Розділу 4, що коштує приблизно 200 тактів. Дванадцять таких дають 2 400 тактів для обертання однієї вершини. Простий куб має 8 вершин: 19 200 тактів лише на обертання. Розділ 4 показав, що це вкладається в бюджет кадру -- ледве.

Тепер спробуй щось цікавіше. Сфера, апроксимована 20 вершинами і 36 гранями:

```
20 вершин x 2 400 тактів = 48 000 тактів
```

Це 67% бюджету кадру Pentagon (71 680 тактів), витрачених ще до того, як намальовано хоч один піксель. Потрібна ще перспективна проєкція, відсікання задніх граней, сортування полігонів і власне заповнення. Місця немає. Об'єкт не може бути складнішим за куб, якщо не знайти принципово дешевший спосіб обчислення позицій вершин.

Dark і STS знайшли один.

---

## Метод середньої точки

Ідея -- геометрична. Не кожна вершина об'єкта несе незалежну інформацію. Багато вершин перебувають на структурно передбачуваних позиціях -- серединах ребер, центрах граней, відбиттях інших вершин. Якщо ці залежності виразити явно, можна замінити дороге множення дешевим усередненням.

### Куб як основа

Розглянь куб із центром у початку координат. Він має 8 вершин, але це не 8 незалежних точок. Це 4 пари діаметрально протилежних вершин. Знаючи одну вершину пари, другу отримуєш запереченням через центр:

```
v0 = ( x,  y,  z)    →    v7 = (-x, -y, -z)
v1 = ( x,  y, -z)    →    v6 = (-x, -y,  z)
v2 = ( x, -y,  z)    →    v5 = (-x,  y, -z)
v3 = ( x, -y, -z)    →    v4 = (-x,  y,  z)
```

Оберни 4 вершини повною 12-множинною процедурою. Заперечуй їх, щоб отримати інші 4. Заперечення на Z80 -- це `NEG`: 8 тактів на одну координату, 24 такти на всі три. Порівняй з 2 400 тактів для повного обертання. Ти скоротив обчислення вершин майже вдвічі.

Але метод середньої точки йде набагато далі за дзеркалення.

### Виведення вершин через усереднення

Ключова операція -- усереднення: для двох уже обчислених точок їхня середня точка -- просто середнє арифметичне їхніх координат.

```
v_new = (v_a + v_b) / 2
```

На Z80 це додавання і зсув:

```z80
; Average two signed 8-bit coordinates
; A = first coordinate, B = second coordinate
; Result in A = (A + B) / 2

    add  a, b           ;  4 T-states
    sra  a              ;  8 T-states
                        ; ----
                        ; 12 T-states total
```

`SRA` (Shift Right Arithmetic) зберігає біт знаку, тож це правильно працює для від'ємних координат. Для всіх трьох координат (x, y, z) усереднення коштує 36 тактів на виведену вершину. Порівняй з 2 400 тактів для повного обертання.

Співвідношення вражаюче: усереднення в **66 разів дешевше** за обертання.

Це означає, що можна будувати складні об'єкти з невеликого набору "базових" вершин, які обертаєш повністю, а потім виводиш решту через ланцюжки усереднень. Чим більше вершин можна вивести, тим більше часу економиш.

### Побудова складних об'єктів

Припустимо, потрібен об'єкт з 20 вершинами. За методом середньої точки:

1. Повне обертання 4 базових вершин: 4 x 2 400 = 9 600 тактів
2. Дзеркалення 4 вершин запереченням: 4 x 24 = 96 тактів
3. Виведення 12 вершин усередненням: 12 x 36 = 432 такти
4. **Разом: 10 128 тактів**

Без методу середньої точки ті ж 20 вершин коштували б 48 000 тактів. Ти зекономив 37 872 такти -- більш ніж половину бюджету кадру, вивільнену для проєкції, відсікання та рендерингу.

Обмеження -- топологічне: вершину можна вивести усередненням лише тоді, коли вона дійсно лежить на середині між двома іншими (або достатньо близько, щоб похибка була невидимою при роздільності 256x192). Це визначає, як проєктувати 3D-моделі. Ти не моделюєш вільно і потім оптимізуєш -- ти проєктуєш модель *навколо* структури середніх точок від самого початку.

Dark і STS наводять приклади ланцюжків виведення:

```
v8  = (v4 + v5) / 2
v9  = (v3 + v7) / 2
v10 = (v2 + v6) / 2
v11 = (v8 + v9) / 2     ; виведена з двох вже виведених вершин
```

Зверни увагу, що v11 виведена з v8 і v9, які самі є виведеними. Ланцюжки можуть заходити на кілька рівнів вглиб. Кожен рівень додає лише 36 тактів на вершину, тож вартість залишається незначною незалежно від глибини.

---

## Віртуальний процесор

Ось де Dark робить щось, що для 1998 року здається анахронізмом. Замість жорсткого кодування ланцюжків виведення для кожного конкретного об'єкта, він проєктує мініатюрний інтерпретатор -- віртуальний процесор -- що виконує "програми", які описують, як обчислювати вершини.

### Архітектура

Віртуальний процесор має:

- **Один регістр** (робочий регістр, що містить одну 3D-точку -- три байти: x, y, z)
- **64 комірки пам'яті** (кожна містить одну 3D-точку -- 192 байти загалом)
- **4 інструкції**

| Опкод | Біти | Назва | Операція |
|--------|------|------|-----------|
| 00 | `00nnnnnn` | **Load** | регістр <-- комірка[n] |
| 01 | `01nnnnnn` | **Store** | комірка[n] <-- регістр |
| 10 | `10nnnnnn` | **Average** | регістр <-- (регістр + комірка[n]) / 2 |
| 11 | `11------` | **End** | зупинити виконання |

Кожна інструкція кодується одним байтом: 2 біти для опкоду, 6 бітів для номера комірки (0--63). Увесь набір інструкцій вміщується в 256 можливих значень.

### Виконання

Цикл інтерпретатора надзвичайно компактний:

```z80
; Virtual processor main loop
; IX points to the program (sequence of 1-byte instructions)
; Point RAM at a fixed address, 3 bytes per cell

vp_loop:
    ld   a, (ix+0)        ; fetch instruction
    inc  ix
    ld   b, a             ; save full instruction
    and  %11000000        ; extract opcode (top 2 bits)

    cp   %11000000        ; END?
    ret  z                ; yes — halt

    ld   a, b
    and  %00111111        ; extract cell number (bottom 6 bits)
    ; ... compute cell address from cell number ...
    ; ... dispatch based on opcode ...

    jr   vp_loop
```

Інструкція **Load** копіює значення x, y, z комірки в робочий регістр. **Store** копіює робочий регістр назад у комірку. **Average** додає координати комірки до робочого регістра і зсуває кожен результат вправо на один -- операція середньої точки. **End** завершує програму.

### Написання програм

Ланцюжок виведення вершин стає простою послідовністю байтів. Dark використовує компактну нотацію у статті:

```z80
; Example: derive v8 = (v4 + v5) / 2, then store it
; Cell 4 = v4, Cell 5 = v5, Cell 8 = destination

    DB  4           ; LOAD cell[4]     (opcode 00, cell 4)
    DB  128+5       ; AVG  cell[5]     (opcode 10, cell 5 = %10000101)
    DB  64+8        ; STORE cell[8]    (opcode 01, cell 8 = %01001000)
```

Нотація `128+5` кодує `%10000101` -- опкод 10 (Average) з номером комірки 5. `64+8` кодує `%01001000` -- опкод 01 (Store) з номером комірки 8. Прості числа, запаковані в байти даних, що утворюють мініатюрну предметно-орієнтовану програму.

Повний опис об'єкта може виглядати так:

```z80
; Midpoint program for a 12-vertex object
; Cells 0-3: basis vertices (rotated by main code)
; Cells 4-7: mirrored vertices (negated by main code)
; Cells 8-11: derived via midpoint averaging

midpoint_program:
    DB  0               ; LOAD v0
    DB  128+1           ; AVG  v1           -> register = (v0+v1)/2
    DB  64+8            ; STORE v8

    DB  2               ; LOAD v2
    DB  128+3           ; AVG  v3           -> register = (v2+v3)/2
    DB  64+9            ; STORE v9

    DB  4               ; LOAD v4
    DB  128+5           ; AVG  v5           -> register = (v4+v5)/2
    DB  64+10           ; STORE v10

    DB  6               ; LOAD v6
    DB  128+7           ; AVG  v7           -> register = (v6+v7)/2
    DB  64+11           ; STORE v11

    DB  192             ; END               (%11000000)
```

Тринадцять байтів описують обчислення чотирьох виведених вершин. Віртуальний процесор виконує їх приблизно за 13 x 30 = 390 тактів (кожна інструкція займає приблизно 25--35 тактів залежно від типу). Чотири повністю обернуті вершини коштували б 9 600 тактів. Економія величезна.

### Чому саме віртуальний процесор?

Можна запитати: чому б не написати код усереднення безпосередньо на Z80-асемблері? Вставити додавання і зсуви прямо в код, пропустивши накладні витрати інтерпретатора. Це було б трохи швидше на вершину.

Відповідь -- гнучкість. Віртуальний процесор відділяє *опис* топології об'єкта від *виконання* обчислення вершин. Змінити об'єкт? Напиши нову програму -- нову послідовність байтів даних. Код інтерпретатора не змінюється. Можна зберігати програми для кількох об'єктів і перемикатися між ними без жодних витрат на код. Можна навіть генерувати програми алгоритмічно.

По суті, це предметно-орієнтований інтерпретатор байткоду -- патерн, який сучасні програмісти впізнали б з ігрових рушіїв, компіляторів шейдерів і скриптових мов. Dark спроєктував його в 1998 році, на ZX Spectrum, щоб зекономити такти на обчисленні вершин. Архітектура напрочуд чиста.

---

## Обертання

Коли метод середньої точки бере на себе більшість вершин, базові вершини все одно потрібно обертати повноцінно. Dark і STS використовують послідовне обертання навколо трьох осей у порядку: Z, потім Y, потім X. Кожне обертання використовує таблиці синуса і косинуса з Розділу 4.

### Обертання навколо осі Z

Обертання навколо Z впливає лише на X та Y:

```
X' = X * cos(Az) + Y * sin(Az)
Y' = -X * sin(Az) + Y * cos(Az)
```

На Z80-асемблері, з використанням знакового множення 8x8 і 256-елементних таблиць синуса/косинуса:

```z80
; Rotate point around Z axis
; Input:  (px), (py) = coordinates; (angle_z) = rotation angle
; Output: (px), (py) updated
; Uses:   cos_table, sin_table (page-aligned, signed 8-bit)

rotate_z:
    ld   a, (angle_z)
    ld   l, a
    ld   h, cos_table >> 8
    ld   d, (hl)            ; D = cos(Az)
    ld   h, sin_table >> 8
    ld   e, (hl)            ; E = sin(Az)

    ; X' = X*cos(Az) + Y*sin(Az)
    ld   a, (px)
    ld   b, a
    ld   c, d               ; B=X, C=cos
    call mul_signed          ; HL = X * cos(Az)
    push hl

    ld   a, (py)
    ld   b, a
    ld   c, e               ; B=Y, C=sin
    call mul_signed          ; HL = Y * sin(Az)
    pop  de
    add  hl, de             ; HL = X*cos + Y*sin
    ld   a, h               ; take high byte as new X'
    ld   (px), a

    ; Y' = -X*sin(Az) + Y*cos(Az)
    ld   a, (px_original)   ; need the original X, not the updated one
    neg
    ld   b, a
    ld   c, e               ; B=-X, C=sin
    call mul_signed          ; HL = -X * sin(Az)
    push hl

    ld   a, (py)
    ld   b, a
    ld   c, d               ; B=Y, C=cos
    call mul_signed          ; HL = Y * cos(Az)
    pop  de
    add  hl, de             ; HL = -X*sin + Y*cos
    ld   a, h
    ld   (py), a

    ret
```

Той самий патерн повторюється для обертання навколо осі Y (впливає на X і Z) та осі X (впливає на Y і Z). Dark обгортає всі три в єдину процедуру `ROTATE`, що приймає три параметри кута і перетворює точку на місці.

Зверни увагу на деталь збереження оригінального значення X. Друга формула використовує X до обертання, а не щойно обчислене X'. Поширена помилка -- використати вже оновлену координату, що дає перекошене обертання. Dark явно звертає на це увагу у статті.

### Вартість на базову вершину

Кожне обертання навколо осі вимагає 4 множень і 2 додавань. При 200 тактах на множення і 11 тактах на 16-бітне додавання:

```
На вісь:    4 x 200 + 2 x 11 = 822 такти
Три осі:    3 x 822 = 2 466 тактів на вершину
```

Із 4 базовими вершинами: приблизно 9 864 такти на обертання. Додай виконання програми середньої точки -- і отримаєш повне обчислення вершин для довільно складного об'єкта за частку наївної вартості.

---

## Проєкція

Коли всі вершини обернуті в 3D-просторі, потрібно спроєктувати їх на 2D-екран.

### Паралельна проєкція

Найпростіший підхід: повністю ігноруй координату Z. Просто використовуй X та Y як екранні координати (з відповідним зсувом для центрування об'єкта на екрані).

```z80
; Parallel projection: screen coords = rotated X, Y + offset
    ld   a, (px)
    add  a, 128             ; center horizontally (128 = half of 256)
    ld   (screen_x), a

    ld   a, (py)
    add  a, 96              ; center vertically (96 = half of 192)
    ld   (screen_y), a
```

Вартість: фактично нуль. Результат виглядає плоским -- об'єкти не здаються такими, що віддаляються в глибину. Паралельна проєкція корисна для каркасних попередніх переглядів та ефектів, де саме обертання створює ілюзію глибини, але їй бракує відчутного ефекту перспективи.

### Перспективна проєкція

Перспектива робить ближні об'єкти більшими, а далекі -- меншими, створюючи підказку глибини, що робить 3D переконливим:

```
Xscreen = (X * Scale) / (Z + Zdistance) + Xoffset
Yscreen = (Y * Scale) / (Z + Zdistance) + Yoffset
```

`Scale` контролює поле зору. `Zdistance` -- відстань від камери до площини проєкції: запобігає діленню на нуль, коли Z наближається до камери, і контролює, наскільки агресивно об'єкти масштабуються з глибиною. `Xoffset` та `Yoffset` центрують проєкцію на екрані.

Дорога операція тут -- ділення. Одне ділення на координату, дві координати на вершину. З логарифмічним діленням з Розділу 4 (~60 тактів на ділення) вартість помірна:

```z80
; Perspective projection for one vertex
; Input:  (px), (py), (pz) = rotated 3D coordinates
; Output: (screen_x), (screen_y)

perspective:
    ; Compute denominator: Z + Zdistance
    ld   a, (pz)
    add  a, ZDISTANCE       ; Z + viewing distance
    ld   c, a               ; C = denominator

    ; Xscreen = (X * Scale) / (Z + Zdist) + Xoffset
    ld   a, (px)
    ld   b, SCALE
    call mul_signed          ; HL = X * Scale
    ld   a, h               ; take high byte as numerator
    call log_divide          ; A = A / C (using log tables)
    add  a, XOFFSET
    ld   (screen_x), a

    ; Yscreen = (Y * Scale) / (Z + Zdist) + Yoffset
    ld   a, (py)
    ld   b, SCALE
    call mul_signed          ; HL = Y * Scale
    ld   a, h
    call log_divide          ; A = A / C
    add  a, YOFFSET
    ld   (screen_y), a

    ret
```

Кожна вершина коштує два множення (400 тактів) і два логарифмічних ділення (120 тактів), плюс накладні витрати -- приблизно 600 тактів на вершину. Для 20 вершин: 12 000 тактів. Разом із обертанням за методом середньої точки маємо приблизно 22 000 тактів на все обчислення вершин і проєкцію. Менше третини бюджету кадру.

---

## Суцільні полігони

Каркасний об'єкт -- це колекція ребер. Суцільний об'єкт -- це колекція заповнених полігонів. Перехід від каркасу до суцільного вимагає три додаткові можливості: визначення видимих граней, їх сортування за глибиною і заповнення пікселями.

### Відсікання задніх граней

Закритий 3D-об'єкт має грані, що вказують на глядача, і грані, що вказують від нього. Задні полігони приховані й не потребують малювання. Їх пропуск економить час рендерингу і створює правильний суцільний вигляд без повного буфера глибини.

Тест -- геометричний. Для кожної грані обчисли Z-компоненту нормалі поверхні через векторний добуток двох векторів ребер:

```
Дано три вершини грані: v0, v1, v2

Вектори ребер:
    V = v1 - v0 = (Vx, Vy)    (в екранних координатах)
    W = v2 - v0 = (Wx, Wy)

Z-компонента нормалі = Vx * Wy - Vy * Wx
```

Якщо результат додатний -- грань орієнтована до глядача і має бути намальована. Якщо від'ємний -- грань дивиться від нас, відсікаємо її. Якщо нуль -- грань ребром і невидима.

```z80
; Backface culling test for one face
; Input: three projected vertices (x0,y0), (x1,y1), (x2,y2)
; Output: carry flag set if face is back-facing (should be culled)

backface_test:
    ; V = v1 - v0
    ld   a, (x1)
    sub  (ix+x0)
    ld   d, a               ; D = Vx = x1 - x0

    ld   a, (y1)
    sub  (ix+y0)
    ld   e, a               ; E = Vy = y1 - y0

    ; W = v2 - v0
    ld   a, (x2)
    sub  (ix+x0)
    ld   b, a               ; B = Wx = x2 - x0

    ld   a, (y2)
    sub  (ix+y0)
    ld   c, a               ; C = Wy = y2 - y0

    ; Normal Z = Vx * Wy - Vy * Wx
    ld   a, d
    call mul_signed_c        ; HL = Vx * Wy (D * C)
    push hl

    ld   a, e
    ld   c, b
    call mul_signed_c        ; HL = Vy * Wx (E * B)

    pop  de
    ex   de, hl
    or   a
    sbc  hl, de             ; HL = Vx*Wy - Vy*Wx

    bit  7, h               ; check sign
    ret                     ; carry/sign indicates facing
```

Два множення і віднімання на грань. При 400 тактах на множення плюс накладні витрати тест коштує приблизно 500 тактів на грань. Для об'єкта з 12 гранями це 6 000 тактів -- і для кожної відсіченої грані ти економиш повну вартість її заповнення.

У типовому обертовому суцільному об'єкті приблизно половина граней у кожен момент часу -- задні. Їх відсікання вдвічі зменшує навантаження на заповнення.

### Сортування за Z

Для опуклих об'єктів (куб, тетраедр) одне відсікання задніх граней дає правильний результат: кожна видима грань повністю видима, без перекриттів. Для увігнутих або багатооб'єктних сцен потрібно малювати грані від дальніх до ближніх, щоб ближчі перекривали дальші -- алгоритм художника.

Dark і STS обчислюють значення глибини для кожної видимої грані (зазвичай середнє Z її вершин) і сортують список граней відповідно. Простого сортування вставками достатньо для малої кількості граней -- сортування 6--12 граней займає незначний час порівняно з їх заповненням.

```z80
; Simplified depth sort: compute average Z for each visible face,
; sort face indices by descending Z (farthest first)

sort_faces:
    ; For each visible face:
    ;   average_z = (z[v0] + z[v1] + z[v2] + z[v3]) / 4
    ;   store (average_z, face_index) in sort buffer
    ; Then insertion-sort the buffer by average_z
    ; ...
```

### Заповнення опуклих полігонів

Коли відомо, які грані малювати і в якому порядку, потрібно їх заповнити. Опуклий полігон (усі внутрішні кути менші за 180 градусів) можна заповнити простим построковим підходом:

1. Знайди найвищу і найнижчу вершини.
2. Одночасно іди вниз по лівому і правому ребрах, по одному рядку розгортки за раз.
3. Для кожного рядка малюй горизонтальну лінію від лівого ребра до правого.

Прохід по ребрах використовує інкрементальне крокування у стилі Брезенхема -- без ділення на рядок, лише додавання та умовні збільшення. Горизонтальне заповнення -- це щільний цикл байтових записів:

```z80
; Fill one scan line from x_left to x_right at screen row Y
; Screen address already computed in HL

fill_scanline:
    ld   a, (x_right)
    sub  (ix+x_left)
    ret  c                  ; nothing to fill if right < left
    ret  z
    ld   b, a               ; B = pixel count

    ; For byte-aligned fills: write whole bytes
    ld   a, $FF             ; solid fill
.fill_loop:
    ld   (hl), a
    inc  l                  ; next byte (within same screen line)
    djnz .fill_loop
    ret
```

Це спрощено -- реальні заповнювачі полігонів мусять обробляти неповні байти на лівому та правому краях, де межа полігона проходить всередині байта, а не по його краю. Ці крайні випадки додають складності, але не багато вартості, бо вони трапляються лише двічі на рядок розгортки.

---

## Збираємо все разом

Повний цикл кадру для суцільного 3D-об'єкта, що обертається, слідує такій послідовності:

![Конвеєр 3D-рендерингу: модель, обертання, проєкція, екран](illustrations/output/ch05_3d_pipeline.png)

```
1. Оновити кути обертання (Az, Ay, Ax)
2. Для кожної базової вершини:
     Обернути навколо Z, Y, X осей             [~2 400 T на вершину]
3. Заперечити базові вершини для дзеркал       [~24 T на вершину]
4. Виконати програму середньої точки           [~36 T на виведену вершину]
5. Спроєктувати всі вершини (перспектива)      [~600 T на вершину]
6. Для кожної грані:
     Тест задньої грані                         [~500 T на грань]
     Якщо видима: обчислити середнє Z
7. Сортувати видимі грані за Z                 [~200 T для малих списків]
8. Для кожної видимої грані (від дальньої до ближньої):
     Заповнити полігон                           [залежить від площі]
9. Чекати наступний кадр (HALT)
```

Для об'єкта з 20 вершинами, 18 гранями та 4 базовими вершинами бюджет на кадр розподіляється так:

| Етап | Вершини/Грані | Вартість за одиницю | Разом |
|-------|---------------|----------|-------|
| Обертання (базові) | 4 | 2 466 | 9 864 |
| Заперечення (дзеркала) | 4 | 24 | 96 |
| Виведення через середню точку | 12 | 36 | 432 |
| Проєкція | 20 | 600 | 12 000 |
| Тест задніх граней | 18 | 500 | 9 000 |
| Сортування за Z | ~9 видимих | - | ~200 |
| Заповнення полігонів | ~9 видимих | ~1 500 серед. | ~13 500 |
| **Разом** | | | **~45 092** |

Сорок п'ять тисяч тактів із 71 680 доступних. Тісно, але здійсненно -- залишається 26 000 тактів на очищення екрану, оновлення кутів і малювання ребер або підсвічування контурів, що робить об'єкт чітким. І це для об'єкта з 20 вершинами -- значно складнішого за все, що можна було б дозволити з наївним обертанням.

---

## Форма об'єктів

Метод середньої точки впливає на те, як ти думаєш про 3D-моделі. Ти не проєктуєш меш і потім оптимізуєш -- ти починаєш із топології, яку метод вимагає.

Хороший об'єкт для методу середньої точки починається з малої бази. Чотири повністю обернуті точки визначають тетраедроподібний скелет. Заперечення подвоює їх до восьми. Усереднення за методом середньої точки заповнює решту. Мистецтво -- у виборі базових вершин, що дають корисні виведені точки.

Розглянь побудову об'єкта з 14 вершинами з нуля:

```
Базові:    v0, v1, v2, v3         (4 повністю обернуті)
Дзеркала:  v4, v5, v6, v7         (4 заперечені)
Виведені:
  v8  = (v0 + v1) / 2           середина ребра
  v9  = (v2 + v3) / 2           середина ребра
  v10 = (v4 + v5) / 2           середина ребра на дзеркальній стороні
  v11 = (v6 + v7) / 2           середина ребра на дзеркальній стороні
  v12 = (v0 + v2) / 2           середина перехресного ребра
  v13 = (v8 + v10) / 2          виведення другого рівня
```

Програма віртуального процесора для цього -- 19 байтів:

```z80
object_14v_program:
    DB  0, 128+1, 64+8      ; v8  = avg(v0, v1)
    DB  2, 128+3, 64+9      ; v9  = avg(v2, v3)
    DB  4, 128+5, 64+10     ; v10 = avg(v4, v5)
    DB  6, 128+7, 64+11     ; v11 = avg(v6, v7)
    DB  0, 128+2, 64+12     ; v12 = avg(v0, v2)
    DB  8, 128+10, 64+13    ; v13 = avg(v8, v10)
    DB  192                  ; END
```

Дев'ятнадцять байтів даних замінюють те, що інакше коштувало б 14 400 тактів множень обертання для 6 виведених вершин.

Можна йти далі. Другий рівень усереднення (виведення з уже виведених точок) не додає жодних додаткових витрат на інструкцію -- віртуальному процесору байдуже, чи комірка містить обернуту або виведену точку. Dark і STS описують ланцюжки завглибшки на три-чотири рівні, будуючи об'єкти з 30 і більше вершин лише з 3--4 базових точок.

Обмеження -- точність. Кожен крок усереднення вносить похибку округлення до 0,5 одиниць (від цілочисельного зсуву). Після трьох рівнів виведення кумулятивна похибка може досягти 1,5 одиниць -- помітно на об'єкті завширшки 60 пікселів, невидимо на об'єкті завширшки 120. Проєктуй об'єкти достатньо великими, щоб округлення було нижче роздільності екрану.

---

## Практика: суцільний об'єкт, що обертається

Ось план побудови повного суцільного 3D-об'єкта, що обертається, з використанням усього матеріалу цього розділу.

### Крок 1: Визначити об'єкт

Почни з базових вершин. Зрізаний октаедр добре підходить для методу середньої точки:

```z80
; 4 basis vertices in signed 8-bit coordinates
basis_vertices:
    DB   30,   0,  30     ; v0 (x, y, z)
    DB    0,  30,  30     ; v1
    DB   30,  30,   0     ; v2
    DB    0,   0,   0     ; v3 (at origin for center reference)
```

### Крок 2: Написати програму середньої точки

```z80
midpoint_prog:
    ; Mirrors: cells 4-7 are pre-negated by the main loop
    ; Derive additional vertices:
    DB  0, 128+1, 64+8        ; v8  = avg(v0, v1)
    DB  2, 128+3, 64+9        ; v9  = avg(v2, v3)
    DB  0, 128+2, 64+10       ; v10 = avg(v0, v2)
    DB  1, 128+3, 64+11       ; v11 = avg(v1, v3)
    DB  192                    ; END
```

### Крок 3: Визначити грані

```z80
; Face table: each face is a list of vertex indices + attribute byte
; Vertex order must be consistent (clockwise when front-facing)
face_table:
    DB  4, 0, 1, 8, 10        ; face 0: quad (4 vertices)
    DB  4, 2, 3, 9, 11        ; face 1: quad
    ; ... remaining faces ...
    DB  0                      ; end marker
```

### Крок 4: Цикл кадру

```z80
main_loop:
    halt                       ; wait for vsync (IM1)

    ; Clear the screen area (or use double buffering)
    call clear_viewport

    ; Update angles
    ld   hl, angle_z
    inc  (hl)
    ld   hl, angle_x
    ld   a, (hl)
    add  a, 2
    ld   (hl), a

    ; Rotate basis vertices
    ld   b, 4                  ; 4 basis vertices
    ld   ix, basis_vertices
    ld   iy, point_ram         ; cell 0 onwards
.rotate_basis:
    push bc
    call rotate_xyz            ; rotate point at (IX) by current angles
                               ; store result at (IY)
    ld   bc, 3
    add  ix, bc
    add  iy, bc
    pop  bc
    djnz .rotate_basis

    ; Negate for mirrors (cells 4-7 = negation of cells 0-3)
    call negate_basis

    ; Run midpoint program
    ld   ix, midpoint_prog
    call virtual_processor

    ; Project all vertices
    call project_all

    ; Backface cull and sort
    call cull_and_sort

    ; Draw visible faces
    call draw_faces

    jr   main_loop
```

Це скелет. Кожний `call` приховує процедуру, побудовану з технік цього розділу та Розділу 4. Сам цикл кадру чистий -- оновити, обчислити, намалювати, повторити.

---

## Історичний контекст: від журналу до демо

Dark і STS опублікували метод середньої точки у Spectrum Expert #02 в 1998 році. Це були молоді кодери з Санкт-Петербурга, що писали для дискового журналу, який поширювався в російській спільноті ZX Spectrum. Статті написані в прямому, практичному стилі людей, що навчають ровесників -- ось проблема, ось трюк, ось код.

Але Spectrum Expert не був академічною вправою. Dark був із X-Trade, тієї ж групи, що створила *Illusion* -- демо, яке здобуло перше місце на ENLiGHT'96. Алгоритми в журналі -- не теоретичні пропозиції; це будівельні блоки реального, переможного демо-коду. Таблиці синусів з Розділу 4 рухали ротозумер. Малювальник ліній рендерив каркаси. А метод середньої точки живив 3D-об'єкти.

Підхід із віртуальним процесором особливо вражає ретроспективно. В 1998 році домінуючі парадигми в професійній розробці ігор зсувалися в бік апаратного прискорення і геть від програмного рендерингу. На Spectrum апаратного прискорення не існувало. Все було програмним, і програмне забезпечення мало бути *спроєктованим* -- не просто написаним, а архітектурно продуманим. Інтерпретатор байткоду Dark'а для обчислення вершин -- це зразок програмної архітектури, який не виглядав би чужорідно в системі анімацій сучасного ігрового рушія чи компіляторі шейдерів. Він відділяє дані від виконання, дозволяє швидку ітерацію над дизайном об'єктів і тримає гарячий цикл щільним.

Зв'язок з *Illusion* глибший за спільне авторство. Коли Introspec дизасемблював *Illusion* двадцять років потому, він знайшов ту саму математичну інфраструктуру: множник зсувом і додаванням, параболічну таблицю синусів, дільник на таблицях логарифмів. Метод середньої точки і віртуальний процесор -- розширення цієї інфраструктури: те саме мислення, застосоване до іншої проблеми. Dark не просто публікував алгоритми; він документував інженерну філософію свого демо, що перемогло на змаганні.

У наступному розділі ми побачимо один із найвражаючіших ефектів *Illusion* впритул: текстурно-накладену сферу. Вона використовує ті ж таблиці синусів і ту ж арифметику з фіксованою точкою з Розділу 4, поєднані з техніками самомодифікованого коду з Розділу 3 і зовсім іншим підходом до проблеми рендерингу. Метод середньої точки і сфера -- рідні: народжені від того самого кодера, тих самих інструментів, того самого невпинного прагнення вмістити неможливе в 71 680 тактів.

---

## Підсумок

- Наївне обертання 3D-об'єктів вимагає 12 множень на вершину -- занадто дорого для складних об'єктів на Z80 з частотою 3,5 МГц.
- **Метод середньої точки** повністю обертає лише кілька базових вершин, а решту виводить через усереднення. Усереднення коштує ~36 тактів на вершину проти ~2 400 для повного обертання -- в 66 разів дешевше.
- **Віртуальний процесор** з 4 інструкціями (Load, Store, Average, End) виконує компактні "програми", що описують ланцюжки виведення вершин. Топологія об'єкта -- це дані, а не код.
- **Обертання** використовує послідовні перетворення осей Z/Y/X з таблицями підстановки синуса/косинуса з Розділу 4.
- **Перспективна проєкція** використовує логарифмічне ділення з Розділу 4 для ділення на Z.
- **Відсікання задніх граней** через тест нормалі перехресним добутком усуває невидимі грані при ~500 тактах кожна.
- **Сортування за Z** з алгоритмом художника обробляє перекриваючі грані для неопуклих об'єктів.
- Суцільний об'єкт з 20 вершинами можна відрендерити приблизно за ~45 000 тактів на кадр -- тісно, але здійсненно в межах 71 680-тактного бюджету.
- Ці техніки були опубліковані у Spectrum Expert #02 (1998) тою ж командою, що створила *Illusion*. Журнальні статті документують інженерію за демо.

---

*Усі підрахунки тактів у цьому розділі -- для Pentagon (без станів очікування). На стандартному 48K Spectrum зі спірною пам'яттю розраховуй на більші значення для коду, що виконується у нижніх 32K RAM. Повна таблиця таймінгів -- у Додатку A.*

> **Джерела:** Dark & STS, "Програмування: 3D-графіка" (Spectrum Expert #01, 1997); Dark & STS, "Програмування: 3D-графіка -- Метод середньої точки" (Spectrum Expert #02, 1998). Дизайн віртуального процесора і приклади виведення за методом середньої точки взяті безпосередньо зі статті SE#02.
