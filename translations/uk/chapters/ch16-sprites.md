# Розділ 16: Швидкі спрайти

> *«Два кольори на комірку? Гаразд. Але ці два кольори будуть рухатися.»*

---

Кожна гра потребує об'єктів, що рухаються. Кулі, вороги, персонаж гравця, вибухи. На будь-якому обладнанні з блітером або GPU механіка розміщення маленького зображення в довільній позиції екрану вирішується за тебе. На ZX Spectrum — це твоя проблема.

Spectrum не має апаратних спрайтів, блітера чи співпроцесора. Кожен піксель кожного спрайта розміщується твоїм кодом Z80, одна інструкція за раз, у ту саму відеопам'ять, яку ULA читає 50 разів на секунду. І оскільки розкладка екранної пам'яті черезрядкова (Розділ 2), «на один рядок нижче» означає `INC H` — якщо тільки ти не перетинаєш межу знакоряду, бо тоді це означає дещо значно потворніше.

Цей розділ представляє шість методів малювання спрайтів на Spectrum, від найпростішої XOR-процедури до скомпільованих спрайтів, що виконуються на теоретичній максимальній швидкості апаратури. Кожен метод має свої компроміси. Ми також розглянемо Agon Light 2, де VDP надає апаратні спрайти, і вся проблема зводиться до кількох викликів API.

---

## Метод 1: XOR-спрайти

### Найпростіший підхід

XOR-малювання — це мінімально життєздатний спрайт. Він не потребує даних маски, буфера збереження фону та кроку стирання. Ти малюєш спрайт, XOR-ючи його піксельні дані з екраном, і стираєш його, XOR-ючи ті самі дані знову — властивість XOR, що `A XOR B XOR B = A`, гарантує відновлення фону.

Ось повна процедура XOR-спрайта 16×16:

```z80
; Draw a 16x16 XOR sprite
; Input:  HL = screen address (top-left byte of sprite position)
;         IX = pointer to sprite data (32 bytes: 2 bytes x 16 rows)
;
xor_sprite_16x16:
    ld   b, 16              ;  7 T   16 rows

.row:
    ld   a, (ix+0)          ; 19 T   left byte of sprite row
    xor  (hl)               ;  7 T   combine with screen
    ld   (hl), a            ;  7 T   write back
    inc  l                  ;  4 T   move right one byte

    ld   a, (ix+1)          ; 19 T   right byte of sprite row
    xor  (hl)               ;  7 T
    ld   (hl), a            ;  7 T   write back
    dec  l                  ;  4 T   restore column

    inc  ix                 ; 10 T   \  advance sprite
    inc  ix                 ; 10 T   /  data pointer

    inc  h                  ;  4 T   move down one pixel row
    ld   a, h               ;  4 T   \
    and  7                  ;  7 T    | check character
    jr   nz, .no_boundary   ;  7 T   /  boundary crossing

    ; Character boundary: adjust HL
    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    jr   c, .no_fix         ;  7 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T
.no_fix:

.no_boundary:
    djnz .row               ; 13 T  (8 on last)
    ret                     ; 10 T
```

Внутрішній цикл коштує 98 тактів (T-state) на рядок у звичайному випадку (без перетину межі знакоряду) і до 131 такту (T-state) на межах знакорядів. Для 16 рядків: приблизно 1 700 тактів (T-state) на малювання. Щоб стерти спрайт, виклич ту саму процедуру знову з тією самою адресою екрану — XOR скасує себе.

Загальна вартість анімації одного XOR-спрайта: ~3 400 тактів (T-state) на кадр (малювання + стирання).

### Коли XOR працює

XOR-спрайти ідеальні для:

- **Курсорів.** Блимаючий текстовий курсор, перехрестя, підсвітка виділення. Будь-що, що сидить поверх статичного фону і не має потреби виглядати гарно.
- **Куль.** Снаряд 2×2 або 4×4, що рухається достатньо швидко, щоб візуальні артефакти були непомітні.
- **Відлагоджувальних маркерів.** Відображення меж зіткнення, позицій сутностей, вузлів шляху.

### Коли XOR підводить

XOR має дві серйозні проблеми. По-перше, візуальна якість погана. Там, де спрайт перекривається з існуючими даними екрану, пікселі інвертуються замість заміни. Білий спрайт, що проходить по білому тексту, стає невидимим. Ретельно намальований персонаж перетворюється на кашу інвертованих пікселів на тлі деталізованого фону.

По-друге, XOR не дає контролю над атрибутами. Колір спрайта — будь-яка комбінація ink/paper, що трапилась у комірках, які він перекриває. Для кулі чи курсора це прийнятно. Для спрайта персонажа — ні.

Попри свої обмеження, XOR достатньо корисний, щоб кожен ігровий програміст мав його в арсеналі. Двадцять рядків коду, нуль додаткової пам'яті, і воно просто працює.

---

## Метод 2: OR+AND маскировані спрайти

### Індустріальний стандарт

Майже кожна комерційна гра для Spectrum, випущена після 1984 року, використовувала цю техніку або її близький варіант. Маскований спрайт несе два фрагменти даних для кожного рядка: *маску* та *графіку*. Маска визначає форму спрайта — які пікселі належать спрайту, а які прозорі. Графіка визначає зовнішній вигляд спрайта — які з пікселів форми встановлені.

Алгоритм малювання для кожного байта:

1. Прочитай байт екрану.
2. AND його з маскою. Це очищає пікселі, де з'явиться спрайт, залишаючи решту фону недоторканою.
3. OR його з графікою. Це штампує пікселі спрайта в очищену область.

Результат: спрайт з'являється на екрані з прозорими областями, крізь які видно фон. Жодних XOR-артефактів. Жодних інвертованих пікселів. Чисті, професійні спрайти.

### Формат даних

Для спрайта 16×16 кожен рядок містить 4 байти: маска-ліва, графіка-ліва, маска-права, графіка-права. Байт маски має `1` для прозорих пікселів і `0` для непрозорих (бо AND з 1 зберігає фон, AND з 0 очищає його). Загальний обсяг даних на спрайт: 16 рядків × 4 байти = 64 байти.

### Внутрішній цикл

```z80
; Draw a 16x16 masked sprite (byte-aligned)
; Input:  HL = screen address
;         DE = pointer to sprite data
;              Format per row: mask_L, gfx_L, mask_R, gfx_R
;
masked_sprite_16x16:
    ld   b, 16              ;  7 T

.row:
    ; --- Left byte ---
    ld   a, (de)            ;  7 T   load mask
    and  (hl)               ;  7 T   clear sprite-shaped hole in background
    inc  de                 ;  6 T
    ld   c, a               ;  4 T   save masked background

    ld   a, (de)            ;  7 T   load graphic
    or   c                  ;  4 T   stamp sprite into hole
    ld   (hl), a            ;  7 T   write to screen
    inc  de                 ;  6 T
    inc  l                  ;  4 T   move right

    ; --- Right byte ---
    ld   a, (de)            ;  7 T   load mask
    and  (hl)               ;  7 T
    inc  de                 ;  6 T
    ld   c, a               ;  4 T

    ld   a, (de)            ;  7 T   load graphic
    or   c                  ;  4 T
    ld   (hl), a            ;  7 T
    inc  de                 ;  6 T
    dec  l                  ;  4 T   restore column

    ; --- Next row (DOWN_HL) ---
    inc  h                  ;  4 T
    ld   a, h               ;  4 T
    and  7                  ;  7 T
    jr   nz, .no_boundary   ;  7 T

    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    jr   c, .no_fix         ;  7 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T
.no_fix:
.no_boundary:
    djnz .row               ; 13 T
    ret                     ; 10 T
```

### Підрахунок тактів

Підрахуємо звичайний випадок (без перетину межі знакоряду):

| Секція | Інструкції | Такти (T-state) |
|--------|-----------|-----------------|
| Лівий байт: маска+малювання | `ld a,(de)` + `and (hl)` + `inc de` + `ld c,a` + `ld a,(de)` + `or c` + `ld (hl),a` + `inc de` + `inc l` | 52 |
| Правий байт: маска+малювання | Та сама послідовність + `dec l` | 52 |
| Перехід до рядка | `inc h` + `ld a,h` + `and 7` + `jr nz` | 22 |
| Цикл | `djnz` | 13 |
| **Усього на рядок** | | **139** |

Для 16 рядків: 16 × 139 = **2 224 такти (T-state)** (звичайний випадок). Додай накладні витрати на перетин меж для ~2 меж у 16-піксельному спрайті: приблизно **2 300 тактів (T-state)** загалом.

Але це лише малювання спрайта. Тобі також потрібно стерти спрайт попереднього кадру, тобто відновити фон — ми розглянемо це в Методі 6 (Брудні прямокутники). Поки що зазнач, що саме малювання приблизно на 35% дорожче за XOR, але візуальна якість незрівнянно краща.

### Вирівнювання по байтах і проблема зсуву

Процедура вище передбачає, що спрайт починається на межі байта — тобто координата x кратна 8. На практиці ігрові персонажі рухаються піксель за пікселем, а не стрибками по 8 пікселів. Якщо позиція x твого спрайта — 53, він починається в колонці байтів 6, піксель 5 усередині цього байта. Дані спрайта потрібно зсунути вправо на 5 біт.

Зсув можна робити під час малювання:

```z80
; Shift mask and graphic right by A bits
; This adds significant cost per byte
    ld   a, (de)            ;  7 T   load mask byte
    ld   c, a               ;  4 T
    ld   a, b               ;  4 T   shift count
.shift:
    srl  c                  ;  8 T   \
    dec  a                  ;  4 T    | per-bit shift loop
    jr   nz, .shift         ; 12 T   /
```

Кожен біт зсуву коштує 24 такти (T-state) на байт у цьому наївному циклі. Для 5-бітного зсуву на 16-широкому спрайті (3 байти на рядок після зсуву, оскільки спрайт виходить у третій байт) ти дивишся на додаткові 5 × 24 × 3 = 360 тактів (T-state) на рядок — подвоюючи вартість малювання. Для 8 спрайтів при 25 fps ці накладні витрати зсуву самі по собі з'їдять приблизно 46 000 тактів (T-state) на кадр — понад 60% бюджету.

Ось чому існують попередньо зсунуті спрайти.

---

## Метод 3: Попередньо зсунуті спрайти

### Компроміс між пам'яттю і швидкістю

Ідея проста: замість зсуву даних спрайта під час малювання, попередньо обчисли зсунуті версії спрайта під час завантаження (або під час асемблювання) і зберігай їх разом з оригіналом. Коли потрібно намалювати спрайт зі зсувом 3 пікселі всередині байта, використовуй версію, попередньо зсунуту на 3 пікселі.

Є дві поширені конфігурації:

**4 зсунуті копії** (зсув на 0, 2, 4, 6 пікселів). Це дає 2-піксельну горизонтальну роздільність. Спрайт прив'язується до парних піксельних позицій, що часто прийнятно для ігрових персонажів. Вартість пам'яті: 4× від незсунутих даних.

**8 зсунутих копій** (зсув на 0, 1, 2, 3, 4, 5, 6, 7 пікселів). Повне піксельне горизонтальне позиціонування. Вартість пам'яті: 8× від незсунутих даних. Але кожна зсунута версія також ширша: 16-піксельний спрайт, зсунутий на 1–7 біт, виходить у третю колонку байтів, тож кожна зсунута копія займає 3 байти в ширину замість 2.

### Розрахунок пам'яті

Для маскованого спрайта 16×16:

| Конфігурація | Байтів на рядок | Рядків | Копій | Усього |
|--------------|-----------------|--------|-------|--------|
| Лише незсунутий | 4 (маска+графіка × 2 байти) | 16 | 1 | 64 |
| 4 зсуви | 4 | 16 | 4 | 256 |
| 8 зсувів (3 байти в ширину) | 6 (маска+графіка × 3 байти) | 16 | 8 | 768 |

Для спрайта з 4 кадрами анімації, помнож на 4:

| Конфігурація | На кадр | 4 кадри | 8 спрайтів |
|--------------|---------|---------|------------|
| Незсунутий + зсув під час виконання | 64 | 256 | 2 048 |
| 4 попередні зсуви | 256 | 1 024 | 8 192 |
| 8 попередніх зсувів | 768 | 3 072 | 24 576 |

24 КБ на 8 спрайтів з повним попереднім зсувом. На 128K Spectrum це півтора банки пам'яті лише на дані спрайтів. На 48K машині це майже половина доступної оперативної пам'яті. Компроміс суворий.

### Практичний компроміс

Більшість ігор використовують 4 попередньо зсунуті копії. 2-піксельна горизонтальна роздільність ледь помітна в геймплеї. Деякі ігри використовують 8 копій для персонажа гравця (де плавність руху найважливіша) і 4 копії або навіть зсув під час виконання для менш важливих спрайтів.

Процедура малювання попередньо зсунутих спрайтів ідентична процедурі маскованого спрайта, вирівняного по байтах — ти просто обираєш правильний набір попередньо зсунутих даних перед викликом:

```z80
; Select pre-shifted sprite data
; Input:  A = x coordinate (0-255)
;         IY = base of pre-shift table (4 entries, each pointing to 16-row data)
; Output: DE = pointer to correct shifted sprite data
;
select_preshift:
    and  $06                ;  7 T   mask to shifts 0,2,4,6 (4 copies)
    ld   c, a               ;  4 T
    ld   b, 0               ;  7 T
    add  iy, bc             ; 15 T
    ld   e, (iy+0)          ; 19 T
    ld   d, (iy+1)          ; 19 T   DE = pointer to shifted data
    ret
```

Час малювання такий самий, як у Методу 2: ~2 300 тактів (T-state). Але ти повністю усунув вартість попіксельного зсуву. Ціна сплачується пам'яттю, а не тактами.

---

## Метод 4: Стекові спрайти (метод PUSH)

### Найшвидший вивід на Z80

Ми бачили в Розділі 3, що PUSH записує 2 байти за 11 тактів (T-state) — 5,5 тактів (T-state) на байт, найшвидша операція запису на Z80. Стекові спрайти експлуатують це для виводу спрайтів: встановлюють SP на дно екранної області спрайта, завантажують регістрові пари даними спрайта і PUSH-ать їх на екран.

Техніка потребує критичного налаштування:

1. **DI** — заборонити переривання. Якщо переривання спрацює, поки SP вказує на екран, CPU штовхне адресу повернення у твої піксельні дані, зіпсувавши зображення і, ймовірно, спричинивши збій.
2. **Зберегти SP** — сховати реальний вказівник стеку за допомогою самомодифікованого коду (SMC).
3. **Встановити SP** на нижній правий кут екранної області спрайта (PUSH працює вниз).
4. **Завантажити і PUSH** — завантажити дані спрайта в регістрові пари і PUSH-нути їх послідовно.
5. **Відновити SP і EI** — повернути стек на місце і знову дозволити переривання.

### Внутрішній цикл

Для спрайта 16×16 (2 байти в ширину) кожен рядок — один PUSH:

```z80
; Stack sprite: 16x16, writes 2 bytes per row via PUSH
; Input:  screen_addr = pre-calculated bottom-right screen address
;         sprite_data = 32 bytes of pixel data (2 bytes x 16 rows,
;                       stored bottom-to-top because PUSH goes downward)
;
stack_sprite_16x16:
    di                           ;  4 T

    ld   (restore_sp + 1), sp    ; 20 T   save SP (self-mod)

    ld   sp, (screen_addr)       ; 20 T   SP = bottom of sprite on screen
    ld   ix, sprite_data         ; 14 T

    ; Row 15 (bottom) - each PUSH writes 2 bytes and decrements SP
    ld   h, (ix+31)              ; 19 T   \
    ld   l, (ix+30)              ; 19 T    | load bottom row
    push hl                      ; 11 T   /  write to screen

    ; But wait --- SP just decremented by 2, and the next row UP
    ; on the Spectrum screen is NOT at SP-2. The interleaved layout
    ; means "one row up" is at a completely different address.
    ;
    ; This is the fundamental problem with stack sprites on the
    ; Spectrum: the screen is not contiguous in memory.
```

І ось фундаментальна складність. Метод PUSH — найшвидший можливий запис, але черезрядкова розкладка екрану Spectrum означає, що послідовні рядки екрану не знаходяться за послідовними адресами. SP декрементується лінійно, але рядки екрану слідують патерну `010TTSSS LLLCCCCC` з Розділу 2.

### Як це працює: попередньо обчислений ланцюжок SP

Розв'язок — не покладатися на авто-декремент SP для навігації між рядками. Замість цього ти явно встановлюєш SP для кожного рядка:

```z80
; Stack sprite: 16x16 with explicit SP per row
; This is the practical version --- each row gets SP set independently
;
stack_sprite_16x16:
    di                           ;  4 T
    ld   (restore_sp + 1), sp    ; 20 T

    ld   hl, (sprite_data + 0)   ; 16 T   row 0 data
    ld   sp, (row_addrs + 0)     ; 20 T   SP = screen addr for row 0 + 2
    push hl                      ; 11 T   write row 0
                                 ;        total per row: 47 T

    ld   hl, (sprite_data + 2)   ; 16 T   row 1 data
    ld   sp, (row_addrs + 2)     ; 20 T
    push hl                      ; 11 T
    ; ... repeated for all 16 rows ...

restore_sp:
    ld   sp, $0000               ; 10 T   self-modified
    ei                           ;  4 T
    ret                          ; 10 T
```

Кожен рядок коштує 47 тактів (T-state). Для 16 рядків: 16 × 47 = 752 такти (T-state), плюс налаштування та завершення (~60 тактів). Усього: приблизно **810 тактів (T-state)**.

Порівняй це з ~2 300 тактами Методу 2. Стековий спрайт майже в 3 рази швидший — але він має обмеження.

### Ціна

**Без маскування.** PUSH записує 2 байти безумовно. Він перезаписує все, що було на екрані. Немає кроку AND-з-маскою. Спрайт завжди суцільний прямокутник — будь-які «прозорі» пікселі покажуть колір фону спрайта, а не ігрового фону. Для спрайтів на однотонному фоні (багато класичних ігор Spectrum використовували чорний) це прийнятно. Для спрайтів поверх деталізованих фонів — ні.

**Попередньо обчислені адреси рядків.** Тобі потрібна таблиця адрес екрану для всіх 16 рядків спрайта, що оновлюється при кожному русі спрайта. Це вартість налаштування на кожен кадр — не величезна, але й не безкоштовна.

**Переривання вимкнені.** Для 8 спрайтів приблизно 6 500 тактів (T-state) з вимкненими перериваннями. Якщо твоя музика працює через IM2, плануй малювання спрайтів одразу після HALT.

**Дані мають зберігатися в порядку PUSH.** Оскільки PUSH записує старший байт за адресою (SP-1), а молодший за (SP-2), і SP декрементується *перед* записом, розкладка даних потребує уважності. Дані спрайта зберігаються у зворотному порядку: правий байт рядка стає молодшим байтом, завантаженим у регістр, а лівий — старшим.

### Коли використовувати стекові спрайти

Стекові спрайти — це зброя вибору, коли потрібна сира швидкість, і твій фон достатньо простий, щоб повне перезаписування прямокутниками було прийнятним. Аркадні ігри з чорним фоном, оверлеями рахунку та швидкорухомими об'єктами — природна ніша. Метод PUSH також використовується для очищення екрану та масового виводу даних (Розділ 3), де обмеження «без маскування» не має значення.

---

## Метод 5: Скомпільовані спрайти

### Спрайт — це код

Скомпільований спрайт доводить філософію генерації коду з Розділу 3 до логічного завершення. Замість таблиці даних, яку інтерпретує процедура малювання, спрайт *сам є* виконуваною процедурою. Кожен видимий піксельний байт у спрайті стає інструкцією `LD (HL), n`. Прозорі ділянки стають інструкціями `INC L` або `INC H` для пропуску. Весь спрайт відмальовується викликом `CALL`.

### Як це працює

Розглянь простий спрайт 8×8 з деякими прозорими пікселями. У маскованому спрайті ти б зберігав пари маска+графіка і виконував цикл AND/OR. У скомпільованому спрайті ти генеруєш інструкції Z80 під час асемблювання (або під час завантаження):

```z80
; Compiled sprite for a small arrow shape
; Input:  HL = screen address of top-left byte
; The sprite draws itself.
;
compiled_arrow:
    ; Row 0: one pixel byte
    ld   (hl), $18          ; 10 T   ..##....
    inc  h                  ;  4 T   next row

    ; Row 1: one pixel byte
    ld   (hl), $3C          ; 10 T   ..####..
    inc  h                  ;  4 T

    ; Row 2: one pixel byte
    ld   (hl), $7E          ; 10 T   .######.
    inc  h                  ;  4 T

    ; Row 3: one pixel byte
    ld   (hl), $FF          ; 10 T   ########
    inc  h                  ;  4 T

    ; Row 4: one pixel byte
    ld   (hl), $3C          ; 10 T   ..####..
    inc  h                  ;  4 T

    ; Row 5: one pixel byte
    ld   (hl), $3C          ; 10 T   ..####..
    inc  h                  ;  4 T

    ; Row 6: one pixel byte
    ld   (hl), $3C          ; 10 T   ..####..
    inc  h                  ;  4 T

    ; Row 7: one pixel byte
    ld   (hl), $3C          ; 10 T   ..####..

    ret                     ; 10 T

    ; Total: 8 x (10 + 4) + 10 = 122 T-states
    ; Compare: masked routine for 8x8 = ~600 T-states
```

Це 122 такти (T-state) для спрайта 8×8. Маскований підхід займає приблизно в 5 разів більше.

### Скомпільований спрайт 16×16

Для ширшого спрайта кожен рядок може мати кілька інструкцій `LD (HL), n`, розділених `INC L`:

```z80
; Compiled sprite: 16x16 (2 bytes wide)
; Input:  HL = screen address of top-left
;
compiled_sprite_16x16:
    ; Row 0
    ld   (hl), $3C          ; 10 T   left byte
    inc  l                  ;  4 T
    ld   (hl), $0F          ; 10 T   right byte
    dec  l                  ;  4 T   restore column
    inc  h                  ;  4 T   next row
                            ;        row cost: 32 T

    ; Row 1
    ld   (hl), $7E          ; 10 T
    inc  l                  ;  4 T
    ld   (hl), $1F          ; 10 T
    dec  l                  ;  4 T
    inc  h                  ;  4 T
                            ;        row cost: 32 T

    ; ... rows 2-6 similar ...

    ; Row 7 (character boundary)
    ld   (hl), $FF          ; 10 T
    inc  l                  ;  4 T
    ld   (hl), $FF          ; 10 T
    dec  l                  ;  4 T
    ; Character boundary crossing:
    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T   boundary cost: 30 T
    inc  h                  ;  4 T
                            ;        row cost: 62 T

    ; Rows 8-15 similar to 0-6, with another boundary at row 15
    ; ...
    ret                     ; 10 T
```

На рядок (звичайний випадок): 32 такти (T-state). Для 16 рядків з 1–2 перетинами меж: приблизно **570 тактів (T-state)**.

### Компроміси

**Сильні сторони:**
- Найшвидший метод спрайтів з підтримкою маскування. Ти можеш включити AND-маскування у скомпільовані спрайти — кожен байт стає `ld a,(hl)` / `and mask` / `or graphic` / `ld (hl),a` замість простого `ld (hl),n`. Навіть з маскуванням скомпільований підхід уникає накладних витрат циклу, управління вказівниками даних та підрахунку рядків.
- Нуль накладних витрат на цикл. Код повністю прямолінійний.
- Прозорі ділянки нічого не коштують, якщо вони займають цілі байти — ти просто пропускаєш їх через `INC L` або `INC H`.

**Слабкі сторони:**
- **Розмір коду.** Кожен видимий байт займає 2 байти коду (`LD (HL), n`). З маскуванням (4 інструкції на байт) розмір коду приблизно потроюється. Повний набір з 8 попередньо зсунутих скомпільованих спрайтів з 4 кадрами анімації може сягати кількох кілобайт на спрайт.
- **Без зміни даних під час виконання.** Піксельні значення вбудовані в операнди інструкцій. Анімація потребує окремої скомпільованої процедури на кадр.
- **Обробка меж вбудована.** Перетини меж знакорядів знаходяться у фіксованих позиціях, тож спрайт мусить підтримувати послідовне вертикальне вирівнювання, або тобі потрібні кілька скомпільованих версій.

### Скомпільовані спрайти з маскуванням

Для спрайтів, що мають з'являтися поверх деталізованого фону, ти компілюєш маску в код:

```z80
; Compiled sprite with masking: one byte
; Instead of ld (hl),n, we do:
    ld   a, (hl)            ;  7 T   read screen
    and  $C3                ;  7 T   mask: clear sprite pixels
    or   $3C                ;  7 T   graphic: stamp sprite
    ld   (hl), a            ;  7 T   write back
                            ;        per-byte cost: 28 T
```

28 тактів (T-state) на байт, проти 52 тактів (T-state) на байт у універсальній маскованій процедурі (Метод 2). Виграш досягається за рахунок усунення управління вказівниками, підрахунку циклів та завантаження даних — значення маски та графіки є безпосередніми операндами.

Для 16 рядків × 2 байти: 16 × (28 + 28 + 4 + 4 + 4) = 16 × 68 = **1 088 тактів (T-state)**. Це приблизно половина вартості універсальної маскованої процедури, з повною підтримкою прозорості.

| Метод | Вартість малювання 16×16 | Маскування | Примітки |
|-------|--------------------------|------------|----------|
| XOR-спрайт | ~1 700 T | Ні | Малювання + стирання = ~3 400 T |
| OR+AND маскований | ~2 300 T | Так | Стандартний підхід |
| Попередньо зсунутий маскований | ~2 300 T | Так | Без вартості зсуву; 4–8× пам'яті |
| Стековий спрайт (PUSH) | ~810 T | Ні | Потрібен DI; суцільний прямокутник |
| Скомпільований (без маски) | ~570 T | Ні | Код = спрайт; великий обсяг |
| Скомпільований (маскований) | ~1 088 T | Так | Найкраще з обох; найбільший обсяг |

![Порівняння методів відмальовування спрайтів](illustrations/output/ch16_sprite_methods.png)

---

## Метод 6: Брудні прямокутники

### Проблема фону

Методи 1–5 всі вирішують питання *розміщення* пікселів на екрані. Але спрайти рухаються. Кожен кадр спрайт знаходиться в новій позиції. Перед малюванням спрайта в новій позиції ти мусиш стерти його зі старої — інакше екран заповниться примарними залишковими зображеннями.

Метод XOR вирішує це неявно: XOR старої позиції для стирання, XOR нової позиції для малювання. Але для всіх інших методів тобі потрібен спосіб відновлення фону.

Є три поширені підходи:

**Повне очищення екрану.** Стерти піксельну область кожен кадр (~36 000 тактів (T-state) з PUSH з Розділу 3), потім перемалювати все. Можливо, але дорого.

**Збереження/відновлення фону.** Перед малюванням кожного спрайта зберегти екран за ним. Для стирання скопіювати збережений буфер назад. Вартість — O(розмір_спрайта) на спрайт, а не O(розмір_екрану).

**Відстежування брудних прямокутників.** Вдосконалення: відстежуй, які прямокутники були змінені, відновлюй лише їх, потім малюй нові спрайти (зберігаючи новий фон по ходу).

### Цикл збереження/відновлення

Практичний підхід для більшості ігор Spectrum — збереження/відновлення фону на кожен спрайт. Ось цикл для одного спрайта за кадр:

1. **Відновити** фон, збережений минулого кадру (скопіювати збережений буфер на стару позицію екрану).
2. **Зберегти** фон на новій позиції екрану (скопіювати екран у буфер збереження).
3. **Намалювати** спрайт на новій позиції.

Порядок має значення. Ти відновлюєш перед збереженням, щоб уникнути перезаписування нового збереження фону застарілими даними, якщо спрайти перекриваються.

### Процедура збереження/відновлення

Для спрайта 16×16 (2 байти в ширину, 16 рядків) буфер фону — 32 байти:

```z80
; Save background behind a 16x16 sprite
; Input:  HL = screen address (top-left)
;         DE = pointer to save buffer (32 bytes)
;
save_background_16x16:
    ld   b, 16              ;  7 T

.row:
    ld   a, (hl)            ;  7 T   read left byte
    ld   (de), a            ;  7 T   save it
    inc  de                 ;  6 T
    inc  l                  ;  4 T

    ld   a, (hl)            ;  7 T   read right byte
    ld   (de), a            ;  7 T   save it
    inc  de                 ;  6 T
    dec  l                  ;  4 T

    ; DOWN_HL (same as sprite routines)
    inc  h                  ;  4 T
    ld   a, h               ;  4 T
    and  7                  ;  7 T
    jr   nz, .no_boundary   ;  7 T
    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    jr   c, .no_fix         ;  7 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T
.no_fix:
.no_boundary:
    djnz .row               ; 13 T
    ret                     ; 10 T
```

Процедура відновлення ідентична зі заміною джерела та призначення: читання з буфера, запис на екран. Кожна процедура займає приблизно **1 400 тактів (T-state)** для 16 рядків.

### Повний бюджет кадру

Обчислимо покадрову вартість для 8 анімованих спрайтів 16×16 з використанням OR+AND маскування зі збереженням/відновленням фону:

| Операція | На спрайт | 8 спрайтів |
|----------|-----------|------------|
| Відновлення фону | ~1 400 T | 11 200 T |
| Збереження нового фону | ~1 400 T | 11 200 T |
| Малювання спрайта (маскований) | ~2 300 T | 18 400 T |
| **Усього** | **~5 100 T** | **~40 800 T** |

На Pentagon (71 680 тактів (T-state) на кадр): 40 800 T залишає **30 880 T** для ігрової логіки, обробки введення, музики і всього іншого. При 25 fps ти маєш удвічі більший бюджет (два кадри на оновлення), що дає ~103 000 тактів (T-state) для неспрайтової роботи. Це комфортно для гри.

Якщо використовуєш скомпільовані масковані спрайти:

| Операція | На спрайт | 8 спрайтів |
|----------|-----------|------------|
| Відновлення фону | ~1 400 T | 11 200 T |
| Збереження нового фону | ~1 400 T | 11 200 T |
| Малювання спрайта (скомпільований, маскований) | ~1 088 T | 8 704 T |
| **Усього** | **~3 888 T** | **~31 104 T** |

Це економить майже 10 000 тактів (T-state) на кадр — суттєве покращення, що купує тобі більше простору для ігрової логіки або більше спрайтів.

### Порядок малювання та перекриття

Коли кілька спрайтів перекриваються, порядок малювання має значення. Найпростіший правильний підхід:

1. Відновити всі фони (у зворотному порядку малювання, щоб правильно обробити перекриття).
2. Зберегти всі нові фони.
3. Намалювати всі спрайти.

Відновлення у зворотному порядку гарантує, що коли два спрайти перекривалися минулого кадру, буфер збереження раннього спрайта (який зафіксував чистий фон) відновлюється останнім, правильно очищуючи зону перекриття.

Логіка: якщо спрайт A був намальований поверх спрайта B, буфер збереження A містить пікселі B. Відновлення A спочатку оголює B, потім відновлення B відкриває чистий фон. Відновлення в прямому порядку залишає артефакти. Багато ігор обходять це, запобігаючи перекриттю або миручись з незначними глюками.

---

## Оптимізація внутрішніх циклів

### Усунення управління вказівниками

Процедури вище витрачають значний час на управління вказівниками: `inc de`, `inc l`, `dec l` та логіку перетину меж DOWN_HL. Кілька оптимізацій можуть зменшити ці накладні витрати.

**Використовуй LDI замість ручного копіювання.** Для операцій збереження/відновлення LDI-ланцюжок (Розділ 3) копіює байт з (HL) у (DE), інкрементує обидва та декрементує BC — все за 16 тактів (T-state). Порівняно з нашим ручним `ld a,(hl)` + `ld (de),a` + `inc de` + `inc l` за 24 такти (T-state), LDI економить 8 тактів (T-state) на байт. Для спрайта 16×16 (32 байти) це 256 тактів (T-state), збережених на кожну операцію збереження чи відновлення.

```z80
; Save background using LDI (partial unroll, 2 bytes per row)
; HL = screen address, DE = save buffer
;
save_bg_ldi:
    ld   b, 16              ;  7 T
.row:
    ldi                     ; 16 T   copy left byte
    ldi                     ; 16 T   copy right byte
    dec  l                  ;  4 T   \
    dec  l                  ;  4 T   /  LDI advanced L by 2, undo it

    ; DOWN_HL
    inc  h                  ;  4 T
    ld   a, h               ;  4 T
    and  7                  ;  7 T
    jr   nz, .no_boundary   ;  7 T
    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    jr   c, .no_fix         ;  7 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T
.no_fix:
.no_boundary:
    djnz .row               ; 13 T
    ret                     ; 10 T
```

Вартість рядка у звичайному випадку: 16 + 16 + 4 + 4 + 4 + 4 + 7 + 7 + 13 = **75 тактів (T-state)**. Для 16 рядків: приблизно **1 200 тактів (T-state)** — вартісне покращення порівняно з 1 400 тактами ручного підходу.

**Поєднай збереження і малювання.** Замість збереження-потім-малювання як двох окремих проходів по екранній області, поєднай їх в один прохід: для кожного байта прочитай екран (зберігаючи його), потім запиши дані спрайта. Це вдвічі скорочує кількість операцій переходу між рядками та усуває один повний прохід DOWN_HL:

```z80
; Combined save-and-draw for masked sprite
; HL = screen address, DE = sprite data (mask, gfx pairs)
; IX = save buffer
;
save_and_draw_16x16:
    ld   b, 16              ;  7 T
.row:
    ; Left byte
    ld   a, (hl)            ;  7 T   read screen (for saving)
    ld   (ix+0), a          ; 19 T   save to buffer
    ld   c, a               ;  4 T

    ld   a, (de)            ;  7 T   load mask
    and  c                  ;  4 T   mask background
    inc  de                 ;  6 T
    ld   c, a               ;  4 T

    ld   a, (de)            ;  7 T   load graphic
    or   c                  ;  4 T   stamp sprite
    ld   (hl), a            ;  7 T   write to screen
    inc  de                 ;  6 T
    inc  l                  ;  4 T

    ; Right byte (similar)
    ld   a, (hl)            ;  7 T
    ld   (ix+1), a          ; 19 T
    ld   c, a               ;  4 T

    ld   a, (de)            ;  7 T
    and  c                  ;  4 T
    inc  de                 ;  6 T
    ld   c, a               ;  4 T

    ld   a, (de)            ;  7 T
    or   c                  ;  4 T
    ld   (hl), a            ;  7 T
    inc  de                 ;  6 T
    dec  l                  ;  4 T

    ; Advance IX and HL
    inc  ix                 ; 10 T
    inc  ix                 ; 10 T

    inc  h                  ;  4 T
    ld   a, h               ;  4 T
    and  7                  ;  7 T
    jr   nz, .no_boundary   ;  7 T
    ld   a, l               ;  4 T
    add  a, 32              ;  7 T
    ld   l, a               ;  4 T
    jr   c, .no_fix         ;  7 T
    ld   a, h               ;  4 T
    sub  8                  ;  7 T
    ld   h, a               ;  4 T
.no_fix:
.no_boundary:
    djnz .row               ; 13 T
    ret                     ; 10 T
```

Це поєднує збереження і малювання в один прохід. Вартість на рядок (звичайний випадок): приблизно **200 тактів (T-state)**. Для 16 рядків: приблизно **3 300 тактів (T-state)** — порівняно з окремими збереженням (~1 200 T) + малюванням (~2 300 T) = 3 500 тактів (T-state). Економія скромна (~200 T на спрайт), але вона накопичується для 8 спрайтів.

Для максимальної продуктивності розгорни всю процедуру: без циклу DJNZ, явний код для кожного рядка з перетинами меж, вбудованими в рядках 7 та 15. Це усуває накладні витрати на цикл та перевірку меж, зменшуючи загальну вартість до приблизно **2 780 тактів (T-state)** ціною ~300 байтів коду на процедуру спрайта.

---

## Agon Light 2: Апаратні спрайти VDP

Agon Light 2 використовує принципово інший підхід. eZ80 спілкується з VDP (Video Display Processor) на ESP32, який обробляє всю відмальовку спрайтів апаратно. CPU завантажує растрові зображення, потім видає команди для позиціонування, показу, приховування та анімації спрайтів. VDP компонує спрайти під час власного проходу відмальовки, без витрат CPU на піксель. Підтримується до 256 слотів спрайтів.

Послідовність VDU-команд для визначення та активації спрайта:

```
VDU 23, 27, 0, n                     ; Select sprite n
VDU 23, 27, 1, w, h, format          ; Create sprite: w x h pixels
; ... upload bitmap data ...
VDU 23, 27, 4, x_lo, x_hi, y_lo, y_hi  ; Set position
VDU 23, 27, 11                        ; Show sprite
```

В асемблері eZ80 ці команди надсилаються як послідовності байтів до VDP через `RST $10` (вивід символу MOS). Кожна команда — це послідовність пар `ld a, byte : rst $10`.

### Переміщення спрайта

Після визначення переміщення спрайта — це лише команда позиціонування:

```z80
; Agon: Move sprite 0 to (x, y)
; Input: BC = x, DE = y
;
move_sprite:
    ld   a, 23 : rst $10
    ld   a, 27 : rst $10
    ld   a, 4  : rst $10    ; move command
    ld   a, 0  : rst $10    ; sprite number

    ld   a, c  : rst $10    ; x low
    ld   a, b  : rst $10    ; x high
    ld   a, e  : rst $10    ; y low
    ld   a, d  : rst $10    ; y high
    ret
```

Вартість для CPU при переміщенні спрайта — лише вартість відправки ~10 байтів через послідовний інтерфейс. При 1 152 000 бод кожен байт займає приблизно 9 мікросекунд, тож переміщення одного спрайта займає приблизно 90 мікросекунд — близько 1 660 тактів (T-state) при 18,432 МГц. Переміщення 8 спрайтів: ~13 000 тактів (T-state). VDP обробляє все піксельне компонування, прозорість та управління фоном апаратно.

### Обмеження рядка розгортки

VDP має практичне обмеження на кількість піксельних спрайтів на горизонтальний рядок розгортки. Коли занадто багато спрайтів перекриваються на одній лінії, деякі можуть мерехтіти — те саме явище, яке спостерігається на NES та Master System. Розумна рекомендація — від 8 до 12 спрайтів 16×16 на рядок розгортки. Для 8 спрайтів, розподілених по екрану, ти навряд чи досягнеш цього обмеження.

### Компроміс

Agon усуває всю проблему малювання спрайтів. Без збереження/відновлення, без маскування, без навігації по черезрядковому екрану. Ціна — абстракція: без попіксельних трюків, без креативної маніпуляції даними, і залежність від можливостей прошивки VDP. Spectrum змушує тебе будувати все з нуля. Agon звільняє тебе, щоб витрачати ці зусилля на ігровий дизайн.

---

## Практика: 8 анімованих спрайтів при 25 fps

### Реалізація на Spectrum

Наша мета: 8 анімованих спрайтів 16×16 зі збереженням/відновленням фону, що працюють при 25 fps (оновлення кожні 2 кадри) на ZX Spectrum 128K.

**Архітектура:**

Кожен спрайт має структуру даних:

```z80
; Sprite structure (12 bytes per sprite)
;
SPRITE_X        EQU 0       ; x coordinate (0-255)
SPRITE_Y        EQU 1       ; y coordinate (0-191)
SPRITE_OLD_X    EQU 2       ; previous x (for erase)
SPRITE_OLD_Y    EQU 3       ; previous y
SPRITE_FRAME    EQU 4       ; current animation frame (0-3)
SPRITE_DIR      EQU 5       ; direction / flags
SPRITE_DX       EQU 6       ; x velocity (signed)
SPRITE_DY       EQU 7       ; y velocity (signed)
SPRITE_GFX      EQU 8       ; pointer to sprite graphic data (2 bytes)
SPRITE_SAVE     EQU 10      ; pointer to background save buffer (2 bytes)

SPRITE_SIZE     EQU 12
NUM_SPRITES     EQU 8
```

**Цикл кадру (кожні 2 VBLANK):**

```z80
main_loop:
    halt                    ; wait for VBLANK
    halt                    ; wait again (25 fps = every 2nd frame)

    ; Phase 1: Restore all backgrounds (reverse order)
    ld   ix, sprites + (NUM_SPRITES - 1) * SPRITE_SIZE
    ld   b, NUM_SPRITES
.restore_loop:
    call restore_sprite_bg
    ld   de, -SPRITE_SIZE
    add  ix, de
    djnz .restore_loop

    ; Phase 2: Update positions
    ld   ix, sprites
    ld   b, NUM_SPRITES
.update_loop:
    call update_sprite_position
    ld   de, SPRITE_SIZE
    add  ix, de
    djnz .update_loop

    ; Phase 3: Save backgrounds and draw (forward order)
    ld   ix, sprites
    ld   b, NUM_SPRITES
.draw_loop:
    call save_and_draw_sprite
    ld   de, SPRITE_SIZE
    add  ix, de
    djnz .draw_loop

    ; Phase 4: Game logic, input, sound
    call process_input
    call update_game_logic
    call update_sound

    jr   main_loop
```

**Бюджет тактів:**

| Фаза | Вартість |
|------|----------|
| 2 × HALT | 0 T (очікування) |
| Відновлення 8 фонів | 8 × 1 200 = 9 600 T |
| Оновлення 8 позицій | 8 × 200 = 1 600 T |
| Збереження + малювання 8 спрайтів | 8 × 3 300 = 26 400 T |
| Накладні витрати циклу | ~2 000 T |
| **Загальна робота зі спрайтами** | **~39 600 T** |
| **Доступно для ігрової логіки** | **~103 000 T** |

З бюджетом на 2 кадри в 143 360 тактів (T-state) (2 × 71 680 на Pentagon) ми маємо приблизно 103 000 тактів (T-state) для ігрової логіки, введення та звуку. Це щедро — достатньо для AI сутностей (Розділ 19), тайлового виявлення зіткнень, відтворення музики та обробки введення.

Перед малюванням кожного спрайта обчисли адресу екрану з (x, y) за допомогою процедури з Розділу 2 і обери правильні попередньо зсунуті дані на основі `x AND $06` (для 4 рівнів зсуву). Логіка вибору попереднього зсуву з Методу 3 застосовується безпосередньо.

### Реалізація на Agon

На Agon головний цикл стає тривіально простим: чекай на VSync, онови позиції, надішли команди переміщення `VDU 23,27,4` для кожного спрайта і переходь до ігрової логіки. Без збереження/відновлення, без маскування, без обчислення адрес екрану, без навігації по черезрядкових рядках. VDP обробляє все.

Контраст показовий. На Spectrum відмальовка спрайтів — домінуюча вартість — 40 000 тактів (T-state) на кадр, де кожен збережений такт у внутрішньому циклі безпосередньо перетворюється на більше спрайтів або більше ігрової логіки. На Agon відмальовка спрайтів фактично безкоштовна з точки зору CPU, і твої інженерні зусилля йдуть на ігровий дизайн, а не на штовхання пікселів. Обидва підходи мають свої задоволення.

---

## Підсумок

- **XOR-спрайти** — найпростіший метод: XOR для малювання, XOR знову для стирання. ~1 700 тактів (T-state) для малювання спрайта 16×16. Без маски, без збереження фону. Візуальна якість погана (інвертовані пікселі на тлі деталей фону). Добре для курсорів, куль та відлагоджувальних маркерів.

- **OR+AND масковані спрайти** — індустріальний стандарт. Кожен байт проходить через послідовність AND-з-маскою, OR-з-графікою, що забезпечує чисту прозорість. ~2 300 тактів (T-state) для спрайта 16×16. Це те, що використовує більшість комерційних ігор для Spectrum.

- **Попередньо зсунуті спрайти** усувають вартість попіксельного зсуву, зберігаючи 4 або 8 попередньо обчислених зсунутих копій даних спрайта. Час малювання такий самий, як у маскованої процедури. Вартість пам'яті масштабується від 4× (4 зсуви, 2-піксельна роздільність) до 8× (8 зсувів, повна піксельна роздільність). Стандартний компроміс між пам'яттю та швидкістю.

- **Стекові спрайти (метод PUSH)** — найшвидший необроблений вивід: ~810 тактів (T-state) для спрайта 16×16. Потребують DI/EI, явного управління SP на кожен рядок і створюють суцільні прямокутники (без маскування). Найкращі для ігор з простими фонами.

- **Скомпільовані спрайти** перетворюють спрайт на виконуваний код. Кожен піксельний байт стає інструкцією `LD (HL),n`. ~570 тактів (T-state) без маскування, ~1 088 тактів (T-state) зі скомпільованим маскуванням. Найшвидший маскований метод ціною великого обсягу коду. Анімація потребує окремих скомпільованих процедур на кадр.

- **Брудні прямокутники** зі збереженням/відновленням фону — стандартна техніка для анімації спрайтів. Зберігай фон перед малюванням, відновлюй його перед малюванням наступного кадру. Відновлюй у зворотному порядку малювання для правильної обробки перекриваючихся спрайтів. Комбінований підхід збереження-і-малювання зменшує вартість на спрайт до ~3 300 тактів (T-state).

- **8 спрайтів при 25 fps** на Spectrum 128K коштують приблизно 40 000 тактів (T-state) за цикл оновлення (кожні 2 кадри), залишаючи ~103 000 тактів (T-state) для ігрової логіки — комфортний бюджет для справжньої гри.

- **Апаратні спрайти Agon Light 2** усувають всю проблему відмальовки. Визнач спрайти один раз, переміщуй їх VDU-командами. Вартість для CPU мінімальна. Компроміс — абстракція: ти здобуваєш продуктивність, але втрачаєш можливість робити попіксельні трюки з даними спрайтів.

- Вибір методу спрайтів залежить від потреб твоєї гри: складність фону, кількість спрайтів, потреби в анімації, доступна пам'ять та цільова частота кадрів. Більшість ігор для Spectrum використовують OR+AND маскування з попереднім зсувом та брудними прямокутниками. Демосценні продукції та ігри, критичні до продуктивності, сягають за скомпільованими спрайтами або методом PUSH.

---

## Спробуй сам

1. **Реалізуй всі шість методів.** Візьми простий дизайн спрайта 8×8 і реалізуй XOR, маскований та скомпільований варіанти. Використай тестову обв'язку з кольором бордюру з Розділу 1, щоб порівняти їхню вартість малювання. Різниця має бути чітко видимою.

2. **Генератор попередніх зсувів.** Напиши утиліту (на Python, Processing або в асемблері Z80), що приймає маскований спрайт і генерує 4 попередньо зсунуті версії. Зберігай їх у пам'яті і напиши процедуру малювання, що обирає правильну версію на основі координати x.

3. **Демо збереження/відновлення фону.** Розмісти маскований спрайт на візерунковому фоні (шахівниця з практичного завдання Розділу 2). Рухай спрайт клавіатурою. Перевір, що фон правильно відновлюється при русі спрайта. Потім додай другий спрайт і перевір, що зони перекриття обробляються правильно.

4. **Виклик на 8 спрайтів.** Реалізуй повну систему з 8 спрайтами зі збереженням/відновленням фону та анімацією. Почни з підходу OR+AND маскування. Виміряй бюджет тактів кольорами бордюру. Якщо є запас, переключись на скомпільовані масковані спрайти і виміряй покращення.

5. **Порівняння з Agon.** Якщо маєш Agon Light 2, реалізуй ту саму анімацію з 8 спрайтами, використовуючи апаратні спрайти VDP. Порівняй складність коду та бюджет CPU, доступний для ігрової логіки.

---

> **Джерела:** Фольклор програмування графіки Spectrum, широко задокументований у спільноті ZX; Розділ 3 цієї книги для PUSH-трюків та самомодифікованого коду (SMC); Розділ 2 для розкладки екрану та DOWN_HL; документація VDP Agon Light 2 (прошивка Quark, API спрайтів FabGL); розділи з розробки ігор з *book-plan.md* для фреймворку шести методів та практичних цілей.
