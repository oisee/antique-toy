# Розділ 17: Скролінг

> «Екран має ширину 256 пікселів. Рівень — 8 000. Якимось чином гравець має пройти крізь нього.»

---

Кожна гра з горизонтальним скролінгом потребує руху світу. Гравець біжить вправо, фон зсувається вліво. Це виглядає просто. На обладнанні з регістром прокрутки — NES, Mega Drive, Agon Light 2 — це *справді* просто: запиши зсув, і апаратура зробить решту. На ZX Spectrum немає регістра прокрутки. Немає жодної апаратної допомоги. Щоб прокрутити екран, ти переміщуєш байти сам. Усі 6 144 з них.

Цей розділ проходить через кожен практичний метод скролінгу на Spectrum, від найдешевшого до найдорожчого: скролінг атрибутів (768 байтів, тривіальний), вертикальний піксельний скролінг (хитрий через черезрядкову розкладку пам'яті з Розділу 2), горизонтальний піксельний скролінг (дорогий — кожен байт у кожному рядку має бути зсунутий) та комбінований метод, який справжні ігри використовують для досягнення плавного горизонтального скролінгу в рамках прийнятного бюджету. Ми порахуємо кожен такт (T-state), побудуємо порівняльні таблиці і покажемо, як трюк з тіньовим екраном на 128K робить все це без розривів.

Потім ми подивимось, як Agon Light 2 вирішує ту саму проблему за допомогою апаратних зсувів прокрутки та підтримки тайлових карт — корисний контраст, що показує, що «та сама ISA з іншою апаратурою» реально означає на практиці.

---

## Бюджет

Перш ніж писати хоча б одну інструкцію, встановимо, з чим працюємо.

На Pentagon (модель таймінгу, на яку орієнтується більшість демо та ігор для Spectrum) один кадр — це **71 680 тактів (T-state)**. На стандартному 48K/128K Spectrum — 69 888. Ми будемо використовувати цифру Pentagon протягом усього розділу, але аналіз застосовується до обох — різниця близько 2,5%.

Повноекранний скролінг означає переміщення даних по всіх 6 144 байтах піксельної пам'яті (і, можливо, 768 байтах пам'яті атрибутів). Питання завжди одне: чи можемо ми зробити це за один кадр, і якщо так, скільки тактів (T-state) залишиться на все інше — ігрову логіку, малювання спрайтів, музику, введення?

Ось сира вартість просто *торкання* кожного байта в піксельній області різними методами:

| Метод | На байт | 6 144 байти | % кадру |
|-------|---------|-------------|---------|
| `ldir` | 21 T | 129 003 T | 180% |
| ланцюжок `ldi` | 16 T | 98 304 T | 137% |
| `ld a,(hl)` + `ld (de),a` + `inc hl` + `inc de` | 24 T | 147 456 T | 206% |
| `push` (2 байти) | 5,5 T/байт | 33 792 T | 47% |

Перші три методи не можуть перемістити повну піксельну область за один кадр. Навіть LDI-ланцюжки, найшвидший метод копіювання після PUSH, перевищують бюджет на 37%. А скролінг — це не просто копіювання — горизонтальний скролінг потребує операції *зсуву* на кожному байті, що додає до вартості на байт.

Ось чому скролінг на Spectrum — це проблема проєктування, а не лише кодування. Ти не можеш грубою силою зробити повноекранний піксельний скролінг при 50 fps. Ти мусиш обирати метод, виходячи з того, що твоя гра може собі дозволити.

---

## Вертикальний піксельний скролінг

Вертикальний скролінг переміщує вміст екрану вгору або вниз на один чи кілька рядків пікселів. Концептуально це просто: скопіювати кожен рядок на позицію рядка вище (для прокрутки вгору) або нижче (для прокрутки вниз). На лінійному фреймбуфері це було б одним блочним копіюванням. На Spectrum черезрядкова розкладка пам'яті (Розділ 2) робить це значно цікавішим.

### Проблема черезрядковості

Пригадай структуру адреси екрану з Розділу 2:

```
High byte:  0 1 0 T T S S S
Low byte:   L L L C C C C C
```

Де TT = третина (0–2), SSS = рядок розгортки всередині символьної комірки (0–7), LLL = знакоряд всередині третини (0–7), CCCCC = байт колонки (0–31).

Щоб прокрутити вгору на один піксель, потрібно скопіювати вміст рядка N у рядок N-1, для кожного рядка від 1 до 191. Адреси джерела та призначення для сусідніх піксельних рядків *не* розділені сталим зсувом. Всередині символьної комірки послідовні рядки відрізняються на $0100 у старшому байті (просто `INC H` / `DEC H`). Але на межах символьних комірок — кожен 8-й рядок — зв'язок змінюється: потрібно збільшити L на 32 і скинути біти рядка розгортки в H. На межах третин (кожен 64-й рядок) корекція знову інша.

### Алгоритм: прокрутка вгору на один піксель

Підхід, який працює *з* черезрядковою розкладкою, а не проти неї, використовує структуру роздільних лічильників з Розділу 2. Підтримуй два вказівники (джерело та призначення) і просувай обидва, використовуючи природну ієрархію екрану: 3 третини, 8 знакорядів на третину, 8 рядків розгортки на знакоряд. Всередині кожної символьної комірки переміщення між рядками розгортки — просто `INC H` / `INC D` для джерела та призначення. На межах знакорядів скидай біти рядка розгортки і додай 32 до L. На межах третин додай 8 до H і скинь L. Внутрішній цикл копіює 32 байти на рядок через LDIR або LDI-ланцюжок, а просування вказівників вбудоване у структуру зовнішнього циклу.

### Аналіз вартості

Для кожного з 191 копіювань рядків ми мусимо скопіювати 32 байти з джерела до призначення. Використовуючи LDIR:

- На рядок: 32 байти × 21 такт (T-state) - 5 = 667 тактів (T-state) для LDIR, плюс накладні витрати на управління вказівниками.
- Управління вказівниками (збереження/відновлення джерела та призначення, просування рядка розгортки): приблизно 60 тактів (T-state) на рядок всередині символьної комірки, більше на межах.

**Усього з LDIR: приблизно 143 000 тактів (T-state).** Це приблизно **два повних кадри**. Вертикальний піксельний скролінг на один рядок через LDIR не вміщується в один кадр.

Ми можемо зробити краще. Заміни LDIR на LDI-ланцюжок — 32 інструкції LDI на рядок:

- На рядок: 32 × 16 = 512 тактів (T-state) для LDI, плюс ~50 тактів (T-state) управління вказівниками.
- Усього: 191 × 562 = **107 342 такти (T-state).** Все ще перевищує бюджет приблизно на 50%.

PUSH-трюк тут незручний, бо нам потрібно копіювати *між* двома несуміжними областями з нелінійним зв'язком. PUSH записує у суміжні низхідні адреси, що не відповідає черезрядковому патерну джерело/призначення.

### Часткова прокрутка: практичний підхід

Реальність така, що більшість ігор не прокручують увесь 192-рядковий дисплей. Типова гра резервує:

- Верхні 2 знакоряди (16 пікселів) для рядка стану — не прокручуються.
- Нижній 1 знакоряд (8 пікселів) для рядка рахунку — не прокручується.
- Середина: 21 знакоряд = 168 піксельних рядків = ігрова область прокрутки.

168 рядків вертикальної піксельної прокрутки з LDI-ланцюжками: 168 × 562 = **94 416 тактів (T-state)**, або 132% кадру. Все ще забагато для одного кадру, якщо хочеш час на щось інше.

Ось чому чиста вертикальна піксельна прокрутка по 1 пікселю/кадр рідкість в іграх для Spectrum. Поширені підходи:

1. **Прокрутка на 8 пікселів (один знакоряд).** Переміщуй атрибути та піксельні дані, вирівняні по знакорядах. Це значно дешевше, бо ти копіюєш лише 21 знакоряд × 8 рядків розгортки = 168 рядків, але можеш використати трюк блочного копіювання: всередині кожної третини знакоряди суміжні блоками. Вартість: приблизно 40 000–50 000 тактів (T-state) з LDIR. Можливо.

2. **Прокрутка на 1 піксель за допомогою лічильника.** Прокручуй 1 піксель на кадр візуально, поєднуючи прокрутку рівня знакоряду (дешеву, кожні 8 кадрів) зі лічильником піксельного зсуву (малювання нового вмісту зі зсувом всередині 8-піксельної символьної комірки). Ми розглянемо цей комбінований підхід у секції горизонтального скролінгу нижче, бо він значно частіше потрібен саме там.

3. **Використання тіньового екрану (лише 128K).** Малюй прокручений вміст у задній буфер, потім перемикай. Це усуває розриви і дозволяє розподілити роботу між кадрами. Ми розглянемо це далі в розділі.

### Прокрутка на 8 пікселів (один знакоряд)

Прокрутка на повний знакоряд драматично дешевша, бо джерело та призначення зв'язані простим зсувом всередині кожної третини. Знакоряди всередині третини розташовані через 32 байти в L. Тож прокрутка на один знакоряд вгору означає копіювання з L+32 у L, для кожного рядка розгортки та кожної третини.

Для прокрутки ігрової області на один знакоряд ключове спостереження полягає в тому, що всередині одного рядка розгортки знакоряди зберігаються суміжно (через 32 байти). Рядок розгортки 0 знакорядів 0–7 у третині живе за адресами `$xx00`, `$xx20`, `$xx40`, ..., `$xxE0`. Прокрутка N знакорядів вгору на одну позицію всередині одного рядка розгортки — це, отже, одне блочне копіювання (N-1) × 32 байтів.

Для ігрової області з 20 знакорядів, дані одного рядка розгортки — це 20 × 32 = 640 байтів. Прокрутка цього рядка розгортки означає копіювання 19 × 32 = 608 байтів уперед на 32. Ми робимо це для кожного з 8 рядків розгортки, обробляючи межі третин окремо.

**Оціночна вартість:** 8 рядків розгортки × ~12 700 тактів (T-state) на рядок розгортки (608 байтів через LDIR) + обробка меж третин = приблизно **105 000 тактів (T-state)**. Це 146% кадру.

Навіть прокрутка на знакоряд для всієї ігрової області за один кадр — це тісно. Ігри вирішують це:

- **Прокруткою під час гасіння (бордюрний період).** Верхній і нижній бордюри на Pentagon дають приблизно 14 000 тактів (T-state) вільного часу, де немає конкуренції за пам'ять.
- **Розподілом на два кадри.** Прокрути верхню половину на одному кадрі, нижню — на наступному. Візуальний ефект — прокрутка 25 fps стрибками по 8 пікселів.
- **Використанням тіньового екрану** (див. нижче).

---

## Горизонтальний піксельний скролінг

Горизонтальний скролінг — хліб і масло ігор з боковою прокруткою: світ рухається вліво або вправо, поки гравець йде. І це найдорожчий тип скролінгу на Spectrum, бо він потребує не просто копіювання байтів, а їхнього *зсуву*.

### Чому горизонтальний скролінг дорогий

Коли ти прокручуєш екран вліво на один піксель, кожен байт у кожному рядку має зсунути свої біти вліво на одну позицію, і біт, що випадає з лівого краю одного байта, має стати правим бітом його лівого сусіда. Це ланцюжок обертання-з-переносом через усі 32 байти кожного рядка.

Інструкція Z80 `RL` (rotate left through carry) — це інструмент для цього. Для зсуву вліво кожен піксель рухається на одну позицію ліворуч. Біт 7 — лівий піксель у байті, біт 0 — правий. Зсув вліво означає, що біт 7 кожного байта виходить і має увійти в біт 0 байта ліворуч. Прапорець перенесення з'єднує сусідні байти, тож ми обробляємо рядок **справа наліво**:

```z80
; Scroll one pixel row left by 1 pixel
; HL points to byte 31 (rightmost) of the row
;
; Process right to left. Each byte rotates left; carry propagates.
;
    or   a                    ; 4 T   clear carry (no pixel entering from right)

    ; Byte 31 (rightmost)
    rl   (hl)                 ; 15 T  shift left, bit 7 -> carry, carry -> bit 0
    dec  hl                   ; 6 T
    ; Byte 30
    rl   (hl)                 ; 15 T
    dec  hl                   ; 6 T
    ; ...repeat for bytes 29 down to 0...
    ; Byte 0 (leftmost)
    rl   (hl)                 ; 15 T  bit 7 of byte 0 is lost (scrolled off screen)
```

Кожен байт коштує: 15 (RL (HL)) + 6 (DEC HL) = **21 такт (T-state)** на байт. Для 32 байтів на рядок: 32 × 21 - 6 = **666 тактів (T-state)** на рядок (нам не потрібен останній DEC HL).

Фактично, перший байт потребує `OR A` (4 T) для очищення переносу. Тож один рядок коштує: 4 + 32 × 15 + 31 × 6 = 4 + 480 + 186 = **670 тактів (T-state)**.

Для 192 рядків: 192 × 670 = **128 640 тактів (T-state)**. Це **179% кадру**.

Повноекранний горизонтальний піксельний скролінг на один піксель не вміщується в один кадр з використанням RL-ланцюжків. І це *лише зсув* — ми ще не малювали новий вміст на правому краї.

### Повний розрахунок бюджету

Розпишемо повну вартість на рядок з усіма накладними витратами навігації по черезрядковому екрану:

| Операція | Тактів (T-state) на рядок |
|----------|---------------------------|
| Встановити HL на початок рядка (або просунути від попереднього) | ~15 |
| Встановити HL на правий байт: `ld a, l : or $1F : ld l, a` | 15 |
| Очистити перенос: `or a` | 4 |
| 32 × `rl (hl)` | 480 |
| 31 × `dec hl` (між байтами) | 186 |
| Перехід до наступного рядка (`inc h` або перетин межі) | 4–77 |
| **Усього на рядок (типово)** | **~704** |

Для 192 рядків: 192 × 704 = **135 168 тактів (T-state)** = **189% одного кадру**.

Для 168-рядкової ігрової області: 168 × 704 = **118 272 такти (T-state)** = **165% одного кадру**.

Немає способу зробити повноекранний однопіксельний горизонтальний скролінг за один кадр стандартними методами на Z80 з тактовою частотою 3,5 МГц. Це фундаментальне обмеження, яке визначає кожну техніку скролінгу в цьому розділі.

### Чи можемо ми зробити краще?

Ти можеш подумати, що розгортка циклу або альтернативні режими адресації допоможуть. Ні. `RL (IX+d)` коштує 23 такти (T-state) — *більше*, ніж `RL (HL)` з 15 T. Послідовність завантаження-обертання-запису (`LD A,(HL) : RLA : LD (HL),A` за 18 T на байт, плюс 6 T на `DEC HL` = 24 T) також повільніша. Ланцюжок `RL (HL) : DEC HL` за 21 T/байт є по суті оптимальним для горизонтального піксельного скролінгу на Z80.

**Підсумок:** Єдиний спосіб зробити горизонтальний скролінг доступним — зменшити кількість рядків або байтів, які ти прокручуєш.

---

## Скролінг атрибутів (знаковий)

Якщо піксельний скролінг дорогий, то скролінг атрибутів майже безкоштовний для порівняння. Скролінг атрибутів переміщує дисплей стрибками по 8 пікселів (одна символьна комірка). Ти переміщуєш лише 768 байтів пам'яті атрибутів та відповідні піксельні блоки, вирівняні по знакорядах — або, частіше, переміщуєш лише атрибути і перемальовуєш ігрову область з тайлової карти.

### Скролінг атрибутів через LDIR

Область атрибутів лінійна: 32 байти на рядок, 24 рядки, послідовно від `$5800` до `$5AFF`. Прокрутка вліво на одну знакову колонку означає копіювання байтів 1–31 на позиції 0–30 в кожному рядку, потім запис нової колонки на позицію 31.

Для всієї 24-рядкової області атрибутів:

```z80
; Scroll all attributes left by 1 character column
; New column data in a 24-byte table at new_col_data
;
scroll_attrs_left:
    ld   hl, $5801          ; 10 T  source: column 1
    ld   de, $5800          ; 10 T  dest: column 0
    ld   bc, 767            ; 10 T  768 - 1 bytes
    ldir                    ; 767*21 + 16 = 16,123 T

    ; Now fill the rightmost column with new data
    ld   hl, new_col_data   ; 10 T
    ld   de, $581F          ; 10 T  column 31 of row 0
    ld   b, 24              ; 7 T
.fill_col:
    ld   a, (hl)            ; 7 T
    ld   (de), a            ; 7 T
    inc  hl                 ; 6 T
    ; advance DE by 32 (next attribute row)
    ld   a, e               ; 4 T
    add  a, 32              ; 7 T
    ld   e, a               ; 4 T
    jr   nc, .no_carry      ; 12/7 T
    inc  d                  ; 4 T
.no_carry:
    djnz .fill_col          ; 13 T
    ret

    ; Total LDIR: ~16,123 T
    ; Total column fill: ~24 * 50 = ~1,200 T
    ; Grand total: ~17,323 T = 24.2% of frame
```

**17 323 такти (T-state) для повноекранного скролінгу атрибутів.** Це близько 24% кадру. Порівняй це з 135 000+ тактами для піксельного скролінгу. Скролінг атрибутів майже в 8 разів дешевший.

Підступ: прокрутка стрибає на 8 пікселів за раз. Візуальний результат — грубий і смикотливий. Для текстових скролерів у демо це часто прийнятно — глядач читає текст, а не оцінює плавність. Для гри стрибки по 8 пікселів відчуваються жахливо. Ось тут з'являється комбінований метод.

---

## Комбінований метод: знаковий скролінг + піксельний зсув

Це техніка, яку насправді використовує більшість ігор з горизонтальним скролінгом для Spectrum. Ідея проста і потужна:

1. Підтримуй лічильник **піксельного зсуву** від 0 до 7. Кожен кадр збільшуй зсув.
2. Коли зсув досягає 8, скинь його на 0 і виконай **скролінг атрибутів/знакорядів** — дешеву операцію.
3. На кожному кадрі відмальовуй ігрову область з поточним піксельним зсувом. Цей зсув зсуває весь дисплей на 0–7 пікселів всередині поточних позицій знакових колонок.

Піксельний зсув можна застосувати двома способами:

**Метод A: Зсув нової колонки.** Зсувай лише одну колонку піксельних даних (колонку, що входить у поле зору) на поточний зсув. Решта екрану малюється з тайлів із знаковим вирівнюванням. Це працює, коли маєш тайловий рендерер, що перемальовує з карти.

**Метод B: Віртуальний зсув апаратного стилю.** Підтримуй зсув відмальовки, що контролює, де всередині кожної символьної комірки починаються тайлові дані. Це концептуально подібне до апаратного регістра прокрутки, але реалізоване програмно.

Метод A поширеніший на практиці. Розберімо його.

### Як це працює

Уяви, що ігрова область має ширину 20 знакорядів (160 пікселів) і висоту 20 знакорядів. Дані рівня — тайлова карта, де кожен тайл має розмір 8×8 пікселів (одна символьна комірка).

Стан прокрутки складається з:
- `scroll_tile_x`: яка тайлова колонка знаходиться на лівому краї екрану (ціле число, просувається на 1 кожні 8 кадрів).
- `scroll_pixel_x`: піксельний зсув всередині поточного тайлу (0–7, просувається на 1 кожен кадр).

Кожен кадр:

1. **Якщо `scroll_pixel_x` дорівнює 0:** Перемалюй всю ігрову область з тайлової карти зі знаковим вирівнюванням. Це тайловий рендерер, який можна зробити швидким за допомогою LDIR або LDI-ланцюжків (кожен рядок тайлу — це 1 байт або кілька байтів даних, скопійованих на правильну адресу екрану). Вартість: 20 колонок × 20 рядків × ~100 T на тайл = ~40 000 T. Доступно.

2. **Якщо `scroll_pixel_x` від 1 до 7:** Перемалюй ігрову область зі зсувом на `scroll_pixel_x` пікселів. Для більшої частини ігрової області тайли вирівняні по знакорядах і можуть бути намальовані нормально — піксельний зсув впливає лише на **ліву та праву видимі колонки**, де тайл видно частково.

Зачекай — це ефективна інтерпретація, але вона потребує тайлового рендерера, що обрізає на субзнакових межах. Простіший (і поширеніший) підхід:

### Простий комбінований метод

1. Кожні 8 кадрів виконуй скролінг рівня знакоряду (LDIR атрибутів і піксельних даних вліво на одну колонку). Вартість: ~17 000 T для атрибутів + ~40 000 T для піксельних даних = ~57 000 T. Виконується раз на 8 кадрів.

2. Кожен кадр зсувай **вузьке вікно** на 1 піксель. Це вікно шириною лише 1 колонка (32 байти) або 2 колонки (64 байти) — шов між старими даними та новою колонкою, що входить.

3. **Між знаковими прокрутками** дисплей показує останню знаково-прокручену позицію з піксельним зсувом 0–7, застосованим до крайньої колонки. Гравець сприймає плавну прокрутку по 1 пікселю на кадр.

Ось розбивка вартості на кадр:

| Операція | Тактів (T-state) | Частота |
|----------|-------------------|---------|
| Знаковий скролінг (повна ігрова область) | ~57 000 | Кожен 8-й кадр |
| Піксельний зсув 1–2 крайніх колонок (20 рядків × 2 кол. × 21 T/байт × 8 рядків розгортки) | ~6 720 | Кожен кадр |
| Малювання нової тайлової колонки на правому краї | ~5 000 | Кожен 8-й кадр |
| Оновлення колонки атрибутів | ~1 200 | Кожен 8-й кадр |

**На 7 з 8 кадрів:** ~6 720 тактів (T-state) на піксельний зсув краю. Це менше 10% бюджету кадру. Достатньо місця для ігрової логіки, спрайтів та музики.

**На кожен 8-й кадр:** ~6 720 + 57 000 + 5 000 + 1 200 = ~69 920 тактів (T-state). Це 97,5% бюджету кадру. Тісно, але можливо — особливо якщо розподілити знаковий скролінг на два кадри або використати тіньовий екран.

### Реалізація: піксельний зсув крайньої колонки

Ключова внутрішня процедура зсуває 1 або 2 колонки піксельних даних на 1 піксель. Для вікна з 2 колонок (16 пікселів) кожен рядок має 2 байти для зсуву:

```z80
; Shift 2 bytes left by 1 pixel with carry propagation
; HL points to the right byte of the pair
;
    or   a                ; 4 T    clear carry
    rl   (hl)             ; 15 T   right byte: shift left, bit 7 -> carry
    dec  hl               ; 6 T
    rl   (hl)             ; 15 T   left byte: carry -> bit 0, bit 7 lost
                          ; total: 40 T per row (for 2-byte window)
```

Для 160 рядків (20 знакорядів × 8 рядків розгортки): 160 × 40 = **6 400 тактів (T-state)**. З накладними витратами на просування вказівників (~20 T на рядок) загальна вартість — близько **9 600 тактів (T-state)** на кадр. Дуже доступно.

### Конвеєр відмальовки

Ось повна покадрова послідовність для комбінованого горизонтального скролера:

```z80
frame_loop:
    halt                         ; wait for interrupt

    ; --- Always: advance pixel offset ---
    ld   a, (scroll_pixel_x)
    inc  a
    cp   8
    jr   nz, .no_char_scroll

    ; --- Every 8th frame: character scroll ---
    xor  a                       ; reset pixel offset to 0
    ld   (scroll_pixel_x), a

    ; Advance tile position
    ld   hl, (scroll_tile_x)
    inc  hl
    ld   (scroll_tile_x), hl

    ; Scroll pixel data left by 1 column (8 pixels)
    call scroll_pixels_left_char

    ; Scroll attributes left by 1 column
    call scroll_attrs_left

    ; Draw new tile column at right edge
    call draw_right_column

    jr   .scroll_done

.no_char_scroll:
    ld   (scroll_pixel_x), a

    ; Shift the edge columns by 1 pixel
    call shift_edge_columns

.scroll_done:
    ; --- Game logic, sprites, music ---
    call update_entities
    call draw_sprites
    call play_music

    jr   frame_loop
```

Це скелет справжнього бокового скролера для Spectrum. Ключове спостереження: плавний однопіксельний скролінг досягається *без* зсуву всього екрану кожен кадр. Дорогий знаковий скролінг відбувається лише раз на 8 кадрів, а покадрова робота мінімальна.

---

## Прокрутка піксельних даних на одну знакову колонку

Знакова піксельна прокрутка (крок 2 у конвеєрі вище) зсуває 8 пікселів даних ліворуч для кожного рядка. Оскільки 8 пікселів = 1 байт, це *байтове* копіювання, а не бітове обертання. 32 байти кожного рядка зсуваються вліво на 1 байт: байт[1] йде на позицію байт[0], байт[2] на байт[1], ..., байт[31] на байт[30], а байт[31] очищується або заповнюється новими даними.

Для одного рядка це LDIR на 31 байт:

```z80
; Shift one pixel row left by 8 pixels (1 byte)
; HL = address of byte 1 (source), DE = address of byte 0 (dest)
; BC = 31
;
    ldir                     ; 31*21 - 5 = 646 T per row... wait.
                             ; Actually: 30*21 + 16 = 646 T. Yes.
```

Для повної ігрової області (168 рядків): 168 × 646 = 108 528 тактів (T-state) + накладні витрати навігації рядків.

Кращий підхід використовує той факт, що всередині кожного рядка розгортки знакоряду байти суміжні. Для 20 знакових колонок дані одного рядка розгортки — це 20 суміжних байтів. Прокрутка цього рядка розгортки вліво на 1 байт означає LDIR на 19 байтів:

```z80
; Scroll one scan line of the play area left by 1 character column
; Play area is 20 columns wide (columns 2-21, for example)
; Source: column 3, Dest: column 2, count: 19
;
    ld   hl, row_addr + 3    ; source = byte 3 of this scan line
    ld   de, row_addr + 2    ; dest   = byte 2
    ld   bc, 19              ; 19 bytes to copy
    ldir                     ; 18*21 + 16 = 394 T
```

Для 160 рядків: 160 × 394 = 63 040 тактів (T-state). Додай ~20 T на рядок для навігації вказівниками: 160 × 414 = **66 240 тактів (T-state)**. Це 92% кадру. Можливо, але тісно для бюджету «кожен 8-й кадр».

З LDI-ланцюжками (19 LDI на рядок): 19 × 16 = 304 T на рядок. Для 160 рядків: 160 × 324 = **51 840 тактів (T-state)** = 72% кадру. Тепер залишається 28% для малювання нової колонки та оновлення атрибутів.

---

## Трюк з тіньовим екраном

ZX Spectrum 128K має функцію, що трансформує проблему скролінгу: **два екранні буфери**. Стандартний екран живе за адресою `$4000` на сторінці 5 (завжди відображений на `$4000`–`$7FFF`). Тіньовий екран живе за адресою `$C000` на сторінці 7 (відображений на `$C000`–`$FFFF`, коли сторінка 7 підключена).

Порт `$7FFD` контролює, який екран відображається:

```z80
; Bit 3 of port $7FFD selects the display screen:
;   Bit 3 = 0: display page 5 (standard screen at $4000)
;   Bit 3 = 1: display page 7 (shadow screen at $C000)

    ld   a, (current_bank)
    or   %00001000           ; set bit 3: display shadow screen
    ld   bc, $7FFD
    out  (c), a
```

Трюк для скролінгу:

1. **Кадр N:** Гравець бачить стандартний екран (сторінка 5). Тим часом ти малюєш вміст *наступного* кадру з прокруткою на тіньовий екран (сторінка 7, за адресою `$C000`).
2. **Кадр N+1:** Перемикай дисплей на тіньовий екран. Гравець тепер бачить щойно намальований кадр без розривів. Тим часом ти починаєш малювати кадр N+2 на тепер прихований стандартний екран.

Цей підхід подвійної буферизації повністю усуває розриви і дає тобі повний кадр (або більше) для підготовки кожного прокрученого кадру. Ціна — необхідність підтримувати два повних стани екрану, і кожна «прокрутка» фактично є повним перемальовуванням ігрової області в задній буфер.

```z80
; Flip displayed screen and return back buffer address in HL
;
; screen_flag:  0 = showing page 5, drawing to page 7
;               1 = showing page 7, drawing to page 5
;
flip_screens:
    ld   a, (screen_flag)
    xor  1                   ; 4 T   toggle
    ld   (screen_flag), a

    ld   hl, $C000           ; assume drawing to page 7
    or   a
    jr   z, .show_page5

    ; Now showing page 7, draw to page 5
    ld   hl, $4000
    ld   a, (current_bank)
    or   %00001000           ; bit 3 set: display page 7
    jr   .do_flip

.show_page5:
    ld   a, (current_bank)
    and  %11110111           ; bit 3 clear: display page 5

.do_flip:
    ld   bc, $7FFD
    out  (c), a
    ld   (current_bank), a
    ret                      ; HL = back buffer address
```

### Стратегія скролінгу з тіньовим екраном

З подвійною буферизацією підхід до скролінгу змінюється:

**Замість прокрутки живого екрану на місці** (що спричиняє розриви і має завершитися протягом одного кадру), ти **перемальовуєш ігрову область з тайлової карти** в задній буфер на новій позиції прокрутки. Це принципово інше. Ти не *переміщуєш* існуючі дані екрану — ти *відмальовуєш заново* з карти.

Це більше роботи на кадр (ти перемальовуєш усю ігрову область, а не просто зсуваєш її), але це має значні переваги:

1. **Без розривів.** Гравець ніколи не бачить наполовину прокручений екран.
2. **Без зсуву крайніх колонок.** Ти відмальовуєш кожен тайл на його правильному субзнаковому зсуві безпосередньо.
3. **Гнучка швидкість прокрутки.** Ти можеш прокручувати 1, 2 або 3 пікселі на кадр, не змінюючи логіку відмальовки.
4. **Простіший код.** Тайловий рендерер простіший за комбінований зсув-і-копіювання скролер.

Вартість повного перемальовування ігрової області з тайлів залежить від твого тайлового рендерера. З 20 × 20 тайлів, кожен тайл — 8 байтів (8 рядків розгортки × 1 байт), з використанням LDI-ланцюжків:

- 400 тайлів × 8 байтів × 16 T на LDI = 51 200 тактів (T-state) для виводу даних.
- Плюс пошук адрес тайлів і розрахунок адрес екрану: ~20 T на тайл × 400 = 8 000 T.
- **Усього: ~59 200 тактів (T-state)** = 82% кадру.

Це залишає 18% (~12 900 тактів (T-state)) для спрайтів, ігрової логіки та музики. Тісно, але робоче.

### Порівняння: методи скролінгу на ZX Spectrum

| Метод | Тактів/кадр | % кадру | Візуальна якість | Примітки |
|-------|-------------|---------|------------------|----------|
| Повний піксельний скролінг (горизонт., 1 пікс.) | ~135 000 | 189% | Плавний | Неможливо при 50 fps |
| Повний піксельний скролінг (вертик., 1 пікс.) | ~107 000 | 149% | Плавний | Неможливо при 50 fps |
| Лише скролінг атрибутів | ~17 000 | 24% | Смикотливий (стрибки 8 пікс.) | Дуже дешевий |
| Комбінований (знак. + піксельний край) | ~10 000 серед., ~70 000 пік. | 14%/98% | Плавний | Найкращий однобуферний метод |
| Тіньовий екран + перемальовка тайлів | ~59 000 | 82% | Плавний, без розривів | Потребує 128K |
| Знаковий скролінг (стрибки 8 пікс.) | ~52 000–66 000 | 73–92% | Смикотливий | Для прокрутки тексту/статусу |

![Порівняння вартості технік скролінгу](illustrations/output/ch17_scroll_costs.png)

---

## Прокрутка вправо (і проблема напрямку)

Все вище описує прокрутку вліво (гравець рухається вправо, світ зсувається вліво). А що щодо прокрутки вправо?

Для скролінгу атрибутів розверни напрямок LDIR. Копіюй байти 0–30 на позиції 1–31, справа наліво. LDIR копіює вперед (від молодших до старших адрес), тому для прокрутки вправо потрібен LDDR (копіювання назад):

```z80
; Scroll attributes right by 1 character column
;
scroll_attrs_right:
    ld   hl, $5ADE          ; source: last row, column 30
    ld   de, $5ADF          ; dest: last row, column 31
    ld   bc, 767            ; 768 - 1 bytes
    lddr                    ; 767*21 + 16 = 16,123 T
    ret
```

Для бітового піксельного зсуву прокрутка вправо використовує `RR (HL)` замість `RL (HL)`, обробляючи зліва направо:

```z80
; Scroll one pixel row RIGHT by 1 pixel
; HL points to byte 0 (leftmost)
;
    or   a                ; 4 T    clear carry
    rr   (hl)             ; 15 T   shift right, bit 0 -> carry
    inc  hl               ; 6 T
    rr   (hl)             ; 15 T   carry -> bit 7
    inc  hl               ; 6 T
    ; ... 32 bytes total ...
```

Вартість на байт ідентична: 21 такт (T-state). Прокрутка вправо коштує стільки ж, скільки прокрутка вліво. Комбінований метод працює в обох напрямках з тим самим бюджетом.

Для двонаправленого скролінгу (гравець може йти вліво або вправо) потрібні дві версії процедур знакового скролінгу та крайнього зсуву, що перемикаються залежно від напрямку. Самомодифікований код (SMC) тут корисний: перед прокруткою патчиш опкод RL/RR і напрямок INC/DEC у процедурі зсуву. Це дозволяє уникнути розгалуження всередині внутрішнього циклу (див. Розділ 3 для патерну SMC).

---

## Agon Light 2: Апаратний скролінг

VDP (Video Display Processor) Agon Light 2 обробляє скролінг принципово інакше, ніж Spectrum. Там, де програміст Spectrum мусить переміщувати байти вручну, Agon забезпечує апаратну підтримку зсувів прокрутки та тайлових карт.

### Апаратні зсуви прокрутки

VDP підтримує зсув вікна перегляду для растрових режимів. Встановлюючи регістри зсуву прокрутки, ти зсуваєш усе відображене зображення без переміщення жодних піксельних даних. eZ80 надсилає команду VDP через послідовний зв'язок:

```z80
; Agon: set horizontal scroll offset
; VDU 23, 0, &C3, x_low, x_high
;
    ld   a, 23
    call vdu_write      ; VDU command prefix
    ld   a, 0
    call vdu_write
    ld   a, $C3         ; set scroll offset command
    call vdu_write
    ld   a, (scroll_x)
    call vdu_write      ; x offset low byte
    ld   a, (scroll_x+1)
    call vdu_write      ; x offset high byte
```

Апаратура застосовує цей зсув при читанні фреймбуфера для відображення. Жодні піксельні дані не переміщуються, жодні такти (T-state) CPU не витрачаються на зсув байтів, і прокрутка ідеально плавна на будь-якій швидкості. Вартість для CPU — лише накладні витрати послідовного зв'язку (кілька сотень тактів (T-state) на послідовність VDU-команд).

### Тайловий скролінг

Режим тайлової карти VDP забезпечує нативну тайлову відмальовку. Ти визначаєш набір тайлів (8×8 або 16×16 піксельних патернів), будуєш масив карти, що посилається на індекси тайлів, і апаратура відмальовує карту під час відображення. Прокрутка досягається зміною зсуву вікна перегляду тайлової карти:

```z80
; Agon: set tilemap scroll offset
; VDU 23, 27, <tilemap_scroll_command>, offset_x, offset_y
;
    ld   a, 23
    call vdu_write
    ld   a, 27
    call vdu_write
    ld   a, 14          ; set tilemap scroll offset
    call vdu_write
    ; ... send x and y offsets ...
```

Тайлова карта загортається автоматично. Коли вікно перегляду прокручується за край карти, апаратура загортає на початок (або ти можеш оновити крайню колонку новими індексами тайлів — техніка завантаження колонок кільцевого буфера).

### Завантаження колонок кільцевого буфера

Для нескінченно прокручуваного рівня тайлова карта діє як кільцевий буфер. Карта ширша за екран хоча б на одну колонку. Коли гравець прокручує вправо:

1. Апаратний зсув прокрутки просувається на 1 піксель на кадр (або будь-яку бажану швидкість).
2. Коли нова тайлова колонка збирається прокрутитися в поле зору, eZ80 записує нові індекси тайлів у колонку, що щойно прокрутилася за лівий край.
3. Тайлова карта загортається, і щойно записана колонка з'являється праворуч.

```z80
; Ring-buffer column loading (Agon, conceptual)
;
; tilemap is 40 columns wide, screen shows 32
; scroll_col tracks which column is at the left edge
;
ring_buffer_load:
    ld   a, (scroll_col)
    add  a, 32              ; column about to appear on right
    and  39                  ; wrap to tilemap width (mod 40)
    ld   c, a               ; C = column index to update

    ; Load new tile data for this column from the level map
    ; (level_map is a wider array of tile indices)
    ld   hl, (level_ptr)     ; pointer into the level data
    ld   b, 20               ; 20 rows
.load_col:
    ld   a, (hl)             ; read tile index from level
    inc  hl
    ; Write tile index to tilemap at (C, row)
    call set_tilemap_cell    ; VDP command to set one cell
    djnz .load_col

    ld   (level_ptr), hl
    ret
```

Робота CPU на кадр мінімальна: запис 20 індексів тайлів через VDP-команди, можливо 2 000–3 000 тактів (T-state) загалом. Решта кадру доступна для ігрової логіки. Порівняй це з 59 000+ тактами Spectrum для тайлової перемальовки зі скролінгом. Апаратна тайлова карта Agon дає приблизно 20-кратне зниження вартості CPU для скролінгу.

### Порівняння: Spectrum проти Agon — скролінг

| Аспект | ZX Spectrum | Agon Light 2 |
|--------|-------------|---------------|
| Ґранулярність прокрутки | Обмежена програмно; 1 пікс. можливий, але дорогий | 1 пікс. нативно, нульова вартість CPU |
| Вартість CPU на кадр | 10 000–135 000 T | 500–3 000 T |
| Розриви | Видимі без подвійної буферизації | Немає (VDP обробляє синхронізацію) |
| Зміна напрямку | Потребує альтернативних процедур або SMC | Змінити знак зсуву |
| Обмеження розміру карти | Обмежене RAM, без апаратної підтримки | Розмір тайлової карти обмежений пам'яттю VDP |
| Колір на тайл | 2 кольори на комірку 8×8 (атрибут) | Повний колір на піксель |

Контраст разючий. На що програміст Spectrum витрачає більшу частину бюджету кадру — переміщення піксельних даних по перемішаній розкладці пам'яті — Agon вирішує записом у регістр. Це не критика жодної з платформ. Це демонстрація того, як рішення в проєктуванні апаратури поширюються через кожен рівень програмного забезпечення. Обмеження Spectrum змусили розвинути комбінований метод скролінгу, тайлові рушії та трюки з тіньовим екраном. Обмеження Agon лежать в іншому місці (затримка послідовного VDP, накладні витрати команд для складних сцен).

---

## Практика: рівень з горизонтальним скролінгом

### Версія для Spectrum: комбінований знаковий + піксельний скролінг

Побудуй горизонтальний скролер з ігровою областю 20×20 знакорядів, що прокручується плавно зі швидкістю 1 піксель на кадр. Дані рівня — тайлова карта, збережена в банку пам'яті.

Ось повна структура:

```z80
; Side-scroller engine — ZX Spectrum 128K
; Uses combined character + pixel method with shadow screen.
;
    ORG $8000

PLAY_X      EQU 2           ; play area starts at column 2
PLAY_Y      EQU 2           ; play area starts at char row 2
PLAY_W      EQU 20          ; play area width in characters
PLAY_H      EQU 20          ; play area height in characters

scroll_pixel_x:   DB 0      ; pixel offset 0-7
scroll_tile_x:    DW 0      ; tile column at left edge
screen_flag:      DB 0      ; which screen is visible
current_bank:     DB 0      ; current $7FFD value

; --- Main loop ---
main:
    halt                     ; 4 T   sync to frame

    ; Advance scroll
    ld   a, (scroll_pixel_x) ; 13 T
    inc  a                   ; 4 T
    cp   8                   ; 7 T
    jr   c, .pixel_only      ; 12/7 T

    ; Character scroll frame
    xor  a
    ld   (scroll_pixel_x), a

    ; Advance tile position
    ld   hl, (scroll_tile_x)
    inc  hl
    ld   (scroll_tile_x), hl

    ; Get back buffer address
    call get_back_buffer     ; HL = $4000 or $C000

    ; Redraw full play area from tilemap into back buffer
    call render_play_area    ; ~50,000 T

    ; Flip screens
    call flip_screens        ; ~30 T

    jr   .frame_done

.pixel_only:
    ld   (scroll_pixel_x), a

    ; Shift edge columns in current (non-displayed) buffer
    call get_back_buffer
    call shift_edge_columns  ; ~9,600 T

    call flip_screens

.frame_done:
    call update_player       ; ~2,000 T
    call draw_sprites        ; ~5,000 T
    call play_music          ; ~3,000 T (IM2 handler)

    jr   main

; --- Render full play area from tilemap ---
; Input: HL = base address of target screen ($4000 or $C000)
;
render_play_area:
    ; For each tile in the play area:
    ;   Look up tile index from tilemap
    ;   Copy 8 bytes of tile data to screen, navigating interleave
    ;
    ; 20 columns x 20 rows = 400 tiles
    ; Each tile: 8 scan lines x 1 byte = 8 LDI operations
    ; Per tile: lookup (20 T) + 8 x (LDI 16 T + INC H 4 T) = 180 T
    ; Total: 400 x 180 = 72,000 T
    ;
    ; (Actual implementation uses PUSH tricks and
    ;  pre-computed screen address tables for ~55,000 T)
    ret

; --- Shift edge columns by 1 pixel ---
; Shifts the 2 rightmost columns of the play area left by 1 pixel
;
shift_edge_columns:
    ; For each of 160 pixel rows in the play area:
    ;   Navigate to the correct screen address
    ;   RL (HL) on the 2 edge bytes, right to left
    ;
    ; Per row: 40 T (2 bytes shifted) + 20 T (navigation)
    ; Total: 160 x 60 = 9,600 T
    ret
```

### Версія для Agon: апаратний тайловий скролінг

Версія для Agon драматично простіша. Головний цикл викликає `vsync`, інкрементує 16-бітний зсув прокрутки, надсилає його до VDP через процедуру `set_scroll_offset` (кілька викликів `vdu_write`), і кожні 8 пікселів викликає `ring_buffer_load` для оновлення однієї колонки індексів тайлів. Весь скролінг коштує менше 3 000 тактів (T-state) на кадр, залишаючи 365 000+ тактів (T-state) для ігрової логіки, AI, фізики та відмальовки. Версія для Spectrum — це ретельна вправа з підрахунку тактів, де кожна техніка з Розділів 2 і 3 зводиться разом, щоб досягти того, що Agon робить одним записом у апаратний регістр.

---

## Вертикальний + горизонтальний: комбінований скролінг

Деякі ігри прокручуються в обох напрямках одночасно. На Spectrum застосуй комбінований метод до обох осей: знаковий скролінг + піксельний зсув (0–7) для кожної. Знаковий скролінг у кожному напрямку відбувається раз на 8 кадрів. Збіг обох на одному кадрі — це ймовірність 1/64 (приблизно кожні 1,3 секунди) — або прийми один пропущений кадр, або розподіли роботу. Покадрова вартість зсуву краю для обох осей: горизонтальні крайні колонки (~9 600 T) + вертикальні крайні рядки (~6 400 T) = ~16 000 T = 22% кадру. Прийнятно.

---

## Поради з оптимізації

### 1. Використовуй таблицю підстановки адрес екрану

Попередньо обчисли таблицю з 192 адрес екрану (по одній на піксельний рядок) у RAM. Вартість: 384 байти. Перевага: 16-бітний пошук по таблиці (приблизно 30 тактів (T-state)) замінює бітові маніпуляції обчислення адреси (91 такт (T-state)).

### 2. Прокручуй лише видиме

Якщо спрайти закривають частину ігрової області, ти можеш пропустити прокрутку рядків за непрозорими спрайтами. Відстежуй, які рядки потребують прокрутки, за допомогою бітової карти брудних рядків. Ця оптимізація окуповується, коли спрайти закривають значну частину ігрової області.

### 3. Використовуй PUSH для знакового скролінгу

Для знакової піксельної прокрутки (копіювання 19 байтів уліво на рядок розгортки) PUSH-трюк працює добре. Встанови SP на кінець ігрової області рядка розгортки, POP 10 байтів, зсунь вміст регістрів і PUSH їх назад зі зсувом на один байт. Це складно для налаштування, але зменшує вартість на рядок розгортки на 30–40%.

### 4. Розподіли знаковий скролінг між кадрами

Якщо знаковий скролінг (кожен 8-й кадр) занадто дорогий для одного кадру, розподіли його: прокрути верхню половину ігрової області на кадрі N, а нижню — на кадрі N+1. Візуальний артефакт (верхня половина зсувається на 1 кадр раніше нижньої) ледь помітний при 50 fps.

### 5. Трюки з палітрою та атрибутами

Для скролінгу лише атрибутів (без піксельних даних) розглянь використання змін FLASH або BRIGHT для створення ілюзії руху всередині статичної піксельної сітки. Набір атрибутних кольорів, що змінюється ротацією на знаково-вирівняних тайлах, може імітувати потік, воду або конвеєрні стрічки без переміщення жодних піксельних даних.

---

## Підсумок

- **Повноекранний піксельний скролінг на ZX Spectrum неможливий при 50 fps.** Горизонтальний піксельний скролінг коштує ~135 000 тактів (T-state) для 192 рядків (189% бюджету кадру). Вертикальний коштує ~107 000 тактів (T-state) (149%). Черезрядкова розкладка пам'яті додає складності вертикальному скролінгу, а відсутність barrel shifter робить горизонтальний скролінг за своєю суттю дорогим.

- **Скролінг атрибутів дешевий** — ~17 000 тактів (T-state) (24% кадру), але рухається грубими стрибками по 8 пікселів.

- **Комбінований метод** — це те, що використовують справжні ігри: знакові прокрутки (кожні 8 кадрів) плюс покадровий піксельний зсув 1–2 крайніх колонок. Середня покадрова вартість — менше 10 000 тактів (T-state). Пік на кадрах знакової прокрутки (~70 000 T) можна згладити тіньовим екраном або розподілом між кадрами.

- **Тіньовий екран** (128K, сторінка 7) забезпечує подвійну буферизацію без розривів. Малюй наступний кадр у задній буфер, потім перемикай дисплей. Це змінює стратегію скролінгу з «зсунь існуючі дані» на «перемалюй з тайлової карти», що концептуально простіше і усуває розриви.

- **Напрямок горизонтального скролінгу** не змінює вартість. Прокрутка вправо використовує `RR (HL)` замість `RL (HL)`, зліва направо замість справа наліво, з тими самими 21 тактами (T-state) на байт.

- **Вертикальний піксельний скролінг** ускладнюється черезрядковою розкладкою екрану Spectrum. Переміщення на один рядок пікселів вниз означає навігацію по структурі адрес `010TTSSS LLLCCCCC`, з різними корекціями вказівників на межах символьних комірок та третин. Підхід роздільних лічильників з Розділу 2 — необхідний.

- **Agon Light 2** забезпечує апаратні зсуви прокрутки та тайлову відмальовку, що зменшують вартість CPU скролінгу до кількох VDP-команд на кадр (~500–3 000 тактів (T-state)). Завантаження колонок кільцевого буфера підтримує тайлову карту актуальною, коли нова місцевість прокручується в поле зору. Те, що програміст Spectrum будує за 70 000 тактів (T-state), Agon вирішує записом у регістр.

- **Ключові техніки з попередніх розділів** тут необхідні: черезрядкова розкладка екрану та навігація роздільними лічильниками (Розділ 2), LDI-ланцюжки та PUSH-трюки для швидкого переміщення даних (Розділ 3), та самомодифікований код (SMC) для процедур скролінгу, що перемикаються за напрямком (Розділ 3).

---

> **Джерела:** Introspec «Eshchyo raz pro DOWN_HL» (Hype, 2020) — навігація по черезрядковому екрану; Introspec «GO WEST Part 1» (Hype, 2015) — вартість спірної пам'яті; DenisGrachev «Ringo Render 64x48» (Hype, 2022) — скролінг зі зсувом у половину знакоряду; ZX Spectrum 128K Technical Manual — порт `$7FFD` та тіньовий екран; документація VDP Agon Light 2 — тайлові карти та команди зсуву прокрутки.
