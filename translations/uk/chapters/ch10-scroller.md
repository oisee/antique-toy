# Розділ 10: Скролер з точкового поля та 4-фазний колір

> *"Два нормальних кадри та два інвертованих кадри. Око бачить середнє."*
> -- Introspec, Making of Eager (2015)

---

ZX Spectrum відображає два кольори на комірку 8x8. Текст прокручується по екрану з будь-якою швидкістю, яку може забезпечити процесор. Це фіксовані обмеження — залізо робить те, що робить, і жодна хитрість не змінить кремній.

Але хитрість може змінити те, що *сприймає* глядач.

Цей розділ зводить разом дві техніки з двох різних демо, розділених майже двадцятьма роками, але пов'язаних спільним принципом. Скролер з точкового поля з *Illusion* від X-Trade (ENLiGHT'96) рендерить текст як хмару окремих точок, що підстрибують, кожна розміщена ціною лише 36 тактів. 4-фазна колірна анімація з *Eager* від Introspec'а (3BM Open Air 2015) чергує чотири ретельно побудованих кадри на 50 Гц, щоб обманути око і показати кольори, які залізо не може видати. Одна використовує просторову роздільність — розміщує точки де завгодно, без обмежень символьних комірок. Інша використовує часову роздільність — перемикає кадри швидше, ніж може встигнути око. Разом вони демонструють дві основні осі обману на обмеженому залізі: простір і час.

---

## Частина 1: Скролер з точкового поля

### Що бачить глядач

Уяви повідомлення — "ILLUSION BY X-TRADE" — відрендерене не суцільними блочними символами, а як поле окремих точок, кожна точка — один піксель. Текст плавно дрейфує горизонтально по екрану. Але точки не сидять на плоских рядках розгортки. Вони підстрибують. Усе точкове поле хвилясто коливається синусоїдою, кожна колонка зміщена вертикально відносно сусідів, створюючи враження тексту, що пульсує на водній поверхні.

### Шрифт як текстура

Шрифт зберігається як бітмап-текстура у пам'яті — один біт на точку. Якщо біт 1, точка з'являється на екрані. Якщо біт 0, нічого не відбувається. Критичне слово — *прозорий*. У звичайному рендерері ти записуєш кожну піксельну позицію. У скролері з точкового поля прозорі пікселі майже безкоштовні. Ти перевіряєш біт, і якщо він нульовий, пропускаєш. Лише встановлені пікселі потребують запису у відеопам'ять.

Це означає, що вартість рендерингу пропорційна кількості видимих точок, а не загальній площі. Типовий символ 8x8 може мати 20 встановлених пікселів із 64. Для великого прокручуваного повідомлення ця економія має величезне значення. BC вказує на дані шрифту; RLA зсуває кожен біт у прапорець переносу для визначення увімкнено чи вимкнено.

### Стекові таблиці адрес

У звичайному скролері екранна позиція кожного пікселя обчислюється з координат (x, y) за допомогою формули черезрядкових адрес Spectrum. Це обчислення включає зсуви, маски та пошук по таблицях. Робити це для тисяч пікселів за кадр з'їло б увесь бюджет.

Розв'язок Dark'а: попередньо обчисли кожну екранну адресу та зберігай їх як таблицю, по якій ходить вказівник стеку. POP зчитує 2 байти та автоінкрементує SP, усе за 10 тактів. Вкажи SP на таблицю замість реального стеку, і POP стає найшвидшим можливим отриманням адреси — жодних індексних регістрів, жодної арифметики вказівників, жодних накладних витрат.

Рух підстрибування закодований цілком у таблиці адрес. Кожен запис — екранна адреса, що вже включає вертикальний синусоїдальний зсув. "Підстрибування" не відбувається під час рендерингу. Воно відбулося, коли таблиця була побудована. Усі три виміри анімації — позиція скролу, хвиля підстрибування, форма символу — згортаються в єдину лінійну послідовність 16-бітних адрес, споживаних на повній швидкості через POP.

### Внутрішній цикл

Аналіз Introspec'а 2017 року Illusion розкриває внутрішній цикл. Один байт даних шрифту містить 8 бітів — 8 пікселів. `LD A,(BC)` зчитує байт один раз, потім RLA зсуває по одному біту за раз через 8 розгорнутих ітерацій:

```z80
; Dotfield scroller inner loop (unrolled for one font byte)
; BC = pointer to font/texture data, SP = pre-built address table

    ld   a,(bc)      ;  7 T  read font byte (once per 8 pixels)
    inc  bc          ;  6 T  advance to next font byte

    ; Pixel 7 (MSB)
    pop  hl          ; 10 T  get screen address from stack
    rla              ;  4 T  shift texture bit into carry
    jr   nc,.skip7   ; 12/7 T  skip if transparent
    set  7,(hl)      ; 15 T  plot the dot
.skip7:
    ; Pixel 6
    pop  hl          ; 10 T
    rla              ;  4 T
    jr   nc,.skip6   ; 12/7 T
    set  6,(hl)      ; 15 T
.skip6:
    ; ... pixels 5 through 0 follow the same pattern,
    ; with SET 5 through SET 0 ...
```

Попіксельна вартість, за винятком амортизованого зчитування байта:

| Шлях | Інструкції | Такти |
|------|-------------|----------|
| Непрозорий піксель | `pop hl` + `rla` + `jr nc` (не взято) + `set ?,(hl)` | **36** |
| Прозорий піксель | `pop hl` + `rla` + `jr nc` (взято) | **26** |

`LD A,(BC)` та `INC BC` коштують 13 тактів, амортизованих на 8 пікселів — приблизно 1,6 T на піксель. "36 тактів на піксель" Introspec'а — це найгірша вартість у межах розгорнутого байта, без цих накладних витрат.

Бітова позиція SET змінюється для кожного пікселя (7, 6, 5 ... 0), тому цикл розгорнутий 8 разів, а не повторюється. Параметризувати бітову позицію в SET без IX/IY індексації (надто повільно) або самомодифікованого коду (накладні витрати) неможливо. Розгортання — чисте рішення.

### Бюджетна арифметика

Бюджет кадру Pentagon — 71 680 тактів. Припускаючи, що 60-70% доступні для скролера (решта йде на музику, очищення екрану, побудову таблиці), це приблизно 45 000 тактів.

Розглянемо 4 096 точок (8 символів тексту 8x8). Типовий шрифт заповнений приблизно на 30%: 1 200 непрозорих точок по 36 T кожна, 2 900 прозорих по 26 T кожна. Разом: 43 200 + 75 400 + 6 656 (накладні витрати на зчитування байтів) = приблизно 125 000 тактів. Це близько 1,75 кадри — скролер оновлюється приблизно на 28 fps, комфортно плавно.

Числа працюють, тому що дві оптимізації компонуються. Стекова адресація усуває всі обчислення координат. Прозорість на основі текстури усуває всі записи для порожніх пікселів.

### Як закодоване підстрибування

Таблиця адрес — це місце, де живе мистецтво. Для створення руху підстрибування таблиця синусів зміщує вертикальну позицію кожної колонки:

```
y_offset = sin_table[(column * 8 + scroll_pos * 2) & 255]
```

Множення на 8 контролює просторову частоту; множник 2 при позиції скролу контролює швидкість фази. Для кожної точки (x, y + y_offset) обчислюється адреса екрану Spectrum і зберігається в таблиці. Код побудови таблиці виконується один раз за кадр, поза внутрішнім циклом. Внутрішній цикл бачить лише потік попередньо обчислених адрес.

---

## Частина 2: 4-фазна колірна анімація

### Проблема кольору

Кожна комірка 8x8 має один колір чорнила (0-7) і один колір паперу (0-7). В межах одного кадру ти отримуєш рівно два кольори на комірку. Але Spectrum працює на 50 кадрах за секунду, і людське око не бачить окремих кадрів на такій частоті. Воно бачить середнє.

### Трюк

4-фазна техніка Introspec'а циклічно проходить чотири кадри:

1. **Нормальний A:** чорнило = C1, папір = C2. Піксельні дані = патерн A.
2. **Нормальний B:** чорнило = C3, папір = C4. Піксельні дані = патерн B.
3. **Інвертований A:** чорнило = C2, папір = C1. Піксельні дані = патерн A (ті самі пікселі, поміняні кольори).
4. **Інвертований B:** чорнило = C4, папір = C3. Піксельні дані = патерн B (ті самі пікселі, поміняні кольори).

При 50 Гц кожен кадр відображається 20 мілісекунд. Чотирикадровий цикл завершується за 80 мс — 12,5 циклів на секунду, вище порогу злиття мерехтіння на CRT-дисплеях.

### Математика сприйняття

Простежимо один піксель, що "увімкнений" у патерні A та "вимкнений" у патерні B:

| Кадр | Стан пікселя | Відображений колір |
|-------|-------------|-----------------|
| Нормальний A | увімкнений (чорнило) | C1 |
| Нормальний B | вимкнений (папір) | C4 |
| Інвертований A | увімкнений (чорнило) | C2 |
| Інвертований B | вимкнений (папір) | C3 |

Око сприймає середнє: (C1 + C2 + C3 + C4) / 4.

Тепер перевіримо: піксель, "увімкнений" в обох патернах, бачить C1, C3, C2, C4. Піксель, "вимкнений" в обох, бачить C2, C4, C1, C3. Усі випадки дають однакове середнє. Піксельний патерн не впливає на сприйнятий відтінок — лише вибір C1 по C4 впливає.

Тоді навіщо два патерни? Тому що *проміжні* переходи мають значення. Піксель, що чергується між яскраво-червоним і яскраво-зеленим, помітно мерехтить на 12,5 Гц. Піксель, що чергується між подібними відтінками, ледве мерехтить. Патерни дизерингу — шахматки, напівтонові сітки, впорядковані матриці — контролюють *текстуру* мерехтіння. Introspec обрав патерни так, щоб переходи між кадрами давали мінімальне видиме коливання. Це антиклешовий підбір пікселів: ретельне розташування бітів "увімкнено" та "вимкнено", щоб жоден піксель не перемикався між драматично різними кольорами в послідовних кадрах.

### Чому інвертування суттєве

Без кроку інвертування "увімкнені" пікселі завжди показували б чорнило, а "вимкнені" — завжди папір. Ти отримав би рівно два видимих кольори на комірку, що мерехтять між двома різними парами. Інвертування гарантує, що і чорнило, і папір вносять вклад в обидва стани пікселів протягом циклу, змішуючи всі чотири кольори в сприйнятий вивід.

На Spectrum інвертування дешеве — поміняй біти чорнила та паперу в байті атрибута, або попередньо обчисли обидва — нормальний та інвертований — буфери і циклічно перемикай між ними.

### Практична вартість

Чотири попередньо побудовані буфери атрибутів, що перемикаються один раз за кадр. Покадрова вартість — блокове копіювання 768 байтів у RAM атрибутів: приблизно 16 000 тактів через LDIR, або приблизно 4 500 тактів через PUSH-трюки. Менше чверті бюджету кадру в будь-якому випадку.

Пам'ять: 4 x 768 = 3 072 байти на буфери. Піксельні патерни (A і B) записуються один раз при ініціалізації і більше ніколи не змінюються.

### Накладення тексту

В Eager прокручуваний текст накладається на колірну анімацію. Найпростіший підхід резервує певні комірки для тексту, виключаючи їх із колірного циклу — фіксовані атрибути білого на чорному зі справжніми гліфами шрифту. Більш витончений підхід інтегрує текст у фазову анімацію: форми гліфів перезаписують конкретні біти в патернах A та B, гарантуючи, що текст видимий у кожному кадрі, тоді як навколишні пікселі все ще циклічно змінюються. Це створює текст, що, здається, плаває на анімованому фоні, з колірним розтіканням до країв кожної літери.

---

## Спільний принцип: Часове шахрайство

Скролер з точкового поля використовує 50 кадрів за секунду для *просторової* гнучкості. Кожен кадр — знімок позицій точок в один момент; мозок глядача інтерполює між знімками, сприймаючи плавний рух. Завдання процесора — *розмістити* точки якомога швидше, зчитуючи попередньо обчислені адреси зі стеку.

4-фазна колірна анімація використовує 50 кадрів за секунду для *колірної* гнучкості. Кожен кадр відображає один з чотирьох колірних станів; сітківка глядача усереднює їх. Жоден окремий кадр не містить сприйнятий результат — він існує лише в інерції зору.

Обидві використовують одну й ту саму фізичну реальність: CRT оновлюється на 50 Гц, і зорова система людини не може розрізнити окремі кадри на такій частоті. *Часова* роздільність Spectrum значно багатша за його просторову чи колірну роздільність. Кодери демосцени відкрили, що часова роздільність — найдешевша вісь для експлуатації.

Обидві зводять свої внутрішні цикли до абсолютного мінімуму. Скролер до 36 тактів на точку. Колірна анімація до єдиного копіювання буфера за кадр. Обидві виносять складність із внутрішнього циклу в попередні обчислення. І обидві дають результати, які виглядають для непідготовленого глядача так, ніби залізо не повинно бути на це здатне.

Ось що робить демосцену часовою формою мистецтва. Скріншот скролера з точкового поля показує розсип пікселів. Скріншот 4-фазної колірної анімації показує два кольори на комірку, точно як залізо специфікує. Їх потрібно побачити *у русі*, щоб побачити, як вони працюють. Краса — в послідовності, а не в кадрі.

---

## Практика 1: Скролер підстрибуючого точкового тексту

Побудуй спрощений скролер з точкового поля: коротке текстове повідомлення, відрендерене як підстрибуюче точкове поле з використанням POP-адресації.

**Структури даних.** Вирівняний за сторінкою бітмап-шрифт 8x8 (ROM-шрифт за адресою `$3D00` працює). 256-байтна таблиця синусів для зміщення підстрибування. RAM-буфер для таблиці адрес (до 4 096 x 2 байтів).

**Побудова таблиці.** Перед кожним кадром пройди по видимих символах. Для кожного біта кожного байта шрифту обчисли екранну адресу, що включає синусоїдальне зміщення підстрибування, та збережи її в таблиці адрес. Це виконується один раз за кадр поза внутрішнім циклом.

**Рендеринг.** Вимкни переривання. Збережи SP через самомодифікований код. Вкажи SP на таблицю адрес. Виконай розгорнутий внутрішній цикл: `ld a,(bc) : inc bc`, потім 8 повторень `pop hl : rla : jr nc,skip : set N,(hl)` з N від 7 до 0. Віднови SP. Увімкни переривання.

**Основний цикл.** `halt` (синхронізація з 50 Гц), очисти екран (очищення через PUSH з Розділу 3), побудуй таблицю адрес, відрендери точкове поле, просунь позицію скролу та фазу підстрибування.

**Розширення.** Часткове очищення екрану (відстежуй обмежувальний прямокутник). Подвійна буферизація через тіньовий екран на 128K. Кілька гармонік підстрибування. Змінна щільність точок для розрідженого, більш ефірного вигляду.

---

## Практика 2: 4-фазна циклічна колірна анімація

Побудуй 4-фазну колірну анімацію, що створює плавні градієнти.

**Піксельні патерни.** Заповни бітмап-пам'ять двома комплементарними патернами дизерингу. Найпростіше: парні піксельні рядки отримують `$55` (01010101), непарні рядки — `$AA` (10101010). Для виробничої якості використовуй впорядковану матрицю Баєра 4x4.

**Буфери атрибутів.** Попередньо обчисли чотири 768-байтні буфери. Буфери 0 та 1 містять нормальні атрибути з двома різними колірними схемами (змінне чорнило/папір по екрану для діагонального градієнта). Буфери 2 та 3 — інвертовані версії — біти чорнила та паперу поміняні. Обмін — це бітова ротація: три RRCA для переміщення бітів чорнила на позицію паперу, три RLCA в інший бік, маскування та комбінування.

**Основний цикл.** Кожен кадр: `halt`, індексуй у 4-елементну таблицю вказівників на буфери, використовуючи лічильник фази (AND 3), LDIR 768 байтів у `$5800`, інкрементуй лічильник фази. Це весь runtime-рушій — приблизно 16 000 тактів на кадр.

**Анімація.** Для рухомого градієнта регенеруй один буфер за кадр (той, що стає найстарішим у 4-кадровому циклі) з просуваючим колірним зміщенням. Це підтримує конвеєр: відображай кадр N, генеруючи кадр N+4. Альтернативно, попередньо обчисли всі буфери по банках 128K для нульової вартості виконання.

---

## Підсумок

- **Скролер з точкового поля** рендерить текст як окремі точки. Внутрішній цикл — `pop hl : rla : jr nc,skip : set ?,(hl)` — коштує 36 тактів на непрозорий піксель, 26 на прозорий.
- **Стекова адресація** кодує траєкторію підстрибування як попередньо побудовані екранні адреси. POP отримує їх за 10 тактів кожну — найшвидший довільний доступ на читання на Z80.
- **4-фазний колір** циклічно перемикає 4 атрибутних кадри (2 нормальних + 2 інвертованих) на 50 Гц. Інерція зору усереднює кольори, створюючи ілюзію більш ніж 2 кольорів на комірку.
- Крок **інвертування** гарантує, що всі чотири кольори вносять вклад у кожну піксельну позицію.
- Обидві техніки використовують **часову роздільність** для створення ефектів, неможливих у будь-якому окремому кадрі.
- Скролер використовує стек для просторової гнучкості; колірна анімація використовує чергування кадрів для колірної гнучкості — дві основні осі демосценового обману.

---

## Спробуй сам

1. Побудуй скролер з точкового поля. Почни з одного статичного символу, нанесеного через POP-базований внутрішній цикл. Перевір очікуваний таймінг тестовою обв'язкою з бордюру Розділу 1. Потім додай таблицю підстрибування та спостерігай, як він хвилясто коливається.

2. Експериментуй з параметрами підстрибування. Зміни амплітуду синуса, просторову частоту та швидкість фази. Невеликі зміни дають драматичні візуальні відмінності.

3. Побудуй 4-фазну колірну анімацію. Почни з рівномірного кольору (всі комірки однакові в кожній фазі). Переконайся, що бачиш стабільний колір, який не є ні чорнилом, ні папером жодного окремого кадру. Потім додай діагональний градієнт.

4. Спробуй різні патерни дизерингу. Шахматка, блоки 2x2, матриця Баєра, випадковий шум. Які мінімізують видиме мерехтіння? Які дають найплавніші сприйняті градієнти?

5. Поєднай обидві техніки: 4-фазний колірний фон з монохромним скролером з точкового поля зверху.

---

> **Джерела:** Introspec, "Technical Analysis of Illusion by X-Trade" (Hype, 2017); Introspec, "Making of Eager" (Hype, 2015); Dark, "Programming Algorithms" (Spectrum Expert #01, 1997). Дизасемблювання внутрішнього циклу та підрахунки тактів слідують аналізу Introspec'а 2017 року. 4-фазна колірна техніка описана у статті making-of Eager та file_id.diz партійної версії.
