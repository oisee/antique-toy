# Розділ 1: Мислити тактами

> "Кодерські ефекти — це завжди про еволюцію обчислювальної схеми."
> -- Introspec (spke), Life on Mars

У тебе є 71 680 тактів. Це твоє полотно, твій бюджет, увесь твій світ. Кожна інструкція, яку ти пишеш, коштує певну кількість цих тактів. Кожен кадр лічильник скидається, і ти отримуєш ще 71 680 — ні більше, ні менше. Пропустиш дедлайн — і екран розірветься, музика засікатиме, ілюзія зруйнується.

Цей розділ про те, як навчитися бачити свій код так, як його бачить Z80-демосценер: не як текст, не як алгоритми, а як *бюджет*.

---

## Такти: Валюта Z80

Процесор Z80 не виконує інструкції рівними порціями. Кожна інструкція займає певну кількість **тактів** (T-state) — фундаментальних тактових циклів процесора. На частоті 3,5 МГц один такт триває приблизно 286 наносекунд. Це число не важливе. Важливо те, що інструкції мають дуже різну вартість, і тобі потрібно знати ці вартості напам'ять.

Ось декілька інструкцій, які ти використовуватимеш постійно:

| Інструкція | Що робить | Такти |
|-------------|-------------|----------|
| `NOP` | Нічого | 4 |
| `LD A,B` | Копіює B в A | 4 |
| `LD A,(HL)` | Завантажує байт з адреси пам'яті в HL | 7 |
| `LD (HL),A` | Зберігає A за адресою пам'яті в HL | 7 |
| `LD A,n` | Завантажує безпосередній байт в A | 7 |
| `INC HL` | Збільшує HL | 6 |
| `ADD A,B` | Додає B до A | 4 |
| `PUSH HL` | Кладе HL на стек | 11 |
| `DJNZ label` | Зменшує B, стрибає якщо не нуль | 13 (перехід) / 8 (прохід) |
| `LDIR` | Блокове копіювання, за байт | 21 (повтор) / 16 (останній байт) |
| `OUT (n),A` | Записує A в порт вводу/виводу | 11 |

Подивись на діапазон. Регістр-регістрова `LD A,B` коштує 4 такти — мінімум для будь-якої інструкції. Читання з пам'яті `LD A,(HL)` коштує 7, бо процесору потрібні додаткові машинні цикли, щоб виставити адресу на шину й дочекатися відповіді від RAM. `LDIR`, інструкція блокового копіювання, за яку кожен кодер Spectrum береться інстинктивно, коштує 21 такт на кожний байт, який вона копіює (окрім останнього байта, який коштує 16). Це більш ніж у п'ять разів дорожче за NOP.

![Вартість у тактах поширених інструкцій Z80](illustrations/output/ch01_tstate_costs.png)

Чому це важливо? Тому що коли ти заповнюєш екран, оновлюєш дані спрайтів або обчислюєш наступний кадр ефекту плазми, кожна інструкція з'їдає твій бюджет. Різниця між інструкцією на 4 такти та інструкцією на 7 тактів, помножена на десять тисяч ітерацій у внутрішньому циклі, — це різниця між ефектом, що працює на 50 кадрах за секунду, і тим, що не працює.

### Машинні цикли та доступ до пам'яті

Кожен такт — це один тік процесорного годинника, але Z80 не звертається до пам'яті на кожному тіку. Інструкції розбиваються на **машинні цикли** (M-цикли), кожен з яких займає 3–6 тактів. Перший машинний цикл кожної інструкції — це **вибірка опкоду** (M1), яка завжди займає 4 такти: процесор виставляє лічильник команд на адресну шину, зчитує байт опкоду і одночасно оновлює DRAM. Наступні машинні цикли зчитують додаткові байти (операнди, дані з пам'яті) або записують результати.

Ось чому `LD A,B` займає рівно 4 такти — це однобайтова інструкція, яка повністю завершується під час вибірки опкоду. А `LD A,(HL)` займає 7 тактів: 4 на вибірку опкоду, потім ще 3 на цикл читання пам'яті, де процесор виставляє HL на адресну шину та зчитує байт за цією адресою.

Тобі не потрібно запам'ятовувати внутрішню розбивку машинних циклів для кожної інструкції. Але розуміння патерну — вибірка опкоду + читання операндів + доступ до пам'яті = загальна вартість — допомагає виробити інтуїцію щодо того, *чому* інструкції коштують стільки, скільки коштують. `PUSH HL` на 11 тактів стає зрозумілим, коли усвідомлюєш, що процесор мусить виконати вибірку опкоду (5T у цьому випадку, оскільки він також зменшує SP), а потім два окремі цикли запису в пам'ять (по 3T кожен), щоб зберегти старший і молодший байти HL на стеку.

---

## Кадр: Твоє полотно

ZX Spectrum генерує відеосигнал PAL зі швидкістю приблизно 50 кадрів на секунду. Кожен кадр мікросхема ULA зчитує відеопам'ять і малює екран, рядок за рядком. Наприкінці кожного кадру ULA генерує масковане переривання. Процесор виконує інструкцію `HALT`, щоб дочекатися цього переривання, виконує свою роботу, а потім знову `HALT` — чекає на наступний кадр. Це серцебиття кожної програми для Spectrum.

Кількість тактів між одним перериванням та наступним — **бюджет кадру** — залежить від машини:

| Машина | Тактів на кадр | Рядків розгортки | Гц |
|---------|-------------------|-----------|-----|
| ZX Spectrum 48K | 69 888 | 312 | 50,08 |
| ZX Spectrum 128K | 70 908 | 311 | 50,02 |
| Pentagon 128 | 71 680 | 320 | 48,83 |

Це *загальна* кількість тактів між перериваннями. Практичний бюджет менший — віднімай вартість обробника переривань (музичний програвач PT3 зазвичай споживає 3 000–5 000 тактів на кадр), накладні витрати HALT, а на не-Pentagon-машинах — штрафи за конфлікти доступу. На Pentagon з музичним програвачем розраховуй приблизно на 66 000–68 000 тактів для основного циклу. У розділі 15 є детальні такт-карти.

![Розподіл бюджету кадру по моделях ZX Spectrum](illustrations/output/ch01_frame_budget.png)

Якщо твій основний цикл — обробка введення, ігрова логіка, оновлення звуку, рендеринг екрану — займає більше тактів, ніж один кадр, ти губиш кадри. Все сповільнюється. Трюк із бордюрною смугою, який ми побудуємо далі в цьому розділі, зробить це болісно видимим.

Щоб поставити ці числа в перспективу: одна команда `LDIR`, що копіює 6 912 байтів (один повний екран піксельних даних), коштує приблизно 6 912 x 21 = 145 152 такти. Це більше ніж два повних кадри на Spectrum 48K. Ти не можеш навіть скопіювати екран один раз за кадр найпростішим можливим способом. Ось такі обмеження змушують мислити творчо.

---

## Pentagon проти машин з очікуванням

Ти помітиш, що бюджети кадрів вище різняться між машинами. Різниця не лише в числах — вона відображає фундаментальний архітектурний розкол, який сформував демосцену ZX Spectrum.

### Оригінальні машини Sinclair

На оригінальних Spectrum 48K та 128K екранна пам'ять розташована за адресами `$4000`–`$5AFF` (піксельні дані) та `$5800`–`$5B00` (атрибути кольорів). Ця область пам'яті — фактично весь діапазон `$4000`–`$7FFF` — є **спірною пам'яттю**. ULA (Uncommitted Logic Array), яка генерує відеосигнал, повинна зчитувати цю пам'ять для малювання екрану. Процесор та ULA ділять одну шину пам'яті, і коли обидва хочуть зчитувати одночасно, ULA перемагає. Процесор змушений чекати.

Протягом 192 активних рядків розгортки кожен доступ процесора до діапазону `$4000`–`$7FFF` потенційно затримується. Затримка слідує повторюваному 8-тактовому патерну: 6, 5, 4, 3, 2, 1, 0, 0 додаткових тактів очікування, що циклічно повторюються впродовж кожного рядка. Інструкція, яка мала б зайняти 7 тактів, може зайняти 13, якщо потрапить на найгіршу фазу циклу конфлікту.

Це робить підрахунок тактів на оригінальних Spectrum'ах кошмаром. Твій ретельно вирахуваний внутрішній цикл працює з різною швидкістю залежно від того, де у кадрі він виконується та чи код або дані, до яких він звертається, потрапляють у спірний діапазон. Introspec задокументував це у своїх статтях "GO WEST" на Hype (2015): під час рендерингу екрану кожен байтовий доступ до спірної пам'яті коштує в середньому 2,625 додаткових тактів. Для стекових операцій, що пишуть в екранну пам'ять, очікуй приблизно 1,3 додаткових такти на байт.

### Pentagon: Чисті такти

Pentagon 128, найпопулярніший радянський клон ZX Spectrum, обрав інший підхід. Його розробники надали ULA власне вікно доступу до пам'яті, яке не конфліктує з процесором. **На Pentagon немає спірної пам'яті.** Кожна інструкція займає рівно стільки тактів, скільки зазначено в документації, незалежно від того, де розташований код і до якої пам'яті він звертається.

Ось чому Pentagon має іншу довжину кадру — 71 680 тактів, 320 рядків розгортки. Тайминги ULA дещо відрізняються, бо немає потреби чергувати доступ процесора та ULA. Але виграш величезний: ти можеш рахувати такти з абсолютною впевненістю. Коли твій внутрішній цикл каже, що він коштує 36 тактів на ітерацію, він коштує 36 тактів на ітерацію кожного разу, в будь-якому місці кадру.

Ці чисті тайминги — причина, чому Pentagon став стандартною платформою для демосцени ZX Spectrum, особливо на теренах колишнього СРСР, де ці клони були повсюдними. Коли ти дивишся демо від груп на кшталт X-Trade, 4th Dimension чи Life on Mars, вони переважно розраховані на тайминги Pentagon. Коли Introspec писав свій легендарний технічний аналіз Illusion від X-Trade, підрахунки тактів, які він наводив, передбачали Pentagon.

Для навчання модель Pentagon ідеальна: ти можеш зосередитися на розумінні того, скільки коштують інструкції, не турбуючись про ефекти конфлікту. Усі таблиці тактів у цій книзі припускають тайминги Pentagon, якщо не зазначено інше. Коли нам потрібно буде обговорити різницю (а ми обговоримо, у розділі 15), ми будемо чіткими.

**Практичне правило:** розміщуй свій критичний за часом код у неспірній пам'яті (`$8000`–`$FFFF` на 48K), і підрахунки тактів будуть коректні і на Pentagon'ах, і на оригінальних Spectrum'ах.

---

## Мислення бюджетами

Тепер, коли ти знаєш розмір кадру, можна починати арифметику, яка визначає спосіб мислення Z80-демосцени.

Скажімо, ти хочеш заповнити весь екран обчисленим кольором кожен кадр — простий ефект плазми, оновлюючи лише 768 байтів пам'яті атрибутів за адресою `$5800`. На 50 кадрах за секунду потрібно обчислити й записати 768 кольорових значень кожні 71 680 тактів.

Якщо твій внутрішній цикл на кожен байт атрибуту виглядає так:

```z80
    ld   a,c        ; 4T   column index
    add  a,b        ; 4T   add row index (diagonal pattern)
    add  a,d        ; 4T   add frame counter (animation)
    and  7          ; 7T   clamp to 0-7
    ld   (hl),a     ; 7T   write attribute
    inc  hl         ; 6T   next attribute address
                    ; --- 32T per byte
```

Це 32 такти на байт. Для 768 байтів: 32 x 768 = 24 576 тактів. Додай накладні витрати циклу (підтримка лічильників рядків і стовпців, `DJNZ` для внутрішнього циклу), і вийде приблизно 28 000–30 000 тактів. Це залишає понад 40 000 тактів на все інше — відтворення музики, обробку введення, що завгодно.

Але що якби ти хотів оновити кожен *піксельний* байт, усі 6 144? При 32 тактах на байт це 196 608 тактів — майже три кадри. Раптом ти дивишся на частоту оновлення 17 кадрів за секунду замість 50. Тобі потрібен або швидший внутрішній цикл, або менша область оновлення, або зовсім інший підхід.

Саме так мислять Z80-програмісти. Кожне дизайнерське рішення починається з арифметики: скільки байтів, скільки тактів на байт, скільки тактів у бюджеті кадру, чи вміщується? Коли не вміщується, ти не тягнешся до швидшої машини — ти тягнешся до розумнішого алгоритму.

---

> **Бічна панель: Agon Light 2**
>
> Agon Light 2 працює на Zilog eZ80 з частотою 18,432 МГц. eZ80 виконує той самий набір інструкцій Z80 (це прямий архітектурний нащадок), але більшість інструкцій виконуються за меншу кількість тактів — багато однобайтових інструкцій завершуються лише за 1 цикл замість 4. На частоті 18,432 МГц із частотою кадрів 50 Гц ти отримуєш приблизно **368 640 тактів на кадр**.
>
> Це трохи більше ніж у 5 разів перевищує бюджет Pentagon. Та сама мова асемблера Z80, ті самі регістри, ті самі мнемоніки інструкцій — але з п'ятикратним простором для маневру. Внутрішній цикл, що споживає 70% кадру Pentagon, може використовувати лише 14% кадру Agon.
>
> Це не робить Agon "легким". Він має свої обмеження: відсутність відеопам'яті у стилі ULA (дисплеєм керує співпроцесор ESP32, що працює з VDP), плоска 24-бітна адресація замість банкованої пам'яті та абсолютно інша модель вводу/виводу. Але якщо ти коли-небудь мріяв мати *трохи більше простору* в бюджеті кадру для чогось амбітного, Agon — це місце, де те саме мислення Z80 масштабується вгору.
>
> Протягом цієї книги ми зауважуватимемо, де більший бюджет Agon змінює розклад. Наразі просто запам'ятай число: **~368 000 тактів**. Той самий набір інструкцій, п'ятикратне полотно.

---

## Практика: Налаштування середовища розробки

Перш ніж ми напишемо нашу першу тестову обв'язку, тобі потрібен робочий набір інструментів. Налаштування, описане тут, відповідає посібнику sq з Hype (2019), який став стандартом спільноти.

### Що тобі потрібно

1. **VS Code** — твій редактор та інтегроване середовище.
2. **Розширення Z80 Macro Assembler** від mborik (`mborik.z80-macroasm`) — підсвічування синтаксису, автодоповнення, розпізнавання символів для асемблера Z80. Встанови з маркетплейсу VS Code.
3. **Z80 Assembly Meter** від Nestor Sancho — показує кількість байтів і тактів для поточно виділеної інструкції (інструкцій) у рядку стану. Це безцінний інструмент. Виділи блок коду й миттєво побач його загальну вартість у тактах.
4. **sjasmplus** — власне асемблер. Кросплатформний, з відкритим кодом, підтримує макроси, скрипти на Lua, безліч форматів виводу. Завантаж з https://github.com/z00m128/sjasmplus і розмісти бінарний файл десь у своєму PATH.
5. **Unreal Speccy** (Windows) або **Fuse** (кросплатформний) — емулятор. Unreal Speccy є кращим для розробки демо, бо він точно емулює тайминги Pentagon та має вбудований зневаджувач.

### Структура проєкту

Створи каталог для своїх експериментів з розділу 1. Мінімальний проєкт виглядає так:

```
ch01/
  main.a80          -- твій вихідний файл
  build.bat         -- (Windows) sjasmplus main.a80
  Makefile           -- (macOS/Linux) мета збирання
```

### Конфігурація збирання

У VS Code налаштуй задачу збирання (`.vscode/tasks.json`), щоб компілювати через Ctrl+Shift+B:

```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Assemble Z80",
      "type": "shell",
      "command": "sjasmplus",
      "args": [
        "--fullpath",
        "--nologo",
        "--msg=war",
        "${file}"
      ],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "problemMatcher": {
        "owner": "z80",
        "fileLocation": "absolute",
        "pattern": {
          "regexp": "^(.*)\\((\\d+)\\):\\s+(error|warning):\\s+(.*)$",
          "file": 1,
          "line": 2,
          "severity": 3,
          "message": 4
        }
      }
    }
  ]
}
```

Натисни Ctrl+Shift+B. Якщо sjasmplus є в твоєму PATH і немає помилок, ти отримаєш файл `.sna` або `.tap` (залежно від директив у вихідному коді), який можна відкрити безпосередньо в емуляторі.

Для інтеграції з Unreal Speccy розширення Alex_Rider'а 2024 року додає прив'язку F5-для-запуску — емулятор відкриває твій скомпільований знімок автоматично. Якщо ти на macOS чи Linux і використовуєш Fuse, просте правило Makefile робить те саме:

```makefile
run: main.sna
	fuse --machine pentagon main.sna
```

---

## Практика: Тестова обв'язка

Це найважливіший інструмент зневадження, який ти побудуєш у цілій книзі. Він гранично простий, не вимагає спеціального обладнання, і ти використовуватимеш його постійно.

Ідея: зміни колір бордюру на червоний безпосередньо перед кодом, який хочеш виміряти, і зміни назад на чорний безпосередньо після. Бордюр Spectrum малюється ULA в реальному часі, синхронно з електронним променем. Ширша червона смуга означає більше тактів, витрачених у твоєму коді.

Ось повна обв'язка:

```z80
    ORG $8000

start:
    ; Wait for the frame interrupt
    halt

    ; --- Border RED: code under test begins ---
    ld   a, 2          ; 7T  red = colour 2
    out  ($FE), a      ; 11T write to border port

    ; ===== CODE UNDER TEST =====
    ; Replace this block with whatever you want to measure.
    ; Example: 256 iterations of a NOP loop.

    ld   b, 0          ; 7T  B=0 wraps to 256 iterations
.loop:
    nop                ; 4T
    nop                ; 4T
    nop                ; 4T
    nop                ; 4T  -- 16T per iteration body
    djnz .loop         ; 13T taken, 8T on final iteration
    ; Total: 256 * (16+13) - 5 = 7,419 T-states

    ; ===== END CODE UNDER TEST =====

    ; --- Border BLACK: idle ---
    xor  a             ; 4T  A=0 (black), shorter than LD A,0
    out  ($FE), a      ; 11T

    ; Loop forever
    jr   start
```

Завантаж це в свій емулятор. Ти побачиш червону смугу на бордюрі. Висота цієї смуги прямо пропорційна кількості тактів, які твій тестовий код спожив.

### Читання смуги

Кожен рядок розгортки займає 224 такти (на Pentagon). Отже, якщо твоя червона смуга має висоту N рядків розгортки, твій код зайняв приблизно N x 224 тактів. Приклад вище використовує близько 7 419 тактів, що становить приблизно 33 рядки — ти маєш побачити червону смугу приблизно на одну шосту висоти бордюру.

Тепер спробуй замінити цикл NOP чимось важчим. Заміни чотири NOP на:

```z80
.loop:
    ld   a,(hl)        ; 7T
    add  a,(hl)        ; 7T
    ld   (de),a        ; 7T
    inc  hl            ; 6T   -- 27T per iteration body
    djnz .loop         ; 13T taken
    ; Total: 256 * (27+13) - 5 = 10,235 T-states
```

Червона смуга помітно зростає. Ця візуальна різниця — ти бачиш її без зневаджувача, без профілювальника, без жодних інструментів — це 2 816 тактів. Приблизно 12 рядків розгортки.

Саме так кодери демо для Spectrum профілювали свої ефекти з 1980-х. Бордюр — це твій осцилограф.

### Варіації

Ти можеш використовувати різні кольори для позначення різних фаз свого коду:

```z80
    ld   a, 2          ; red
    out  ($FE), a
    call render_sprites
    ld   a, 1          ; blue
    out  ($FE), a
    call update_music
    ld   a, 4          ; green
    out  ($FE), a
    call game_logic
    xor  a             ; black
    out  ($FE), a
```

Тепер бордюр показує червону смугу (рендеринг спрайтів), потім синю (музика), потім зелену (ігрова логіка), потім чорну (час простою). Ти бачиш з одного погляду, яка підсистема з'їдає твій бюджет кадру.

Зауваження про `xor a` проти `ld a, 0`: обидва встановлюють A в нуль. `XOR A` займає 4 такти та 1 байт. `LD A, 0` займає 7 тактів та 2 байти. У тестовій обв'язці різниця незначна, але варто помітити — саме така мікро-обізнаність і є суттю програмування на Z80.

---

## Що вміщується в кадр?

Скористаймося нашою бюджетною арифметикою, щоб відповісти на деякі практичні питання.

**Скільки спрайтів можна намалювати за кадр?** Маскований спрайт 16x16 методом OR+AND займає приблизно 16 рядків x (читання маски + читання спрайта + читання екрану + комбінування + запис на екран) на кожен байт. Розумна оцінка — приблизно 1 200 тактів на спрайт. На Pentagon це 71 680 / 1 200 = ~59 спрайтів, якщо рендеринг спрайтів — *єдине*, що ти робиш. На практиці, з музикою, ігровою логікою та всім іншим, 8–12 повних спрайтів за кадр — типове значення.

**Скільки байтів може скопіювати LDIR за кадр?** При 21 такті на байт: 71 680 / 21 = 3 413 байтів. Навіть не половина екрану.

**Скільки операцій множення?** Швидке множення 8x8 через таблицю квадратів займає приблизно 54 такти. 71 680 / 54 = 1 327 множень за кадр. Обертання однієї 3D-точки потребує 9 множень. Отже, ти міг би обертати приблизно 147 точок за кадр, *якщо не робив нічого іншого*. Практична межа з повним рушієм демо: 30–50 точок.

Кожне дизайнерське питання зводиться до цієї арифметики. Чи можу я це зробити? Скільки я можу зробити? Від чого мені доведеться відмовитися, щоб звільнити місце?

---

## Історична замітка: Поради Dark'а

У 1997 році програміст на ім'я Dark з групи X-Trade опублікував серію статей у *Spectrum Expert* #01, російському електронному журналі для розробників ZX Spectrum. Ці статті охоплювали множення, ділення, генерацію синуса/косинуса та алгоритми малювання ліній на асемблері Z80 — фундаментальні будівельні блоки, що живлять кожен демо-ефект.

Dark відкрив таким зверненням:

> "Прочитайте підручник з математики — похідні, інтеграли. Знаючи їх, ви зможете створити таблицю практично будь-якої функції в асемблері."

Це була не порожня теорія. Dark був не просто автором — він був кодером. Демо X-Trade *Illusion*, випущене на ENLiGHT'96, містило текстуровану сферу, що обертається, ротозумер, 3D-рушій та скролер з точками, що підстрибують, — і все це працювало на Z80 з частотою 3,5 МГц. Алгоритми, які Dark описував у своїх журнальних статтях, були тими самими алгоритмами, що живили ефекти його демо.

Двадцять років потому Introspec (spke) опублікував детальний технічний аналіз Illusion на Hype, аналізуючи внутрішні цикли інструкція за інструкцією, рахуючи кожен такт. Журнальні статті 1997 року та зворотна інженерія 2017 року розповідають ту саму історію з обох боків: автор пояснює свої будівельні блоки, а колега вимірює готову машину. Ми прослідкуємо цю нитку протягом усієї книги.

Порада Dark'а актуальна й досі: математика не опціональна. Тобі не потрібен диплом математика, але потрібно розуміти, як перетворити математичну функцію в таблицю, як апроксимувати дорогі операції дешевими та як мислити в категоріях похибки проти швидкості. Розділ 4 детально розбере алгоритми Dark'а. Наразі запам'ятай його пораду. Це точка відліку для всього.

---

## Обчислювальна схема

Introspec, описуючи, що робить демо-ефект хорошим, дистилював філософію в одне речення:

> "Кодерські ефекти — це завжди про еволюцію обчислювальної схеми."

Це найглибше прозріння у цьому розділі. Демо-ефект — це не картинка; це *процес*. Кожен кадр обчислювальна схема породжує наступний стан з попереднього. Мистецтво полягає у виборі схеми, яка створює візуально привабливу еволюцію, вміщуючись у бюджет кадру.

Плазма — це обчислювальна схема: сума синусоїд у кожній позиції сітки зі зсувом за часом. Тунель — це обчислювальна схема: пошук кута й відстані з попередньо обчислених таблиць зі зсувом за часом. Обертовий 3D-об'єкт — це обчислювальна схема: множення координат вершин на матрицю обертання, яка змінюється кожен кадр. Конкретна схема визначає візуальний результат, вартість у тактах і вимоги до пам'яті — все одночасно, все взаємопов'язано.

Коли ти сідаєш писати ефект, ти питаєш не "як мені намалювати цю картинку". Ти питаєш "яке обчислення, еволюціонуючи кадр за кадром, породить цей візуал?" Ця зміна мислення — від зображення до процесу, від результату до схеми — це світогляд Z80-програміста.

І перше обмеження будь-якої схеми — це бюджет. 71 680 тактів. Чи зможеш ти еволюціонувати своє обчислення в межах цього бюджету? Якщо ні, чи можеш ти знайти дешевшу схему, що дає схожий візуал? Чи можеш ти попередньо обчислити частину схеми в таблиці? Чи можеш ти розподілити обчислення на кілька кадрів? Чи можеш ти використати симетрію, щоб обчислити половину екрану й віддзеркалити другу?

Ці питання рухають кожен розділ цієї книги. Вони починаються тут, із підрахунку тактів.

---

## Підсумок

- Кожна інструкція Z80 має конкретну вартість у тактах. Вивчи напам'ять поширені: `NOP` = 4, `LD A,B` = 4, `LD A,(HL)` = 7, `PUSH HL` = 11, `LDIR` = 21/16, `OUT (n),A` = 11.
- **Бюджет кадру** — це твоє жорстке обмеження: 69 888 тактів (48K), 70 908 (128K) або 71 680 (Pentagon). На 50 кадрах за секунду все має вміститися.
- **Pentagon не має спірної пам'яті**, що робить підрахунок тактів надійним і передбачуваним. Ось чому він став стандартом демосцени.
- **Agon Light 2** (eZ80 @ 18,432 МГц) дає ~368 000 тактів на кадр — той самий набір інструкцій, п'ятикратний простір.
- **Тестова обв'язка з кольором бордюру** — це твій осцилограф: червоний перед кодом, чорний після, читай ширину смуги.
- Програмування на Z80 — це **бюджетна арифметика**: байти x тактів на байт проти бюджету кадру. Кожне дизайнерське рішення починається тут.
- Ефекти — це **обчислювальні схеми, що еволюціонують у часі**. Мистецтво — знайти схему, яка вміщується в бюджет і гарно виглядає.

---

## Спробуй сам

1. Зібери тестову обв'язку з цього розділу. Заміни цикл NOP на `LDIR`, що копіює 256 байтів, і порівняй ширину смуги з NOP-версією. Вирахуй очікувану різницю тактів і перевір її візуально.

2. Напиши цикл, який заповнює всі 768 байтів пам'яті атрибутів (`$5800`–`$5AFF`) одним значенням кольору. Виміряй його обв'язкою. Потім спробуй заповнити за допомогою `LDIR` замість побайтового циклу. Що швидше? На скільки рядків розгортки?

3. Відкрий Z80 Assembly Meter у VS Code. Виділяй різні блоки коду й стеж за лічильником тактів у рядку стану. Звикни перевіряти вартість під час написання.

4. Налаштуй багатокольоровий бордюрний профілювальник (червоний / синій / зелений / чорний) з трьома циклами-заглушками різної довжини. Підбери кількість ітерацій, поки не зможеш візуально розрізнити всі три смуги. Це твоя калібрувальна вправа для читання бордюрних таймінгів.

---

*Далі: Розділ 2 — Екран як головоломка. Ми зануримося у сумнозвісну перемішану розкладку відеопам'яті Spectrum і дізнаємося, чому `INC H` переміщує нас на один піксель вниз.*
