# Розділ 4: Математика, яка справді потрібна

> *"Читай підручник з математики -- похідні, інтеграли. Вони тобі знадобляться."*
> -- Dark, Spectrum Expert #01 (1997)

У 1997 році підліток із Санкт-Петербурга сів писати журнальну статтю про множення. Не те, що вивчають у школі -- те, завдяки якому каркасний куб обертається на ZX Spectrum із швидкістю 50 кадрів на секунду. Його звали Dark, він кодив у групі X-Trade, а його демо *Illusion* вже здобуло перше місце на ENLiGHT'96. Тепер він писав *Spectrum Expert*, електронний журнал, що поширювався на дискетах, і збирався пояснити, як саме працюють його алгоритми.

Те, що далі, взято безпосередньо зі статті Dark'а "Алгоритми програмування" у Spectrum Expert #01. Це підпрограми, на яких працювала *Illusion* -- те саме множення, що обертало вершини, та сама таблиця синусів, що рухала ротозумер, той самий малювальник ліній, що рендерив каркаси з повною частотою кадрів. Коли Introspec дизасемблював *Illusion* двадцять років потому в блозі Hype, він знайшов саме ці алгоритми всередині бінарника.

---

## Множення на Z80

Z80 не має інструкції множення. Кожного разу, коли тобі потрібно A помножити на B -- для матриць обертання, перспективної проєкції, текстурного накладання -- ти мусиш синтезувати це зі зсувів і додавань. Dark подає два методи, і він характерно чесний щодо компромісу між ними.

### Метод 1: Зсув і додавання від молодшого біта

Класичний підхід. Сканування бітів множника від молодшого до старшого. Для кожного встановленого біта -- додавання множеного до акумулятора. Після кожного біта -- зсув акумулятора вправо. Після восьми ітерацій акумулятор містить повний добуток.

Ось множення 8x8 без знаку від Dark'а. Вхід: B помножити на C. Результат в A (старший байт) і C (молодший байт):

```z80
; MULU112 -- 8x8 unsigned multiply
; Input:  B = multiplicand, C = multiplier
; Output: A:C = B * C (16-bit result, A=high, C=low)
; Cost:   196-204 T-states (Pentagon)
;
; From Dark / X-Trade, Spectrum Expert #01 (1997)

mulu112:
    ld   a, 0           ; clear accumulator (high byte of result)
    ld   d, 8           ; 8 bits to process

.loop:
    rr   c              ; shift LSB of multiplier into carry
    jr   nc, .noadd     ; if bit was 0, skip addition
    add  a, b           ; add multiplicand to accumulator
.noadd:
    rra                 ; shift accumulator right (carry into bit 7,
                        ;   bit 0 into carry -- this carry feeds
                        ;   back into C via the next RR C)
    dec  d
    jr   nz, .loop
    ret
```

Вивчи це уважно. Інструкція `RRA` зсуває A вправо, але також виштовхує молодший біт A у прапорець перенесення. На наступній ітерації `RR C` ротує це перенесення у старший біт C. Тож молодші біти добутку поступово збираються в C, а старші накопичуються в A. Після восьми ітерацій повний 16-бітний результат лежить в A:C.

Вартість -- від 196 до 204 тактів залежно від кількості встановлених бітів множника: кожен встановлений біт коштує додатковий `ADD A,B` (4 такти). Приклад у `chapters/ch04-maths/examples/multiply8.a80` показує варіант, що повертає результат в HL.

Для 16x16 із 32-бітним результатом MULU224 Dark'а працює за 730--826 тактів. На практиці демосценові 3D-рушії уникають повних 16x16 множень, тримаючи координати у форматі 8.8 з фіксованою точкою і використовуючи множення 8x8, де можливо.

![Покрокова схема множення 8x8 зсувом і додаванням](illustrations/output/ch04_multiply_walkthrough.png)

### Метод 2: Пошук у таблиці квадратів

Другий метод Dark'а обмінює пам'ять на швидкість, використовуючи алгебраїчну тотожність, яку кожен демосценер рано чи пізно відкриває:

```
A * B = ((A+B)^2 - (A-B)^2) / 4
```

Заздалегідь обчисли таблицю значень n^2/4, і множення стане двома пошуками та відніманням -- приблизно 61 такт, більш ніж утричі швидше за зсув і додавання.

Потрібна 512-байтна таблиця (n^2/4) для n = 0 до 511, вирівняна по сторінці для індексації одним регістром. Таблиця мусить бути 512 байтів, бо (A+B) може досягти 510.

```z80
; MULU_FAST -- Square table multiply
; Input:  B, C = unsigned 8-bit factors
; Output: HL = B * C (16-bit result)
; Cost:   ~61 T-states (Pentagon)
; Requires: sq_table = 512-byte table of n^2/4, page-aligned
;
; A*B = ((A+B)^2 - (A-B)^2) / 4

mulu_fast:
    ld   h, sq_table >> 8  ; high byte of table address
    ld   a, b
    add  a, c              ; A = B + C (may overflow into carry)
    ld   l, a
    ld   e, (hl)           ; look up (B+C)^2/4 low byte
    inc  h
    ld   d, (hl)           ; look up (B+C)^2/4 high byte

    ld   a, b
    sub  c                 ; A = B - C (may go negative)
    jr   nc, .pos
    neg                    ; take absolute value
.pos:
    ld   l, a
    dec  h
    ld   a, e
    sub  (hl)              ; subtract (B-C)^2/4 low byte
    ld   e, a
    inc  h
    ld   a, d
    sbc  a, (hl)           ; subtract (B-C)^2/4 high byte
    ld   d, a

    ex   de, hl            ; HL = result
    ret
```

Компроміс? Dark характерно чесний: **"Обирай: швидкість чи точність."** Таблиця зберігає цілочисельні значення n^2/4, тож є похибка округлення до 0,25 на один пошук. Для великих значень це незначно. Для малих координатних дельт у 3D-обертанні похибка спричиняє видиме тремтіння вершин. Із зсувом і додаванням обертання ідеально плавне.

Для текстурного накладання, плазми, скролерів -- використовуй швидке множення. Для каркасного 3D, де око стежить за окремими вершинами -- залишайся з зсувом і додаванням. Dark це знав, бо пробував обидва варіанти в *Illusion*.

**Генерація таблиці квадратів** -- це одноразова стартова вартість. Dark пропонує використовувати метод похідних: оскільки d(x^2)/dx = 2x, таблицю можна будувати інкрементально, додаючи на кожному кроці лінійно зростаючу дельту. На практиці більшість кодерів обчислюють таблицю в BASIC-завантажувачі або процедурі ініціалізації і йдуть далі.

---

## Ділення на Z80

Ділення на Z80 ще болючіше за множення. Немає інструкції ділення, а алгоритм за своєю природою послідовний -- кожен біт частки залежить від попереднього віднімання. Dark знову подає два методи: точний і швидкий.

### Метод 1: Зсув і віднімання (ділення з відновленням)

Двійкове ділення у стовпчик. Починаємо з обнуленого акумулятора. Діленне зсувається зліва, по одному біту за ітерацію. Пробуємо відняти дільник; якщо вдається -- встановлюємо біт частки. Якщо не вдається -- відновлюємо акумулятор, звідси "ділення з відновленням".

```z80
; DIVU111 -- 8-bit unsigned divide
; Input:  B = dividend, C = divisor
; Output: B = quotient, A = remainder
; Cost:   236-244 T-states (Pentagon)
;
; From Dark / X-Trade, Spectrum Expert #01 (1997)

divu111:
    xor  a               ; clear accumulator (remainder workspace)
    ld   d, 8            ; 8 bits to process

.loop:
    sla  b               ; shift dividend left -- MSB into carry
    rla                  ; shift carry into accumulator
    cp   c               ; try to subtract divisor
    jr   c, .too_small   ; if accumulator < divisor, skip
    sub  c               ; subtract divisor from accumulator
    inc  b               ; set bit 0 of quotient (B was just shifted,
                         ;   so bit 0 is free)
.too_small:
    dec  d
    jr   nz, .loop
    ret                  ; B = quotient, A = remainder
```

`INC B` для встановлення біта частки -- це витончений трюк: B щойно зсунуто вліво через `SLA B`, тож біт 0 гарантовано нуль. `INC B` встановлює його, не зачіпаючи інших бітів -- дешевше, ніж `OR` чи `SET`.

16-бітна версія (DIVU222) коштує 938--1034 тактів. Тисяча тактів на одне ділення. Із бюджетом кадру ~70 000 тактів можна дозволити собі хіба що 70 ділень на кадр -- не роблячи більше нічого. Ось чому демосценові 3D-рушії докладають надзвичайних зусиль, щоб уникнути ділення.

### Метод 2: Логарифмічне ділення

Швидша альтернатива Dark'а використовує таблиці логарифмів:

```
Log(A / B) = Log(A) - Log(B)
A / B = AntiLog(Log(A) - Log(B))
```

Із двома 256-байтними таблицями підстановки -- Log і AntiLog -- ділення стає двома пошуками, відніманням і третім пошуком. Вартість падає приблизно до 50--70 тактів. Для перспективного ділення (ділення на Z, щоб спроєктувати 3D-точки на екран) це радикальна зміна.

**Генерація таблиці логарифмів** -- ось де починається цікаве. Dark пропонує будувати її за допомогою похідних -- тим самим інкрементальним методом, що й таблицю квадратів. Похідна log2(x) дорівнює 1/(x * ln(2)), тож ти накопичуєш дрібні приростки крок за кроком, починаючи від log2(1) = 0 і рухаючись вгору. Константу 1/ln(2) = 1.4427 потрібно масштабувати, щоб вона вмістилася у 8-бітний діапазон таблиці.

І ось де виявляється чесність Dark'а. Вивівши формулу генерації, він намагається обчислити поправковий коефіцієнт для масштабування таблиці і отримує 0.4606. А потім пише -- у опублікованій журнальній статті -- *"Щось тут не сходиться, тому рекомендується написати аналогічне самому."*

Сімнадцятирічний хлопець у 1997 році, публікуючись у дисковому журналі, який читають його ровесники по всій російській Spectrum-сцені, відкрито каже: я це запрацював, але в моєму виведенні є прогалина, розберіться з чистою версією самі. Така чесність рідкісна в технічному письмі будь-якого рівня, і це одна з речей, що робить Spectrum Expert таким визначним документом.

На практиці таблиці логарифмів працюють. Похибки округлення від стиснення неперервної функції у 256 байтів прийнятні для перспективної проєкції. 3D-рушій Dark'а в *Illusion* використовує саме цю техніку.

---

## Синус і косинус

Обертання, скролінг, плазма -- кожен ефект, що вигинається, потребує тригонометрії. На Z80 ти заздалегідь обчислюєш таблицю підстановки. Підхід Dark'а красиво прагматичний: парабола достатньо близька до синусоїди для демосценової роботи.

### Параболічна апроксимація

Половина періоду косинуса, від 0 до pi, вигинається від +1 вниз до -1. Парабола y = 1 - 2*(x/pi)^2 іде майже тим самим шляхом. Максимальна похибка -- близько 5,6% -- жахлива для інженерії, невидима в демо при роздільності 256x192.

Dark генерує 256-байтну знакову таблицю косинуса (-128 до +127), індексовану кутом: 0 = 0 градусів, 64 = 90 градусів, 128 = 180 градусів, 256 обертається на 0. Степінь двійки в періоді означає, що індекс кута обертається природно при 8-бітному переповненні, а косинус стає синусом додаванням 64.

```z80
; Generate 256-byte signed cosine table (-128..+127)
; using parabolic approximation
;
; The table covers one full period: cos(n * 2*pi/256)
; scaled to signed 8-bit range.
;
; Approach: for the first half (0..127), compute
;   y = 127 - (x^2 * 255 / 128^2)
; approximated via incrementing differences.
; Mirror for second half.

gen_cos_table:
    ld   hl, cos_table
    ld   b, 0              ; x = 0
    ld   de, 0             ; running delta (fixed-point)

    ; First quarter: cos descends from +127 to 0
    ; Second quarter: continues to -128
    ; ...build via incremental squared differences

    ; In practice, the generation loop runs ~30 bytes
    ; and produces the table in a few hundred cycles.
```

Ключове спостереження: не потрібно обчислювати x^2 для кожного запису. Оскільки (x+1)^2 - x^2 = 2x + 1, параболу будуємо інкрементально -- починаємо з піку, віднімаємо лінійно зростаючу дельту. Без множення, без ділення, без плаваючої точки.

Результат -- кусково-параболічна апроксимація. Побудуй її поруч з істинним синусом -- і ледве побачиш різницю. Для каркасного 3D чи підстрибуючого скролера це більш ніж достатньо.

> **Врізка: 9 заповідей Raider'а щодо таблиць синусів**
>
> В коментарях на Hype під аналізом *Illusion* від Introspec'а, ветеран-кодер Raider залишив список правил проєктування таблиць синусів, який неформально став відомий як "9 заповідей". Ключові принципи:
>
> - Використовуй розмір таблиці, що є степенем двійки (256 записів -- канон).
> - Вирівнюй таблицю по межі сторінки, щоб `H` тримав базу, а `L` -- чистий кут; індексація безкоштовна.
> - Зберігай знакові значення для прямого використання в координатній арифметиці.
> - Дай куту обертатися природно через 8-бітне переповнення -- без перевірки меж.
> - Косинус -- це просто синус, зсунутий на чверть періоду: завантаж кут, додай 64, знайди в таблиці.
> - Якщо потрібна вища точність, використай 16-бітну таблицю (512 байтів), але це рідко потрібно.
> - Генеруй таблицю при запуску, а не зберігай у бінарнику -- економить місце, нічого не коштує.
> - Для 3D-обертання попередньо помнож на масштабний коефіцієнт і зберігай вже масштабовані значення.
> - Ніколи не обчислюй тригонометрію під час виконання. Якщо думаєш, що потрібно -- ти помиляєшся.
>
> Ці заповіді відображають десятиліття колективного досвіду. Дотримуйся їх -- і твої таблиці синусів будуть швидкими, компактними і правильними.

---

## Лінія Брезенхема

Кожне ребро каркасного об'єкта -- це лінія від (x1,y1) до (x2,y2), і тобі потрібно малювати її швидко. Розгляд Dark'а у Spectrum Expert #01 -- найдовша секція його статті, де він проходить через три послідовно швидші підходи.

### Класичний алгоритм і модифікація Xopha

Алгоритм Брезенхема крокує вздовж головної осі по одному пікселю за раз, підтримуючи акумулятор похибки для кроків по другорядній осі. На Spectrum "поставити піксель" -- дорого: черезрядкова розкладка екранної пам'яті означає, що обчислення адреси байта і позиції біта коштує реальних тактів. ROM-підпрограма займає понад 1000 тактів на піксель. Навіть оптимізований вручну цикл Брезенхема коштує ~80 тактів на піксель.

Dark згадує покращення Xopha: підтримувати вказівник на екран (HL) і рухати його інкрементально, а не перераховувати з нуля. Рух вправо -- ротація бітової маски; рух вниз -- багатоінструкційне налаштування DOWN_HL. Краще, але основна проблема залишається.

### Матричний метод Dark'а: сітки пікселів 8x8

Тоді Dark робить своє ключове спостереження: **"87,5% перевірок витрачаються даремно."**

У циклі Брезенхема на кожному пікселі ти питаєш: чи варто зробити бічний крок? Для майже горизонтальної лінії відповідь майже завжди "ні". В середньому сім із восьми перевірок не дають бічного кроку. Ти спалюєш такти на умовному переході, який майже ніколи не спрацьовує.

Рішення Dark'а: заздалегідь обчислити піксельний патерн для кожного нахилу лінії в межах сітки пікселів 8x8 і розгорнути цикл малювання, щоб виводити цілі клітинки сітки за раз. Сегмент лінії в межах 8x8 ділянки повністю визначається нахилом. Для кожного з восьми октантів перераховуються всі можливі 8-піксельні патерни як прямі послідовності інструкцій `SET bit,(HL)` із зсувами адреси між ними.

```z80
; Example: one unrolled 8-pixel segment of a nearly-horizontal line
; (octant 0: moving right, gently sloping down)
;
; The line enters at the left edge of an 8x8 character cell
; and exits at the right edge, dropping one pixel row partway through.

    set  7, (hl)        ; pixel 0 (leftmost bit in byte)
    set  6, (hl)        ; pixel 1
    set  5, (hl)        ; pixel 2
    set  4, (hl)        ; pixel 3
    set  3, (hl)        ; pixel 4
    ; --- step down one pixel row ---
    inc  h              ; next screen row (within character cell)
    set  2, (hl)        ; pixel 5
    set  1, (hl)        ; pixel 6
    set  0, (hl)        ; pixel 7 (rightmost bit in byte)
```

Без умовних переходів. Без акумулятора похибки. `SET bit,(HL)` займає 15 тактів; вісім таких інструкцій плюс пара `INC H` дають ~130 тактів на 8-піксельний сегмент, або приблизно 16 тактів на піксель. З урахуванням пошуку і зсуву клітинки Dark досягає приблизно **48 тактів на піксель** -- майже вдвічі менше за класичну вартість Брезенхема.

Ціна -- пам'ять: окрема розгорнута підпрограма для кожного нахилу в кожному октанті, загалом приблизно **3 КБ**. На 128K Spectrum -- помірна інвестиція заради величезного приросту швидкості.

### Завершення пасткою

Замість перевірки лічильника циклу на кожному пікселі Dark ставить вартового там, де лінія закінчується. Коли код малювання натикається на вартового, він виходить -- повністю усуваючи накладні витрати `DEC counter / JR NZ`.

Повна система -- вибір октанта, пошук сегмента, розгорнуте малювання, завершення пасткою -- один із найвражаючих фрагментів коду в Spectrum Expert #01. Коли Introspec дизасемблував *Illusion* у 2017 році, він знайшов цей матричний метод за роботою, що малює каркаси з повною частотою кадрів.

---

## Арифметика з фіксованою точкою

Кожен алгоритм у цьому розділі передбачає щось, що ми ще не зробили явним: числа з фіксованою точкою.

Z80 не має блоку обчислень з плаваючою точкою. Кожен регістр зберігає ціле число. Але демо-ефекти потребують дробових значень -- кутів обертання, субпіксельних швидкостей, масштабних коефіцієнтів. Рішення -- фіксована точка: обери конвенцію, де "десяткова крапка" лежить всередині цілого числа, а потім роби всю арифметику з цілими числами, подумки відстежуючи масштабування.

### Формат 8.8

Найпоширеніший формат на Z80 -- **8.8**: старший байт = ціла частина, молодший байт = дробова частина. Одна 16-бітна регістрова пара зберігає одне число з фіксованою точкою:

```
H = ціла частина    (-128..+127 знакове, або 0..255 беззнакове)
L = дробова частина  (0..255, що відповідає 0/256 до 255/256)
```

`HL = $0180` відповідає 1.5 (H=1, L=128, а 128/256 = 0.5). `HL = $FF80` знакове -- це -0.5 (H=$FF = -1 у доповнювальному коді, L=$80 додає 0.5).

Краса: **додавання і віднімання безкоштовні** -- просто звичайні 16-бітні операції:

```z80
; Fixed-point 8.8 addition: result = a + b
; HL = first operand, DE = second operand
    add  hl, de          ; that's it. 11 T-states.

; Fixed-point 8.8 subtraction: result = a - b
    or   a               ; clear carry
    sbc  hl, de          ; 15 T-states.
```

Процесору байдуже, що ти трактуєш ці числа як фіксовану точку. Двійкове додавання однакове незалежно від того, чи біти відповідають цілим числам, чи значенням 8.8.

### Множення з фіксованою точкою

Множення двох чисел 8.8 дає результат 16.16 -- 32 біти. Тобі потрібно назад 8.8, тож беремо біти 8..23 добутку (фактично зсув вправо на 8). На практиці, з малими цілими частинами (координати, коефіцієнти обертання між -1 і +1), можна розкласти множення на часткові добутки:

```z80
; Fixed-point 8.8 multiply (simplified)
; Input:  BC = first operand (B.C in 8.8)
;         DE = second operand (D.E in 8.8)
; Output: HL = result (H.L in 8.8)
;
; Full product = BC * DE (32 bits), we want bits 8..23
;
; Decomposition:
;   BC * DE = (B*256+C) * (D*256+E)
;           = B*D*65536 + (B*E + C*D)*256 + C*E
;
; In 8.8 result (bits 8..23):
;   H.L = B*D*256 + B*E + C*D + (C*E)/256
;
; For small B,D (say -1..+1), B*D*256 is the dominant term.
; C*E/256 is a rounding correction.
; Total cost: ~200 T-states using the shift-and-add multiplier.

fixmul88:
    ; Multiply B*E -> add to result high
    ld   a, b
    call mul8             ; A = B*E (assuming 8x8->8 truncated)
    ld   h, a

    ; Multiply C*D -> add to result
    ld   a, c
    ld   b, d
    call mul8             ; A = C*D
    add  a, h
    ld   h, a

    ; For higher precision, also compute B*D and C*E
    ; and combine. In practice, the two middle terms
    ; are often sufficient for demo work.

    ld   l, 0             ; fractional part (approximate)
    ret
```

Для обертання, керованого таблицею синусів, де значення синуса -- 8-бітні знакові (-128 до +127, що відповідають -1.0 до +0.996), множення 8-бітної координати на значення синуса через `mulu112` дає 16-бітний результат уже у форматі 8.8 -- старший байт є обернутою цілочисельною координатою, молодший байт -- дробом.

### Чому фіксована точка важлива

Формат 8.8 -- це оптимальний баланс для Z80: вміщується в регістрову пару, додавання/віднімання безкоштовні, множення коштує ~200 тактів, і точність достатня для ефектів з екранною роздільністю. Існують інші формати -- 4.12 для більшої дробової точності, 12.4 для більшого цілочисельного діапазону -- але 8.8 покриває переважну більшість випадків. Розділи з розробки ігор далі в цій книзі використовують виключно 8.8.

---

## Теорія і практика

Ці алгоритми -- не ізольовані техніки. Вони утворюють систему. Множення живить матрицю обертання. Обертання видає координати, що потребують перспективного ділення. Ділення використовує таблиці логарифмів. Спроєктовані вершини з'єднуються лініями, що малюються матричним методом. Усе це працює на арифметиці з фіксованою точкою, із значеннями синуса з параболічної таблиці.

Dark проєктував їх як компоненти єдиного рушія -- рушія, що живив *Illusion*. Каркасний куб, що обертається з повною частотою кадрів, задіює кожну підпрограму з цього розділу:

1. **Читання кута обертання** з таблиці синусів (параболічна апроксимація, ~20 тактів на пошук)
2. **Множення** координат вершин на коефіцієнти обертання (зсув і додавання для точності або таблиця квадратів для швидкості -- ~200 або ~60 тактів на множення, 12 множень на вершину)
3. **Ділення** на Z для перспективної проєкції (таблиці логарифмів, ~60 тактів на ділення)
4. **Малювання ліній** між спроєктованими вершинами (матричний Брезенхем, ~48 тактів на піксель)

Для простого куба (8 вершин, 12 ребер) загальна вартість на кадр приблизно:

- Обертання: 8 вершин x 12 множень x 200 тактів = 19 200 тактів
- Проєкція: 8 вершин x 1 ділення x 60 тактів = 480 тактів
- Малювання ліній: 12 ребер x ~40 пікселів x 48 тактів = 23 040 тактів
- **Разом: ~42 720 тактів** -- вільно вкладається у ~70 000-тактний бюджет кадру

Переключися на швидке табличне множення -- і обертання падає до 5 760 тактів. Вершини трохи тремтять, але тепер маєш запас для складніших об'єктів. Швидкість чи точність -- у демо ти робиш цей вибір для кожного ефекту, кожного кадру.

---

## Що Dark зробив правильно

Озираючись на Spectrum Expert #01 через майже тридцять років, вражає не лише якість алгоритмів, а й якість мислення. Dark подає кожен алгоритм, чесно пояснює компроміси, визнає, коли його виведення має прогалини, і довіряє читачеві заповнити ці прогалини.

Він писав для Spectrum-кодерів у Росії наприкінці 1990-х -- спільноти, що створювала одні з найвражаючіших 8-бітних демо у світі, на апаратурі, від якої решта світу вже відмовилася. Це будівельні блоки, якими вони користувалися. Коли ти напишеш свій перший 3D-рушій для Spectrum, саме ці підпрограми зроблять це можливим.

У наступному розділі Dark і STS розширюють цю математичну основу до повноцінної 3D-системи: метод середньої точки для інтерполяції вершин, відсікання задніх граней і рендеринг суцільних полігонів. Математика тут -- фундамент. Розділ 5 -- це архітектура, побудована на ньому.

---

## Випадкові числа: Коли таблиці не годяться

Усе, що було в цьому розділі досі, -- детерміновано. За тих самих входів те саме множення, той самий пошук у синусній таблиці, те саме малювання лінії -- дадуть той самий вихід. Саме це потрібно для обертання каркасного куба чи плавної плазми.

Але іноді потрібен хаос. Зірки, що мерехтять у зоряному полі. Частинки, що розлітаються від вибуху. Шумові текстури для генерації рельєфу. Перемішаний порядок завантажувальних екранів. У змаганнях із sizecoding (256 байтів або менше) хороший генератор псевдовипадкових чисел може створити напрочуд складні візуальні ефекти майже без коду.

Z80 не має апаратного генератора випадкових чисел. Доведеться синтезувати випадковість з арифметики, і якість цієї арифметики важливіша, ніж може здатися.

### Трюк з регістром R

Z80 має вбудоване джерело ентропії, до якого багато кодерів тягнуться першим: регістр R. Він автоматично збільшується з кожною вибіркою інструкції (кожен цикл M1), циклічно проходячи значення 0--127. Прочитати його можна за 9 тактів:

```z80
    ld   a, r              ; 9 T -- read refresh counter
```

Це *не* ГПВЧ. Регістр R повністю детермінований -- він зростає на одиницю з кожною інструкцією, і його значення в будь-якій точці залежить виключно від шляху виконання коду з моменту скидання. У демо з фіксованим основним циклом R видає ту саму послідовність щоразу. Але він корисний як джерело для ініціалізації: прочитай R один раз при запуску (коли час залежить від того, скільки користувач чекав перед натисканням клавіші) і подай це непередбачуване значення у справжній ГПВЧ.

Деякі кодери підмішують R у генератор при кожному виклику, додаючи справжню ентропію від таймінгу інструкцій. Генератор Ion нижче використовує саме цей трюк.

### Чотири генератори зі спільноти

У 2024 році Gogin (з російської ZX-сцени) зібрав колекцію Z80 ГПВЧ-підпрограм і поділився ними для оцінки. Gogin протестував їх систематично, заповнюючи великі растрові зображення для виявлення статистичних патернів. Результати повчальні -- не всі "випадкові" підпрограми однаково випадкові.

Ось чотири генератори з тієї колекції, впорядковані від найкращої до найгіршої якості.

#### CMWC-генератор Патріка Рака (Найкраща якість)

Це генератор **Complement Multiply-With-Carry** від Патріка Рака, що використовує множник 253 і 8-байтний циклічний буфер. Математика за CMWC добре вивчена: Джордж Марсалья довів, що певні комбінації множника і буфера дають послідовності з величезними періодами. Із множником 253 і розміром буфера 8 теоретичний період становить (253^8 - 1) / 254 -- приблизно 2^66 значень до повторення.

```z80
; Patrik Rak's CMWC PRNG
; Quality: Excellent -- passes visual bitmap tests
; Size:    ~30 bytes code + 8 bytes table
; Output:  A = pseudo-random byte
; Period:  ~2^66

patrik_rak_cmwc_rnd:
    ld   hl, .table
.smc_idx:
    ld   bc, 0              ; 10 T -- i (self-modifying)
    add  hl, bc             ; 11 T
    ld   a, c               ; 4 T
    inc  a                  ; 4 T
    and  7                  ; 7 T -- wrap index to 0-7
    ld   (.smc_idx+1), a    ; 13 T -- store new index
    ld   c, (hl)            ; 7 T -- y = q[i]
    ex   de, hl             ; 4 T
    ld   h, c               ; 4 T -- t = 256 * y
    ld   l, b               ; 4 T
    sbc  hl, bc             ; 15 T -- t = 255 * y
    sbc  hl, bc             ; 15 T -- t = 254 * y
    sbc  hl, bc             ; 15 T -- t = 253 * y
.smc_car:
    ld   c, 0               ; 7 T -- carry (self-modifying)
    add  hl, bc             ; 11 T -- t = 253 * y + c
    ld   a, h               ; 4 T
    ld   (.smc_car+1), a    ; 13 T -- c = t / 256
    ld   a, l               ; 4 T -- x = t % 256
    cpl                     ; 4 T -- x = ~x (complement)
    ld   (de), a            ; 7 T -- q[i] = x
    ret                     ; 10 T

.table:
    DB   82, 97, 120, 111, 102, 116, 20, 12
```

Алгоритм множить поточний запис буфера на 253, додає значення перенесення, зберігає нове перенесення і доповнює результат. 8-байтний циклічний буфер означає, що простір станів генератора величезний -- 8 байтів буфера плюс 1 байт перенесення плюс індекс, що дає набагато більше внутрішнього стану, ніж будь-який однорегістровий генератор.

Вердикт Gogin'а: **найкраща якість** у колекції. При заповненні растрового зображення 256x192 видимих патернів не виникає навіть у великих масштабах.

#### Ion Random (Друге місце)

Спочатку з Ion Shell для калькулятора TI-83, адаптований для Z80. Цей генератор змішує регістр R із зворотним зв'язком, досягаючи напрочуд гарної випадковості всього з ~15 байтів:

```z80
; Ion Random
; Quality: Good -- minor patterns visible only at extreme scale
; Size:    ~15 bytes
; Output:  A = pseudo-random byte
; Origin:  Ion Shell (TI-83), adapted for Z80

ion_rnd:
.smc_seed:
    ld   hl, 0              ; 10 T -- seed (self-modifying)
    ld   a, r               ; 9 T -- read refresh counter
    ld   d, a               ; 4 T
    ld   e, (hl)            ; 7 T
    add  hl, de             ; 11 T
    add  a, l               ; 4 T
    xor  h                  ; 4 T
    ld   (.smc_seed+1), hl  ; 16 T -- update seed
    ret                     ; 10 T
```

Вприскування регістра R означає, що цей генератор видає різні послідовності залежно від контексту виклику -- кількість інструкцій, виконаних між викликами, впливає на R, який подається назад у стан. Для демо-основного циклу з фіксованим таймінгом R зростає передбачувано, але нелінійне змішування (ADD + XOR) все одно дає хороший результат. У грі, де введення гравця змінює патерн викликів, внесок R додає справжню непередбачуваність.

Вердикт Gogin'а: **друге місце**. Дуже компактний, хороша якість для свого розміру.

#### XORshift 16-біт (Посередній)

16-бітний генератор XORshift -- адаптація Z80 для добре відомого сімейства Марсальї:

```z80
; 16-bit XORshift PRNG
; Quality: Mediocre -- visible diagonal patterns in bitmap tests
; Size:    ~25 bytes
; Output:  A = pseudo-random byte (H or L)
; Period:  65535

xorshift_rnd:
.smc_state:
    ld   hl, 1              ; 10 T -- state (self-modifying, must not be 0)
    ld   a, h               ; 4 T
    rra                     ; 4 T
    ld   a, l               ; 4 T
    rra                     ; 4 T
    xor  h                  ; 4 T
    ld   h, a               ; 4 T
    ld   a, l               ; 4 T
    rra                     ; 4 T
    ld   a, h               ; 4 T
    rra                     ; 4 T
    xor  l                  ; 4 T
    ld   l, a               ; 4 T
    xor  h                  ; 4 T
    ld   h, a               ; 4 T
    ld   (.smc_state+1), hl ; 16 T -- update state
    ret                     ; 10 T
```

Генератори XORshift швидкі та прості, але з лише 16 бітами стану період становить максимум 65 535. Більш проблематично те, що патерн бітових ротацій створює видимі діагональні смуги, коли вихід відображається на пікселі. Для швидкого зоряного поля чи ефекту частинок це може бути прийнятним. Для чого-небудь, що заповнює великі ділянки екрану "шумом", патерни стають очевидними.

#### Варіант CMWC від Raxoft (Посередній)

Варіант CMWC від Raxoft, подібний за принципом до версії Патріка Рака, але з іншим розташуванням буфера. Gogin виявив, що він дає **видимі патерни у великому масштабі** -- ймовірно, через те, як поширення перенесення взаємодіє з індексацією буфера. Ми включаємо його в компільований приклад (`examples/prng.a80`) для повноти, але для продакшн-використання версія Патріка Рака однозначно краща.

### Підхід Tribonacci від Elite

Варто коротко згадати: легендарна *Elite* (1984) використовувала послідовність, подібну до Tribonacci, для процедурної генерації галактики. Три регістри живлять один одного по циклу, генеруючи детерміновані, але добре розподілені послідовності. Ключове спостереження -- відтворюваність: за того самого зерна генерується та сама галактика щоразу, а отже вся всесвіт міг "вміститися" у декілька байтів стану генератора. Девід Брабен та Ієн Белл використовували це для генерації 8 галактик по 256 зоряних систем кожна з кількох байтів зерен. Техніка ближча до хеш-функції, ніж до ГПВЧ, але принцип -- малий стан, велика видима складність -- той самий, що рухає демосценовий sizecoding.

### Генератор галактик Elite: Детальніший розгляд

Підхід Tribonacci заслуговує більше деталей, бо ілюструє глибокий принцип: **ГПВЧ -- це не лише джерело випадкових чисел, а й алгоритм стиснення.**

Девіду Брабену та Ієну Беллу потрібні були 8 галактик по 256 зоряних систем, кожна з назвою, позицією, економікою, типом уряду і технологічним рівнем. Зберігання всього цього явно спожило б кілобайти. Натомість вони зберігали лише 6-байтне зерно на галактику і детермінований генератор, що розгортав кожне зерно у повні дані зоряної системи. Генератор був циклом зворотного зв'язку з трьох регістрів -- кожен крок ротує і XOR-ує три 16-бітних значення:

```
; Elite's galaxy generator (conceptual, 6502 origin):
;   seed = [s0, s1, s2]  (three 16-bit words)
;   twist: s0' = s1, s1' = s2, s2' = s0 + s1 + s2  (mod 65536)
;   repeat twist for each byte of star system data
```

На Z80 той самий принцип працює з трьома парами регістрів. Операція "twist" генерує детерміновані, але добре розподілені значення. Важлива властивість: за того самого зерна генерується та сама галактика щоразу. Навігація між зірками -- це просто перезадання зерна й перегенерація.

Ця ідея -- **малий стан, велика видима складність** -- рухає демосценовий sizecoding теж. 256-байтне інтро, що заповнює екран вигадливими візерунками, робить саме те, що робила Elite: розгортає крихітне зерно у великий, складний вихід через детермінований процес.

### Формована випадковість

Іноді потрібні числа, що є випадковими, але слідують певному розподілу. Плоский рівномірний ГПВЧ дає кожному значенню однакову ймовірність, але реальні явища рідко рівномірні: частоти появи ворогів, швидкості частинок, висоти рельєфу -- все це тяжіє до групування навколо бажаних значень.

Поширені трюки на Z80:

- **Трикутний розподіл** -- додай два рівномірно випадкових байти і зсунь вправо. Сума кластеризується навколо центру (128), даючи "природно виглядаючу" варіацію. Вартість: два виклики ГПВЧ + ADD + SRL = ~20 додаткових тактів.

```z80
; Triangular random: result clusters around 128
    call patrik_rak_cmwc_rnd  ; A = uniform random
    ld   b, a
    call patrik_rak_cmwc_rnd  ; A = another uniform random
    add  a, b                 ; sum (wraps at 256)
    rra                       ; divide by 2 → triangular distribution
```

- **Вибірка з відхиленням** -- генеруй випадкове число, відхиляй значення поза бажаним діапазоном. Для діапазонів, що є степенем двійки, це безкоштовно (просто AND із маскою). Для довільних діапазонів -- зациклюй, поки значення не влізе.

- **Зважені таблиці** -- зберігай 256-байтну таблицю підстановки, де кожне вихідне значення з'являється пропорційно до бажаної ймовірності. Індексуй рівномірно випадковим байтом. Таблиця коштує 256 байтів, але пошук миттєвий (7 тактів). Ідеально, коли розподіл складний і фіксований.

- **ГПВЧ як хеш-функція** -- подавай структуровані дані (координати, номери кадрів) через ГПВЧ для отримання детермінованого шуму. Саме так працюють плазма та шумові текстури в sizecoding: `random(x XOR y XOR frame)` дає різноманітне значення для кожного пікселя кожного кадру, але при цьому повністю відтворюване.

### Зерна та відтворюваність

У демо відтворюваність зазвичай бажана: ефект повинен виглядати однаково щоразу, бо кодер хореографував візуали під музику. Задай зерно ГПВЧ один раз фіксованим значенням -- і послідовність детермінована.

У грі важлива непередбачуваність. Поширені стратегії задання зерна:

- **Системна змінна FRAMES ($5C78)** -- ROM Spectrum підтримує 3-байтний лічильник кадрів за адресою $5C78, що зростає кожну 1/50-ту секунди від увімкнення. Читання його дає залежне від часу зерно, що змінюється залежно від того, скільки машина працює. Art-top рекомендує використовувати його для ініціалізації CMWC-таблиці Патріка Рака:

```z80
; Seed Patrik Rak CMWC from FRAMES system variable
    ld   hl, $5C78            ; FRAMES (3 bytes, increments at 50 Hz)
    ld   a, (hl)              ; low byte -- most variable
    ld   de, patrik_rak_cmwc_rnd.table
    ld   b, 8
.seed_loop:
    xor  (hl)                 ; mix with FRAMES
    ld   (de), a              ; write to table
    inc  de
    rlca                      ; rotate for variety
    add  a, b                 ; add loop counter
    djnz .seed_loop
```

- **Читання R у момент користувацького вводу** -- точна кількість інструкцій між скиданням і натисканням клавіші гравцем різниться щоразу. `LD A,R` у цей момент захоплює ентропію таймінгу.
- **Накопичення лічильника кадрів** -- XOR-уй регістр R в акумулятор кожен кадр під час титульного екрану; використовуй накопичене значення як зерно при старті гри.
- **Комбінування кількох джерел** -- XOR-уй разом R, молодший байт FRAMES та байт з "плаваючої шини" (на 48K Spectrum при читанні певних портів повертається те, що ULA якраз витягує з RAM -- джерело позиційної ентропії).

Для демо просто ініціалізуй стан генератора відомим значенням і залиш його. Компільований приклад (`examples/prng.a80`) показує всі чотири генератори з фіксованими зернами.

### Порівняльна таблиця

| Алгоритм | Розмір (байти) | Швидкість (такти) | Якість | Період | Примітки |
|-----------|-------------|-------------------|---------|--------|-------|
| Patrik Rak CMWC | ~30 + 8 таблиця | ~170 | Відмінна | ~2^66 | Найкращий загалом; 8-байтний буфер |
| Ion Random | ~15 | ~75 | Добра | Залежить від R | Компактний; змішує регістр R |
| XORshift 16 | ~25 | ~90 | Посередня | 65 535 | Видимі діагональні патерни |
| Raxoft CMWC | ~35 + 10 таблиця | ~180 | Посередня | ~2^66 | Патерни видимі у великому масштабі |
| LD A,R одна | 2 | 9 | Слабка | 128 | НЕ є ГПВЧ; використовуй лише як зерно |

Для більшості демосценової роботи **CMWC Патріка Рака** -- беззаперечний переможець: відмінна якість, розумний розмір і період настільки довгий, що ніколи не повториться під час демо. Якщо критичний розмір коду (sizecoding, 256-байтні інтро), **Ion Random** вміщує чудову якість у 15 байтів. XORshift -- запасний варіант, коли потрібно щось швидке і не важлива візуальна якість.

> **Подяки:** Колекцію ГПВЧ, оцінку якості та растрове тестування — **Gogin**. CMWC-генератор Патріка Рака базується на теорії Complementary Multiply-With-Carry Джорджа Марсальї. Ion Random походить з **Ion Shell** для калькулятора TI-83.

---

*Усі підрахунки тактів у цьому розділі -- для Pentagon (без станів очікування). На стандартному 48K Spectrum чи Scorpion із спірною пам'яттю розраховуй на більші значення для коду, що виконується у нижніх 32K RAM. Повна таблиця таймінгів -- у Додатку A.*
