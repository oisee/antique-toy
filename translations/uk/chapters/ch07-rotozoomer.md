# Розділ 7: Ротозумер і чанкі-пікселі

> *"Трюк у тому, що ти не обертаєш екран. Ти обертаєш свій прохід по текстурі."*
> -- перефразування ключової ідеї, що стоїть за кожним ротозумером

---

Є момент в Illusion, коли екран заповнюється патерном — текстурою, монохромною, що повторюється — і потім вона починає обертатися. Обертання плавне і безперервне, зум дихає туди-сюди, і все це йде в такому темпі, що забуваєш, що дивишся, як Z80 штовхає пікселі на 3,5 МГц. Це не найтехнічніший ефект у демо. Сфера (Розділ 6) складніша математично. Скролер з точкового поля (Розділ 10) щільніший за тактовим бюджетом. Але ротозумер — це той, що виглядає невимушено, а на Spectrum зробити щось невимушеним — найважчий трюк з усіх.

Цей розділ простежує два потоки. Перший — аналіз Introspec'а 2017 року ротозумера з Illusion від X-Trade. Другий — стаття sq 2022 року на Hype про оптимізацію чанкі-пікселів, яка доводить підхід до 4x4 пікселів і каталогізує сімейство стратегій рендерингу з точними підрахунками тактів. Разом вони відображають простір проектування: як працюють чанкі-пікселі, як їх використовують ротозумери, і які компроміси продуктивності визначають, чи твій ефект біжить з 4 кадрів на екран чи з 12.

---

## Що насправді робить ротозумер

Ротозумер відображає 2D-текстуру, повернуту на деякий кут і масштабовану з деяким коефіцієнтом. Наївний підхід: для кожного екранного пікселя обчислити відповідну текстурну координату через тригонометричне обертання:

```
    tx = sx * cos(theta) * scale  +  sy * sin(theta) * scale  +  offset_x
    ty = -sx * sin(theta) * scale  +  sy * cos(theta) * scale  +  offset_y
```

При 256x192 це 49 152 пікселі, кожному з яких потрібні два множення. Навіть з множенням через таблицю квадратів на 54 такти (Розділ 4), ти перевищуєш п'ять мільйонів тактів — приблизно 70 кадрів процесорного часу. Ефект математично тривіальний і обчислювально неможливий.

Ключова ідея в тому, що перетворення *лінійне*. Рух на один піксель вправо на екрані завжди додає однакове (dx, dy) до текстурних координат. Рух на один піксель вниз завжди додає однакове (dx', dy'). Попіксельна вартість схлопується з двох множень до двох додавань:

```
Step right:   dx = cos(theta) * scale,   dy = -sin(theta) * scale
Step down:    dx' = sin(theta) * scale,  dy' = cos(theta) * scale
```

Почни кожен рядок з правильної текстурної координати і крокуй на (dx, dy) для кожного пікселя. Внутрішній цикл стає: зчитай тексель, просунься на (dx, dy), повтори. Два додавання на піксель, жодних множень. Підготовка на кадр — чотири множення для обчислення крокових векторів з поточного кута та масштабу. Все інше випливає з лінійності.

Це фундаментальна оптимізація за кожним ротозумером на будь-якій платформі. На Amiga, на PC, на Spectrum.

---

## Чанкі-пікселі: Обмін роздільності на швидкість

Навіть при двох додаваннях на піксель, записати 6 144 байти в черезрядкову відеопам'ять Spectrum за кадр непрактично — не якщо ти також хочеш оновити кут і залишити час для музики. Чанкі-пікселі вирішують це, зменшуючи ефективну роздільність. Замість одного текселя на екранний піксель, ти відображаєш один тексель на блок 2x2, 4x4 або 8x8.

Illusion використовує чанкі-пікселі 2x2: ефективна роздільність 128x96, зменшення роботи в 4 рази. Ефект виглядає блочним зблизька, але на тій швидкості, з якою текстура пролітає по екрану, рух приховує грубість. Око пробачає низьку роздільність, коли все рухається.

Кодування розроблене для внутрішнього циклу. Кожен чанкі-піксель зберігається як `$03` (увімкнений) або `$00` (вимкнений). Чому `$03`? Тому що `ADD A,A` двічі зсуває його вліво на 2 позиції, і потім `ADD A,(HL)` злиає наступний `$03` пікселя в молодші біти. Чотири чанкі-пікселі об'єднуються в один вихідний байт, використовуючи лише зсуви та додавання — без маскування, без розгалужень, без бітових маніпуляцій.

---

## Внутрішній цикл з Illusion

Дизасемблювання Introspec'а розкриває базову послідовність рендерингу. HL ходить по текстурі; H відстежує одну вісь, а L — іншу:

```z80
; Inner loop: combine 4 chunky pixels into one output byte
    ld   a,(hl)        ;  7T  -- read first chunky pixel ($03 or $00)
    inc  l             ;  4T  -- step right in texture
    dec  h             ;  4T  -- step up in texture
    add  a,a           ;  4T  -- shift left
    add  a,a           ;  4T  -- shift left (now shifted by 2)
    add  a,(hl)        ;  7T  -- add second chunky pixel
```

Послідовність повторюється для третього та четвертого пікселів. `inc l` і `dec h` разом трасують діагональний шлях по текстурі — а діагональний означає повернутий. Конкретна комбінація інструкцій інкременту та декременту визначає кут повороту.

| Крок | Інструкції | Такти |
|------|-------------|----------|
| Зчитати піксель 1 | `ld a,(hl)` | 7 |
| Хід | `inc l : dec h` | 8 |
| Зсув + Зчитати піксель 2 | `add a,a : add a,a : add a,(hl)` | 15 |
| Хід | `inc l : dec h` | 8 |
| Зсув + Зчитати піксель 3 | `add a,a : add a,a : add a,(hl)` | 15 |
| Хід | `inc l : dec h` | 8 |
| Зсув + Зчитати піксель 4 | `add a,a : add a,a : add a,(hl)` | 15 |
| Хід | `inc l : dec h` | 8 |
| Вивід + просування | `ld (de),a : inc e` | ~11 |
| **Разом на байт** | | **~95** |

Introspec виміряв приблизно 95 тактів на 4 чанки.

Критичне спостереження: напрямок ходу жорстко зашитий у потоці інструкцій. Інший кут повороту потребує інших інструкцій. Вісім основних напрямків можливі з використанням комбінацій `inc l`, `dec l`, `inc h`, `dec h` та `nop`. Це означає, що код рендерингу змінюється кожен кадр.

---

## Покадрова генерація коду

Код рендерингу генерується наново кожен кадр, з інструкціями напрямку ходу, пропатченими для поточного кута:

| Діапазон кутів | Крок H | Крок L | Напрямок |
|-------------|--------|--------|-----------|
| ~0 градусів | `nop` | `inc l` | Чисто вправо |
| ~45 градусів | `dec h` | `inc l` | Вправо і вгору |
| ~90 градусів | `dec h` | `nop` | Чисто вгору |
| ~135 градусів | `dec h` | `dec l` | Вліво і вгору |
| ~180 градусів | `nop` | `dec l` | Чисто вліво |
| ~225 градусів | `inc h` | `dec l` | Вліво і вниз |
| ~270 градусів | `inc h` | `nop` | Чисто вниз |
| ~315 градусів | `inc h` | `inc l` | Вправо і вниз |

Для проміжних кутів генератор розподіляє кроки нерівномірно, використовуючи накопичення помилки в стилі Брезенхема. Поворот на 30 градусів чергує `inc l : nop` та `inc l : dec h` приблизно у співвідношенні 2:1, наближаючи тангенс 30 градусів (1,73:1). Результуючий код — розгорнутий цикл, де кожна ітерація має свою специфічну пару ходу, налаштовану на поточний кут.

Вартість рендерингу для 128x96 при чанкі 2x2:

```
16 output bytes/row x 95 T-states = 1,520 T-states/row
1,520 x 96 rows = 145,920 T-states total
```

Приблизно 2 кадри на Pentagon. Оцінка Introspec'а в 4-6 кадрів на екран більш консервативна, з урахуванням генерації коду, переносу буфера та накладних витрат, що накопичуються понад голий внутрішній цикл.

---

## Перенос буфера на екран

Ротозумер рендерить у позаекранний буфер, потім переносить у відеопам'ять. Черезрядкова розкладка екрану робить прямий рендеринг болючим, а буферизація уникає розривів.

Перенос використовує стек:

```z80
    pop  hl                   ; 10T -- read 2 bytes from buffer
    ld   (screen_addr),hl     ; 16T -- write 2 bytes to screen
```

Екранні адреси вбудовані як літеральні операнди, попередньо обчислені для черезрядковості Spectrum — ще один приклад генерації коду. При 26 тактах на два байти повний перенос 1 536 байтів коштує менше 20 000 тактів. Прохід рендерингу — вузьке місце, не перенос.

---

## Глибоке занурення: Чанкі-пікселі 4x4 (sq, Hype 2022)

Стаття sq доводить чанкі-пікселі до 4x4 — ефективна роздільність 64x48. Візуальний результат грубіший, але виграш у продуктивності відкриває ефекти на кшталт бамп-мапінгу та черезрядкового рендерингу. Стаття — це дослідження методології оптимізації: почни просто, ітеративно покращуй, вимірюй на кожному кроці.

**Підхід 1: Базовий LD/INC (101 такт на пару).** Завантаж чанкі-значення, запиши в буфер, просунь вказівники. Вузьке місце — керування вказівниками: `INC HL` на 6 тактів накопичується за тисячі ітерацій.

**Підхід 2: Варіант з LDI (104 такти — повільніше!).** `LDI` копіює байт і автоінкрементує обидва вказівники однією інструкцією. Але вона також декрементує BC, споживаючи регістрову пару. Накладні витрати на збереження/відновлення роблять її *повільнішою* за наївний підхід. Повчальна історія: на Z80 "розумна" інструкція — не завжди швидка.

**Підхід 3: LDD подвійний байт (80 тактів на пару).** Розташувавши джерело і призначення у зворотному порядку, автодекремент `LDD` працює на твою користь. Комбінована двобайтна послідовність використовує це для покращення на 21% порівняно з базовою лінією.

**Підхід 4: Самомодифікований код (76-78 тактів на пару).** Попередньо згенеруй 256 процедур рендерингу, по одній на кожне можливе значення байта, кожна з піксельним значенням, впеченим як безпосередній операнд:

```z80
; One of 256 pre-generated procedures
proc_A5:
    ld   (hl),$A5        ; 10T  -- value baked into instruction
    inc  l               ;  4T
    ld   (hl),$A5        ; 10T  -- 4x4 block spans 2 bytes horizontally
    ; ... handle vertical repetition ...
    ret                  ; 10T
```

256 процедур займають приблизно 3 КБ. Попіксельний рендеринг падає до 76-78 тактів — на 23% швидше за базову лінію, на 27% швидше за LDI.

### Порівняння продуктивності

| Підхід | Тактів/пара | Відносно | Пам'ять |
|----------|------------|----------|--------|
| Базовий LD/INC | 101 | 1.00x | Мінімум |
| Варіант з LDI | 104 | 0.97x | Мінімум |
| LDD подвійний байт | 80 | 1.26x | Мінімум |
| Самомодифікований (256 процедур) | 76-78 | 1.30x | ~3 КБ |

Самомодифікований підхід виграє, але перевага над LDD невелика. У демо на 128K 3 КБ легко доступні. У продукції на 48K підхід з LDD може бути кращим інженерним рішенням.

### Історичне коріння: Born Dead #05

sq зазначає, що ці техніки будуються на роботі, опублікованій у Born Dead #05, російській демосценовій газеті приблизно 2001 року. Базова стаття описувала основний чанкі-рендеринг; внесок sq — систематична оптимізація та варіант із попередньо згенерованими процедурами. Ось як еволюціонує знання сцени: техніка з'являється в маловідомому дисковому журналі, циркулює у спільноті, а двадцять один рік потому хтось повертається до неї зі свіжими вимірами та новими трюками.

---

## Практика: Побудова простого ротозумера

Ось структура робочого ротозумера з чанкі-пікселями 2x2 та шахматною текстурою.

**Текстура.** 256-байтна таблиця, вирівняна за сторінкою, де кожен байт дорівнює `$03` або `$00`, утворюючи 8-піксельні смуги. Регістр H забезпечує другий вимір; XOR H у пошук створює повну шахматку:

```z80
    ALIGN 256
texture:
    LUA ALLPASS
    for i = 0, 255 do
        if math.floor(i / 8) % 2 == 0 then
            sj.add_byte(0x03)
        else
            sj.add_byte(0x00)
        end
    end
    ENDLUA
```

**Таблиця синусів і покадрова підготовка.** 256-елементна таблиця синусів, вирівняна за сторінкою, керує обертанням. Кожен кадр зчитує `sin(frame_counter)` і `cos(frame_counter)` (косинус через зсув індексу на 64) для обчислення крокових векторів, потім патчить інструкції ходу внутрішнього циклу правильними опкодами.

**Цикл рендерингу.** Зовнішній цикл задає початкову текстурну координату для кожного рядка (крокуючи перпендикулярно до напрямку ходу). Внутрішній цикл ходить по текстурі:

```z80
.byte_loop:
    ld   a,(hl)              ; read texel 1
    inc  l                   ; walk (patched per-frame)
    add  a,a : add  a,a     ; shift
    add  a,(hl)              ; read texel 2
    inc  l                   ; walk
    add  a,a : add  a,a     ; shift
    add  a,(hl)              ; read texel 3
    inc  l                   ; walk
    add  a,a : add  a,a     ; shift
    add  a,(hl)              ; read texel 4
    inc  l                   ; walk
    ld   (de),a              ; write output byte
    inc  de
    djnz .byte_loop
```

Інструкції `inc l` — це цілі генератора коду. Перед кожним кадром вони патчаться відповідною комбінацією `inc l`/`dec l`/`inc h`/`dec h`/`nop` на основі поточного кута. Для некардинальних кутів акумулятор помилки Брезенхема розподіляє кроки по мінорній осі по всьому рядку, тому кожна інструкція ходу в розгорнутому циклі може відрізнятися від своїх сусідів.

**Основний цикл.** `HALT` для vsync, обчисли крокові вектори, згенеруй код ходу, відрендери в буфер, стекове копіювання буфера на екран, інкрементуй лічильник кадрів, повтори.

---

## Простір проектування

Розмір чанкі-пікселя — найважливіше проектне рішення в ротозумері:

| Параметр | 2x2 (Illusion) | 4x4 (sq) | 8x8 (атрибути) |
|-----------|----------------|----------|-------------------|
| Роздільність | 128x96 | 64x48 | 32x24 |
| Текселів/кадр | 12 288 | 3 072 | 768 |
| Вартість внутрішнього циклу | ~146 000 T | ~29 000 T | ~7 300 T |
| Кадрів/екран | ~2,3 | ~0,5 | ~0,1 |
| Візуальна якість | Гарний рух | Чанкі, але швидко | Дуже блочно |
| Застосування | Головні ефекти | Бамп-мапінг, накладки | Атрибутні ефекти |

Версія 4x4 вкладається в один кадр із запасом для музичного рушія та інших ефектів. Версія 2x2 займає 2-3 кадри, але виглядає суттєво краще. Випадок 8x8 — це атрибутний тунель з Розділу 9.

Коли у тебе є швидкий чанкі-рендерер, ротозумер — лише одне застосування. Той самий рушій керує **бамп-мапінгом** (зчитуй різниці висот замість сирих текселів, виводь тінювання), **черезрядковими ефектами** (рендери непарні/парні рядки на чергових кадрах, подвоюючи ефективну частоту кадрів ціною мерехтіння) та **спотворенням текстури** (варіюй напрямок ходу по рядках для хвильових або пульсуючих ефектів). Ротозумер 4x4 може ділити кадр зі скролтекстом, музичним рушієм та переносом екрану. Робота sq була мотивована саме цією універсальністю.

---

## Ротозумер у контексті

Ротозумер — це не алгоритм обертання. Це *патерн обходу пам'яті*. Ти йдеш по буферу прямою лінією, і напрямок ходу визначає, що ти бачиш. Обертання — це один вибір напрямку. Зум — це вибір розміру кроку. Z80 не знає тригонометрію. Він знає `INC L` і `DEC H`. Все інше — інтерпретація програміста.

В Illusion ротозумер сусідить зі сферою та скролером з точкового поля. Усі три ділять одну архітектуру: попередньо обчислені параметри, згенеровані внутрішні цикли, послідовний доступ до пам'яті. Сфера використовує таблиці пропуску та змінну кількість `INC L`. Ротозумер використовує пропатчені за напрямком інструкції ходу. Точкове поле використовує стекові таблиці адрес. Три ефекти, одна філософія рушія.

Dark побудував їх усі. Introspec відстежив їх усі. Патерн, що їх з'єднує, — це урок Частини II: обчисли те, що потрібно, до початку внутрішнього циклу, згенеруй код, що не робить нічого, крім зчитати-зсунути-записати, і тримай доступ до пам'яті послідовним.

---

## Підсумок

- Ротозумер відображає повернуту та масштабовану текстуру, ходячи по ній під кутом. Лінійність зменшує попіксельну вартість з двох множень до двох додавань.
- Чанкі-пікселі (2x2, 4x4) зменшують ефективну роздільність і вартість рендерингу пропорційно. Illusion використовує 2x2 при 128x96; система sq використовує 4x4 при 64x48.
- Внутрішній цикл Illusion: `ld a,(hl) : add a,a : add a,a : add a,(hl)` з інструкціями ходу між зчитуваннями. Вартість: ~95 тактів на байт для 4 чанкі-пікселів.
- Напрямок ходу змінюється кожен кадр, вимагаючи генерації коду — цикл рендерингу патчиться перед кожним кадром.
- Шлях оптимізації sq для 4x4: базовий LD/INC (101 такт) до LDI (104 такти, повільніше) до LDD (80 тактів) до самомодифікованого коду з 256 попередньо згенерованими процедурами (76-78 тактів, ~3 КБ). Базується на ранній роботі в Born Dead #05 (~2001).
- Перенос буфера на екран через `pop hl : ld (nn),hl` при ~26 тактах на два байти.
- Ротозумер ділить свою архітектуру зі сферою (Розділ 6) та точковим полем (Розділ 10): попередньо обчислені параметри, згенеровані внутрішні цикли, послідовний доступ до пам'яті.

---

> **Джерела:** Introspec, "Technical Analysis of Illusion by X-Trade" (Hype, 2017); sq, "Chunky Effects on ZX Spectrum" (Hype, 2022); Born Dead #05 (~2001, оригінальні техніки чанкі-пікселів).
