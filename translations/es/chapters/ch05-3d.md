# Capitulo 5: 3D a 3,5 MHz

> *"Calcula solo lo que debas. Deriva el resto."*
> --- Dark & STS, Spectrum Expert #02 (1998)

El capitulo anterior te dio los bloques de construccion: multiplicacion, division, tablas de seno, dibujo de lineas. Ahora los juntamos. El objetivo es un objeto tridimensional solido girando en un ZX Spectrum --- poligonos rellenos, eliminacion de caras traseras, ordenamiento correcto de profundidad --- a una tasa de fotogramas utilizable.

Aqui es donde te topas con el muro.

---

## El Problema: Doce Multiplicaciones Por Vertice

Rotar un punto en el espacio tridimensional alrededor de los tres ejes requiere una secuencia de multiplicaciones trigonometricas. Si rotas secuencialmente --- primero alrededor de Z, luego Y, luego X --- cada eje implica cuatro multiplicaciones y dos sumas para transformar dos coordenadas. Tres ejes, cuatro multiplicaciones cada uno: doce multiplicaciones por vertice.

Toma la multiplicacion por desplazamiento y suma del Capitulo 4, que cuesta aproximadamente 200 T-states. Doce de esas te dan 2.400 T-states para rotar un solo vertice. Un cubo simple tiene 8 vertices: 19.200 T-states solo para la rotacion. El Capitulo 4 mostro que esto cabe en el presupuesto de fotograma --- apenas.

Ahora intenta algo mas interesante. Una esfera aproximada por 20 vertices y 36 caras:

```
20 vertices x 2.400 T-states = 48.000 T-states
```

Eso es el 67% del presupuesto de fotograma de 71.680 T-states del Pentagon, consumido antes de haber dibujado un solo pixel. Aun necesitas proyeccion en perspectiva, eliminacion de caras traseras, ordenamiento de poligonos y el relleno propiamente dicho. No hay espacio. El objeto no puede ser mas complejo que un cubo a menos que encuentres una forma fundamentalmente mas barata de calcular las posiciones de los vertices.

Dark y STS encontraron una.

---

## El Metodo del Punto Medio

La idea es geometrica. No todos los vertices de un objeto llevan informacion independiente. Muchos vertices se situan en posiciones estructuralmente predecibles --- puntos medios de aristas, centros de caras, reflejos de otros vertices. Si puedes expresar esas relaciones explicitamente, puedes reemplazar multiplicaciones costosas con promedios baratos.

### El Cubo como Base

Considera un cubo centrado en el origen. Tiene 8 vertices, pero no son 8 puntos independientes. Son 4 pares de vertices diametralmente opuestos. Si conoces un vertice de un par, el otro es su negacion a traves del centro:

```
v0 = ( x,  y,  z)    ->    v7 = (-x, -y, -z)
v1 = ( x,  y, -z)    ->    v6 = (-x, -y,  z)
v2 = ( x, -y,  z)    ->    v5 = (-x,  y, -z)
v3 = ( x, -y, -z)    ->    v4 = (-x,  y,  z)
```

Rota 4 vertices usando el procedimiento completo de 12 multiplicaciones. Negalos para obtener los otros 4. La negacion en el Z80 es `NEG` --- 8 T-states para una coordenada, 24 T-states para las tres. Compara eso con 2.400 T-states para una rotacion completa. Has reducido el calculo de vertices casi a la mitad.

Pero el metodo del punto medio va mucho mas alla del espejado.

### Derivar Vertices por Promediado

La operacion clave es el promedio: dados dos puntos ya calculados, su punto medio es simplemente la media de sus coordenadas.

```
v_new = (v_a + v_b) / 2
```

En el Z80, esto es una suma y un desplazamiento:

```z80
; Average two signed 8-bit coordinates
; A = first coordinate, B = second coordinate
; Result in A = (A + B) / 2

    add  a, b           ;  4 T-states
    sra  a              ;  8 T-states
                        ; ----
                        ; 12 T-states total
```

`SRA` (Desplazamiento Aritmetico a la Derecha) preserva el bit de signo, asi que esto funciona correctamente para coordenadas negativas. Para las tres coordenadas (x, y, z), promediar cuesta 36 T-states por vertice derivado. Compara eso con 2.400 T-states para una rotacion completa.

La proporcion es asombrosa: promediar es **66 veces mas barato** que rotar.

Esto significa que puedes construir objetos complejos a partir de un pequeno conjunto de vertices "base" que rotas completamente, y luego derivar todos los vertices restantes a traves de cadenas de promedios. Cuantos mas vertices puedas derivar, mas tiempo ahorras.

### Construir Objetos Complejos

Supongamos que quieres un objeto de 20 vertices. Con el metodo del punto medio:

1. Rotar 4 vertices base completamente: 4 x 2.400 = 9.600 T-states
2. Espejar 4 vertices por negacion: 4 x 24 = 96 T-states
3. Derivar 12 vertices por promediado: 12 x 36 = 432 T-states
4. **Total: 10.128 T-states**

Sin el metodo del punto medio, los mismos 20 vertices costarian 48.000 T-states. Has ahorrado 37.872 T-states --- mas de la mitad del presupuesto de fotograma liberado para proyeccion, eliminacion de caras y renderizado.

La restriccion es topologica: solo puedes derivar un vertice por promediado si genuinamente se encuentra en el punto medio de otros dos vertices (o lo suficientemente cerca como para que el error sea invisible a resolucion de 256x192). Esto determina como disenas tus modelos 3D. No modelas libremente y luego optimizas --- disenas el modelo *alrededor* de la estructura de punto medio desde el principio.

Dark y STS dan ejemplos de las cadenas de derivacion:

```
v8  = (v4 + v5) / 2
v9  = (v3 + v7) / 2
v10 = (v2 + v6) / 2
v11 = (v8 + v9) / 2     ; derivado de dos vertices ya derivados
```

Observa que v11 se deriva de v8 y v9, que a su vez son derivados. Las cadenas pueden tener varios niveles de profundidad. Cada nivel agrega solo 36 T-states por vertice, asi que el coste permanece insignificante independientemente de la profundidad.

---

## El Procesador Virtual

Aqui es donde Dark hace algo que parece anacronico para 1998. En lugar de codificar de forma fija las cadenas de derivacion para cada objeto especifico, disena un pequeno interprete --- un procesador virtual --- que ejecuta "programas" describiendo como calcular vertices.

### Arquitectura

El procesador virtual tiene:

- **Un registro** (un registro de trabajo que contiene un punto 3D --- tres bytes: x, y, z)
- **64 celdas de RAM** (cada celda contiene un punto 3D --- 192 bytes en total)
- **4 instrucciones**

| Opcode | Bits | Nombre | Operacion |
|--------|------|--------|-----------|
| 00 | `00nnnnnn` | **Load** | registro <-- celda[n] |
| 01 | `01nnnnnn` | **Store** | celda[n] <-- registro |
| 10 | `10nnnnnn` | **Average** | registro <-- (registro + celda[n]) / 2 |
| 11 | `11------` | **End** | detener ejecucion |

Cada instruccion se codifica en un solo byte: 2 bits para el opcode, 6 bits para el numero de celda (0--63). Todo el conjunto de instrucciones cabe en 256 valores posibles.

### Ejecucion

El bucle del interprete es notablemente compacto:

```z80
; Virtual processor main loop
; IX points to the program (sequence of 1-byte instructions)
; Point RAM at a fixed address, 3 bytes per cell

vp_loop:
    ld   a, (ix+0)        ; fetch instruction
    inc  ix
    ld   b, a             ; save full instruction
    and  %11000000        ; extract opcode (top 2 bits)

    cp   %11000000        ; END?
    ret  z                ; yes -- halt

    ld   a, b
    and  %00111111        ; extract cell number (bottom 6 bits)
    ; ... compute cell address from cell number ...
    ; ... dispatch based on opcode ...

    jr   vp_loop
```

La instruccion **Load** copia los valores x, y, z de una celda al registro de trabajo. **Store** copia el registro de trabajo de vuelta a una celda. **Average** suma las coordenadas de la celda al registro de trabajo y desplaza cada resultado un bit a la derecha --- la operacion de punto medio. **End** termina el programa.

### Escribir Programas

Una cadena de derivacion de vertices se convierte en una simple secuencia de bytes. Dark usa una notacion compacta en el articulo:

```z80
; Example: derive v8 = (v4 + v5) / 2, then store it
; Cell 4 = v4, Cell 5 = v5, Cell 8 = destination

    DB  4           ; LOAD cell[4]     (opcode 00, cell 4)
    DB  128+5       ; AVG  cell[5]     (opcode 10, cell 5 = %10000101)
    DB  64+8        ; STORE cell[8]    (opcode 01, cell 8 = %01001000)
```

La notacion `128+5` codifica `%10000101` --- opcode 10 (Average) con numero de celda 5. `64+8` codifica `%01001000` --- opcode 01 (Store) con numero de celda 8. Numeros crudos, empaquetados en bytes de datos, formando un diminuto programa de dominio especifico.

Una descripcion completa de objeto podria verse asi:

```z80
; Midpoint program for a 12-vertex object
; Cells 0-3: basis vertices (rotated by main code)
; Cells 4-7: mirrored vertices (negated by main code)
; Cells 8-11: derived via midpoint averaging

midpoint_program:
    DB  0               ; LOAD v0
    DB  128+1           ; AVG  v1           -> register = (v0+v1)/2
    DB  64+8            ; STORE v8

    DB  2               ; LOAD v2
    DB  128+3           ; AVG  v3           -> register = (v2+v3)/2
    DB  64+9            ; STORE v9

    DB  4               ; LOAD v4
    DB  128+5           ; AVG  v5           -> register = (v4+v5)/2
    DB  64+10           ; STORE v10

    DB  6               ; LOAD v6
    DB  128+7           ; AVG  v7           -> register = (v6+v7)/2
    DB  64+11           ; STORE v11

    DB  192             ; END               (%11000000)
```

Trece bytes describen el calculo de cuatro vertices derivados. El procesador virtual los ejecuta en aproximadamente 13 x 30 = 390 T-states (cada instruccion toma aproximadamente 25--35 T-states dependiendo del tipo). Cuatro vertices completamente rotados habrian costado 9.600 T-states. Los ahorros son enormes.

### Por Que un Procesador Virtual?

Podrias preguntar: por que no simplemente escribir el codigo de promediado directamente en ensamblador Z80? Poner las sumas y desplazamientos en linea, saltarse la sobrecarga del interprete. Seria ligeramente mas rapido por vertice.

La respuesta es flexibilidad. El procesador virtual separa la *descripcion* de la topologia de un objeto de la *ejecucion* del calculo de vertices. Cambiar el objeto? Escribe un nuevo programa --- una nueva secuencia de bytes de datos. El codigo del interprete permanece igual. Puedes almacenar programas para multiples objetos y cambiar entre ellos a coste cero de codigo. Incluso puedes generar programas algoritmicamente.

Esto es, en esencia, un interprete de bytecode de dominio especifico --- un patron que los programadores modernos reconocerian de motores de juegos, compiladores de shaders y lenguajes de scripting. Dark lo diseno en 1998, en un ZX Spectrum, para ahorrar T-states en calculo de vertices. La arquitectura es notablemente limpia.

---

## Rotacion

Con el metodo del punto medio manejando la mayoria de los vertices, aun necesitas rotar los vertices base correctamente. Dark y STS usan rotacion secuencial alrededor de los tres ejes, aplicada en orden: Z, luego Y, luego X. Cada rotacion usa las tablas de seno y coseno del Capitulo 4.

### Rotacion en el Eje Z

La rotacion alrededor de Z afecta solo a X e Y:

```
X' = X * cos(Az) + Y * sin(Az)
Y' = -X * sin(Az) + Y * cos(Az)
```

En ensamblador Z80, usando la multiplicacion 8x8 con signo y las tablas de seno/coseno de 256 entradas:

```z80
; Rotate point around Z axis
; Input:  (px), (py) = coordinates; (angle_z) = rotation angle
; Output: (px), (py) updated
; Uses:   cos_table, sin_table (page-aligned, signed 8-bit)

rotate_z:
    ld   a, (angle_z)
    ld   l, a
    ld   h, cos_table >> 8
    ld   d, (hl)            ; D = cos(Az)
    ld   h, sin_table >> 8
    ld   e, (hl)            ; E = sin(Az)

    ; X' = X*cos(Az) + Y*sin(Az)
    ld   a, (px)
    ld   b, a
    ld   c, d               ; B=X, C=cos
    call mul_signed          ; HL = X * cos(Az)
    push hl

    ld   a, (py)
    ld   b, a
    ld   c, e               ; B=Y, C=sin
    call mul_signed          ; HL = Y * sin(Az)
    pop  de
    add  hl, de             ; HL = X*cos + Y*sin
    ld   a, h               ; take high byte as new X'
    ld   (px), a

    ; Y' = -X*sin(Az) + Y*cos(Az)
    ld   a, (px_original)   ; need the original X, not the updated one
    neg
    ld   b, a
    ld   c, e               ; B=-X, C=sin
    call mul_signed          ; HL = -X * sin(Az)
    push hl

    ld   a, (py)
    ld   b, a
    ld   c, d               ; B=Y, C=cos
    call mul_signed          ; HL = Y * cos(Az)
    pop  de
    add  hl, de             ; HL = -X*sin + Y*cos
    ld   a, h
    ld   (py), a

    ret
```

El mismo patron se repite para la rotacion en el eje Y (afectando X y Z) y la rotacion en el eje X (afectando Y y Z). Dark envuelve las tres en un unico procedimiento `ROTATE` que toma tres parametros de angulo y transforma un punto en su lugar.

Nota el detalle sobre preservar el valor original de X. La segunda formula usa el X pre-rotacion, no el X' que acabas de calcular. Un error comun es usar la coordenada ya actualizada, lo que produce una rotacion sesgada. Dark aborda esto explicitamente en el articulo.

### Coste Por Vertice Base

Cada rotacion de eje requiere 4 multiplicaciones y 2 sumas. A 200 T-states por multiplicacion y 11 T-states por suma de 16 bits:

```
Por eje:   4 x 200 + 2 x 11 = 822 T-states
Tres ejes: 3 x 822 = 2.466 T-states por vertice
```

Con 4 vertices base: aproximadamente 9.864 T-states para la rotacion. Anade la ejecucion del programa de punto medio y tienes el calculo completo de vertices para un objeto arbitrariamente complejo a una fraccion del coste ingenuo.

---

## Proyeccion

Una vez que todos los vertices estan rotados en el espacio 3D, necesitas proyectarlos en la pantalla 2D.

### Proyeccion Paralela

El enfoque mas simple: ignora la coordenada Z por completo. Simplemente usa X e Y como coordenadas de pantalla (con el desplazamiento apropiado para centrar el objeto en la pantalla).

```z80
; Parallel projection: screen coords = rotated X, Y + offset
    ld   a, (px)
    add  a, 128             ; center horizontally (128 = half of 256)
    ld   (screen_x), a

    ld   a, (py)
    add  a, 96              ; center vertically (96 = half of 192)
    ld   (screen_y), a
```

Coste: esencialmente cero. El resultado se ve plano --- los objetos no parecen retroceder en la distancia. La proyeccion paralela es util para previsualizaciones de alambre y efectos donde la rotacion misma proporciona la ilusion de profundidad, pero carece del impacto visceral de la perspectiva.

### Proyeccion en Perspectiva

La perspectiva hace que los objetos cercanos se vean mas grandes y los lejanos mas pequenos, produciendo la pista de profundidad que hace convincente el 3D:

```
Xpantalla = (X * Escala) / (Z + Zdistancia) + Xdesplazamiento
Ypantalla = (Y * Escala) / (Z + Zdistancia) + Ydesplazamiento
```

`Escala` controla el campo de vision. `Zdistancia` es la distancia de la camara al plano de proyeccion --- previene la division por cero cuando Z se acerca a la camara y controla cuan agresivamente los objetos se escalan con la profundidad. `Xdesplazamiento` e `Ydesplazamiento` centran la proyeccion en la pantalla.

La operacion costosa aqui es la division. Una division por coordenada, dos coordenadas por vertice. Usando la division logaritmica del Capitulo 4 (~60 T-states por division), el coste es modesto:

```z80
; Perspective projection for one vertex
; Input:  (px), (py), (pz) = rotated 3D coordinates
; Output: (screen_x), (screen_y)

perspective:
    ; Compute denominator: Z + Zdistance
    ld   a, (pz)
    add  a, ZDISTANCE       ; Z + viewing distance
    ld   c, a               ; C = denominator

    ; Xscreen = (X * Scale) / (Z + Zdist) + Xoffset
    ld   a, (px)
    ld   b, SCALE
    call mul_signed          ; HL = X * Scale
    ld   a, h               ; take high byte as numerator
    call log_divide          ; A = A / C (using log tables)
    add  a, XOFFSET
    ld   (screen_x), a

    ; Yscreen = (Y * Scale) / (Z + Zdist) + Yoffset
    ld   a, (py)
    ld   b, SCALE
    call mul_signed          ; HL = Y * Scale
    ld   a, h
    call log_divide          ; A = A / C
    add  a, YOFFSET
    ld   (screen_y), a

    ret
```

Cada vertice cuesta dos multiplicaciones (400 T-states) y dos divisiones logaritmicas (120 T-states), mas sobrecarga --- aproximadamente 600 T-states por vertice. Para 20 vertices: 12.000 T-states. Combinado con la rotacion de punto medio, estamos en aproximadamente 22.000 T-states para todo el calculo y proyeccion de vertices. Menos de un tercio del presupuesto de fotograma.

---

## Poligonos Solidos

Un objeto de alambre es una coleccion de aristas. Un objeto solido es una coleccion de poligonos rellenos. Pasar de alambre a solido requiere tres capacidades adicionales: determinar que caras son visibles, ordenarlas por profundidad y rellenarlas con pixeles.

### Eliminacion de Caras Traseras

Un objeto 3D cerrado tiene caras que apuntan hacia el espectador y caras que apuntan en sentido contrario. Los poligonos que miran hacia atras estan ocultos y no necesitan ser dibujados. Omitirlos ahorra tanto tiempo de renderizado como produce una apariencia solida correcta sin requerir un buffer de profundidad completo.

La prueba es geometrica. Para cada cara, calcula el componente Z de la normal de superficie usando el producto cruzado de dos vectores de arista:

```
Dados tres vertices de una cara: v0, v1, v2

Vectores de arista:
    V = v1 - v0 = (Vx, Vy)    (en coordenadas de pantalla)
    W = v2 - v0 = (Wx, Wy)

Componente Z de la normal = Vx * Wy - Vy * Wx
```

Si el resultado es positivo, la cara esta orientada hacia el espectador y debe dibujarse. Si es negativo, la cara apunta en sentido contrario --- eliminala. Si es cero, la cara esta de canto e invisible.

```z80
; Backface culling test for one face
; Input: three projected vertices (x0,y0), (x1,y1), (x2,y2)
; Output: carry flag set if face is back-facing (should be culled)

backface_test:
    ; V = v1 - v0
    ld   a, (x1)
    sub  (ix+x0)
    ld   d, a               ; D = Vx = x1 - x0

    ld   a, (y1)
    sub  (ix+y0)
    ld   e, a               ; E = Vy = y1 - y0

    ; W = v2 - v0
    ld   a, (x2)
    sub  (ix+x0)
    ld   b, a               ; B = Wx = x2 - x0

    ld   a, (y2)
    sub  (ix+y0)
    ld   c, a               ; C = Wy = y2 - y0

    ; Normal Z = Vx * Wy - Vy * Wx
    ld   a, d
    call mul_signed_c        ; HL = Vx * Wy (D * C)
    push hl

    ld   a, e
    ld   c, b
    call mul_signed_c        ; HL = Vy * Wx (E * B)

    pop  de
    ex   de, hl
    or   a
    sbc  hl, de             ; HL = Vx*Wy - Vy*Wx

    bit  7, h               ; check sign
    ret                     ; carry/sign indicates facing
```

Dos multiplicaciones y una resta por cara. A 400 T-states por las multiplicaciones mas sobrecarga, la prueba cuesta aproximadamente 500 T-states por cara. Para un objeto de 12 caras, son 6.000 T-states --- y por cada cara eliminada, te ahorras el coste completo de rellenarla.

En un solido rotatorio tipico, aproximadamente la mitad de las caras estan mirando hacia atras en cualquier momento. Eliminarlas reduce tu carga de relleno a la mitad.

### Ordenamiento por Z

Para un objeto convexo (un cubo, un tetraedro), la eliminacion de caras traseras sola produce resultados correctos: cada cara visible es completamente visible, sin solapamientos. Para escenas concavas o con multiples objetos, necesitas dibujar las caras en orden de atras hacia adelante para que las caras mas cercanas sobrescriban a las mas lejanas --- el algoritmo del pintor.

Dark y STS calculan un valor de profundidad para cada cara visible (tipicamente el Z promedio de sus vertices) y ordenan la lista de caras en consecuencia. Un simple ordenamiento por insercion es adecuado para los pequenos conteos de caras involucrados --- ordenar 6--12 caras toma tiempo insignificante comparado con rellenarlas.

```z80
; Simplified depth sort: compute average Z for each visible face,
; sort face indices by descending Z (farthest first)

sort_faces:
    ; For each visible face:
    ;   average_z = (z[v0] + z[v1] + z[v2] + z[v3]) / 4
    ;   store (average_z, face_index) in sort buffer
    ; Then insertion-sort the buffer by average_z
    ; ...
```

### Relleno de Poligonos Convexos

Una vez que sabes que caras dibujar y en que orden, necesitas rellenarlas. Un poligono convexo (todos los angulos interiores menores de 180 grados) puede rellenarse con un enfoque simple de lineas de escaneo:

1. Encuentra los vertices superior e inferior.
2. Recorre la arista izquierda y la arista derecha simultaneamente, una linea de escaneo a la vez.
3. Para cada linea de escaneo, dibuja una linea horizontal de la arista izquierda a la derecha.

El recorrido de aristas usa avance incremental estilo Bresenham --- no se necesita division por linea de escaneo, solo sumas e incrementos condicionales. El relleno horizontal en si es un bucle ajustado de escrituras de bytes:

```z80
; Fill one scan line from x_left to x_right at screen row Y
; Screen address already computed in HL

fill_scanline:
    ld   a, (x_right)
    sub  (ix+x_left)
    ret  c                  ; nothing to fill if right < left
    ret  z
    ld   b, a               ; B = pixel count

    ; For byte-aligned fills: write whole bytes
    ld   a, $FF             ; solid fill
.fill_loop:
    ld   (hl), a
    inc  l                  ; next byte (within same screen line)
    djnz .fill_loop
    ret
```

Esto esta simplificado --- los rellenadores de poligonos reales deben manejar bytes parciales en las aristas izquierda y derecha, donde el limite del poligono cae dentro de un byte en lugar de en un limite de byte. Esos casos limite agregan complejidad pero no mucho coste, ya que ocurren solo dos veces por linea de escaneo.

---

## Juntandolo Todo

El bucle de fotograma completo para un objeto solido 3D giratorio sigue esta secuencia:

![Pipeline de renderizado 3D: modelo, rotacion, proyeccion, pantalla](illustrations/output/ch05_3d_pipeline.png)

```
1. Actualizar angulos de rotacion (Az, Ay, Ax)
2. Para cada vertice base:
     Rotar a traves de los ejes Z, Y, X          [~2.400 T por vertice]
3. Negar vertices base para obtener espejos       [~24 T por vertice]
4. Ejecutar programa de punto medio para derivar el resto  [~36 T por vertice derivado]
5. Proyectar todos los vertices (perspectiva)     [~600 T por vertice]
6. Para cada cara:
     Prueba de cara trasera                       [~500 T por cara]
     Si visible: calcular Z promedio
7. Ordenar caras visibles por Z                   [~200 T para listas pequenas]
8. Para cada cara visible (de atras hacia adelante):
     Rellenar poligono                            [varia con el area]
9. Esperar al siguiente fotograma (HALT)
```

Para un objeto de 20 vertices y 18 caras con 4 vertices base, el presupuesto por fotograma se desglosa asi:

| Etapa | Vertices/Caras | Coste por unidad | Total |
|-------|---------------|------------------|-------|
| Rotacion (base) | 4 | 2.466 | 9.864 |
| Negacion (espejos) | 4 | 24 | 96 |
| Derivacion punto medio | 12 | 36 | 432 |
| Proyeccion | 20 | 600 | 12.000 |
| Prueba cara trasera | 18 | 500 | 9.000 |
| Ordenamiento Z | ~9 visibles | - | ~200 |
| Relleno de poligonos | ~9 visibles | ~1.500 prom. | ~13.500 |
| **Total** | | | **~45.092** |

Cuarenta y cinco mil T-states de 71.680 disponibles. Ajustado, pero viable --- te quedan 26.000 T-states para borrado de pantalla, actualizaciones de angulos y el dibujo de lineas o resaltado de aristas que hace que el objeto se vea nitido. Y esto es para un objeto de 20 vertices, mucho mas complejo que cualquier cosa que podrias permitirte con rotacion ingenua.

---

## La Forma de los Objetos

El metodo del punto medio influye en como piensas sobre los modelos 3D. No disenas una malla y luego la optimizas --- empiezas desde la topologia que el metodo requiere.

Un buen objeto de punto medio comienza con una base pequena. Cuatro puntos completamente rotados definen un esqueleto tipo tetraedro. La negacion duplica eso a ocho. El promediado de punto medio rellena el resto. El arte esta en elegir vertices base que produzcan puntos derivados utiles.

Considera construir un objeto de 14 vertices desde cero:

```
Base:     v0, v1, v2, v3         (4 completamente rotados)
Espejos:  v4, v5, v6, v7         (4 negados)
Derivados:
  v8  = (v0 + v1) / 2           punto medio de arista
  v9  = (v2 + v3) / 2           punto medio de arista
  v10 = (v4 + v5) / 2           punto medio de arista en lado espejado
  v11 = (v6 + v7) / 2           punto medio de arista en lado espejado
  v12 = (v0 + v2) / 2           punto medio de arista cruzada
  v13 = (v8 + v10) / 2          derivacion de segundo nivel
```

El programa de procesador virtual para esto son 19 bytes:

```z80
object_14v_program:
    DB  0, 128+1, 64+8      ; v8  = avg(v0, v1)
    DB  2, 128+3, 64+9      ; v9  = avg(v2, v3)
    DB  4, 128+5, 64+10     ; v10 = avg(v4, v5)
    DB  6, 128+7, 64+11     ; v11 = avg(v6, v7)
    DB  0, 128+2, 64+12     ; v12 = avg(v0, v2)
    DB  8, 128+10, 64+13    ; v13 = avg(v8, v10)
    DB  192                  ; END
```

Diecinueve bytes de datos reemplazan lo que de otra forma serian 14.400 T-states de multiplicaciones de rotacion para los 6 vertices derivados.

Puedes ir mas alla. Un segundo nivel de promediado (derivar de puntos ya derivados) no cuesta nada adicional por instruccion --- al procesador virtual no le importa si una celda contiene un punto rotado o derivado. Dark y STS describen cadenas de tres o cuatro niveles de profundidad, construyendo objetos con 30 o mas vertices a partir de solo 3--4 puntos base.

La restriccion es la precision. Cada paso de promediado introduce un error de redondeo de hasta 0,5 unidades (del desplazamiento entero). Despues de tres niveles de derivacion, el error acumulado puede alcanzar 1,5 unidades --- perceptible en un objeto que abarca 60 pixeles, invisible en uno que abarca 120. Disena tus objetos lo suficientemente grandes como para que el redondeo este por debajo de la resolucion de pantalla.

---

## Practico: Un Objeto Solido Giratorio

Aqui esta el esquema para construir un solido 3D giratorio completo usando todo lo de este capitulo.

### Paso 1: Definir el Objeto

Comienza con vertices base. Un octaedro truncado funciona bien con el metodo del punto medio:

```z80
; 4 basis vertices in signed 8-bit coordinates
basis_vertices:
    DB   30,   0,  30     ; v0 (x, y, z)
    DB    0,  30,  30     ; v1
    DB   30,  30,   0     ; v2
    DB    0,   0,   0     ; v3 (at origin for center reference)
```

### Paso 2: Escribir el Programa de Punto Medio

```z80
midpoint_prog:
    ; Mirrors: cells 4-7 are pre-negated by the main loop
    ; Derive additional vertices:
    DB  0, 128+1, 64+8        ; v8  = avg(v0, v1)
    DB  2, 128+3, 64+9        ; v9  = avg(v2, v3)
    DB  0, 128+2, 64+10       ; v10 = avg(v0, v2)
    DB  1, 128+3, 64+11       ; v11 = avg(v1, v3)
    DB  192                    ; END
```

### Paso 3: Definir Caras

```z80
; Face table: each face is a list of vertex indices + attribute byte
; Vertex order must be consistent (clockwise when front-facing)
face_table:
    DB  4, 0, 1, 8, 10        ; face 0: quad (4 vertices)
    DB  4, 2, 3, 9, 11        ; face 1: quad
    ; ... remaining faces ...
    DB  0                      ; end marker
```

### Paso 4: El Bucle de Fotograma

```z80
main_loop:
    halt                       ; wait for vsync (IM1)

    ; Clear the screen area (or use double buffering)
    call clear_viewport

    ; Update angles
    ld   hl, angle_z
    inc  (hl)
    ld   hl, angle_x
    ld   a, (hl)
    add  a, 2
    ld   (hl), a

    ; Rotate basis vertices
    ld   b, 4                  ; 4 basis vertices
    ld   ix, basis_vertices
    ld   iy, point_ram         ; cell 0 onwards
.rotate_basis:
    push bc
    call rotate_xyz            ; rotate point at (IX) by current angles
                               ; store result at (IY)
    ld   bc, 3
    add  ix, bc
    add  iy, bc
    pop  bc
    djnz .rotate_basis

    ; Negate for mirrors (cells 4-7 = negation of cells 0-3)
    call negate_basis

    ; Run midpoint program
    ld   ix, midpoint_prog
    call virtual_processor

    ; Project all vertices
    call project_all

    ; Backface cull and sort
    call cull_and_sort

    ; Draw visible faces
    call draw_faces

    jr   main_loop
```

Este es el esqueleto. Cada `call` oculta un procedimiento construido a partir de las tecnicas de este capitulo y el Capitulo 4. El bucle de fotograma en si es limpio --- actualizar, calcular, dibujar, repetir.

---

## Contexto Historico: Del Fanzine a la Demo

Dark y STS publicaron el metodo del punto medio en Spectrum Expert #02 en 1998. Eran coders jovenes en San Petersburgo, escribiendo para un fanzine en disco distribuido dentro de la comunidad rusa de ZX Spectrum. Los articulos estan escritos en el estilo directo y practico de personas ensenando a sus pares --- aqui esta el problema, aqui esta el truco, aqui esta el codigo.

Pero Spectrum Expert no era un ejercicio academico. Dark era de X-Trade, el mismo grupo que produjo *Illusion* --- la demo que gano el primer puesto en ENLiGHT'96. Los algoritmos en la revista no son propuestas teoricas; son los bloques de construccion de codigo de demo real, ganador de competiciones. Las tablas de seno del Capitulo 4 impulsaban el rotozoomer. El dibujador de lineas renderizaba las estructuras de alambre. Y el metodo del punto medio alimentaba los objetos 3D.

El enfoque del procesador virtual es particularmente llamativo en retrospectiva. En 1998, los paradigmas dominantes en el desarrollo profesional de juegos se estaban moviendo hacia la aceleracion por hardware y alejandose del renderizado por software. En el Spectrum, la aceleracion por hardware no existia. Todo era software, y el software tenia que ser *disenado* --- no solo escrito, sino arquitecturado. El interprete de bytecode de Dark para calculo de vertices es una pieza de arquitectura de software que no desentonaria en el sistema de animacion o compilador de shaders de un motor de juegos moderno. Separa datos de ejecucion, permite iteracion rapida en el diseno de objetos y mantiene el bucle caliente ajustado.

La conexion con *Illusion* es mas profunda que la autoria compartida. Cuando Introspec desensamblo *Illusion* veinte anos despues, encontro exactamente la misma infraestructura matematica: el multiplicador de desplazamiento y suma, la tabla de seno parabolica, el divisor de tablas de logaritmos. El metodo del punto medio y el procesador virtual son extensiones de esa infraestructura --- el mismo pensamiento aplicado a un problema diferente. Dark no estaba solo publicando algoritmos; estaba documentando la filosofia de ingenieria detras de su propia demo premiada.

En el siguiente capitulo, veremos uno de los efectos mas espectaculares de *Illusion* de cerca: la esfera mapeada con textura. Usa las mismas tablas de seno y la misma aritmetica de punto fijo del Capitulo 4, combinadas con las tecnicas de codigo auto-modificable del Capitulo 3 y un enfoque completamente diferente al problema de renderizado. El metodo del punto medio y la esfera son hermanos --- nacidos del mismo coder, las mismas herramientas, la misma busqueda incansable de hacer lo imposible caber en 71.680 T-states.

---

## Resumen

- Rotar objetos 3D de forma ingenua requiere 12 multiplicaciones por vertice --- demasiado costoso para objetos complejos en un Z80 a 3,5 MHz.
- El **metodo del punto medio** rota solo unos pocos vertices base completamente, luego deriva el resto mediante promediado. Promediar cuesta ~36 T-states por vertice frente a ~2.400 para rotacion completa --- 66 veces mas barato.
- Un **procesador virtual** con 4 instrucciones (Load, Store, Average, End) ejecuta "programas" compactos que describen cadenas de derivacion de vertices. La topologia del objeto es datos, no codigo.
- La **rotacion** usa transformaciones secuenciales de ejes Z/Y/X con tablas de consulta de seno/coseno del Capitulo 4.
- La **proyeccion en perspectiva** usa la division logaritmica del Capitulo 4 para la division por Z.
- La **eliminacion de caras traseras** mediante prueba de normal por producto cruzado elimina caras invisibles a ~500 T-states cada una.
- El **ordenamiento por Z** con el algoritmo del pintor maneja caras solapadas para objetos no convexos.
- Un objeto solido de 20 vertices puede renderizarse en ~45.000 T-states por fotograma --- ajustado pero factible dentro del presupuesto de 71.680 T-states.
- Estas tecnicas fueron publicadas en Spectrum Expert #02 (1998) por el mismo equipo que construyo *Illusion*. Los articulos de la revista documentan la ingenieria detras de la demo.

---

*Todos los conteos de ciclos en este capitulo son para temporizado Pentagon (sin estados de espera). En un Spectrum 48K estandar con memoria contendida, espera conteos mas altos para codigo ejecutandose en los 32K inferiores de RAM. Ver Apendice A para la referencia completa de temporizado.*

> **Fuentes:** Dark & STS, "Programming: 3D Graphics" (Spectrum Expert #01, 1997); Dark & STS, "Programming: 3D Graphics --- Midpoint Method" (Spectrum Expert #02, 1998). El diseno del procesador virtual y los ejemplos de derivacion por punto medio estan extraidos directamente del articulo de SE#02.
