; game_skeleton.a80 — Complete game loop + entity system skeleton
; From Chapter 18: Game Loop and Entity System
;
; Demonstrates: state machine, QAOP+SPACE input, entity array,
; type dispatch, player movement, enemy patrol, bullet spawning,
; attribute-block rendering placeholder
;
; Assembles with: mza --target zxspectrum
; Note: mza only supports ld a,(ix+d) / ld (ix+d),a for IX-indexed,
; so all IX ops go through register A.

    ORG  $8000

; ============================================================
; Constants
; ============================================================
MAX_ENTITIES    EQU  16
ENTITY_SIZE     EQU  10

ST_TITLE        EQU  0
ST_MENU         EQU  2
ST_GAME         EQU  4
ST_PAUSE        EQU  6
ST_GAMEOVER     EQU  8

TYPE_INACTIVE   EQU  0
TYPE_PLAYER     EQU  1
TYPE_ENEMY      EQU  2
TYPE_BULLET     EQU  3
TYPE_EXPLOSION  EQU  4

INPUT_RIGHT     EQU  0
INPUT_LEFT      EQU  1
INPUT_DOWN      EQU  2
INPUT_UP        EQU  3
INPUT_FIRE      EQU  4

FLAG_ACTIVE     EQU  0
FLAG_VISIBLE    EQU  1
FLAG_COLLIDABLE EQU  2
FLAG_FACING_L   EQU  3

; ============================================================
; Entry point
; ============================================================
entry:
    di
    ld   sp, $FFFF
    im   1
    ei

    ; Clear entity array
    ld   hl, entity_array
    ld   de, entity_array + 1
    ld   bc, MAX_ENTITIES * ENTITY_SIZE - 1
    ld   (hl), 0
    ldir

    ; Start in title state
    ld   a, ST_TITLE
    ld   (game_state), a

; ============================================================
; Main loop with state dispatch
; ============================================================
main_loop:
    halt

    ld   a, 2
    out  ($FE), a

    ; Dispatch to current state
    ld   a, (game_state)
    ld   l, a
    ld   h, 0
    ld   de, state_table
    add  hl, de
    ld   e, (hl)
    inc  hl
    ld   d, (hl)
    ex   de, hl
    jp   (hl)

return_to_loop:
    xor  a
    out  ($FE), a
    jr   main_loop

; ============================================================
; State table
; ============================================================
state_table:
    DW   state_title
    DW   state_menu
    DW   state_game
    DW   state_pause
    DW   state_gameover

; ============================================================
; State handlers
; ============================================================
state_title:
    call read_input_with_edges
    ld   a, (input_pressed)
    bit  INPUT_FIRE, a
    jr   z, .wait
    ld   a, ST_GAME
    ld   (game_state), a
    call init_game
.wait:
    jp   return_to_loop

state_game:
    call read_input_with_edges
    call update_entities
    call render_entities
    jp   return_to_loop

state_pause:
    call read_input_with_edges
    ld   a, (input_pressed)
    bit  INPUT_FIRE, a
    jr   z, .still_paused
    ld   a, ST_GAME
    ld   (game_state), a
.still_paused:
    jp   return_to_loop

state_gameover:
    call read_input_with_edges
    ld   a, (input_pressed)
    bit  INPUT_FIRE, a
    jr   z, .wait
    ld   a, ST_TITLE
    ld   (game_state), a
.wait:
    jp   return_to_loop

state_menu:
    jp   state_title

; ============================================================
; Init game: set up player and enemies
; ============================================================
init_game:
    ld   hl, entity_array
    ld   de, entity_array + 1
    ld   bc, MAX_ENTITIES * ENTITY_SIZE - 1
    ld   (hl), 0
    ldir

    ; Player (slot 0)
    ld   ix, entity_array
    xor  a
    ld   (ix+0), a              ; X frac = 0
    ld   a, 128
    ld   (ix+1), a              ; X pixel = 128
    ld   a, 160
    ld   (ix+2), a              ; Y = 160
    ld   a, TYPE_PLAYER
    ld   (ix+3), a
    ld   a, 1
    ld   (ix+4), a              ; state = active
    xor  a
    ld   (ix+5), a              ; anim_frame
    ld   (ix+6), a              ; dx
    ld   (ix+7), a              ; dy
    ld   a, 3
    ld   (ix+8), a              ; health = 3
    ld   a, %00000111
    ld   (ix+9), a              ; ACTIVE + VISIBLE + COLLIDABLE

    ; 8 enemies (slots 1-8)
    ld   ix, entity_array + ENTITY_SIZE
    ld   b, 8
    ld   c, 24                  ; starting X pixel

.enemy_loop:
    push bc
    xor  a
    ld   (ix+0), a              ; X frac
    ld   a, c
    ld   (ix+1), a              ; X pixel
    ld   a, 32
    ld   (ix+2), a              ; Y = 32
    ld   a, TYPE_ENEMY
    ld   (ix+3), a
    ld   a, 1
    ld   (ix+4), a              ; state = active
    xor  a
    ld   (ix+5), a              ; anim_frame
    ld   a, 1
    ld   (ix+6), a              ; dx = 1
    xor  a
    ld   (ix+7), a              ; dy = 0
    ld   a, 1
    ld   (ix+8), a              ; health = 1
    ld   a, %00000111
    ld   (ix+9), a              ; flags

    ld   de, ENTITY_SIZE
    add  ix, de
    ld   a, c
    add  a, 28
    ld   c, a
    pop  bc
    djnz .enemy_loop

    ret

; ============================================================
; Input system
; ============================================================
input_flags:      DB  0
input_prev:       DB  0
input_pressed:    DB  0

read_input_with_edges:
    ld   a, (input_flags)
    ld   (input_prev), a

    ld   d, 0

    ld   bc, $DFFE
    in   a, (c)
    bit  0, a
    jr   nz, .no_right
    set  INPUT_RIGHT, d
.no_right:
    bit  1, a
    jr   nz, .no_left
    set  INPUT_LEFT, d
.no_left:

    ld   b, $FB
    in   a, (c)
    bit  0, a
    jr   nz, .no_up
    set  INPUT_UP, d
.no_up:

    ld   b, $FD
    in   a, (c)
    bit  0, a
    jr   nz, .no_down
    set  INPUT_DOWN, d
.no_down:

    ld   b, $7F
    in   a, (c)
    bit  0, a
    jr   nz, .no_fire
    set  INPUT_FIRE, d
.no_fire:

    ld   a, d
    ld   (input_flags), a

    ld   a, (input_prev)
    cpl
    ld   b, a
    ld   a, (input_flags)
    and  b
    ld   (input_pressed), a
    ret

; ============================================================
; Entity update loop
; ============================================================
update_entities:
    ld   ix, entity_array
    ld   b, MAX_ENTITIES

.loop:
    push bc
    ld   a, (ix+9)
    bit  FLAG_ACTIVE, a
    jr   z, .skip

    ld   a, (ix+3)              ; type
    call update_by_type

.skip:
    ld   de, ENTITY_SIZE
    add  ix, de
    pop  bc
    djnz .loop
    ret

; ============================================================
; Type dispatch
; ============================================================
type_handlers:
    DW   nop_handler
    DW   update_player
    DW   update_enemy
    DW   update_bullet
    DW   update_explosion

update_by_type:
    add  a, a
    ld   l, a
    ld   h, 0
    ld   de, type_handlers
    add  hl, de
    ld   e, (hl)
    inc  hl
    ld   d, (hl)
    ex   de, hl
    jp   (hl)

nop_handler:
    ret

; ============================================================
; Player update
; ============================================================
update_player:
    ld   a, (input_flags)
    bit  INPUT_RIGHT, a
    jr   z, .not_right
    ld   a, (ix+0)
    add  a, 2
    ld   (ix+0), a
    jr   nc, .x_done_r
    ld   a, (ix+1)
    inc  a
    ld   (ix+1), a
.x_done_r:
    res  FLAG_FACING_L, (ix+9)
    jr   .horiz_done
.not_right:
    bit  INPUT_LEFT, a
    jr   z, .horiz_done
    ld   a, (ix+0)
    sub  2
    ld   (ix+0), a
    jr   nc, .x_done_l
    ld   a, (ix+1)
    dec  a
    ld   (ix+1), a
.x_done_l:
    set  FLAG_FACING_L, (ix+9)
.horiz_done:

    ; Fire bullet on press
    ld   a, (input_pressed)
    bit  INPUT_FIRE, a
    jr   z, .no_fire
    ld   a, (ix+1)
    ld   b, a                   ; player X
    ld   a, (ix+2)
    ld   c, a                   ; player Y
    call spawn_bullet
.no_fire:

    ; Animate
    ld   a, (ix+5)
    inc  a
    and  7
    ld   (ix+5), a
    ret

; ============================================================
; Enemy update (simple patrol)
; ============================================================
update_enemy:
    ld   a, (ix+6)              ; dx
    ld   e, a
    ld   a, (ix+1)              ; X pixel
    add  a, e
    ld   (ix+1), a

    ; Bounce at screen edges
    cp   240
    jr   c, .no_bounce_r
    ld   a, 255                 ; -1 unsigned
    ld   (ix+6), a
    jr   .bounce_done
.no_bounce_r:
    cp   8
    jr   nc, .bounce_done
    ld   a, 1
    ld   (ix+6), a
.bounce_done:

    ; Animate
    ld   a, (ix+5)
    inc  a
    and  3
    ld   (ix+5), a
    ret

; ============================================================
; Bullet update
; ============================================================
update_bullet:
    ld   a, (ix+6)              ; dx
    ld   e, a
    ld   a, (ix+1)
    add  a, e
    ld   (ix+1), a

    cp   248
    jr   nc, .deactivate
    or   a
    jr   z, .deactivate
    ret

.deactivate:
    xor  a
    ld   (ix+9), a
    ret

; ============================================================
; Explosion update
; ============================================================
update_explosion:
    ld   a, (ix+5)
    inc  a
    cp   8
    jr   nc, .done
    ld   (ix+5), a
    ret
.done:
    xor  a
    ld   (ix+9), a
    ret

; ============================================================
; Spawn bullet
; ============================================================
spawn_bullet:
    push ix
    ld   ix, entity_array + 9 * ENTITY_SIZE
    ld   d, 7

.find:
    ld   a, (ix+9)
    bit  FLAG_ACTIVE, a
    jr   z, .found
    ld   e, ENTITY_SIZE
    add  ix, de
    dec  d
    jr   nz, .find
    pop  ix
    scf
    ret

.found:
    xor  a
    ld   (ix+0), a
    ld   a, b
    ld   (ix+1), a
    ld   a, c
    ld   (ix+2), a
    ld   a, TYPE_BULLET
    ld   (ix+3), a
    ld   a, 1
    ld   (ix+4), a
    xor  a
    ld   (ix+5), a
    ld   (ix+7), a              ; dy = 0

    ; Direction from player facing
    ld   a, (entity_array + 9)
    bit  FLAG_FACING_L, a
    jr   z, .right
    ld   a, 252                 ; dx = -4 (unsigned)
    ld   (ix+6), a
    jr   .dir_done
.right:
    ld   a, 4
    ld   (ix+6), a
.dir_done:
    ld   a, 1
    ld   (ix+8), a              ; health = 1
    ld   a, %00000111
    ld   (ix+9), a

    pop  ix
    or   a
    ret

; ============================================================
; Render entities (stub — attribute blocks)
; ============================================================
render_entities:
    ld   ix, entity_array
    ld   b, MAX_ENTITIES

.loop:
    push bc
    ld   a, (ix+9)
    bit  FLAG_VISIBLE, a
    jr   z, .skip

    ; Character column from X pixel
    ld   a, (ix+1)
    rrca
    rrca
    rrca
    and  $1F
    ld   e, a
    ; Character row from Y pixel
    ld   a, (ix+2)
    rrca
    rrca
    rrca
    and  $1F
    ; Attribute address: $5800 + row*32 + col
    ld   l, a
    ld   h, 0
    add  hl, hl
    add  hl, hl
    add  hl, hl
    add  hl, hl
    add  hl, hl
    ld   d, 0
    add  hl, de
    ld   de, $5800
    add  hl, de

    ; Colour by type
    ld   a, (ix+3)
    add  a, a
    or   %01000000
    ld   (hl), a

.skip:
    ld   de, ENTITY_SIZE
    add  ix, de
    pop  bc
    djnz .loop
    ret

; ============================================================
; Data
; ============================================================
game_state:     DB   ST_TITLE

entity_array:
    DS   MAX_ENTITIES * ENTITY_SIZE
