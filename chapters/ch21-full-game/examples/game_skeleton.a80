; game_skeleton.a80 -- 128K Game Skeleton: Main Loop & State Machine
; From Chapter 21: Full Game -- ZX Spectrum 128K
;
; Demonstrates the integration architecture for "Ironclaw", a 128K
; platformer. Shows:
;   1. Main game state machine (menu -> gameplay -> game over -> menu)
;   2. Bank switching via port $7FFD with shadow variable
;   3. Entity update loop using IX register
;   4. Frame-synchronised main loop (HALT -> update -> render -> repeat)
;   5. Subsystem stubs for render, physics, input, menu, game over
;
; This is a pedagogical skeleton -- subsystems are stubs that
; demonstrate the calling convention and frame structure, not
; full implementations. A real game fills in each stub with
; code from earlier chapters (sprites Ch16, scrolling Ch17,
; collisions Ch19, etc.)
;
; Memory map:
;   $8000-$BFFF  Bank 2 (fixed) -- main game code + entity array
;   $C000-$FFFF  Switchable via port $7FFD -- data banks
;   $4000-$57FF  Bank 5 (fixed) -- screen pixels
;   $5800-$5AFF  Attributes
;
; Assembles with: sjasmplus --nologo

    ORG $8000

; ============================================================
; Constants
; ============================================================

; Game states
STATE_MENU      EQU 0
STATE_PLAY      EQU 1
STATE_OVER      EQU 2

; Entity structure offsets
ENT_FLAGS       EQU 0       ; bit 0 = active, bit 1 = visible
ENT_TYPE        EQU 1       ; 0=none, 1=player, 2=enemy, 3=bullet
ENT_X           EQU 2       ; pixel X position
ENT_Y           EQU 3       ; pixel Y position
ENT_VX          EQU 4       ; X velocity (signed)
ENT_VY          EQU 5       ; Y velocity (signed)
ENT_FRAME       EQU 6       ; animation frame
ENT_STATE       EQU 7       ; entity-specific state byte
ENT_SIZE        EQU 8       ; bytes per entity

MAX_ENTITIES    EQU 16

; Port definitions
PORT_BANK       EQU $7FFD   ; 128K bank switching
PORT_FE         EQU $FE     ; ULA (border, keyboard)

; Bank assignments (Ironclaw layout from ch21 text)
BANK_LEVELS_1   EQU 0       ; level data 1-2
BANK_LEVELS_2   EQU 1       ; level data 3-5
BANK_SPRITES    EQU 3       ; pre-shifted sprite graphics
BANK_MUSIC_1    EQU 4       ; PT3 music (title, levels 1-3)
BANK_MUSIC_2    EQU 6       ; PT3 music (levels 4-5, boss)

; ============================================================
; Entry point
; ============================================================
entry:
    di
    ld   sp, $BFFF              ; 10T  stack at top of bank 2
    im   1                      ; 8T

    ; Initialise bank shadow: bank 0, normal screen, ROM 1
    ld   a, %00010000           ; 7T   bit4=ROM1 (48K BASIC)
    ld   (bank_shadow), a       ; 13T
    ld   bc, PORT_BANK          ; 10T
    out  (c), a                 ; 12T

    ; Clear entity array
    ld   hl, entities           ; 10T
    ld   de, entities + 1       ; 10T
    ld   bc, MAX_ENTITIES * ENT_SIZE - 1  ; 10T
    ld   (hl), 0                ; 10T
    ldir                        ; 21T/byte (last 16T)

    ; Start in menu state
    ld   a, STATE_MENU          ; 7T
    ld   (game_state), a        ; 13T

    ei                          ; 4T

; ============================================================
; Main loop -- one iteration per frame
; ============================================================
main_loop:
    halt                        ; sync to 50 Hz vsync

    ; --- Timing: border shows CPU load ---
    ld   a, 2                   ; 7T   red = working
    out  (PORT_FE), a           ; 11T

    ; --- Dispatch to current state handler ---
    ld   a, (game_state)        ; 13T
    add  a, a                   ; 4T   x2 for word table
    ld   l, a                   ; 4T
    ld   h, 0                   ; 7T
    ld   de, state_table        ; 10T
    add  hl, de                 ; 11T
    ld   e, (hl)                ; 7T
    inc  hl                     ; 6T
    ld   d, (hl)                ; 7T
    ex   de, hl                 ; 4T
    jp   (hl)                   ; 4T   jump to state handler
                                ;      handler returns here:
.return:
    ; --- Timing: black border = idle ---
    xor  a                      ; 4T
    out  (PORT_FE), a           ; 11T
    jr   main_loop              ; 12T

; State dispatch table
state_table:
    DW   state_menu
    DW   state_play
    DW   state_over

; ============================================================
; STATE_MENU -- Title screen / menu
; Waits for SPACE to start game.
; ============================================================
state_menu:
    call read_input             ; poll keyboard

    ; Check SPACE (fire) to start game
    ld   a, (input_state)       ; 13T
    bit  4, a                   ; 8T   bit 4 = fire/space
    jr   z, .done               ; 12/7T

    ; Transition: menu -> gameplay
    call init_game              ; spawn player + enemies
    ld   a, STATE_PLAY          ; 7T
    ld   (game_state), a        ; 13T

    ; Page in sprite bank for gameplay
    ld   a, BANK_SPRITES        ; 7T
    call switch_bank            ; page sprites into $C000

.done:
    jp   main_loop.return

; ============================================================
; STATE_PLAY -- Gameplay frame
; Full frame: input -> physics -> entities -> render
; ============================================================
state_play:
    ; --- 1. Read input (~200 T-states) ---
    call read_input

    ; --- 2. Update player from input (~800 T-states) ---
    call update_player

    ; --- 3. Update all entities (~4000 T-states for 16) ---
    call update_entities

    ; --- 4. Run physics / collisions (~2500 T-states) ---
    call check_collisions

    ; --- 5. Render frame (~20000 T-states) ---
    call render_frame

    ; --- Check for game over condition ---
    ld   a, (player_health)     ; 13T
    or   a                      ; 4T
    jr   nz, .alive             ; 12/7T

    ld   a, STATE_OVER          ; 7T
    ld   (game_state), a        ; 13T

.alive:
    jp   main_loop.return

; ============================================================
; STATE_OVER -- Game over screen
; Shows message, waits for SPACE, returns to menu.
; ============================================================
state_over:
    call read_input

    ld   a, (input_state)       ; 13T
    bit  4, a                   ; 8T   SPACE pressed?
    jr   z, .wait               ; 12/7T

    ld   a, STATE_MENU          ; 7T
    ld   (game_state), a        ; 13T

.wait:
    jp   main_loop.return

; ============================================================
; switch_bank -- Page bank A into $C000-$FFFF
;
; Uses shadow variable to preserve ROM/screen select bits.
; In:  A = bank number (0-7)
; Out: bank mapped at $C000, shadow updated
; ============================================================
switch_bank:
    ld   b, a                   ; 4T   save bank number
    ld   a, (bank_shadow)       ; 13T  current $7FFD state
    and  %11111000              ; 7T   clear bank bits 0-2
    or   b                      ; 4T   merge new bank
    ld   (bank_shadow), a       ; 13T  update shadow
    ld   bc, PORT_BANK          ; 10T
    out  (c), a                 ; 12T  write to hardware
    ret                         ; 10T
                                ; --- 73T total

; ============================================================
; read_input -- Poll keyboard (QAOP + SPACE)
;
; Result in input_state:
;   bit 0 = right (P), bit 1 = left (O)
;   bit 2 = down (A),  bit 3 = up (Q)
;   bit 4 = fire (SPACE)
; ============================================================
read_input:
    ld   d, 0                   ; 7T   accumulate bits

    ; P (right) and O (left) -- half-row $DFFE
    ld   bc, $DFFE              ; 10T
    in   a, (c)                 ; 12T
    bit  0, a                   ; 8T   P key (active low)
    jr   nz, .no_right          ; 12/7T
    set  0, d                   ; 8T
.no_right:
    bit  1, a                   ; 8T   O key
    jr   nz, .no_left           ; 12/7T
    set  1, d                   ; 8T
.no_left:

    ; A (down) -- half-row $FDFE
    ld   b, $FD                 ; 7T
    in   a, (c)                 ; 12T
    bit  0, a                   ; 8T
    jr   nz, .no_down           ; 12/7T
    set  2, d                   ; 8T
.no_down:

    ; Q (up) -- half-row $FBFE
    ld   b, $FB                 ; 7T
    in   a, (c)                 ; 12T
    bit  0, a                   ; 8T
    jr   nz, .no_up             ; 12/7T
    set  3, d                   ; 8T
.no_up:

    ; SPACE (fire) -- half-row $7FFE
    ld   b, $7F                 ; 7T
    in   a, (c)                 ; 12T
    bit  0, a                   ; 8T
    jr   nz, .no_fire           ; 12/7T
    set  4, d                   ; 8T
.no_fire:

    ld   a, d                   ; 4T
    ld   (input_state), a       ; 13T
    ret                         ; 10T

; ============================================================
; init_game -- Set up player and enemies for a new game
; ============================================================
init_game:
    ; Clear entity array
    ld   hl, entities           ; 10T
    ld   de, entities + 1       ; 10T
    ld   bc, MAX_ENTITIES * ENT_SIZE - 1
    ld   (hl), 0                ; 10T
    ldir

    ; Spawn player in slot 0
    ld   ix, entities           ; 14T
    ld   (ix+ENT_FLAGS), %00000011  ; 19T  active + visible
    ld   (ix+ENT_TYPE), 1       ; 19T  type = player
    ld   (ix+ENT_X), 32         ; 19T  start X
    ld   (ix+ENT_Y), 160        ; 19T  start Y
    ld   (ix+ENT_VX), 0         ; 19T
    ld   (ix+ENT_VY), 0         ; 19T

    ; Reset player health
    ld   a, 3
    ld   (player_health), a

    ; Spawn 4 enemies in slots 1-4
    ld   ix, entities + ENT_SIZE
    ld   b, 4
    ld   c, 40                  ; starting X

.spawn_loop:
    push bc
    ld   (ix+ENT_FLAGS), %00000011  ; 19T  active + visible
    ld   (ix+ENT_TYPE), 2       ; 19T  type = enemy
    ld   (ix+ENT_X), c          ; 19T
    ld   (ix+ENT_Y), 48         ; 19T
    ld   (ix+ENT_VX), 1         ; 19T  patrol right
    ld   (ix+ENT_VY), 0         ; 19T

    ; Advance IX to next entity slot
    ld   de, ENT_SIZE           ; 10T
    add  ix, de                 ; 15T
    pop  bc
    ld   a, c                   ; 4T
    add  a, 48                  ; 7T   space enemies apart
    ld   c, a                   ; 4T
    djnz .spawn_loop            ; 13/8T
    ret

; ============================================================
; update_entities -- Walk entity array, call update per type
; Uses IX to walk the entity array. Inner loop cycle budget:
;   inactive skip path: ~50T per entity
;   active entity path: ~80T + handler cost
; ============================================================
update_entities:
    ld   ix, entities           ; 14T
    ld   b, MAX_ENTITIES        ; 7T

.loop:
    push bc                     ; 11T
    ld   a, (ix+ENT_FLAGS)      ; 19T
    bit  0, a                   ; 8T   active?
    jr   z, .skip               ; 12/7T

    ; Dispatch by entity type
    ld   a, (ix+ENT_TYPE)       ; 19T
    cp   2                      ; 7T
    jr   z, .enemy              ; 12/7T
    cp   3                      ; 7T
    jr   z, .bullet             ; 12/7T
    jr   .skip                  ; 12T  player handled separately

.enemy:
    call update_enemy           ; patrol AI
    jr   .skip

.bullet:
    call update_bullet          ; move + bounds check
    ; fall through

.skip:
    ld   de, ENT_SIZE           ; 10T
    add  ix, de                 ; 15T  advance to next entity
    pop  bc                     ; 10T
    djnz .loop                  ; 13/8T
    ret                         ; 10T

; ============================================================
; update_player -- Apply input to player entity
; ============================================================
update_player:
    ld   ix, entities           ; player is slot 0

    ld   a, (input_state)       ; 13T
    bit  0, a                   ; 8T   right?
    jr   z, .no_right           ; 12/7T
    inc  (ix+ENT_X)             ; 23T  move right 1px
.no_right:
    bit  1, a                   ; 8T   left?
    jr   z, .no_left            ; 12/7T
    dec  (ix+ENT_X)             ; 23T  move left 1px
.no_left:

    ; Apply gravity stub (simplified)
    call apply_gravity
    ret

; ============================================================
; update_enemy -- Simple patrol: move horizontally, bounce
; IX = pointer to current entity
; ============================================================
update_enemy:
    ld   a, (ix+ENT_X)         ; 19T  current X
    add  a, (ix+ENT_VX)        ; 19T  + velocity
    ld   (ix+ENT_X), a         ; 19T  store new X

    ; Bounce at screen edges
    cp   240                    ; 7T
    jr   c, .no_right           ; 12/7T
    ld   (ix+ENT_VX), -1       ; 19T  reverse: go left
    ret
.no_right:
    cp   8                      ; 7T
    jr   nc, .done              ; 12/7T
    ld   (ix+ENT_VX), 1        ; 19T  reverse: go right
.done:
    ret

; ============================================================
; update_bullet -- Move bullet, deactivate if off-screen
; IX = pointer to current entity
; ============================================================
update_bullet:
    ld   a, (ix+ENT_X)         ; 19T
    add  a, (ix+ENT_VX)        ; 19T
    ld   (ix+ENT_X), a         ; 19T

    ; Off-screen check
    cp   248                    ; 7T
    jr   nc, .kill              ; 12/7T
    or   a                      ; 4T
    ret  nz                     ; 11/5T still on screen
.kill:
    ld   (ix+ENT_FLAGS), 0     ; 19T  deactivate
    ret

; ============================================================
; Subsystem stubs -- placeholders for full implementations
; In a real game, these would be the routines from:
;   render_frame    -> Ch16 sprites + Ch17 scrolling
;   check_collisions -> Ch19 AABB tests
;   apply_gravity   -> Ch18 fixed-point physics
; ============================================================
render_frame:
    ret                         ; stub: real code draws tiles + sprites

check_collisions:
    ret                         ; stub: real code tests AABB overlaps

apply_gravity:
    ret                         ; stub: real code applies 8.8 velocity

; ============================================================
; Data
; ============================================================
game_state:     DB STATE_MENU
input_state:    DB 0
player_health:  DB 3
bank_shadow:    DB %00010000    ; shadow of port $7FFD
                                ; bit4 = ROM1, bits 0-2 = bank 0

; Entity array: 16 entities x 8 bytes = 128 bytes
entities:
    DS MAX_ENTITIES * ENT_SIZE
