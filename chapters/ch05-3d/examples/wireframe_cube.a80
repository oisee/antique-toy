; Chapter 5: Wireframe Cube — Spinning 3D cube with perspective projection
; Demonstrates: rotation, perspective projection, Bresenham line drawing
; Uses Dark's rotate_pair method (Spectrum Expert #01-02, 1997-98)
;
; 8 vertices, 12 edges — a cube centered at the origin
; 4 basis vertices rotated, 4 derived by negation (mirroring)
;
; Target: ZX Spectrum 128K, Pentagon timing
; Assembles with: mza --target zxspectrum

    ORG $8000

; ============================================================
; Constants
; ============================================================
SCREEN      EQU $4000
SCREEN_END  EQU $5800
ATTR_START  EQU $5800
VIEW_DIST   EQU 200        ; viewer distance for perspective
NUM_VERTS   EQU 8
NUM_EDGES   EQU 12

; ============================================================
; Entry point
; ============================================================
start:
    di
    ld   sp, $7FFE

    call clear_screen

    ; Set attributes: white ink, black paper, bright
    ld   hl, ATTR_START
    ld   de, ATTR_START + 1
    ld   (hl), $47          ; %01000111 = bright, paper=0, ink=7
    ld   bc, 767
    ldir

    ; Set border to black
    xor  a
    out  ($FE), a

    ; Init angles to 0
    xor  a
    ld   (angle_x), a
    ld   (angle_y), a
    ld   (angle_z), a

    ei

; ============================================================
; Main loop — one frame per iteration
; ============================================================
main_loop:
    halt

    ; Border red = working
    ld   a, 2
    out  ($FE), a

    ; --- Step 1: Rotate 4 basis vertices ---
    ld   hl, basis_verts
    ld   de, rotated
    ld   b, 4

.rot_loop:
    push bc
    push de
    push hl

    ; Copy basis vertex into vert_in
    ld   a, (hl)
    ld   (vert_in), a
    inc  hl
    ld   a, (hl)
    ld   (vert_in+1), a
    inc  hl
    ld   a, (hl)
    ld   (vert_in+2), a

    call rotate_xyz

    ; Copy vert_out to rotated buffer
    pop  hl
    pop  de
    push hl
    ld   a, (vert_out)
    ld   (de), a
    inc  de
    ld   a, (vert_out+1)
    ld   (de), a
    inc  de
    ld   a, (vert_out+2)
    ld   (de), a
    inc  de

    pop  hl
    ; Advance basis pointer by 3
    inc  hl
    inc  hl
    inc  hl

    pop  bc
    djnz .rot_loop

    ; --- Step 2: Derive vertices 4-7 by negating 0-3 ---
    ; v4 = -v0, v5 = -v1, v6 = -v2, v7 = -v3
    ld   hl, rotated
    ld   de, rotated + 12       ; v4 starts at offset 12
    ld   b, 4

.neg_loop:
    push bc

    ; Negate x
    ld   a, (hl)
    neg
    ld   (de), a
    inc  hl
    inc  de

    ; Negate y
    ld   a, (hl)
    neg
    ld   (de), a
    inc  hl
    inc  de

    ; Negate z
    ld   a, (hl)
    neg
    ld   (de), a
    inc  hl
    inc  de

    pop  bc
    djnz .neg_loop

    ; --- Step 3: Project all 8 vertices to 2D ---
    call project_all

    ; --- Step 4: Clear screen ---
    call clear_screen

    ; --- Step 5: Draw 12 edges ---
    call draw_all_edges

    ; --- Step 6: Update angles ---
    ld   a, (angle_y)
    add  a, 3
    ld   (angle_y), a
    ld   a, (angle_x)
    add  a, 1
    ld   (angle_x), a
    ld   a, (angle_z)
    add  a, 2
    ld   (angle_z), a

    ; Border black = idle
    xor  a
    out  ($FE), a

    jr   main_loop

; ============================================================
; PROJECT_ALL — Project all 8 vertices to 2D screen coords
; ============================================================
project_all:
    ld   hl, rotated
    ld   de, proj_buf
    ld   b, NUM_VERTS

.loop:
    push bc
    push de
    push hl

    ; Load rotated vertex into vert_out for project
    ld   a, (hl)
    ld   (vert_out), a
    inc  hl
    ld   a, (hl)
    ld   (vert_out+1), a
    inc  hl
    ld   a, (hl)
    ld   (vert_out+2), a

    call project

    ; Store projected coords
    pop  hl
    pop  de
    ld   a, (screen_x)
    ld   (de), a
    inc  de
    ld   a, (screen_y)
    ld   (de), a
    inc  de

    ; Advance rotated pointer by 3
    inc  hl
    inc  hl
    inc  hl

    push de
    push hl
    pop  de            ; DE = updated HL (rotated pointer)
    pop  hl            ; HL = updated DE (proj pointer)
    ex   de, hl        ; swap back: HL = rotated, DE = proj

    pop  bc
    djnz .loop
    ret

; ============================================================
; DRAW_ALL_EDGES — Draw wireframe edges using the edge list
; ============================================================
draw_all_edges:
    ld   ix, edge_list
    ld   b, NUM_EDGES

.loop:
    push bc

    ; Get first vertex index, look up projected coords
    ld   a, (ix+0)
    call lookup_proj
    ld   a, (hl)
    ld   (line_x0), a
    inc  hl
    ld   a, (hl)
    ld   (line_y0), a

    ; Get second vertex index, look up projected coords
    ld   a, (ix+1)
    call lookup_proj
    ld   a, (hl)
    ld   (line_x1), a
    inc  hl
    ld   a, (hl)
    ld   (line_y1), a

    ; Bounds check: skip if any Y >= 192
    ld   a, (line_y0)
    cp   192
    jr   nc, .skip
    ld   a, (line_y1)
    cp   192
    jr   nc, .skip

    call draw_line

.skip:
    ; Advance IX by 2
    ld   bc, 2
    add  ix, bc
    pop  bc
    djnz .loop
    ret

; Look up projected coords for vertex A
; Returns HL pointing to (x, y) pair in proj_buf
lookup_proj:
    ld   l, a
    ld   h, 0
    add  hl, hl           ; *2 (2 bytes per vertex)
    ld   de, proj_buf
    add  hl, de
    ret

; ============================================================
; ROTATE_XYZ — 3-axis rotation via rotate_pair
; Rotates (vert_in) by (angle_x, angle_y, angle_z)
; Result in (vert_out)
; ============================================================
rotate_xyz:
    ; Copy vert_in to vert_out
    ld   a, (vert_in)
    ld   (vert_out), a
    ld   a, (vert_in+1)
    ld   (vert_out+1), a
    ld   a, (vert_in+2)
    ld   (vert_out+2), a

    ; Z-axis rotation: affects X, Y
    ld   a, (angle_z)
    call get_sincos
    ld   a, d
    ld   (cur_sin), a
    ld   a, e
    ld   (cur_cos), a
    ld   a, (vert_out)
    ld   (coord_a), a
    ld   a, (vert_out+1)
    ld   (coord_b), a
    call rotate_pair
    ld   a, (result_a)
    ld   (vert_out), a
    ld   a, (result_b)
    ld   (vert_out+1), a

    ; Y-axis rotation: affects X, Z
    ld   a, (angle_y)
    call get_sincos
    ld   a, d
    ld   (cur_sin), a
    ld   a, e
    ld   (cur_cos), a
    ld   a, (vert_out)
    ld   (coord_a), a
    ld   a, (vert_out+2)
    ld   (coord_b), a
    call rotate_pair
    ld   a, (result_a)
    ld   (vert_out), a
    ld   a, (result_b)
    ld   (vert_out+2), a

    ; X-axis rotation: affects Y, Z
    ld   a, (angle_x)
    call get_sincos
    ld   a, d
    ld   (cur_sin), a
    ld   a, e
    ld   (cur_cos), a
    ld   a, (vert_out+1)
    ld   (coord_a), a
    ld   a, (vert_out+2)
    ld   (coord_b), a
    call rotate_pair
    ld   a, (result_a)
    ld   (vert_out+1), a
    ld   a, (result_b)
    ld   (vert_out+2), a
    ret

; ============================================================
; ROTATE_PAIR — 2D rotation subroutine
; (coord_a, coord_b) rotated by (cur_sin, cur_cos)
; a' = (a*cos - b*sin) >> 7
; b' = (a*sin + b*cos) >> 7
; ============================================================
rotate_pair:
    ; a' = a*cos - b*sin
    ld   a, (coord_a)
    ld   d, a
    ld   a, (cur_cos)
    ld   e, a
    call muls8
    ld   (temp_w0), hl      ; temp = a*cos

    ld   a, (coord_b)
    ld   d, a
    ld   a, (cur_sin)
    ld   e, a
    call muls8              ; HL = b*sin

    ex   de, hl
    ld   hl, (temp_w0)
    or   a
    sbc  hl, de             ; HL = a*cos - b*sin
    add  hl, hl             ; shift left to get >>7 via H
    ld   a, h
    ld   (result_a), a

    ; b' = a*sin + b*cos
    ld   a, (coord_a)
    ld   d, a
    ld   a, (cur_sin)
    ld   e, a
    call muls8
    ld   (temp_w0), hl      ; temp = a*sin

    ld   a, (coord_b)
    ld   d, a
    ld   a, (cur_cos)
    ld   e, a
    call muls8              ; HL = b*cos

    ld   de, (temp_w0)
    add  hl, de             ; HL = a*sin + b*cos
    add  hl, hl
    ld   a, h
    ld   (result_b), a
    ret

; ============================================================
; GET_SINCOS — Look up sin and cos for angle A
; Returns D=sin(A), E=cos(A)
; ============================================================
get_sincos:
    ld   hl, sin_table
    ld   l, a               ; page-aligned: H stays correct
    ld   d, (hl)            ; D = sin(A)
    add  a, 64
    ld   l, a
    ld   e, (hl)            ; E = cos(A) = sin(A+64)
    ret

; ============================================================
; PROJECT — Perspective projection
; vert_out (x,y,z) → screen_x, screen_y
; scale = VIEW_DIST * 128 / (z + VIEW_DIST)
; screen_x = x * scale >> 7 + 128
; screen_y = y * scale >> 7 + 96
; ============================================================
project:
    ; Compute z + VIEW_DIST (16-bit)
    ld   a, (vert_out+2)
    ld   e, a
    ld   d, 0
    bit  7, a
    jr   z, .zpos
    dec  d                  ; sign-extend negative z
.zpos:
    ld   hl, VIEW_DIST
    add  hl, de             ; HL = z + VIEW_DIST

    ; Guard: if HL <= 0, clip
    bit  7, h
    jr   nz, .clip
    ld   a, h
    or   l
    jr   z, .clip

    ; Divide VIEW_DIST * 128 by (z + VIEW_DIST)
    ld   b, h
    ld   c, l
    ld   hl, VIEW_DIST * 128
    call div16              ; HL = quotient

    ; Clamp scale to 255
    ld   a, h
    or   a
    jr   z, .scale_ok
    ld   l, 255
.scale_ok:
    ld   a, l
    ld   (proj_scale), a

    ; screen_x = x * scale >> 7 + 128
    ld   a, (vert_out)
    ld   d, a
    ld   a, (proj_scale)
    ld   e, a
    call muls8
    add  hl, hl             ; >>7 via taking H after <<1
    ld   a, h
    add  a, 128
    ld   (screen_x), a

    ; screen_y = y * scale >> 7 + 96
    ld   a, (vert_out+1)
    ld   d, a
    ld   a, (proj_scale)
    ld   e, a
    call muls8
    add  hl, hl
    ld   a, h
    add  a, 96
    ld   (screen_y), a

    or   a
    ret

.clip:
    ld   a, 255
    ld   (screen_x), a
    ld   (screen_y), a
    scf
    ret

; ============================================================
; MULU8 — Unsigned 8x8 multiply: A * E → HL
; ============================================================
mulu8:
    ld   d, 0
    ld   h, d
    ld   l, d
    ld   b, 8
.loop:
    add  hl, hl
    rla
    jr   nc, .skip
    add  hl, de
.skip:
    djnz .loop
    ret

; ============================================================
; MULS8 — Signed 8x8 multiply: D * E → HL
; ============================================================
muls8:
    ld   a, d
    xor  e
    push af                 ; save result sign in bit 7
    ld   a, d
    or   a
    jp   p, .d_pos
    neg
.d_pos:
    ld   d, a
    ld   a, e
    or   a
    jp   p, .e_pos
    neg
.e_pos:
    ld   e, a
    ld   a, d
    call mulu8
    pop  af
    ret  p                  ; positive result — done
    ; Negate HL
    xor  a
    sub  l
    ld   l, a
    sbc  a, a
    sub  h
    ld   h, a
    ret

; ============================================================
; DIV16 — 16-bit division: HL / BC → HL quotient
; ============================================================
div16:
    ld   de, 0
    ld   a, 16
.loop:
    add  hl, hl
    rl   e
    rl   d
    push hl
    ex   de, hl
    or   a
    sbc  hl, bc
    jr   c, .too_small
    ex   de, hl
    pop  hl
    inc  l
    dec  a
    jr   nz, .loop
    ret
.too_small:
    add  hl, bc
    ex   de, hl
    pop  hl
    dec  a
    jr   nz, .loop
    ret

; ============================================================
; PIXEL_ADDR — Compute screen address and pixel mask
; Input: B=x (0-255), C=y (0-191)
; Output: HL=screen address, A=pixel bitmask
; ============================================================
pixel_addr:
    ld   a, c
    and  $C0
    rrca
    rrca
    rrca
    ld   h, a
    ld   a, c
    and  $07
    or   h
    or   $40
    ld   h, a

    ld   a, c
    and  $38
    rlca
    rlca
    ld   l, a
    ld   a, b
    rrca
    rrca
    rrca
    and  $1F
    or   l
    ld   l, a

    ld   a, b
    and  7
    jr   z, .bit0
    ld   d, a
    ld   a, $80
.shift:
    rrca
    dec  d
    jr   nz, .shift
    ret
.bit0:
    ld   a, $80
    ret

; ============================================================
; DOWN_HL / UP_HL — Move screen address one scan line
; ============================================================
down_hl:
    inc  h
    ld   a, h
    and  7
    ret  nz
    ld   a, l
    add  a, 32
    ld   l, a
    ret  c
    ld   a, h
    sub  8
    ld   h, a
    ret

up_hl:
    dec  h
    ld   a, h
    and  7
    cp   7
    ret  nz
    ld   a, l
    sub  32
    ld   l, a
    ret  c
    ld   a, h
    add  a, 8
    ld   h, a
    ret

step_y:
    ld   a, (y_dir)
    or   a
    jr   z, up_hl
    jr   down_hl

; ============================================================
; DRAW_LINE — Bresenham line drawing
; Input: line_x0, line_y0, line_x1, line_y1
; ============================================================
draw_line:
    ; Normalise to left-to-right (x0 <= x1)
    ld   a, (line_x1)
    ld   b, a
    ld   a, (line_x0)
    cp   b
    jr   c, .no_swap
    jr   z, .no_swap

    ; Swap endpoints
    ld   c, a
    ld   a, b
    ld   (line_x0), a
    ld   a, c
    ld   (line_x1), a
    ld   a, (line_y0)
    ld   c, a
    ld   a, (line_y1)
    ld   (line_y0), a
    ld   a, c
    ld   (line_y1), a
.no_swap:

    ; Compute dx
    ld   a, (line_x1)
    ld   b, a
    ld   a, (line_x0)
    ld   c, a
    ld   a, b
    sub  c
    ld   (line_dx), a

    ; Compute dy and y direction
    ld   a, (line_y0)
    ld   b, a
    ld   a, (line_y1)
    sub  b
    jr   nc, .y_down
    neg
    ld   (line_dy), a
    xor  a
    ld   (y_dir), a
    jr   .setup
.y_down:
    ld   (line_dy), a
    ld   a, 1
    ld   (y_dir), a

.setup:
    ; Get starting pixel address and mask
    ld   a, (line_x0)
    ld   b, a
    ld   a, (line_y0)
    ld   c, a
    call pixel_addr
    ld   c, a               ; C = pixel mask

    ; Self-modify comparison values for Bresenham
    ld   a, (line_dx)
    ld   (.smc_hcmp + 1), a
    ld   (.smc_hsub + 1), a

    ; Determine major axis
    ld   a, (line_dx)
    ld   d, a
    ld   a, (line_dy)
    cp   d
    jr   nc, .vmaj

    ; === Horizontal-major ===
    ld   a, (line_dx)
    ld   b, a
    inc  b
    ld   a, (line_dy)
    ld   e, a
    xor  a

.h_pixel:
    ld   d, a
    ld   a, c
    or   (hl)
    ld   (hl), a
    ld   a, d
    dec  b
    ret  z
    rrc  c
    jr   nc, .h_nb
    inc  l
.h_nb:
    add  a, e
.smc_hcmp:
    cp   0
    jr   c, .h_pixel
.smc_hsub:
    sub  0
    push af
    call step_y
    pop  af
    jr   .h_pixel

    ; === Vertical-major ===
.vmaj:
    ld   a, (line_dy)
    ld   (.smc_vcmp + 1), a
    ld   (.smc_vsub + 1), a

    ld   a, (line_dy)
    ld   b, a
    inc  b
    ld   a, (line_dx)
    ld   e, a
    xor  a

.v_pixel:
    ld   d, a
    ld   a, c
    or   (hl)
    ld   (hl), a
    ld   a, d
    dec  b
    ret  z
    push af
    call step_y
    pop  af
    add  a, e
.smc_vcmp:
    cp   0
    jr   c, .v_pixel
.smc_vsub:
    sub  0
    rrc  c
    jr   nc, .v_pixel
    inc  l
    jr   .v_pixel

; ============================================================
; CLEAR_SCREEN — Fast PUSH-based screen clear (~34,000 T)
; ============================================================
clear_screen:
    di
    ld   (cs_sp + 1), sp
    ld   sp, SCREEN_END
    ld   hl, 0
    ld   b, 192
.loop:
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    djnz .loop
cs_sp:
    ld   sp, 0
    ei
    ret

; ============================================================
; Sin/Cos lookup table (256 entries, page-aligned)
; sin(i) = round(127 * sin(2*pi*i/256)), signed 8-bit
; cos(i) = sin(i + 64)
; ============================================================
    ALIGN 256
sin_table:
    ; 0..63 (0 to 90 degrees)
    DB   0,   3,   6,   9,  12,  16,  19,  22
    DB  25,  28,  31,  34,  37,  40,  43,  46
    DB  49,  51,  54,  57,  60,  63,  65,  68
    DB  71,  73,  76,  78,  81,  83,  85,  88
    DB  90,  92,  94,  96,  98, 100, 102, 104
    DB 106, 107, 109, 111, 112, 113, 115, 116
    DB 117, 118, 120, 121, 122, 122, 123, 124
    DB 125, 125, 126, 126, 126, 127, 127, 127
    ; 64..127 (90 to 180 degrees)
    DB 127, 127, 127, 126, 126, 126, 125, 125
    DB 124, 123, 122, 122, 121, 120, 118, 117
    DB 116, 115, 113, 112, 111, 109, 107, 106
    DB 104, 102, 100,  98,  96,  94,  92,  90
    DB  88,  85,  83,  81,  78,  76,  73,  71
    DB  68,  65,  63,  60,  57,  54,  51,  49
    DB  46,  43,  40,  37,  34,  31,  28,  25
    DB  22,  19,  16,  12,   9,   6,   3,   0
    ; 128..191 (180 to 270 degrees — negative values)
    DB    0,  -3,  -6,  -9, -12, -16, -19, -22
    DB  -25, -28, -31, -34, -37, -40, -43, -46
    DB  -49, -51, -54, -57, -60, -63, -65, -68
    DB  -71, -73, -76, -78, -81, -83, -85, -88
    DB  -90, -92, -94, -96, -98,-100,-102,-104
    DB -106,-107,-109,-111,-112,-113,-115,-116
    DB -117,-118,-120,-121,-122,-122,-123,-124
    DB -125,-125,-126,-126,-126,-127,-127,-127
    ; 192..255 (270 to 360 degrees)
    DB -127,-127,-127,-126,-126,-126,-125,-125
    DB -124,-123,-122,-122,-121,-120,-118,-117
    DB -116,-115,-113,-112,-111,-109,-107,-106
    DB -104,-102,-100, -98, -96, -94, -92, -90
    DB  -88, -85, -83, -81, -78, -76, -73, -71
    DB  -68, -65, -63, -60, -57, -54, -51, -49
    DB  -46, -43, -40, -37, -34, -31, -28, -25
    DB  -22, -19, -16, -12,  -9,  -6,  -3,   0

; ============================================================
; Cube data
; ============================================================

; 4 basis vertices — one "half" of the cube
; Cube side length ~70 units (half-side = 35)
; v0 = (+35, +35, +35)
; v1 = (+35, +35, -35)  → unsigned: (+35, +35, 221)
; v2 = (+35, -35, +35)  → unsigned: (+35, 221, +35)
; v3 = (+35, -35, -35)  → unsigned: (+35, 221, 221)
; Mirrors (derived by negation):
; v4 = (-35, -35, -35)
; v5 = (-35, -35, +35)
; v6 = (-35, +35, -35)
; v7 = (-35, +35, +35)
basis_verts:
    DB  35,  35,  35        ; v0
    DB  35,  35, -35        ; v1 (z = -35)
    DB  35, -35,  35        ; v2 (y = -35)
    DB  35, -35, -35        ; v3 (y = -35, z = -35)

; 12 edges of a cube (vertex index pairs)
; Cube edges connect:
;   Top face (y=+35):  v0-v1, v1-v6, v6-v7, v7-v0
;   Bottom face (y=-35): v2-v3, v3-v4, v4-v5, v5-v2
;   Verticals:          v0-v2, v1-v3, v6-v4, v7-v5
edge_list:
    ; Top face edges
    DB  0, 1                ; v0—v1
    DB  1, 6                ; v1—v6
    DB  6, 7                ; v6—v7
    DB  7, 0                ; v7—v0
    ; Bottom face edges
    DB  2, 3                ; v2—v3
    DB  3, 4                ; v3—v4
    DB  4, 5                ; v4—v5
    DB  5, 2                ; v5—v2
    ; Vertical edges
    DB  0, 2                ; v0—v2
    DB  1, 3                ; v1—v3
    DB  6, 4                ; v6—v4
    DB  7, 5                ; v7—v5

; ============================================================
; Variables and buffers
; ============================================================
vert_in:     DS 3
vert_out:    DS 3
angle_x:     DB 0
angle_y:     DB 0
angle_z:     DB 0
cur_sin:     DB 0
cur_cos:     DB 0
coord_a:     DB 0
coord_b:     DB 0
result_a:    DB 0
result_b:    DB 0
temp_w0:     DW 0
proj_scale:  DB 0
screen_x:    DB 0
screen_y:    DB 0

line_x0:     DB 0
line_y0:     DB 0
line_x1:     DB 0
line_y1:     DB 0
line_dx:     DB 0
line_dy:     DB 0
y_dir:       DB 0

rotated:     DS NUM_VERTS * 3   ; 24 bytes: 8 rotated vertices
proj_buf:    DS NUM_VERTS * 2   ; 16 bytes: 8 projected (x,y) pairs
