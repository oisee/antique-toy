; draw.a80 — Drawing routines for torus demo
; Pixel addressing, Bresenham line, screen clear
;
; Assembles with: mza --target zxspectrum
; Included by torus.a80

SCREEN      EQU $4000
SCREEN_END  EQU $5800
ATTR_START  EQU $5800

; ============================================================
; PIXEL_ADDR — Screen address and bit mask for pixel (x, y)
; Input:  B = x (0-255), C = y (0-191)
; Output: HL = screen byte address, A = pixel bit mask
; Destroys: D
;
; Spectrum layout: H = 010 Y7Y6 Y2Y1Y0, L = Y5Y4Y3 XXXXX
; ============================================================
pixel_addr:
    ; H = 010 Y7Y6 Y2Y1Y0
    ld   a, c            ; y
    and  $C0             ; Y7 Y6
    rrca
    rrca
    rrca                 ; >> 3 → bits 4,3
    ld   h, a
    ld   a, c
    and  $07             ; Y2 Y1 Y0
    or   h
    or   $40             ; screen base
    ld   h, a

    ; L = Y5Y4Y3 X7X6X5X4X3
    ld   a, c            ; y
    and  $38             ; Y5 Y4 Y3
    rlca
    rlca                 ; << 2 → bits 7,6,5
    ld   l, a
    ld   a, b            ; x
    rrca
    rrca
    rrca                 ; >> 3
    and  $1F             ; column 0-31
    or   l
    ld   l, a

    ; Mask = $80 >> (x & 7)
    ld   a, b
    and  7
    jr   z, .bit0
    ld   d, a
    ld   a, $80
.shift:
    rrca
    dec  d
    jr   nz, .shift
    ret
.bit0:
    ld   a, $80
    ret

; ============================================================
; DOWN_HL — Move screen address one scan line down
; Input/Output: HL
; Destroys: A
; ~18 T average (fast path: 15 T)
; ============================================================
down_hl:
    inc  h
    ld   a, h
    and  7
    ret  nz              ; still in char cell — done    ; 15 T

    ; Crossed char cell: L += 32, fix H
    ld   a, l
    add  a, 32
    ld   l, a
    ret  c               ; third boundary — H already correct
    ld   a, h
    sub  8
    ld   h, a
    ret

; ============================================================
; UP_HL — Move screen address one scan line up
; Input/Output: HL
; Destroys: A
; ============================================================
up_hl:
    dec  h
    ld   a, h
    and  7
    cp   7
    ret  nz              ; still in char cell

    ; Crossed char cell upward
    ld   a, l
    sub  32
    ld   l, a
    ret  c               ; third boundary — H correct
    ld   a, h
    add  a, 8
    ld   h, a
    ret

; ============================================================
; DRAW_LINE — Bresenham line from (x0,y0) to (x1,y1)
; Input:  line_x0, line_y0, line_x1, line_y1
; Destroys: all registers
;
; Normalises to left-to-right (dx >= 0), then runs
; horizontal-major or vertical-major inner loop.
; Uses self-modifying code for dx comparison in inner loop.
; ~75 T per pixel (horizontal-major, no Y step)
; ============================================================
draw_line:
    ; Ensure x0 <= x1 (draw left-to-right)
    ld   a, (line_x1)
    ld   b, a
    ld   a, (line_x0)
    cp   b
    jr   c, .no_swap     ; x0 < x1
    jr   z, .no_swap     ; x0 == x1

    ; Swap both endpoints
    ld   c, a            ; C = old x0
    ld   a, b
    ld   (line_x0), a    ; x0 = old x1
    ld   a, c
    ld   (line_x1), a    ; x1 = old x0
    ld   a, (line_y0)
    ld   c, a
    ld   a, (line_y1)
    ld   (line_y0), a
    ld   a, c
    ld   (line_y1), a
.no_swap:

    ; dx = x1 - x0 (>= 0)
    ld   a, (line_x1)
    ld   b, a
    ld   a, (line_x0)
    ld   c, a
    ld   a, b
    sub  c
    ld   (line_dx), a

    ; dy = |y1 - y0|, Y direction
    ld   a, (line_y0)
    ld   b, a
    ld   a, (line_y1)
    sub  b               ; A = y1 - y0
    jr   nc, .y_down     ; y1 >= y0: going down

    ; Going up
    neg                  ; A = |dy|
    ld   (line_dy), a
    xor  a
    ld   (y_dir), a      ; 0 = up
    jr   .setup

.y_down:
    ld   (line_dy), a
    ld   a, 1
    ld   (y_dir), a      ; 1 = down

.setup:
    ; Starting pixel address
    ld   a, (line_x0)
    ld   b, a
    ld   a, (line_y0)
    ld   c, a
    call pixel_addr      ; HL = addr, A = mask
    ld   c, a            ; C = pixel mask

    ; Self-modify dx into CP and SUB instructions
    ld   a, (line_dx)
    ld   (smc_hcmp + 1), a
    ld   (smc_hsub + 1), a
    ld   (smc_vcmp + 1), a
    ld   (smc_vsub + 1), a

    ; Choose major axis
    ld   a, (line_dx)
    ld   d, a
    ld   a, (line_dy)
    cp   d               ; dy vs dx
    jr   nc, .vmaj       ; dy >= dx → vertical-major

; ============================================================
; Horizontal-major inner loop
; B = dx+1 pixels, E = dy, C = mask, HL = screen addr
; A = Bresenham error accumulator
; ============================================================
    ld   a, (line_dx)
    ld   b, a
    inc  b               ; pixels = dx + 1
    ld   a, (line_dy)
    ld   e, a            ; E = dy
    xor  a               ; error = 0

.h_pixel:
    ; --- Plot ---
    ld   d, a            ; save error
    ld   a, c
    or   (hl)
    ld   (hl), a
    ld   a, d            ; restore error

    dec  b
    ret  z               ; all pixels drawn

    ; --- Step X right ---
    rrc  c               ; mask >>= 1
    jr   nc, .h_no_byte
    inc  l               ; crossed byte → next column
.h_no_byte:

    ; --- Bresenham ---
    add  a, e            ; error += dy
smc_hcmp:
    cp   0               ; error >= dx? (self-modified)
    jr   c, .h_pixel     ; no → next pixel
smc_hsub:
    sub  0               ; error -= dx (self-modified)

    ; --- Step Y ---
    push af
    call step_y
    pop  af
    jr   .h_pixel

; ============================================================
; Vertical-major inner loop
; B = dy+1 pixels, E = dx, C = mask, HL = screen addr
; ============================================================
.vmaj:
    ; Self-modify dy into comparison
    ld   a, (line_dy)
    ld   (smc_vcmp + 1), a
    ld   (smc_vsub + 1), a

    ld   a, (line_dy)
    ld   b, a
    inc  b               ; pixels = dy + 1
    ld   a, (line_dx)
    ld   e, a            ; E = dx
    xor  a               ; error = 0

.v_pixel:
    ; --- Plot ---
    ld   d, a
    ld   a, c
    or   (hl)
    ld   (hl), a
    ld   a, d

    dec  b
    ret  z

    ; --- Step Y (always) ---
    push af
    call step_y
    pop  af

    ; --- Bresenham ---
    add  a, e            ; error += dx
smc_vcmp:
    cp   0               ; error >= dy? (self-modified)
    jr   c, .v_pixel
smc_vsub:
    sub  0               ; error -= dy (self-modified)

    ; --- Step X right ---
    rrc  c
    jr   nc, .v_pixel
    inc  l
    jr   .v_pixel

; ============================================================
; STEP_Y — Step one scan line in current Y direction
; Reads y_dir flag: 0=up, 1=down
; Destroys: A
; ============================================================
step_y:
    ld   a, (y_dir)
    or   a
    jr   z, up_hl
    jr   down_hl         ; tail-call optimisation

; ============================================================
; CLEAR_SCREEN — PUSH-based fast screen clear
; Clears 6144 bytes of pixel data.
; ~34,000 T-states
; ============================================================
clear_screen:
    di
    ld   (cs_sp + 1), sp

    ld   sp, SCREEN_END
    ld   hl, 0
    ld   b, 192          ; 192 × 16 pushes × 2 bytes = 6144
.cs_loop:
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    djnz .cs_loop

cs_sp:
    ld   sp, 0           ; self-modified: restore SP
    ei
    ret

; ============================================================
; SET_ATTRS — Fill attribute area with single colour
; Input:  A = attribute byte
; ============================================================
set_attrs:
    ld   hl, ATTR_START
    ld   de, ATTR_START + 1
    ld   (hl), a
    ld   bc, 767
    ldir
    ret

; ============================================================
; Variables
; ============================================================
line_x0:   DB 0
line_y0:   DB 0
line_x1:   DB 0
line_y1:   DB 0
line_dx:   DB 0
line_dy:   DB 0
y_dir:     DB 0          ; 0 = up, 1 = down
