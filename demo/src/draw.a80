; draw.a80 — Drawing routines for torus demo
; Pixel addressing, Bresenham line, screen clear
;
; Included by torus.a80

; --- PIXEL_ADDR: (B=x, C=y) → HL=addr, A=mask ---
pixel_addr:
    ld   a, c
    and  $C0
    rrca
    rrca
    rrca
    ld   h, a
    ld   a, c
    and  $07
    or   h
    or   $40
    ld   h, a

    ld   a, c
    and  $38
    rlca
    rlca
    ld   l, a
    ld   a, b
    rrca
    rrca
    rrca
    and  $1F
    or   l
    ld   l, a

    ld   a, b
    and  7
    jr   z, .bit0
    ld   d, a
    ld   a, $80
.shift:
    rrca
    dec  d
    jr   nz, .shift
    ret
.bit0:
    ld   a, $80
    ret

; --- DOWN_HL / UP_HL: screen address ±1 scan line ---
down_hl:
    inc  h
    ld   a, h
    and  7
    ret  nz
    ld   a, l
    add  a, 32
    ld   l, a
    ret  c
    ld   a, h
    sub  8
    ld   h, a
    ret

up_hl:
    dec  h
    ld   a, h
    and  7
    cp   7
    ret  nz
    ld   a, l
    sub  32
    ld   l, a
    ret  c
    ld   a, h
    add  a, 8
    ld   h, a
    ret

step_y:
    ld   a, (y_dir)
    or   a
    jr   z, up_hl
    jr   down_hl

; --- DRAW_LINE: Bresenham (~75 T/pixel) ---
; Normalises to left-to-right, self-modifying inner loop
draw_line:
    ld   a, (line_x1)
    ld   b, a
    ld   a, (line_x0)
    cp   b
    jr   c, .no_swap
    jr   z, .no_swap

    ld   c, a
    ld   a, b
    ld   (line_x0), a
    ld   a, c
    ld   (line_x1), a
    ld   a, (line_y0)
    ld   c, a
    ld   a, (line_y1)
    ld   (line_y0), a
    ld   a, c
    ld   (line_y1), a
.no_swap:

    ld   a, (line_x1)
    ld   b, a
    ld   a, (line_x0)
    ld   c, a
    ld   a, b
    sub  c
    ld   (line_dx), a

    ld   a, (line_y0)
    ld   b, a
    ld   a, (line_y1)
    sub  b
    jr   nc, .y_down
    neg
    ld   (line_dy), a
    xor  a
    ld   (y_dir), a
    jr   .setup
.y_down:
    ld   (line_dy), a
    ld   a, 1
    ld   (y_dir), a

.setup:
    ld   a, (line_x0)
    ld   b, a
    ld   a, (line_y0)
    ld   c, a
    call pixel_addr
    ld   c, a

    ld   a, (line_dx)
    ld   (smc_hcmp + 1), a
    ld   (smc_hsub + 1), a

    ld   a, (line_dx)
    ld   d, a
    ld   a, (line_dy)
    cp   d
    jr   nc, .vmaj

    ; === Horizontal-major ===
    ld   a, (line_dx)
    ld   b, a
    inc  b
    ld   a, (line_dy)
    ld   e, a
    xor  a

.h_pixel:
    ld   d, a
    ld   a, c
    or   (hl)
    ld   (hl), a
    ld   a, d
    dec  b
    ret  z
    rrc  c
    jr   nc, .h_nb
    inc  l
.h_nb:
    add  a, e
smc_hcmp:
    cp   0
    jr   c, .h_pixel
smc_hsub:
    sub  0
    push af
    call step_y
    pop  af
    jr   .h_pixel

    ; === Vertical-major ===
.vmaj:
    ld   a, (line_dy)
    ld   (smc_vcmp + 1), a
    ld   (smc_vsub + 1), a

    ld   a, (line_dy)
    ld   b, a
    inc  b
    ld   a, (line_dx)
    ld   e, a
    xor  a

.v_pixel:
    ld   d, a
    ld   a, c
    or   (hl)
    ld   (hl), a
    ld   a, d
    dec  b
    ret  z
    push af
    call step_y
    pop  af
    add  a, e
smc_vcmp:
    cp   0
    jr   c, .v_pixel
smc_vsub:
    sub  0
    rrc  c
    jr   nc, .v_pixel
    inc  l
    jr   .v_pixel

; --- CLEAR_SCREEN: PUSH-based fast clear (~34,000 T) ---
clear_screen:
    di
    ld   (cs_sp + 1), sp
    ld   sp, SCREEN_END
    ld   hl, 0
    ld   b, 192
.loop:
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    djnz .loop
cs_sp:
    ld   sp, 0
    ei
    ret

; --- SET_ATTRS: fill attribute area ---
set_attrs:
    ld   hl, ATTR_START
    ld   de, ATTR_START + 1
    ld   (hl), a
    ld   bc, 767
    ldir
    ret
