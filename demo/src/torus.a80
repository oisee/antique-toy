; torus.a80 — "Not Eager" hexagonal torus demo effect
; Spinning wireframe torus using Dark's midpoint method (SE#02, 1998)
;
; Target: ZX Spectrum 128K, Pentagon timing (71,680 T/frame)
; Frame rate: 25 fps (2 frames per update = 143,360 T budget)
;
; 8 rings × 6 hex vertices = 48 vertices, 96 edges
; Midpoint derivation: 4 cardinal rings rotated, 4 averaged
;
; Assembles with: mza --target zxspectrum

    ORG $8000

; ============================================================
; Constants
; ============================================================
SCREEN      EQU $4000
SCREEN_END  EQU $5800
ATTR_START  EQU $5800
VIEWER_DIST EQU 200
TORUS_MAJ   EQU 45       ; major radius
TORUS_MIN   EQU 18       ; minor radius
NUM_RINGS   EQU 8
NUM_HEX     EQU 6
NUM_VERTS   EQU NUM_RINGS * NUM_HEX   ; 48
NUM_EDGES   EQU 96

; ============================================================
; Entry point
; ============================================================
start:
    di
    ld   sp, $7FFE

    call clear_screen
    ld   a, %01000111    ; white ink, black paper, bright
    call set_attrs
    ei

    xor  a
    ld   (angle_x), a
    ld   (angle_y), a
    ld   (angle_z), a

; ============================================================
; Main loop — runs once per 2 frames (25 fps)
; ============================================================
main_loop:
    halt
    halt

    ; Border red = working
    ld   a, 2
    out  ($FE), a

    call derive_torus
    call project_all
    call clear_screen
    call draw_all_edges

    ; Animate
    ld   a, (angle_y)
    add  a, 3
    ld   (angle_y), a
    ld   a, (angle_x)
    add  a, 1
    ld   (angle_x), a

    ; Border black = idle
    xor  a
    out  ($FE), a

    jr   main_loop

; ============================================================
; PROJECT_ALL — Project all 48 vertices to 2D
; ============================================================
project_all:
    ld   ix, vertices
    ld   iy, proj_buf
    ld   b, NUM_VERTS

.loop:
    push bc

    ld   a, (ix+0)
    ld   (vert_out), a
    ld   a, (ix+1)
    ld   (vert_out+1), a
    ld   a, (ix+2)
    ld   (vert_out+2), a

    call project

    ld   a, (screen_x)
    ld   (iy+0), a
    ld   a, (screen_y)
    ld   (iy+1), a

    ld   bc, 3
    add  ix, bc
    ld   bc, 2
    add  iy, bc

    pop  bc
    djnz .loop
    ret

; ============================================================
; DRAW_ALL_EDGES — Draw all 96 wireframe edges
; ============================================================
draw_all_edges:
    ld   ix, edge_list
    ld   b, NUM_EDGES

.loop:
    push bc

    ; Vertex 0 coords
    ld   a, (ix+0)
    call lookup_proj
    ld   a, (hl)
    ld   (line_x0), a
    inc  hl
    ld   a, (hl)
    ld   (line_y0), a

    ; Vertex 1 coords
    ld   a, (ix+1)
    call lookup_proj
    ld   a, (hl)
    ld   (line_x1), a
    inc  hl
    ld   a, (hl)
    ld   (line_y1), a

    ; Bounds check
    ld   a, (line_y0)
    cp   192
    jr   nc, .skip
    ld   a, (line_y1)
    cp   192
    jr   nc, .skip

    call draw_line

.skip:
    ld   bc, 2
    add  ix, bc
    pop  bc
    djnz .loop
    ret

; proj_buf[A] → HL
lookup_proj:
    ld   l, a
    ld   h, 0
    add  hl, hl
    ld   de, proj_buf
    add  hl, de
    ret

; ============================================================
; ==================== MATH ROUTINES ========================
; ============================================================

; --- Sin table (256 bytes, page-aligned) ---
    ALIGN 256
sin_table:
    DB   0,   3,   6,   9,  12,  16,  19,  22
    DB  25,  28,  31,  34,  37,  40,  43,  46
    DB  49,  51,  54,  57,  60,  63,  65,  68
    DB  71,  73,  76,  78,  81,  83,  85,  88
    DB  90,  92,  94,  96,  98, 100, 102, 104
    DB 106, 107, 109, 111, 112, 113, 115, 116
    DB 117, 118, 120, 121, 122, 122, 123, 124
    DB 125, 125, 126, 126, 126, 127, 127, 127

    DB 127, 127, 127, 126, 126, 126, 125, 125
    DB 124, 123, 122, 122, 121, 120, 118, 117
    DB 116, 115, 113, 112, 111, 109, 107, 106
    DB 104, 102, 100,  98,  96,  94,  92,  90
    DB  88,  85,  83,  81,  78,  76,  73,  71
    DB  68,  65,  63,  60,  57,  54,  51,  49
    DB  46,  43,  40,  37,  34,  31,  28,  25
    DB  22,  19,  16,  12,   9,   6,   3,   0

    ; 180°..270° — unsigned two's complement for negative values
    DB   0, 253, 250, 247, 244, 240, 237, 234
    DB 231, 228, 225, 222, 219, 216, 213, 210
    DB 207, 205, 202, 199, 196, 193, 191, 188
    DB 185, 183, 180, 178, 175, 173, 171, 168
    DB 166, 164, 162, 160, 158, 156, 154, 152
    DB 150, 149, 147, 145, 144, 143, 141, 140
    DB 139, 138, 136, 135, 134, 134, 133, 132
    DB 131, 131, 130, 130, 130, 129, 129, 129

    ; 270°..360°
    DB 129, 129, 129, 130, 130, 130, 131, 131
    DB 132, 133, 134, 134, 135, 136, 138, 139
    DB 140, 141, 143, 144, 145, 147, 149, 150
    DB 152, 154, 156, 158, 160, 162, 164, 166
    DB 168, 171, 173, 175, 178, 180, 183, 185
    DB 188, 191, 193, 196, 199, 202, 205, 207
    DB 210, 213, 216, 219, 222, 225, 228, 231
    DB 234, 237, 240, 244, 247, 250, 253,   0

; --- MULU8: A × E → HL (unsigned 8×8) ---
; ~170 T
mulu8:
    ld   d, 0
    ld   h, d
    ld   l, d
    ld   b, 8
.loop:
    add  hl, hl
    rla
    jr   nc, .skip
    add  hl, de
.skip:
    djnz .loop
    ret

; --- MULS8: D × E → HL (signed 8×8) ---
; ~220 T
muls8:
    ld   a, d
    xor  e
    push af              ; sign in bit 7
    ld   a, d
    or   a
    jp   p, .d_pos
    neg
.d_pos:
    ld   d, a
    ld   a, e
    or   a
    jp   p, .e_pos
    neg
.e_pos:
    ld   e, a
    ld   a, d
    call mulu8
    pop  af
    ret  p               ; positive result
    ; Negate HL
    xor  a
    sub  l
    ld   l, a
    sbc  a, a
    sub  h
    ld   h, a
    ret

; --- GET_SINCOS: angle A → D=sin, E=cos ---
get_sincos:
    ld   hl, sin_table
    ld   l, a            ; table is page-aligned, so H stays correct
    ld   d, (hl)         ; D = sin(angle)
    add  a, 64
    ld   l, a
    ld   e, (hl)         ; E = cos(angle)
    ret

; --- ROTATE_PAIR: 2D rotation subroutine ---
; (coord_a, coord_b) × (cur_sin, cur_cos) → (result_a, result_b)
; a' = (a*cos - b*sin) >> 7
; b' = (a*sin + b*cos) >> 7
; ~900 T (4 multiplies)
rotate_pair:
    ; a * cos
    ld   a, (coord_a)
    ld   d, a
    ld   a, (cur_cos)
    ld   e, a
    call muls8
    ld   (temp_w0), hl

    ; b * sin
    ld   a, (coord_b)
    ld   d, a
    ld   a, (cur_sin)
    ld   e, a
    call muls8

    ; result_a = (a*cos - b*sin) >> 7
    ex   de, hl
    ld   hl, (temp_w0)
    or   a
    sbc  hl, de
    add  hl, hl          ; << 1 so >> 7 becomes >> 8
    ld   a, h
    ld   (result_a), a

    ; a * sin
    ld   a, (coord_a)
    ld   d, a
    ld   a, (cur_sin)
    ld   e, a
    call muls8
    ld   (temp_w0), hl

    ; b * cos
    ld   a, (coord_b)
    ld   d, a
    ld   a, (cur_cos)
    ld   e, a
    call muls8

    ; result_b = (a*sin + b*cos) >> 7
    ld   de, (temp_w0)
    add  hl, de
    add  hl, hl
    ld   a, h
    ld   (result_b), a
    ret

; --- ROTATE_XYZ: 3-axis rotation ---
; vert_in → vert_out, using angle_x/y/z
; ~2,800 T
rotate_xyz:
    ld   a, (vert_in+0)
    ld   (vert_out+0), a
    ld   a, (vert_in+1)
    ld   (vert_out+1), a
    ld   a, (vert_in+2)
    ld   (vert_out+2), a

    ; Z-axis: X, Y
    ld   a, (angle_z)
    call get_sincos
    ld   a, d
    ld   (cur_sin), a
    ld   a, e
    ld   (cur_cos), a
    ld   a, (vert_out+0)
    ld   (coord_a), a
    ld   a, (vert_out+1)
    ld   (coord_b), a
    call rotate_pair
    ld   a, (result_a)
    ld   (vert_out+0), a
    ld   a, (result_b)
    ld   (vert_out+1), a

    ; Y-axis: X, Z
    ld   a, (angle_y)
    call get_sincos
    ld   a, d
    ld   (cur_sin), a
    ld   a, e
    ld   (cur_cos), a
    ld   a, (vert_out+0)
    ld   (coord_a), a
    ld   a, (vert_out+2)
    ld   (coord_b), a
    call rotate_pair
    ld   a, (result_a)
    ld   (vert_out+0), a
    ld   a, (result_b)
    ld   (vert_out+2), a

    ; X-axis: Y, Z
    ld   a, (angle_x)
    call get_sincos
    ld   a, d
    ld   (cur_sin), a
    ld   a, e
    ld   (cur_cos), a
    ld   a, (vert_out+1)
    ld   (coord_a), a
    ld   a, (vert_out+2)
    ld   (coord_b), a
    call rotate_pair
    ld   a, (result_a)
    ld   (vert_out+1), a
    ld   a, (result_b)
    ld   (vert_out+2), a
    ret

; --- PROJECT: 3D → 2D perspective ---
; vert_out → screen_x, screen_y
; scale = VIEWER_DIST * 128 / (z + VIEWER_DIST)
; ~600 T
project:
    ld   a, (vert_out+2)
    ld   e, a
    ld   d, 0
    bit  7, a
    jr   z, .zpos
    dec  d
.zpos:
    ld   hl, VIEWER_DIST
    add  hl, de

    bit  7, h
    jr   nz, .clip
    ld   a, h
    or   l
    jr   z, .clip

    ld   b, h
    ld   c, l
    ld   hl, VIEWER_DIST * 128
    call div16

    ld   a, h
    or   a
    jr   z, .scale_ok
    ld   l, 255
.scale_ok:
    ld   a, l
    ld   (proj_scale), a

    ; sx = 128 + (x * scale) >> 7
    ld   a, (vert_out+0)
    ld   d, a
    ld   a, (proj_scale)
    ld   e, a
    call muls8
    add  hl, hl
    ld   a, h
    add  a, 128
    ld   (screen_x), a

    ; sy = 96 + (y * scale) >> 7
    ld   a, (vert_out+1)
    ld   d, a
    ld   a, (proj_scale)
    ld   e, a
    call muls8
    add  hl, hl
    ld   a, h
    add  a, 96
    ld   (screen_y), a

    or   a
    ret

.clip:
    ld   a, 255
    ld   (screen_x), a
    ld   (screen_y), a
    scf
    ret

; --- DIV16: HL / BC → HL quotient, DE remainder ---
; Standard restoring division, ~500 T
div16:
    ld   de, 0
    ld   a, 16

.loop:
    add  hl, hl
    rl   e
    rl   d

    push hl
    ex   de, hl
    or   a
    sbc  hl, bc
    jr   c, .too_small

    ex   de, hl
    pop  hl
    inc  l
    dec  a
    jr   nz, .loop
    ret

.too_small:
    add  hl, bc
    ex   de, hl
    pop  hl
    dec  a
    jr   nz, .loop
    ret

; ============================================================
; ==================== DRAWING ROUTINES =====================
; ============================================================

; --- PIXEL_ADDR: (B=x, C=y) → HL=addr, A=mask ---
pixel_addr:
    ld   a, c
    and  $C0
    rrca
    rrca
    rrca
    ld   h, a
    ld   a, c
    and  $07
    or   h
    or   $40
    ld   h, a

    ld   a, c
    and  $38
    rlca
    rlca
    ld   l, a
    ld   a, b
    rrca
    rrca
    rrca
    and  $1F
    or   l
    ld   l, a

    ld   a, b
    and  7
    jr   z, .bit0
    ld   d, a
    ld   a, $80
.shift:
    rrca
    dec  d
    jr   nz, .shift
    ret
.bit0:
    ld   a, $80
    ret

; --- DOWN_HL: screen address one line down ---
down_hl:
    inc  h
    ld   a, h
    and  7
    ret  nz
    ld   a, l
    add  a, 32
    ld   l, a
    ret  c
    ld   a, h
    sub  8
    ld   h, a
    ret

; --- UP_HL: screen address one line up ---
up_hl:
    dec  h
    ld   a, h
    and  7
    cp   7
    ret  nz
    ld   a, l
    sub  32
    ld   l, a
    ret  c
    ld   a, h
    add  a, 8
    ld   h, a
    ret

; --- STEP_Y: step Y by direction flag ---
step_y:
    ld   a, (y_dir)
    or   a
    jr   z, up_hl
    jr   down_hl

; --- DRAW_LINE: Bresenham line drawing ---
; line_x0,y0 → line_x1,y1
; Normalises to left-to-right, self-modifying inner loop
; ~75 T per pixel
draw_line:
    ; Ensure x0 <= x1
    ld   a, (line_x1)
    ld   b, a
    ld   a, (line_x0)
    cp   b
    jr   c, .no_swap
    jr   z, .no_swap

    ld   c, a
    ld   a, b
    ld   (line_x0), a
    ld   a, c
    ld   (line_x1), a
    ld   a, (line_y0)
    ld   c, a
    ld   a, (line_y1)
    ld   (line_y0), a
    ld   a, c
    ld   (line_y1), a
.no_swap:

    ; dx = x1 - x0
    ld   a, (line_x1)
    ld   b, a
    ld   a, (line_x0)
    ld   c, a
    ld   a, b
    sub  c
    ld   (line_dx), a

    ; dy = |y1 - y0|, direction
    ld   a, (line_y0)
    ld   b, a
    ld   a, (line_y1)
    sub  b
    jr   nc, .y_down
    neg
    ld   (line_dy), a
    xor  a
    ld   (y_dir), a      ; 0 = up
    jr   .setup
.y_down:
    ld   (line_dy), a
    ld   a, 1
    ld   (y_dir), a      ; 1 = down

.setup:
    ld   a, (line_x0)
    ld   b, a
    ld   a, (line_y0)
    ld   c, a
    call pixel_addr
    ld   c, a            ; C = pixel mask

    ; Self-modify comparison values
    ld   a, (line_dx)
    ld   (smc_hcmp + 1), a
    ld   (smc_hsub + 1), a

    ; Choose major axis
    ld   a, (line_dx)
    ld   d, a
    ld   a, (line_dy)
    cp   d
    jr   nc, .vmaj

    ; === Horizontal-major ===
    ld   a, (line_dx)
    ld   b, a
    inc  b
    ld   a, (line_dy)
    ld   e, a
    xor  a

.h_pixel:
    ld   d, a
    ld   a, c
    or   (hl)
    ld   (hl), a
    ld   a, d

    dec  b
    ret  z

    rrc  c
    jr   nc, .h_nb
    inc  l
.h_nb:
    add  a, e
smc_hcmp:
    cp   0
    jr   c, .h_pixel
smc_hsub:
    sub  0

    push af
    call step_y
    pop  af
    jr   .h_pixel

    ; === Vertical-major ===
.vmaj:
    ld   a, (line_dy)
    ld   (smc_vcmp + 1), a
    ld   (smc_vsub + 1), a

    ld   a, (line_dy)
    ld   b, a
    inc  b
    ld   a, (line_dx)
    ld   e, a
    xor  a

.v_pixel:
    ld   d, a
    ld   a, c
    or   (hl)
    ld   (hl), a
    ld   a, d

    dec  b
    ret  z

    push af
    call step_y
    pop  af

    add  a, e
smc_vcmp:
    cp   0
    jr   c, .v_pixel
smc_vsub:
    sub  0

    rrc  c
    jr   nc, .v_pixel
    inc  l
    jr   .v_pixel

; --- CLEAR_SCREEN: PUSH-based fast clear (~34,000 T) ---
clear_screen:
    di
    ld   (cs_sp + 1), sp
    ld   sp, SCREEN_END
    ld   hl, 0
    ld   b, 192
.loop:
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    push hl
    djnz .loop
cs_sp:
    ld   sp, 0
    ei
    ret

; --- SET_ATTRS: fill attribute area ---
set_attrs:
    ld   hl, ATTR_START
    ld   de, ATTR_START + 1
    ld   (hl), a
    ld   bc, 767
    ldir
    ret

; ============================================================
; ==================== TORUS GEOMETRY =======================
; ============================================================

; --- DERIVE_TORUS: 48 vertices from rotation + midpoints ---
derive_torus:
    ; Ring 0 (0°): rotate 6 hex verts
    ld   ix, basis_hex
    ld   iy, vertices
    call rotate_6_hex

    ; Ring 2 (90°): rotate 6 hex verts
    ld   ix, basis_hex_r2
    ld   iy, vertices + 2*18
    call rotate_6_hex

    ; Ring 4 (180°): negate X,Z of ring 0
    ld   ix, vertices
    ld   iy, vertices + 4*18
    call negate_ring_xz

    ; Ring 6 (270°): negate X,Z of ring 2
    ld   ix, vertices + 2*18
    ld   iy, vertices + 6*18
    call negate_ring_xz

    ; Ring 1 (45°): avg(ring 0, ring 2)
    ld   ix, vertices
    ld   iy, vertices + 2*18
    ld   hl, vertices + 1*18
    call average_ring

    ; Ring 3 (135°): avg(ring 2, ring 4)
    ld   ix, vertices + 2*18
    ld   iy, vertices + 4*18
    ld   hl, vertices + 3*18
    call average_ring

    ; Ring 5 (225°): avg(ring 4, ring 6)
    ld   ix, vertices + 4*18
    ld   iy, vertices + 6*18
    ld   hl, vertices + 5*18
    call average_ring

    ; Ring 7 (315°): avg(ring 6, ring 0)
    ld   ix, vertices + 6*18
    ld   iy, vertices
    ld   hl, vertices + 7*18
    call average_ring
    ret

; --- ROTATE_6_HEX: rotate 6 basis vertices ---
rotate_6_hex:
    ld   b, 6
.loop:
    push bc
    ld   a, (ix+0)
    ld   (vert_in), a
    ld   a, (ix+1)
    ld   (vert_in+1), a
    ld   a, (ix+2)
    ld   (vert_in+2), a
    call rotate_xyz
    ld   a, (vert_out)
    ld   (iy+0), a
    ld   a, (vert_out+1)
    ld   (iy+1), a
    ld   a, (vert_out+2)
    ld   (iy+2), a
    ld   bc, 3
    add  ix, bc
    add  iy, bc
    pop  bc
    djnz .loop
    ret

; --- NEGATE_RING_XZ: derive opposite ring ---
negate_ring_xz:
    ld   b, 6
.loop:
    ld   a, (ix+0)
    neg
    ld   (iy+0), a
    ld   a, (ix+1)
    ld   (iy+1), a
    ld   a, (ix+2)
    neg
    ld   (iy+2), a
    ld   de, 3
    add  ix, de
    add  iy, de
    djnz .loop
    ret

; --- AVERAGE_RING: midpoint of two rings ---
; IX=ring A, IY=ring B, HL=dest
average_ring:
    ld   b, 18
.loop:
    ld   a, (ix+0)
    ld   c, a
    ld   a, (iy+0)
    add  a, c
    sra  a
    ld   (hl), a
    inc  ix
    inc  iy
    inc  hl
    djnz .loop
    ret

; ============================================================
; ==================== DATA =================================
; ============================================================

; Basis hex vertices — ring 0 at (R, 0, 0)
basis_hex:
    DB  63,   0,   0
    DB  54,  16,   0
    DB  36,  16,   0
    DB  27,   0,   0
    DB  36, 240,   0     ; y = -16 = 240 unsigned
    DB  54, 240,   0

; Basis hex vertices — ring 2 at (0, 0, R)
basis_hex_r2:
    DB   0,   0,  63
    DB   0,  16,  54
    DB   0,  16,  36
    DB   0,   0,  27
    DB   0, 240,  36     ; y = -16
    DB   0, 240,  54

; Edge list: 96 edges (vertex index pairs)
edge_list:
    ; Ring edges (8 × 6 = 48)
    DB  0, 1,  1, 2,  2, 3,  3, 4,  4, 5,  5, 0
    DB  6, 7,  7, 8,  8, 9,  9,10, 10,11, 11, 6
    DB 12,13, 13,14, 14,15, 15,16, 16,17, 17,12
    DB 18,19, 19,20, 20,21, 21,22, 22,23, 23,18
    DB 24,25, 25,26, 26,27, 27,28, 28,29, 29,24
    DB 30,31, 31,32, 32,33, 33,34, 34,35, 35,30
    DB 36,37, 37,38, 38,39, 39,40, 40,41, 41,36
    DB 42,43, 43,44, 44,45, 45,46, 46,47, 47,42
    ; Spoke edges (8 × 6 = 48)
    DB  0, 6,  1, 7,  2, 8,  3, 9,  4,10,  5,11
    DB  6,12,  7,13,  8,14,  9,15, 10,16, 11,17
    DB 12,18, 13,19, 14,20, 15,21, 16,22, 17,23
    DB 18,24, 19,25, 20,26, 21,27, 22,28, 23,29
    DB 24,30, 25,31, 26,32, 27,33, 28,34, 29,35
    DB 30,36, 31,37, 32,38, 33,39, 34,40, 35,41
    DB 36,42, 37,43, 38,44, 39,45, 40,46, 41,47
    DB 42, 0, 43, 1, 44, 2, 45, 3, 46, 4, 47, 5

; ============================================================
; ==================== VARIABLES ============================
; ============================================================
vert_in:     DS 3
vert_out:    DS 3
angle_x:     DB 0
angle_y:     DB 0
angle_z:     DB 0
cur_sin:     DB 0
cur_cos:     DB 0
coord_a:     DB 0
coord_b:     DB 0
result_a:    DB 0
result_b:    DB 0
temp_w0:     DW 0
proj_scale:  DB 0
screen_x:    DB 0
screen_y:    DB 0

line_x0:     DB 0
line_y0:     DB 0
line_x1:     DB 0
line_y1:     DB 0
line_dx:     DB 0
line_dy:     DB 0
y_dir:       DB 0

vertices:    DS NUM_VERTS * 3    ; 144 bytes
proj_buf:    DS NUM_VERTS * 2    ; 96 bytes
