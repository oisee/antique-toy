; math.a80 — Math routines and lookup tables for torus demo
; Includes: sin table, multiply, rotation, perspective projection
;
; Assembles with: mza --target zxspectrum
; Included by torus.a80

; ============================================================
; SIN TABLE — 256 entries, page-aligned, signed 8-bit
; sin(i) = round(127 * sin(2*pi*i/256))
; cos(i) = sin(i + 64)
; ============================================================

    ALIGN 256
sin_table:
    ; 0°..90° (indices 0-63)
    DB   0,   3,   6,   9,  12,  16,  19,  22
    DB  25,  28,  31,  34,  37,  40,  43,  46
    DB  49,  51,  54,  57,  60,  63,  65,  68
    DB  71,  73,  76,  78,  81,  83,  85,  88
    DB  90,  92,  94,  96,  98, 100, 102, 104
    DB 106, 107, 109, 111, 112, 113, 115, 116
    DB 117, 118, 120, 121, 122, 122, 123, 124
    DB 125, 125, 126, 126, 126, 127, 127, 127
    ; 90°..180° (indices 64-127)
    DB 127, 127, 127, 126, 126, 126, 125, 125
    DB 124, 123, 122, 122, 121, 120, 118, 117
    DB 116, 115, 113, 112, 111, 109, 107, 106
    DB 104, 102, 100,  98,  96,  94,  92,  90
    DB  88,  85,  83,  81,  78,  76,  73,  71
    DB  68,  65,  63,  60,  57,  54,  51,  49
    DB  46,  43,  40,  37,  34,  31,  28,  25
    DB  22,  19,  16,  12,   9,   6,   3,   0
    ; 180°..270° (indices 128-191)
    DB   0,  -3,  -6,  -9, -12, -16, -19, -22
    DB -25, -28, -31, -34, -37, -40, -43, -46
    DB -49, -51, -54, -57, -60, -63, -65, -68
    DB -71, -73, -76, -78, -81, -83, -85, -88
    DB -90, -92, -94, -96, -98,-100,-102,-104
    DB -106,-107,-109,-111,-112,-113,-115,-116
    DB -117,-118,-120,-121,-122,-122,-123,-124
    DB -125,-125,-126,-126,-126,-127,-127,-127
    ; 270°..360° (indices 192-255)
    DB -127,-127,-127,-126,-126,-126,-125,-125
    DB -124,-123,-122,-122,-121,-120,-118,-117
    DB -116,-115,-113,-112,-111,-109,-107,-106
    DB -104,-102,-100, -98, -96, -94, -92, -90
    DB  -88, -85, -83, -81, -78, -76, -73, -71
    DB  -68, -65, -63, -60, -57, -54, -51, -49
    DB  -46, -43, -40, -37, -34, -31, -28, -25
    DB  -22, -19, -16, -12,  -9,  -6,  -3,   0

; ============================================================
; MULU8 — Unsigned 8×8 multiply
; Input:  A = multiplicand, E = multiplier
; Output: HL = A * E (16-bit unsigned)
; Destroys: A, D, B
; ~170 T-states
; ============================================================
mulu8:
    ld   d, 0
    ld   h, d
    ld   l, d            ; HL = 0, DE = 00:E
    ld   b, 8            ; 8 bits
.loop:
    add  hl, hl          ; shift result left       ; 11 T
    rla                  ; shift MSB of A into carry; 4 T
    jr   nc, .skip       ; no bit set              ; 12/7 T
    add  hl, de          ; add multiplier           ; 11 T
.skip:
    djnz .loop           ;                          ; 13/8 T
    ret

; ============================================================
; MULS8 — Signed 8×8 multiply
; Input:  D = multiplicand (signed), E = multiplier (signed)
; Output: HL = D * E (16-bit signed)
; Destroys: A, B, D, E
; ~220 T-states
; ============================================================
muls8:
    ld   a, d
    xor  e
    push af              ; save result sign in bit 7

    ; |D|
    ld   a, d
    or   a
    jp   p, .d_pos
    neg
.d_pos:
    ld   d, a

    ; |E|
    ld   a, e
    or   a
    jp   p, .e_pos
    neg
.e_pos:
    ld   e, a

    ; Unsigned multiply: A=|D|, E=|E| → HL
    ld   a, d
    call mulu8           ; HL = |D| * |E|

    ; Apply sign
    pop  af
    ret  p               ; positive — done

    ; Negate HL
    xor  a
    sub  l
    ld   l, a
    sbc  a, a
    sub  h
    ld   h, a
    ret

; ============================================================
; GET_SINCOS — Look up sin and cos from angle
; Input:  A = angle (0-255 = 0°-360°)
; Output: D = sin(angle), E = cos(angle)
; Destroys: A
; ============================================================
get_sincos:
    ld   h, sin_table >> 8
    ld   l, a
    ld   d, (hl)         ; D = sin(angle)
    add  a, 64
    ld   l, a
    ld   e, (hl)         ; E = cos(angle)
    ret

; ============================================================
; ROTATE_PAIR — Rotate two coordinates by sin/cos angle
; Input:  (coord_a), (coord_b) = signed coordinates
;         (cur_sin), (cur_cos) = sin/cos of rotation angle
; Output: (result_a), (result_b) = rotated coordinates
;
; Formula: a' = (a*cos - b*sin) >> 7
;          b' = (a*sin + b*cos) >> 7
; (>> 7 because sin/cos are scaled by 127)
; Destroys: A, B, D, E, HL
; ~900 T-states (4 multiplies + overhead)
; ============================================================
rotate_pair:
    ; a * cos
    ld   a, (coord_a)
    ld   d, a
    ld   a, (cur_cos)
    ld   e, a
    call muls8
    ld   (temp_w0), hl   ; a*cos

    ; b * sin
    ld   a, (coord_b)
    ld   d, a
    ld   a, (cur_sin)
    ld   e, a
    call muls8           ; HL = b*sin

    ; result_a = (a*cos - b*sin) >> 7
    ex   de, hl          ; DE = b*sin
    ld   hl, (temp_w0)   ; HL = a*cos
    or   a
    sbc  hl, de          ; HL = a*cos - b*sin
    add  hl, hl          ; << 1 so >> 7 becomes >> 8
    ld   a, h            ; take high byte = >> 8
    ld   (result_a), a

    ; a * sin
    ld   a, (coord_a)
    ld   d, a
    ld   a, (cur_sin)
    ld   e, a
    call muls8
    ld   (temp_w0), hl   ; a*sin

    ; b * cos
    ld   a, (coord_b)
    ld   d, a
    ld   a, (cur_cos)
    ld   e, a
    call muls8           ; HL = b*cos

    ; result_b = (a*sin + b*cos) >> 7
    ld   de, (temp_w0)   ; DE = a*sin
    add  hl, de          ; HL = a*sin + b*cos
    add  hl, hl
    ld   a, h
    ld   (result_b), a
    ret

; ============================================================
; ROTATE_XYZ — 3-axis rotation of a vertex
; Input:  vert_in[0..2] = (x, y, z) signed bytes
;         angle_x, angle_y, angle_z = rotation angles
; Output: vert_out[0..2] = rotated (x', y', z')
; ~2,800 T-states (3 × rotate_pair)
; ============================================================
rotate_xyz:
    ; Copy input → output (working buffer)
    ld   a, (vert_in+0)
    ld   (vert_out+0), a
    ld   a, (vert_in+1)
    ld   (vert_out+1), a
    ld   a, (vert_in+2)
    ld   (vert_out+2), a

    ; Z-axis rotation: modifies X, Y
    ld   a, (angle_z)
    call get_sincos
    ld   a, d
    ld   (cur_sin), a
    ld   a, e
    ld   (cur_cos), a

    ld   a, (vert_out+0)
    ld   (coord_a), a    ; x
    ld   a, (vert_out+1)
    ld   (coord_b), a    ; y
    call rotate_pair
    ld   a, (result_a)
    ld   (vert_out+0), a ; x'
    ld   a, (result_b)
    ld   (vert_out+1), a ; y'

    ; Y-axis rotation: modifies X, Z
    ld   a, (angle_y)
    call get_sincos
    ld   a, d
    ld   (cur_sin), a
    ld   a, e
    ld   (cur_cos), a

    ld   a, (vert_out+0)
    ld   (coord_a), a    ; x
    ld   a, (vert_out+2)
    ld   (coord_b), a    ; z
    call rotate_pair
    ld   a, (result_a)
    ld   (vert_out+0), a ; x'
    ld   a, (result_b)
    ld   (vert_out+2), a ; z'

    ; X-axis rotation: modifies Y, Z
    ld   a, (angle_x)
    call get_sincos
    ld   a, d
    ld   (cur_sin), a
    ld   a, e
    ld   (cur_cos), a

    ld   a, (vert_out+1)
    ld   (coord_a), a    ; y
    ld   a, (vert_out+2)
    ld   (coord_b), a    ; z
    call rotate_pair
    ld   a, (result_a)
    ld   (vert_out+1), a ; y'
    ld   a, (result_b)
    ld   (vert_out+2), a ; z'
    ret

; ============================================================
; PROJECT — Perspective projection of a single vertex
; Input:  vert_out[0..2] = rotated (x, y, z)
; Output: screen_x, screen_y = 8-bit screen coordinates
;         Carry set if vertex is clipped (behind camera)
;
; Formula: scale = VIEWER_DIST * 128 / (z + VIEWER_DIST)
;          sx = 128 + (x * scale) >> 7
;          sy = 96  + (y * scale) >> 7
; ~600 T-states
; ============================================================
VIEWER_DIST EQU 200

project:
    ; z + VIEWER_DIST
    ld   a, (vert_out+2) ; z (signed)
    ld   e, a
    ld   d, 0
    bit  7, a
    jr   z, .zpos
    dec  d               ; sign-extend to 16-bit
.zpos:
    ld   hl, VIEWER_DIST
    add  hl, de          ; HL = z + D

    ; Clip if z + D <= 0
    bit  7, h
    jr   nz, .clip
    ld   a, h
    or   l
    jr   z, .clip

    ; scale = VIEWER_DIST * 128 / (z + D)
    ; Numerator = 25600, fits in 16 bits
    ld   b, h
    ld   c, l            ; BC = z + D (divisor)
    ld   hl, VIEWER_DIST * 128
    call div16           ; HL = quotient (scale factor)

    ; Clamp scale to 255 max
    ld   a, h
    or   a
    jr   z, .scale_ok
    ld   l, 255          ; clamp
.scale_ok:
    ld   a, l
    ld   (proj_scale), a

    ; sx = 128 + (x * scale) >> 7
    ld   a, (vert_out+0) ; x
    ld   d, a
    ld   a, (proj_scale)
    ld   e, a
    call muls8           ; HL = x * scale
    add  hl, hl          ; << 1 (so >> 7 = >> 8 of this)
    ld   a, h
    add  a, 128          ; center X
    ld   (screen_x), a

    ; sy = 96 + (y * scale) >> 7
    ld   a, (vert_out+1) ; y
    ld   d, a
    ld   a, (proj_scale)
    ld   e, a
    call muls8           ; HL = y * scale
    add  hl, hl
    ld   a, h
    add  a, 96           ; center Y
    ld   (screen_y), a

    or   a               ; clear carry (not clipped)
    ret

.clip:
    ld   a, 255
    ld   (screen_x), a
    ld   (screen_y), a
    scf                  ; set carry = clipped
    ret

; ============================================================
; DIV16 — 16-bit unsigned division
; Input:  HL = dividend, BC = divisor (non-zero)
; Output: HL = quotient, DE = remainder
; Destroys: A
; ~500 T-states
;
; Standard restoring division: shifts dividend left, quotient
; bits fill in from the right as dividend bits shift out.
; ============================================================
div16:
    ld   de, 0           ; DE = remainder
    ld   a, 16           ; 16 iterations

.loop:
    add  hl, hl          ; shift dividend MSB → carry, bit 0 = 0
    rl   e
    rl   d               ; carry → remainder

    ; remainder >= divisor?
    push hl
    ex   de, hl          ; HL = remainder
    or   a               ; clear carry (note: or a doesn't change A)
    sbc  hl, bc          ; try subtract
    jr   c, .too_small

    ; Fits: keep subtracted remainder, set quotient bit
    ex   de, hl          ; DE = new remainder
    pop  hl
    inc  l               ; set bit 0 of quotient
    dec  a
    jr   nz, .loop
    ret

.too_small:
    add  hl, bc          ; restore remainder
    ex   de, hl          ; DE = remainder (unchanged)
    pop  hl
    ; bit 0 stays 0
    dec  a
    jr   nz, .loop
    ret

; ============================================================
; Temporary variables — used by rotation and projection
; ============================================================
vert_in:     DS 3        ; input vertex (x, y, z)
vert_out:    DS 3        ; output / rotated vertex
angle_x:     DB 0        ; rotation angles
angle_y:     DB 0
angle_z:     DB 0
cur_sin:     DB 0
cur_cos:     DB 0
coord_a:     DB 0
coord_b:     DB 0
result_a:    DB 0
result_b:    DB 0
temp_w0:     DW 0        ; 16-bit temp
proj_scale:  DB 0
screen_x:    DB 0
screen_y:    DB 0
